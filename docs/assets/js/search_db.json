[
  {
    "title": "[16]Dixit, A., Oratis, A., Zinelis, K., Lohse, D., &Sanjay, V.Viscoelastic Worthington Jets and Droplets Produced by Bursting Bubbles. J. Fluid Mech., 1010, A2 (2025).",
    "content": "[16]Dixit, A., Oratis, A., Zinelis, K., Lohse, D., &Sanjay, V.Viscoelastic Worthington Jets and Droplets Produced by Bursting Bubbles. J. Fluid Mech., 1010, A2 (2025).",
    "url": "https://comphy-lab.org/research/#16",
    "type": "paper",
    "tags": [
      "Bubbles",
      "Non-Newtonian",
      "Jets",
      "Soft-matter-singularities",
      "Drops",
      "Featured"
    ],
    "priority": 1
  },
  {
    "title": "[11]Sanjay, V., Chantelot, P., & Lohse, D. When does an impacting drop stop bouncing? J. Fluid Mech., 958, A26 (2023).",
    "content": "[11]Sanjay, V., Chantelot, P., & Lohse, D. When does an impacting drop stop bouncing? J. Fluid Mech., 958, A26 (2023).",
    "url": "https://comphy-lab.org/research/#11",
    "type": "paper",
    "tags": [
      "Drops",
      "Bouncing",
      "Dissipative anomaly",
      "Featured"
    ],
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Vatsal Sanjay",
    "content": "Assistant Professor, Durham University [ ](https://github.com/VatsalSy) [ ](https://scholar.google.com/citations?user=tHb_qZoAAAAJ&hl=en) [ ](https://bsky.app/profile/comphy-lab.org) - Department of Physics, Durham Univ. / since 2025 - [Postdoc, Phys. Fluids - Univ. Twente / 2022&#8209;25](https://pof.tnw.utwente.nl/people/profile/1330) - **Ph.D.**, Phys. Fluids - Univ. Twente / 2018&#8209;22, Viscous Free-Surface Flows - **B.Tech. + M.Tech.**, Two-Phase Flow & Instability Lab, IIT-R / 2013&#8209;18, Understanding of mutual interactions between liquid jets: Entrainment and sheet formation - [Personal Website](https://vatsalsanjay.com), Photo: Florian Braakman. **Research Interest:** See [research page](/research) [Download CV](https://raw.githubusercontent.com/VatsalSy/Vatsal_CV/master/Vatsal_CV.pdf){: .cv-button}",
    "url": "https://comphy-lab.org/team/#dr-vatsal-sanjay",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Ayush Dixit M.Sc.",
    "content": "Ph.D. Student, University of Twente Co-advised with [Detlef Lohse](https://en.wikipedia.org/wiki/Detlef_Lohse) [ ](https://github.com/ayushkumardixit) [ ](https://scholar.google.com/citations?hl=en&user=ws43SmkAAAAJ) - [Phys. Fluids - Univ. Twente / 2023&#8209;now](https://pof.tnw.utwente.nl/people/profile/2068) - **B.Tech + M.Tech**, Two-Phase Flow & Instability Lab, IIT-R / 2018&#8209;23, Understanding interfacial interaction in macro and nano scales **Research Interest:** Viscoelastic Flows, Bursting Bubbles, Respiratory Drops.",
    "url": "https://comphy-lab.org/team/#ayush-dixit-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Aman Bhargava M.Sc.",
    "content": "Ph.D. Student, University of Twente Co-advised with [Detlef Lohse](https://en.wikipedia.org/wiki/Detlef_Lohse) [ ](https://github.com/amanb1901) [ ](https://scholar.google.com/citations?hl=en&user=AmGOP8gAAAAJ) - [Phys. Fluids - Univ. Twente / 2024-now](https://pof.tnw.utwente.nl/people/profile/2120) - **M.Sc.** Chem. Eng., Purdue University / 2022&#8209;23 - **B.Tech. (Hons.)** Chem. Eng., IIT-B / 2018&#8209;22 **Research Interest:** Inertial Contact Line, Drop Retraction.",
    "url": "https://comphy-lab.org/team/#aman-bhargava-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Jnandeep Talukdar M.Sc.",
    "content": "Ph.D. Student, University of Twente Co-advised with [Detlef Lohse](https://en.wikipedia.org/wiki/Detlef_Lohse) [ ](https://github.com/spilltheT) [ ](https://scholar.google.com/citations?hl=en&user=Coxj4VQAAAAJ) [ ](https://bsky.app/profile/jnandeep.bsky.social) - [Phys. Fluids - Univ. Twente / 2025&#8209;now](https://pof.tnw.utwente.nl/people/profile/1938) - **M.Sc.**, Phys. Fluids - Univ. Twente / 2023&#8209;25, Singularities with Surfactants - **B.Tech.** Mech. Eng., IIT-P / 2019&#8209;23 **Research Interest:** Surfactant Dynamics, Dissipative Anomaly, Soft Wetting.",
    "url": "https://comphy-lab.org/team/#jnandeep-talukdar-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Saumili Jana M.Sc.",
    "content": "Ph.D. Student, University of Twente Co-advised with [Detlef Lohse](https://en.wikipedia.org/wiki/Detlef_Lohse) [ ](https://github.com/SaumiliJana) - [Phys. Fluids - Univ. Twente / 2025-now](https://pof.tnw.utwente.nl/people/profile/2152) - **B.Tech.+M.Tech.**, Mech. Eng., IIT-KGP / 2020&#8209;25, Retract or Collapse? The Role of Viscosity and Viscoelasticity on Bubble Dynamics **Research Interest:** Soft Impact.",
    "url": "https://comphy-lab.org/team/#saumili-jana-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Floris Hoek B.Sc.",
    "content": "M.Sc. Student, University of Twente Co-advised with [Martin van der Hoef](https://pof.tnw.utwente.nl/people/profile/244) & [Alvaro Marin](https://pof.tnw.utwente.nl/people/profile/243) [ ](https://github.com/Floris-Hoek) - [Phys. Fluids - Univ. Twente / 2024](https://pof.tnw.utwente.nl/people/profile/1937) **Research Interest:** Molecular Dynamics Simulations of Evaporation-Driven Colloidal Self-Assembly.",
    "url": "https://comphy-lab.org/team/#floris-hoek-bsc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - We need you!",
    "content": "See: [Join Us](https://github.com/VatsalSy/Project-ideas-for-prospective-students) for ongoing projects.",
    "url": "https://comphy-lab.org/team/#we-need-you",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Prof. Detlef Lohse",
    "content": "[ ](https://scholar.google.com/citations?user=WvP_pIUAAAAJ) [ ](https://x.com/detlef_lohse) - [Professor, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/3) **Collaboration on:** Drop Impact, Viscoelastic Flows, Dissipative Anomaly, Surfactant Dynamics, Electrolysis, Bubbles, and Everything in Between.",
    "url": "https://comphy-lab.org/team/#prof-detlef-lohse",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Prof. Jacco Snoeijer",
    "content": "[ ](https://scholar.google.com/citations?user=7qdux_4AAAAJ&hl=nl) - [Professor, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/21) **Collaboration on:** Elastic Sheets, Viscoelasticity vs. Elasticity, Surfactant Dynamics, Spinning Pizza.",
    "url": "https://comphy-lab.org/team/#prof-jacco-snoeijer",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Prof. Dominik Krug",
    "content": "[ ](https://scholar.google.com/citations?user=qGEpq7IAAAAJ&hl=en&inst=5726176096060060532&oi=ao) - [Professor, RWTH Aachen University](https://www.aia.rwth-aachen.de/) - [Adjunct Professor, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1199) **Collaboration on:** Electrolysis, Bubble Coalescence, Swimming Bubbles.",
    "url": "https://comphy-lab.org/team/#prof-dominik-krug",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Maziyar (Mazi) Jalaal",
    "content": "[ ](https://scholar.google.com/citations?user=FE8TQeUAAAAJ) [ ](https://x.com/maziyarj) [ ](https://bsky.app/profile/mazi1.bsky.social) - [Associate Professor, Fluid Lab, Univ. Amsterdam](https://www.fluidlab.nl/) **Collaboration on:** Plastocapillarity, Viscoplastic Flows.",
    "url": "https://comphy-lab.org/team/#dr-maziyar-mazi-jalaal",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Uddalok (Udo) Sen",
    "content": "[ ](https://scholar.google.com/citations?user=a6h2uMQAAAAJ) - [Assistant Professor, PhySM, Wageningen University and Research](https://www.physm-lab.org/) **Collaboration on:** Drop Impact, Sheet Retraction.",
    "url": "https://comphy-lab.org/team/#dr-uddalok-udo-sen",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Adj. Prof. Alvaro Marin",
    "content": "[ ](https://scholar.google.com/citations?user=0_jOqqkAAAAJ) [ ](https://github.com/alvarogum) [ ](https://x.com/AlvaroGMarin) [ ](https://bsky.app/profile/alvaromarin.bsky.social) - [Adjunct Professor, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/243) **Collaboration on:** Colloidal Systems, Evaporation, Shell Formation.",
    "url": "https://comphy-lab.org/team/#adj-prof-alvaro-marin",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Christian Diddens",
    "content": "[ ](https://scholar.google.com/citations?user=3QSyucwAAAAJ&hl=en&inst=5726176096060060532&oi=ao) [ ](https://github.com/cdiddens) - [Group Leader, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1143) - [Developer of pyoomph](https://pyoomph.github.io/) **Collaboration on:** Surfactant Dynamics in Free Surface Flows, Dissipative Anomaly, Sliding Drops.",
    "url": "https://comphy-lab.org/team/#dr-christian-diddens",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Prof. Gareth McKinley",
    "content": "[ ](https://scholar.google.com/citations?user=uLxFfGkAAAAJ) [ ](https://en.wikipedia.org/wiki/Gareth_H._McKinley) [ ](https://x.com/garethmckinley) - [Professor, MIT](https://nnf.mit.edu/) **Collaboration on:** Die-Swelling, Viscoelastic Flows.",
    "url": "https://comphy-lab.org/team/#prof-gareth-mckinley",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. John Kolinski",
    "content": "[ ](https://scholar.google.com/citations?user=BDzF8kMAAAAJ) [ ](https://en.wikipedia.org/wiki/John_Martin_Kolinski) - [Assistant Professor, EPFL (\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne)](https://people.epfl.ch/john.kolinski) **Collaboration on:** Soft Impact",
    "url": "https://comphy-lab.org/team/#dr-john-kolinski",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. C. Ricardo Constante-Amores",
    "content": "[ ](https://scholar.google.com/citations?user=ncqnphMAAAAJ) [ ](https://github.com/rcrc15) - [Assistant Professor, Univ. Illinois Urbana-Champaign](https://publish.illinois.edu/constanteamores/home/) **Collaboration on:** Non-Newtonian Flows, Bubble Bursting, Herschel--Bulkley Fluids, Elastic Coating.",
    "url": "https://comphy-lab.org/team/#dr-c-ricardo-constante-amores",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Radu Cimpeanu",
    "content": "[ ](https://scholar.google.com/citations?user=6grZnhQAAAAJ&hl=en&inst=5726176096060060532&oi=ao) [ ](https://x.com/rcimpeanu) [ ](https://github.com/RaduCimpeanu) - [Associate Professor, Univ. Warwick](https://www.raducimpeanu.com/) **Collaboration on:** Open-Source Code Development, Non-Coalescence Impacts.",
    "url": "https://comphy-lab.org/team/#dr-radu-cimpeanu",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Jie Feng",
    "content": "[ ](https://scholar.google.com/citations?user=226dDBAAAAAJ) [ ](https://x.com/FengFluidsLab) - [Assistant Professor, Univ. Illinois Urbana-Champaign](https://fengfluidslab.web.illinois.edu/wp/) **Collaboration on:** Elastic Coating, Bursting Bubbles.",
    "url": "https://comphy-lab.org/team/#dr-jie-feng",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Prof. Omar Matar",
    "content": "[ ](https://scholar.google.com/citations?user=mLXz_NAAAAAJ&hl=en) [ ](https://x.com/okmatar?lang=en) - [Professor, Imperial College London](https://profiles.imperial.ac.uk/o.matar) **Collaboration on:** Surfactant Dynamics, Viscoelastic Drop Impact.",
    "url": "https://comphy-lab.org/team/#prof-omar-matar",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Ratul Dasgupta",
    "content": "[ ](https://scholar.google.com/citations?user=I1jFG_oAAAAJ) [ ](https://x.com/RatulDG) - [Associate Professor, IIT Bombay](https://sites.google.com/view/ratuldasgupta/home) **Collaboration on:** Waves, Dissipative Anomaly.",
    "url": "https://comphy-lab.org/team/#dr-ratul-dasgupta",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Prof. Eric Lauga",
    "content": "[ ](https://scholar.google.com/citations?hl=en&user=5ObY7hsAAAAJ) - [Professor, Univ. Cambridge](https://www.damtp.cam.ac.uk/user/lauga/) **Collaboration on:** Mycofluidic Transport.",
    "url": "https://comphy-lab.org/team/#prof-eric-lauga",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Saikat Datta",
    "content": "[ ](https://scholar.google.com/citations?user=o4mXtIgAAAAJ) - Senior Lecturer, Swansea University **Collaboration on:** Multiscale Simulation, Ice Nucleation and Removal, Hydrogen Storage.",
    "url": "https://comphy-lab.org/team/#dr-saikat-datta",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Doris Vollmer",
    "content": "[ ](https://orcid.org/0000-0001-9599-5589) - [Apl. Professor, Max Planck Institute for Polymer Research, Mainz, Germany.](https://www.mpip-mainz.mpg.de/en/butt/groups/vollmer) **Collaboration on:** Contact Line, Drop Impact, Superhydrophobic Surfaces.",
    "url": "https://comphy-lab.org/team/#dr-doris-vollmer",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Prof. St\u00e9phane Zaleski",
    "content": "[ ](https://scholar.google.com/citations?hl=en&user=no1GX_QAAAAJ) [ ](https://x.com/zaleski) - [Professor, Sorbonne Universite](http://www.ida.upmc.fr/~zaleski/zaleski.html) **Collaboration on:** Holey Sheets.",
    "url": "https://comphy-lab.org/team/#prof-st\u00e9phane-zaleski",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Pierre Chantelot",
    "content": "[ ](https://scholar.google.nl/citations?user=BQWXUKYAAAAJ) - [Postdoc, Institut Langevin, ESPCI Paris](https://sites.google.com/view/pierre-chantelot/) **Collaboration on:** Drop Impact",
    "url": "https://comphy-lab.org/team/#dr-pierre-chantelot",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Aleksandr Bashkatov",
    "content": "[ ](https://scholar.google.com/citations?user=9_vPSFsAAAAJ&hl=en&inst=5726176096060060532&oi=ao) - [Postdoc, RWTH Aachen University](https://scholar.google.com/citations?user=9_vPSFsAAAAJ&hl=en&inst=5726176096060060532&oi=ao) **Collaboration on:** Electrolysis, Bubble Coalescence, Swimming Bubbles.",
    "url": "https://comphy-lab.org/team/#dr-aleksandr-bashkatov",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Vincent Bertin",
    "content": "[ ](https://scholar.google.com/citations?user=jO_RTLR2xBYC&hl=en&inst=5726176096060060532&oi=ao) - [Postdoc, University Aix-Marseille](https://vincent-bertin.github.io/) **Collaboration on:** Elastic Sheets, Spinning Pizza.",
    "url": "https://comphy-lab.org/team/#dr-vincent-bertin",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Alexandros Oratis",
    "content": "[ ](https://scholar.google.com/citations?user=2lOr8WQAAAAJ&hl=en&inst=5726176096060060532&oi=ao) - [Postdoc, TU Delft](https://garbinlab.org/people/) **Collaboration on:** Electrolysis, Bubble Coalescence, Swimming Bubbles.",
    "url": "https://comphy-lab.org/team/#dr-alexandros-oratis",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Arivazhagan (Ari) Balasubramanian M.Sc.",
    "content": "[ ](https://scholar.google.com/citations?user=xyheRZ8AAAAJ) [ ](https://github.com/GbArivazhagan) [ ](https://bsky.app/profile/gbarivaz.bsky.social) - [Ph.D. Student, KTH Sweden](https://www.kth.se/profile/argb?l=en) **Collaboration on:** Elastoviscoplastic Flows, Bursting Bubbles",
    "url": "https://comphy-lab.org/team/#arivazhagan-ari-balasubramanian-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Dr. Konstantinos (Costis) Zinelis",
    "content": "[ ](https://scholar.google.com/citations?user=dZrR_z8AAAAJ&hl=en&inst=5726176096060060532&oi=ao) [ ](https://x.com/KZinelis) - [Postdoc, MIT](https://qigroup.mit.edu/team/) **Collaboration on:** Viscoelastic Flows, Drop Impact.",
    "url": "https://comphy-lab.org/team/#dr-konstantinos-costis-zinelis",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Milan Sent B.Sc.",
    "content": "[ ](https://github.com/mdjsent) - **2025:** Graduated with B.Sc., Univ. Twente - Spinning Pizza",
    "url": "https://comphy-lab.org/team/#milan-sent-bsc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Valentin Rosario M.Sc.",
    "content": "[ ](https://www.linkedin.com/in/valentin-rosario-6377602b2/?originalSubdomain=nl) [ ](https://github.com/ValeRos9) - **2024:** Graduated with M.Sc., Univ. Amsterdam - Modelling the Ward--Hunt ice-shelf as viscoelastic solid",
    "url": "https://comphy-lab.org/team/#valentin-rosario-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Swen van den Heuvel M.Sc.",
    "content": "[ ](https://www.linkedin.com/in/swen-van-den-heuvel-33a1901aa/) - **Now:** [Ph.D. Student, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/2119) - **2023:** [Graduated with M.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/2119) - Hydrodynamic forces acting on vertically rising bubbles",
    "url": "https://comphy-lab.org/team/#swen-van-den-heuvel-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Niels Kuipers B.Sc.",
    "content": "[ ](https://www.linkedin.com/in/nielskuipers1/) - **Now:** M.Sc. Student, Adv. Technology - Univ. Twente - **2023:** [Graduated with B.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/2064) - Partial coalescence of drops on viscous films",
    "url": "https://comphy-lab.org/team/#niels-kuipers-bsc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - C. H. (Luuk) Maurits M.Sc.",
    "content": "- **2023:** [Graduated with M.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1741) - When Laplace meets Marangoni",
    "url": "https://comphy-lab.org/team/#c-h-luuk-maurits-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Tom Appleford M.Sc.",
    "content": "- **Now:** [Ph.D. Student, Fluid Lab - Univ. Amsterdam](https://www.fluidlab.nl/team) - **2022:** [Graduated with M.Sc., Univ. Amsterdam](https://pof.tnw.utwente.nl/people/profile/1741) - The deformation of a droplet in a viscoplastic simple shear flow",
    "url": "https://comphy-lab.org/team/#tom-appleford-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Twan Heijink B.Sc.",
    "content": "[ ](https://www.linkedin.com/in/twanheijink/) - **Now:** Software IVQA Engineer at Thales - **2021:** [Graduated with B.Sc., Saxion Univ.](https://pof.tnw.utwente.nl/people/profile/1822) - Standing waves at a fluid-fluid interface with plastocapillarity",
    "url": "https://comphy-lab.org/team/#twan-heijink-bsc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Steven Meuleman M.Sc.",
    "content": "[ ](https://www.linkedin.com/in/steven-meuleman/) - **Now:** Mechanical Engineer at VIRO - **2020:** Graduated with B.Sc., Univ. Twente - Simulations of foam generation for a custom axisymmetric core-shell nozzle",
    "url": "https://comphy-lab.org/team/#steven-meuleman-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Thijmen Kroeze M.Sc.",
    "content": "[ ](https://www.linkedin.com/in/thijmen-kroeze-535aa3207/) - **Now:** CFD Engineer, Brink Climate Systems - **2020:** [Graduated with B.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1630) - Singular jet dynamics of drop impacts at high Bond numbers",
    "url": "https://comphy-lab.org/team/#thijmen-kroeze-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Coen Verschuur M.Sc.",
    "content": "- **Now:** [Ph.D. Student, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1709) - **2020:** [Graduated with B.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1709) - Early time dynamics in immiscible drop impacts",
    "url": "https://comphy-lab.org/team/#coen-verschuur-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Pim J. Dekker M.Sc.",
    "content": "[ ](https://www.linkedin.com/in/pim-dekker/) - **Now:** [Ph.D. Student, Phys. Fluids - Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1431) - **2019:** [Graduated with B.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1431) - Spreading of a drop on a water-air interface",
    "url": "https://comphy-lab.org/team/#pim-j-dekker-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "Our Team & Collaborators - Laurence Bruggink M.Sc.",
    "content": "[ ](https://www.linkedin.com/in/laurence-bruggink-b733b222a/) - **Now:** Research Engineer at Alfen - **2019:** [Graduated with B.Sc., Univ. Twente](https://pof.tnw.utwente.nl/people/profile/1518) - Bursting bubble in a Herschel--Bulkley fluid",
    "url": "https://comphy-lab.org/team/#laurence-bruggink-msc",
    "type": "website_section",
    "priority": 1
  },
  {
    "title": "[17] Bashkatov, A., B\u00fcrkle, F., Demirk\u0131r, \u00c7., Ding, W.,Sanjay, V., Babich, A., Yang, X., Mutschke, G., Czarske, J., Lohse, D., et al. Electrolyte droplet spraying in H2 bubbles during water electrolysis under normal and microgravity conditions. Nat. Commun., 16, 4580 (2025).",
    "content": "[17] Bashkatov, A., B\u00fcrkle, F., Demirk\u0131r, \u00c7., Ding, W.,Sanjay, V., Babich, A., Yang, X., Mutschke, G., Czarske, J., Lohse, D., et al. Electrolyte droplet spraying in H2 bubbles during water electrolysis under normal and microgravity conditions. Nat. Commun., 16, 4580 (2025).",
    "url": "https://comphy-lab.org/research/#17",
    "type": "paper",
    "tags": [
      "Bubbles",
      "Jets",
      "Coalescence",
      "Soft-matter-singularities",
      "Drops"
    ],
    "priority": 2
  },
  {
    "title": "[15]Sanjay, V., & Lohse, D. Unifying theory of scaling in drop impact: Forces & maximum spreading diameter. Phys. Rev. Lett., 134, 104003 (2025).",
    "content": "[15]Sanjay, V., & Lohse, D. Unifying theory of scaling in drop impact: Forces & maximum spreading diameter. Phys. Rev. Lett., 134, 104003 (2025).",
    "url": "https://comphy-lab.org/research/#15",
    "type": "paper",
    "tags": [
      "Drops",
      "Dissipative anomaly",
      "Superamphiphobic-surfaces",
      "Impact forces"
    ],
    "priority": 2
  },
  {
    "title": "[14]Sanjay, V., Zhang, B., Lv, C., & Lohse, D. The role of viscosity on drop impact forces on non-wetting surfaces. J. Fluid Mech., 1004, A6 (2025).",
    "content": "[14]Sanjay, V., Zhang, B., Lv, C., & Lohse, D. The role of viscosity on drop impact forces on non-wetting surfaces. J. Fluid Mech., 1004, A6 (2025).",
    "url": "https://comphy-lab.org/research/#14",
    "type": "paper",
    "tags": [
      "Drops",
      "Impact forces"
    ],
    "priority": 2
  },
  {
    "title": "[13] Kayal, L.,Sanjay, V., Yewale, N., Kumar, A., & Dasgupta, R. Focusing of concentric free-surface waves. J. Fluid Mech., 1003, A14 (2025).",
    "content": "[13] Kayal, L.,Sanjay, V., Yewale, N., Kumar, A., & Dasgupta, R. Focusing of concentric free-surface waves. J. Fluid Mech., 1003, A14 (2025).",
    "url": "https://comphy-lab.org/research/#13",
    "type": "paper",
    "tags": [
      "Waves",
      "Dissipative anomaly"
    ],
    "priority": 2
  },
  {
    "title": "[12] Balasubramanian, A. G.,Sanjay, V., Jalaal, M., Vinuesa, R., & Tammisola, O. Bursting bubble in an elastoviscoplastic medium. J. Fluid Mech., 1001, A9 (2024).",
    "content": "[12] Balasubramanian, A. G.,Sanjay, V., Jalaal, M., Vinuesa, R., & Tammisola, O. Bursting bubble in an elastoviscoplastic medium. J. Fluid Mech., 1001, A9 (2024).",
    "url": "https://comphy-lab.org/research/#12",
    "type": "paper",
    "tags": [
      "Bubbles",
      "Non-Newtonian",
      "Jets",
      "Soft-matter-singularities"
    ],
    "priority": 2
  },
  {
    "title": "[10]Sanjay, V., Lakshman, S., Chantelot, P., Snoeijer, J. H., & Lohse, D. Drop impact on viscous liquid films. J. Fluid Mech., 958, A25 (2023).",
    "content": "[10]Sanjay, V., Lakshman, S., Chantelot, P., Snoeijer, J. H., & Lohse, D. Drop impact on viscous liquid films. J. Fluid Mech., 958, A25 (2023).",
    "url": "https://comphy-lab.org/research/#10",
    "type": "paper",
    "tags": [
      "Drops",
      "Bouncing",
      "Superhydrophobic surfaces"
    ],
    "priority": 2
  },
  {
    "title": "\u27a1\ufe0fSanjay, V.Viscous free-surface flows. Ph.D. Thesis, Physics of Fluids, University of Twente (2022).",
    "content": "\u27a1\ufe0fSanjay, V.Viscous free-surface flows. Ph.D. Thesis, Physics of Fluids, University of Twente (2022).",
    "url": "https://comphy-lab.org/research/#thesis",
    "type": "paper",
    "tags": [
      "Drops",
      "Jets",
      "Sheets",
      "Bubbles",
      "Soft-matter-singularities",
      "Non-Newtonian"
    ],
    "priority": 2
  },
  {
    "title": "[9]Sanjay, V., Sen, U., Kant, P., and Lohse, D. Taylor\u2013Culick retractions and the influence of the surroundings. J. Fluid Mech., 948, A14 (2022).",
    "content": "[9]Sanjay, V., Sen, U., Kant, P., and Lohse, D. Taylor\u2013Culick retractions and the influence of the surroundings. J. Fluid Mech., 948, A14 (2022).",
    "url": "https://comphy-lab.org/research/#9",
    "type": "paper",
    "tags": [
      "Sheets",
      "Dissipative anomaly",
      "Retraction"
    ],
    "priority": 2
  },
  {
    "title": "[8] Zhang, B.,Sanjay, V., Shi, S., and Zhao, Y., and Lv, C., and Feng, X.-Q., & Lohse, D. Impact forces of water drops falling on superhydrophobic surfaces. Phys. Rev. Lett., 129(10), 104501 (2022).",
    "content": "[8] Zhang, B.,Sanjay, V., Shi, S., and Zhao, Y., and Lv, C., and Feng, X.-Q., & Lohse, D. Impact forces of water drops falling on superhydrophobic surfaces. Phys. Rev. Lett., 129(10), 104501 (2022).",
    "url": "https://comphy-lab.org/research/#8",
    "type": "paper",
    "tags": [
      "Drops",
      "Superhydrophobic surfaces",
      "Impact forces"
    ],
    "priority": 2
  },
  {
    "title": "[7]Sanjay, V., Lohse, D., & Jalaal, M. Bursting bubble in a viscoplastic medium. J. Fluid Mech., 922, A2 (2021).",
    "content": "[7]Sanjay, V., Lohse, D., & Jalaal, M. Bursting bubble in a viscoplastic medium. J. Fluid Mech., 922, A2 (2021).",
    "url": "https://comphy-lab.org/research/#7",
    "type": "paper",
    "tags": [
      "Bubbles",
      "Jets",
      "Non-Newtonian",
      "Soft-matter-singularities"
    ],
    "priority": 2
  },
  {
    "title": "[6] Ram\u00edrez-Soto, O.,Sanjay, V., Lohse, D., Pham, J. T., & Vollmer, D. Lifting a sessile oil drop from a superamphiphobic surface with an impacting one. Sci. Adv., 6(34), eaba4330 (2020).",
    "content": "[6] Ram\u00edrez-Soto, O.,Sanjay, V., Lohse, D., Pham, J. T., & Vollmer, D. Lifting a sessile oil drop from a superamphiphobic surface with an impacting one. Sci. Adv., 6(34), eaba4330 (2020).",
    "url": "https://comphy-lab.org/research/#6",
    "type": "paper",
    "tags": [
      "Drops",
      "Superamphiphobic-surfaces",
      "Lifting"
    ],
    "priority": 2
  },
  {
    "title": "[5] Jain, A.,Sanjay, V., & Das, A. K. Consequences of inclined and dual jet impingement in stagnant liquid and stratified layers. AIChE J., 65(1), 372-384 (2019).",
    "content": "[5] Jain, A.,Sanjay, V., & Das, A. K. Consequences of inclined and dual jet impingement in stagnant liquid and stratified layers. AIChE J., 65(1), 372-384 (2019).",
    "url": "https://comphy-lab.org/research/#5",
    "type": "paper",
    "tags": [
      "Jets",
      "Bubbles"
    ],
    "priority": 2
  },
  {
    "title": "[4] Soni, A.,Sanjay, V., & Das, A. K. Formation of fluid structures due to jet-jet and jet-sheet interactions. Chem. Eng. Sci., 191, 67-77 (2018).",
    "content": "[4] Soni, A.,Sanjay, V., & Das, A. K. Formation of fluid structures due to jet-jet and jet-sheet interactions. Chem. Eng. Sci., 191, 67-77 (2018).",
    "url": "https://comphy-lab.org/research/#4",
    "type": "paper",
    "tags": [
      "Jets"
    ],
    "priority": 2
  },
  {
    "title": "[3]Sanjay, V., Das, A.K. Numerical assessment of hazard in compartmental fire having steady heat release rate from the source. Build. Simul. 11, 613\u2013624 (2018).",
    "content": "[3]Sanjay, V., Das, A.K. Numerical assessment of hazard in compartmental fire having steady heat release rate from the source. Build. Simul. 11, 613\u2013624 (2018).",
    "url": "https://comphy-lab.org/research/#3",
    "type": "paper",
    "tags": [
      "Others",
      "Fire",
      "Evacuation"
    ],
    "priority": 2
  },
  {
    "title": "[2]Sanjay, V., & Das, A. K. Formation of liquid chain by collision of two laminar jets. Phys. Fluids, 29(11), 112101 (2017).",
    "content": "[2]Sanjay, V., & Das, A. K. Formation of liquid chain by collision of two laminar jets. Phys. Fluids, 29(11), 112101 (2017).",
    "url": "https://comphy-lab.org/research/#2",
    "type": "paper",
    "tags": [
      "Jets",
      "Sheets"
    ],
    "priority": 2
  },
  {
    "title": "[1]Sanjay, V., & Das, A. K. On air entrainment in a water pool by impingement of a jet. AIChE J., 63(11), 5169-5181 (2017).",
    "content": "[1]Sanjay, V., & Das, A. K. On air entrainment in a water pool by impingement of a jet. AIChE J., 63(11), 5169-5181 (2017).",
    "url": "https://comphy-lab.org/research/#1",
    "type": "paper",
    "tags": [
      "Jets",
      "Bubbles"
    ],
    "priority": 2
  },
  {
    "title": "Teaching - Teaching",
    "content": "Welcome to the CoMPhy Lab's educational resources. Apart from the university courses, we aim to develop and offer a range of workshops and tutorials on modern computational methods for multiphase flows and high-fidelity simulations. High-Fidelity Simulations Using Basilisk C Universidad Carlos III de Madrid March 10-13, 2025 A comprehensive course on using Basilisk C for simulating multiphase flows, interface tracking, and solving conservation equations. Learn to tackle complex fluid dynamics problems with high-fidelity numerical methods. View Course",
    "url": "https://comphy-lab.org/teaching/#teaching",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "Teaching - About Our Teaching Philosophy",
    "content": "At CoMPhy Lab, we believe in hands-on learning and deep understanding of computational methods. Our courses combine theoretical foundations with practical implementation, allowing students to develop both conceptual understanding and technical skills. Our teaching approach emphasizes: - **Think before you compute**: Understanding the underlying physics before implementation - **Modular code structure**: Building maintainable and extensible computational tools - **Advanced numerical methods**: Mastering state-of-the-art techniques for complex problems - **Open science**: Sharing knowledge and tools with the scientific community. Checkout If you're interested in hosting a course or workshop with CoMPhy Lab, please [contact us](/join) for collaboration opportunities.",
    "url": "https://comphy-lab.org/teaching/#about-our-teaching-philosophy",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\"",
    "content": "// Function to update image visibility based on theme function updateBannerImages() { const theme = document.documentElement.getAttribute('data-theme') || 'light'; const lightImages = document.querySelectorAll('.light-mode-img'); const darkImages = document.querySelectorAll('.dark-mode-img'); if (theme === 'dark') { lightImages.forEach(img => img.style.display = 'none'); darkImages.forEach(img => img.style.display = 'block'); } else { lightImages.forEach(img => img.style.display = 'block'); darkImages.forEach(img => img.style.display = 'none'); } } // Run on page load document.addEventListener('DOMContentLoaded', updateBannerImages); // Watch for theme changes const observer = new MutationObserver(function(mutations) { mutations.forEach(function(mutation) { if (mutation.attributeName === 'data-theme') { updateBannerImages(); } }); }); observer.observe(document.documentElement, { attributes: true });",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid",
    "type": "website_content",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - High-Fidelity Simulations Using Basilisk C",
    "content": "Dates March 10-13, 2025 Location Universidad Carlos III de Madrid, Spain Duration 4 days, full-time",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#high-fidelity-simulations-using-basilisk-c",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - What will you learn?",
    "content": "- **Think before you compute!** Understanding the physics before implementation - **Writing the first code in Basilisk C** Getting comfortable with the framework - **Solving conservation equations** Numerical approaches to fluid dynamics - **Interface tracking methods** Capturing multiphase phenomena accurately - **Non-Newtonian flows** Modeling complex rheological behaviors",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#what-will-you-learn",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Course Description",
    "content": "This intensive 4-day course provides a comprehensive introduction to high-fidelity simulations using Basilisk C, a powerful computational framework for fluid dynamics. Participants will learn to implement and solve complex fluid mechanics problems with an emphasis on multiphase flows, interface dynamics, and non-Newtonian rheology. The course combines theoretical lectures with extensive hands-on sessions, allowing participants to immediately apply concepts through guided coding exercises. By the end of the course, you'll be able to develop your own simulations for a variety of fluid dynamics applications.",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#course-description",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Think before you compute",
    "content": "- **10:00-11:30** &nbsp;|&nbsp; **Lecture (1a)** - Conservation laws and the numerical solution of the Navier\u2013Stokes equations - **11:45-13:00** &nbsp;|&nbsp; **Lecture (1b)** - Transport equations - *Brief intro to Basilisk coding framework*",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#think-before-you-compute",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - First coding steps",
    "content": "- **15:00-18:00** &nbsp;|&nbsp; **Hybrid Session** - Implementing basic transport equations in Basilisk C. - Using headers in Basilisk, modular code structure, problem setup, and compilation - *Whiteboard + coding* - [1st Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment)",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#first-coding-steps",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Coding like a pro",
    "content": "- **10:00-11:15** &nbsp;|&nbsp; **Hackathon (1c)** - Solving Navier\u2013Stokes equations in Basilisk C. - [2nd Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment) - **11:30-13:00** &nbsp;|&nbsp; **Hackathon Continued** - Expanding on the morning tasks and code debugging",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#coding-like-a-pro",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Interface tracking methods",
    "content": "- **10:00-11:30** &nbsp;|&nbsp; **Lecture (2a)** - Interface tracking methods (VoF, level set, phase-field approaches) and numerical strategies - **11:45-13:00** &nbsp;|&nbsp; **Hackathon (2b)** - Hands-on tutorial with interface-tracking to a simple two-phase problem - [3rd Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment)",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#interface-tracking-methods",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Seminar",
    "content": "- **13:30-14:00** &nbsp;|&nbsp; **Department seminar (2c)** - A note on the thrust of airfoils by [Jos\u00e9 Manuel Gordillo](https://scholar.google.com/citations?user=14wOsewAAAAJ&hl=en&inst=5726176096060060532&oi=ao)",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#seminar",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Non-Newtonian flows",
    "content": "- **15:00-16:00** &nbsp;|&nbsp; **Lecture (3a)** - Non-Newtonian flows: viscoelasticity. - **16:15-18:00** &nbsp;|&nbsp; **Hackathon (3b)** - Coding exercises for viscoelastic fluids. - [4th Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment)",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#non-newtonian-flows",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Special topics",
    "content": "- **10:00-11:30** &nbsp;|&nbsp; **Lecture (4a)** - Review and catching up on [4th Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment). - Special Topics: Three-phase flows, - **11:45-13:00** &nbsp;|&nbsp; **Hackathon (4b)** - Special Topics: Holey Sheets, Contact line dynamics. - **15:00-16:30** &nbsp;|&nbsp; **Lecture (4c)** - Open discussion, deeper dives into advanced features, final code reviews, and next steps. ---",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#special-topics",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Prerequisites",
    "content": "- Basic knowledge of fluid mechanics - Experience with programming (any language, C preferred) - Understanding of partial differential equations - Laptop with ability to compile C code",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#prerequisites",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "\"High-Fidelity Simulations Using Basilisk C\" - Registration",
    "content": "For registration details, please contact bubbles@ing.uc3m.es vatsalsy@comphy-lab.org function copyEmail(button) { const textToCopy = button.getAttribute('data-text'); // Create a temporary textarea element to copy from const textarea = document.createElement('textarea'); textarea.value = textToCopy; textarea.setAttribute('readonly', ''); textarea.style.position = 'absolute'; textarea.style.left = '-9999px'; document.body.appendChild(textarea); // Select and copy the text textarea.select(); document.execCommand('copy'); // Remove the temporary element document.body.removeChild(textarea); // Show feedback const originalIcon = button.innerHTML; button.innerHTML = ' '; button.classList.add('copied'); // Restore original state after a delay setTimeout(() => { button.innerHTML = originalIcon; button.classList.remove('copied'); }, 2000); } Course GitHub Repository",
    "url": "https://comphy-lab.org/teaching/2025-Basilisk101-Madrid#registration",
    "type": "website_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public",
    "content": "![CoMPhy-Lab](_Media/CoMPhy-Lab-no-name.png) Here is a list of things on our to-publish list: - [ ] Stokes waves and related topics \ud83d\udcc5 2025-03-01 \u23f3 2025-02-05 ^E1A6F85F-5E63-405E-9EF7-E8CC8662D3CC - [x] Showcase bubbles, waves: \ud83d\udcc5 2025-01-12 ^0B681993-8C8A-49A5-93B6-83368684058E",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "0_todo blog public - To-Do: Blog Posts on Research Papers and Thesis",
    "content": "Below is a list of all the papers and the thesis requiring a dedicated blog post. Each post should highlight the motivation, key findings, and broader implications of the work, along with engaging visuals or videos (where applicable). ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#to-do-blog-posts-on-research-papers-and-thesis",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - Work in Progress",
    "content": "- [ ] **To jump or not to jump: Adhesion and viscous dissipation dictate the detachment of coalescing wall-attached bubbles** Link: [arXiv:2501.05532](https://arxiv.org/abs/2501.05532) - [ ] **Viscoelastic Worthington jets & droplets produced by bursting bubbles** Link: [arXiv:2408.05089](https://arxiv.org/abs/2408.05089) - [ ] **Unifying theory of scaling in drop impact: Forces & maximum spreading diameter** Link: [arXiv:2408.12714](https://arxiv.org/abs/2408.12714) - [ ] **Electrolyte spraying within H\u2082 bubbles during water electrolysis** Link: [arXiv:2409.00515](https://arxiv.org/abs/2409.00515) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#work-in-progress",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2025",
    "content": "- [ ] **The role of viscosity on drop impact forces on non-wetting surfaces** Link: [arXiv:2311.03012](https://arxiv.org/abs/2311.03012) - [ ] **Focusing of concentric free-surface waves** Link: [arXiv:2406.05416](https://arxiv.org/abs/2406.05416) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2025",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2024",
    "content": "- [ ] **Bursting bubble in an elastoviscoplastic medium** Highlight: Cover of _J. Fluid Mech._ Link: [DOI](https://doi.org/10.1017/jfm.2024.109) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2024",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2023",
    "content": "- [ ] **Drop impact on viscous liquid films** Link: [DOI](https://doi.org/10.1017/jfm.2023.895) - [ ] **When does an impacting drop stop bouncing?** Link: [DOI](https://doi.org/10.1017/jfm.2023.896) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2023",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2022",
    "content": "- [ ] **Ph.D. Thesis: Viscous free-surface flows** Links: [Thesis Info](https://www.vatsalsanjay.com/phd-thesis), [DOI](https://doi.org/10.3990/1.9789036554077), move here from old website - [ ] **Impact forces of water drops falling on superhydrophobic surfaces** Highlights: Editor's Suggestion, Research Highlight in _Nature_ Link: [DOI](https://doi.org/10.1103/PhysRevLett.129.104501) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2022",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2021",
    "content": "- [ ] **Bursting bubble in a viscoplastic medium** Link: [DOI](https://doi.org/10.1017/jfm.2021.489) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2021",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2020",
    "content": "- [ ] **Lifting a sessile oil drop from a superamphiphobic surface with an impacting one** Link: [DOI](https://doi.org/10.1126/sciadv.aba4330) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2020",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2019",
    "content": "- [ ] **Consequences of inclined and dual jet impingement in stagnant liquid and stratified layers** Link: [DOI](https://doi.org/10.1002/aic.16373) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2019",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2018",
    "content": "- [ ] **Formation of fluid structures due to jet-jet and jet-sheet interactions** Link: [DOI](https://doi.org/10.1016/j.ces.2018.06.055) - [ ] **Numerical assessment of hazard in compartmental fire having steady heat release rate from the source** Link: [DOI](https://doi.org/10.1007/s12273-017-0411-y) ---",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2018",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_todo blog public - 2017",
    "content": "- [ ] **Formation of liquid chain by collision of two laminar jets** Link: [DOI](https://doi.org/10.1063/1.4998288) - [ ] **On air entrainment in a water pool by impingement of a jet** Link: [DOI](https://doi.org/10.1002/aic.15828) --- > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/0_ToDo-Blog-public/#2017",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Private todo blog public - Elasticity and viscoelasticity",
    "content": "- [ ] Jacco paper \u23f3 2025-01-24 \ud83d\udcc5 2025-02-03 ^9A6D89F2-1B19-460B-9DAD-DAB0109C0BC3 - [ ] all about the elastic mapping \u23f3 2025-01-26 \ud83d\udcc5 2025-02-09 ^499BBFE0-EB2C-48CD-B8F4-7DFA004C79A7",
    "url": "https://blogs.comphy-lab.org/Private-ToDo-Blog-public/#elasticity-and-viscoelasticity",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Computational Multiphase Physics <br> (CoMPhy)",
    "content": "Welcome to the CoMPhy Lab's documentation hub! We are based at the Physics of Fluids Department at the University of Twente, where we explore non-Newtonian free-surface flows and soft matter singularities.",
    "url": "https://blogs.comphy-lab.org/0_README/#computational-multiphase-physics-br-comphy",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Elastoinertial turbulence:",
    "content": "2025-02-24 [[Arrowheads in elastoinertial turbulence]]: Critical review of arrowhead structures in elastoinertial turbulence, examining their existence in 3D flows and experimental observations.",
    "url": "https://blogs.comphy-lab.org/0_README/#elastoinertial-turbulence",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Drop impact dynamics:",
    "content": "2025-02-22 [[2025-JFM-viscous-drop-impact]]: Comprehensive study of viscosity's role in drop impact forces, from raindrops to inkjet printing applications.",
    "url": "https://blogs.comphy-lab.org/0_README/#drop-impact-dynamics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Capillary waves:",
    "content": "2025-01-11 [[Features-of-capillary-waves-during-asymmetric-bubble-coalescence]]: Analysis of capillary wave dynamics during bubble coalescence, focusing on energy transfer and wave propagation mechanisms.",
    "url": "https://blogs.comphy-lab.org/0_README/#capillary-waves",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - H-B formulation:",
    "content": "2024-12-31 [[Herschel\u2013Bulkley formulation]]: Mathematical formulation of the Herschel-Bulkley model for non-Newtonian flows, with emphasis on yield stress fluids.",
    "url": "https://blogs.comphy-lab.org/0_README/#h-b-formulation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Gauss' Law:",
    "content": "2025-01-21 [[Gauss law of Electrostatics]]: Analysis of electric field flux through different surfaces using Gauss's law, with visual demonstrations.",
    "url": "https://blogs.comphy-lab.org/0_README/#gauss-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Seminar-UIUC",
    "content": "2025-01-19 [[Seminar-UIUC-abstract]]: UIUC fluid seminar abstract exploring polymeric flows as a tunable testbed for unsteady, nonlinear continuum mechanics.",
    "url": "https://blogs.comphy-lab.org/0_README/#seminar-uiuc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Connect With Us",
    "content": "- \ud83c\udf10 Website: [comphy-lab.org](http://www.comphy-lab.org) - \ud83d\udce7 Email: [vatsalsy@comphy-lab.org](mailto:vatsalsy@comphy-lab.org) - \ud83d\udc26 Twitter: [@VatsalSanjay](https://twitter.com/VatsalSanjay) - \ud83d\udcbb GitHub: [github.com/VatsalSy](https://github.com/VatsalSy)",
    "url": "https://blogs.comphy-lab.org/0_README/#connect-with-us",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Contributing: We welcome contributions...",
    "content": "We welcome contributions from researchers, students, and collaborators. Here's how you can contribute: 1. **Issues**: Found a problem or have a suggestion?",
    "url": "https://blogs.comphy-lab.org/0_README/#contributing",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0_readme - Contributing: Choose an option...",
    "content": "Choose an option below: - [\ud83d\udde3\ufe0f Request a new blog topic](https://github.com/comphy-lab/CoMPhy-Lab-Blogs/issues/new?template=blog_topic_request.md&labels=blog-request,enhancement) - [\ud83d\udcda Request documentation](https://github.com/comphy-lab/CoMPhy-Lab-Blogs/issues/new?template=documentation_request.md&labels=documentation) - [\ud83d\udd0d Report content correction](https://github.com/comphy-lab/CoMPhy-Lab-Blogs/issues/new?template=content_correction.md&labels=correction) 2. **Pull Requests**: Want to contribute directly? - Fork the repository - Make your changes (it can simply be correcting grammar or making a new post - simply write in plain text or markdown format and add it to the root folder). - Submit a pull request with a clear description of your changes Visit our [GitHub repository](https://github.com/comphy-lab/CoMPhy-Lab-Blogs) to get started. --- *Note: This documentation is maintained by the CoMPhy Lab team and is regularly updated with our latest research findings and computational methods.* > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/0_README/#contributing",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - Viscoelastic Worthington Jets & Droplets: Breaking the Surface of Bubble Physics: > [!abstract] TL;DR...",
    "content": "> [!abstract] TL;DR > When bubbles burst at a liquid surface, they create jets and droplets through a fascinating physical process. Our research reveals how adding polymers to the liquid dramatically changes this behavior, creating three distinct regimes depending on elasticity and relaxation time. These findings have implications for everything from oceanic aerosols to biomedical applications and industrial processes. Have you ever watched a bubble pop at the surface of your sparkling water or champagne? This seemingly simple event $-$ a bubble bursting $-$ conceals rich physics that connects to remarkably diverse phenomena, from ocean spray formation to pathogen transmission in respiratory droplets. As a fluid dynamicist studying interfacial phenomena, I've long been fascinated by what happens in the fleeting moments after a bubble bursts. When a bubble at a liquid\u2013air interface bursts, it often shoots out a thin, fast jet of liquid \u2013 a striking phenomenon known as a _Worthington jet_.",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#viscoelastic-worthington-jets-droplets-breaking-the-surface-of-bubble-physics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - Viscoelastic Worthington Jets & Droplets: Breaking the Surface of Bubble Physics: This process isn\u2019t...",
    "content": "This process isn\u2019t just a neat visual; it plays a role in everything from ocean spray to the fizz in a glass of champagne. In a typical **Newtonian** fluid like water (where the liquid\u2019s viscosity is constant), a bursting bubble leads to an upward jet driven by surface tension. As the jet rises, it can break up into one or multiple tiny droplets due to the Rayleigh\u2013Plateau instability (the same mechanism that causes a stream of water to form droplets). This is the classic picture that decades of research established for bursting bubbles in simple liquids. But what happens if the liquid is not so simple \u2013 say it contains a bit of polymer or has elastic properties? It turns out the story of bubble bursting gets a lot more interesting, which is what our study explores.",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#viscoelastic-worthington-jets-droplets-breaking-the-surface-of-bubble-physics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - The Phenomenon: More Than Just a Pop",
    "content": "When a bubble bursts at a liquid surface, it doesn't simply disappear. Instead, a complex sequence unfolds in milliseconds: 1. The bubble's thin film ruptures[^1][^2] 2. Capillary waves travel along the cavity surface[^3] 3. These waves converge at the bottom of the cavity 4. This convergence creates a focused flow that forms an upward-shooting \"Worthington jet\" [^4][^5][^6] 5. This jet may break into droplets that escape into the air While this process is relatively well-understood for simple liquids like water (Newtonian fluids), many real-world scenarios involve liquids containing polymers\u2014from biological fluids to industrial solutions. Our research investigated how these polymers fundamentally alter the bubble bursting dynamics. See [[History-Worthington-jets-from-bursting-bubbles]] for historical context.",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#the-phenomenon-more-than-just-a-pop",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - The Physics at Play: A Dance of Forces",
    "content": "> [!note] What makes a fluid viscoelastic? > Viscoelastic fluids contain polymers\u2014long molecular chains that introduce elastic behavior. Unlike ordinary liquids that simply flow, these fluids partially \"remember\" their shape when deformed, similar to a memory foam mattress, but in liquid form! The addition of polymers introduces two key parameters beyond the conventional Ohnesorge number (which relates viscous forces to inertial and surface tension forces): 1. **Elastocapillary number** $Ec$: The ratio of elastic modulus to Laplace pressure, measuring the strength of elastic effects. $$Ec = \\frac{GR_0}{\\gamma} $$ 2. **Deborah number** $De$: The ratio of relaxation time to process time, measuring the fluid's \"memory\". $$De = \\frac{\\lambda}{\\sqrt{\\rho R_0^3/\\gamma}}$$ > [!note] Note: > - Higher $Ec$ means stronger elastic effects > - Higher $De$ means the fluid \"remembers\" deformations longer",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#the-physics-at-play-a-dance-of-forces",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - Key Discoveries: Three Distinct Regimes: Our most fascinating...",
    "content": "Our most fascinating finding was the emergence of three distinct regimes: > [!important] The Three Regimes > > 1. **Jets forming droplets**: At low elasticity or fast relaxation times, similar to Newtonian behavior but with modified dynamics > 2. **Jets without droplet formation**: At intermediate elasticity, where polymeric stresses suppress droplet breakup > 3. **Complete jet suppression**: At high elasticity, where polymer stresses prevent jet formation entirely What's particularly interesting is how these regimes depend on the Deborah number. For high De (approaching infinity), the viscoelastic medium preserves memory of deformations, and transitions occur at sharp Ec thresholds. For low De (approaching zero), the system behaves more like a Newtonian fluid with enhanced effective viscosity. The critical thresholds we identified provide fundamental insights into when and how polymers influence Worthington jets and droplets.",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#key-discoveries-three-distinct-regimes",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - Key Discoveries: Three Distinct Regimes: Remarkably, while viscoelasticity...",
    "content": "Remarkably, while viscoelasticity significantly alters the jet dynamics, it doesn't affect the capillary wave speed!",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#key-discoveries-three-distinct-regimes",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - Implementation Details: ElastoFlow Framework",
    "content": "To conduct these simulations, we developed a framework we call \"ElastoFlow\" for the Basilisk C environment. The implementation handles the complex interplay between viscoelasticity, surface tension, and inertia through: - Volume of Fluid (VoF) method for interface tracking - Log-conformation approach for numerical stability with viscoelastic constitutive models - Adaptive Mesh Refinement for efficiently capturing multiscale dynamics > [!tip] Technical Deep Dive Our computational approach overcomes the notorious \"high Weissenberg number problem\" that has historically plagued viscoelastic simulations. The log-conformation formulation we employed maintains the positive-definiteness of the conformation tensor, enabling stable simulations even in highly elastic regimes.",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#implementation-details-elastoflow-framework",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - Broader Implications: Beyond the Laboratory",
    "content": "This research has implications across several domains: - **Oceanic aerosol formation**: Understanding how polymers in seawater affect bubble bursting could improve climate models - **Biomedical applications**: Insights into how biological fluids produce droplets could help control pathogen transmission - **Industrial processes**: Better design of polymer-containing sprays and foams The ability to predict and potentially control droplet formation by adjusting polymer properties opens new avenues for engineering applications.",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#broader-implications-beyond-the-laboratory",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - For Fellow Researchers",
    "content": "If you're interested in exploring this topic further, our simulation code is available on GitHub. We've designed ElastoFlow to be extensible and adaptable to various viscoelastic problems beyond bubble bursting. The framework includes: - Comprehensive implementation of the Oldroyd-B model - Adaptable boundary conditions - Detailed error controls for fluid properties - Streamlined workflows for high-performance computing environments We're continuing to develop this research direction, and we welcome collaborations and extensions of this work.",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#for-fellow-researchers",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - Final Thoughts: What I find...",
    "content": "What I find most fascinating about this study is how the addition of polymers\u2014molecular chains that introduce elasticity\u2014can fundamentally transform fluid behavior in ways that aren't immediately intuitive. A small amount of polymer can completely suppress droplet formation, or in some regimes, enhance it. This work highlights the rich interplay between elasticity, viscosity, and surface tension at fluid interfaces. Each time I watch a bubble burst in slow motion with our simulations, I'm reminded of how complex and beautiful fluid dynamics can be, even in seemingly simple phenomena we observe every day. For those interested in the technical details, please check out our paper and the available code repositories. And as always, I welcome questions and discussions about this fascinating corner of fluid dynamics! > [!faq] Original Paper > A. Dixit, A. Oratis, K. Zinelis, D. Lohse & V. Sanjay, Viscoelastic Worthington jets and droplets produced by bursting bubbles, J.",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#final-thoughts",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - Final Thoughts: Context",
    "content": "Fluid Mech., 1010, A2 (2025) [Open Access](https://doi.org/10.1017/jfm.2025.237).",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#final-thoughts",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - Videos: Context",
    "content": "--- [^1]: V. Sanjay, U. Sen, P. Kant & D. Lohse, Taylor--Culick retractions and the influence of the surroundings, J. Fluid Mech., 948, A14 (2022), [doi: 10.1017/jfm.2022.671](https://doi.org/10.1017/jfm.2022.671) [^2]: E. Villermaux, Fragmentation versus cohesion, J. Fluid Mech., 898, P1 (2020), [doi: 10.1017/jfm.2020.366](https://doi.org/10.1017/jfm.2020.366) [^3]: V. Sanjay, D. Lohse & M. Jalaal, Bursting bubble in a viscoplastic medium, J. Fluid Mech., 922, A2 (2021), [doi: 10.1017/jfm.2021.489](https://doi.org/10.1017/jfm.2021.489) [^4]: A. M. Worthington, On the forms assumed by drops of liquids falling vertically on a horizontal plate, Proc. R. Soc. London A, 25, 261-272 (1877), [doi: 10.1098/rspl.1876.0048](https://doi.org/10.1098/rspl.1876.0048) [^5]: A. M. Worthington, A second paper on the forms assumed by drops of liquids falling vertically on a horizontal plate, Proc. R. Soc. London, 25, 498-503 (1877), [doi: 10.1098/rspl.1876.0073](https://doi.org/10.1098/rspl.1876.0073) [^6]: A. M.",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#videos",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscoelatic worthington jets - Videos: Worthington, A study...",
    "content": "Worthington, A study of splashes, London: Longman, Green and Co (1908), [link](https://bit.ly/Worthington-splash-book) --- > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: May 6, 2025 > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab), [Blogs](https://blogs.comphy-lab.org)",
    "url": "https://blogs.comphy-lab.org/2025-JFM-Viscoelatic-Worthington-jets/#videos",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - CLAUDE.md",
    "content": "This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#claudemd",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - Repository Overview",
    "content": "This is a research blog repository for the Computational Multiphase Physics (CoMPhy) Lab, containing academic content in Markdown format. The site is published at [blogs-comphy-lab.org](https://blogs-comphy-lab.org/).",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#repository-overview",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - Content Structure",
    "content": "- `Blog/` - Research blog posts and updates - `Code-Documentations/` - Technical documentation - `Lecture-Notes/` - Teaching materials and course content - `Talks/` - Presentation materials and abstracts - `_AtomicNotes/` - Atomic knowledge pieces (linked notes) - `_Media/` - Images and media files - `_scripts/` - Jupyter notebooks for generating figures",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#content-structure",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - Markdown Files",
    "content": "All content uses Markdown with YAML frontmatter: ```yaml --- created: YYYY-MM-DDThh:mm:ss+01:00 modified: YYYY-MM-DDThh:mm:ss+01:00 status: [Published/Working/Draft/done \u2705] website: https://blogs-comphy-lab.org/your-post-url --- ```",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#markdown-files",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - Obsidian Features",
    "content": "- Wiki-style links: `[[post-name]]` and `[[post-name|alias]]` - Image embedding: `![[_Media/filename.png]]` - Callouts: `> [!note]`, `> [!tldr]`, `> [!important]`",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#obsidian-features",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - PDF Export",
    "content": "Convert Markdown to PDF using the export script: ```bash ./.obsidian/scripts/export-pdf.sh \"filename.md\" ``` The script handles: - Obsidian syntax conversion to standard Markdown - Image path processing - Bibliography integration via Pandoc - LaTeX/XeLaTeX PDF generation",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#pdf-export",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - Content Validation",
    "content": "- Ensure all images exist in `_Media/` directory - Verify wiki links point to existing content - Check YAML frontmatter format",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#content-validation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - File Organization",
    "content": "- Place new blog posts in `Blog/` - Store images in `_Media/` with descriptive names - Use atomic notes in `_AtomicNotes/` for reusable concepts",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#file-organization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - Mathematical Content",
    "content": "- Use LaTeX syntax for equations: `$$equation$$` or `$inline$` - Include Jupyter notebooks in `_scripts/` for computational examples - Save generated plots to `_Media/`",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#mathematical-content",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - Academic Standards",
    "content": "- Include proper citations and references - Use descriptive filenames without spaces - Maintain consistent notation across related posts",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#academic-standards",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Claude - Publishing Workflow",
    "content": "Content is managed through: 1. Obsidian vault for local editing 2. Git version control for collaboration 3. Website deployment at blogs-comphy-lab.org The repository supports both individual researchers and collaborative editing through GitHub's issue templates and pull request workflow.",
    "url": "https://blogs.comphy-lab.org/CLAUDE/#publishing-workflow",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - Introduction",
    "content": "Bubble bursting at the liquid\u2013air interface is a ubiquitous phenomenon. Whether in a glass of champagne, a carbonated beverage, or a natural setting (e.g., mudpots, ocean spray), bubbles rise due to buoyancy and eventually rupture at the free surface. Upon bursting, the cavity created in the free surface collapses, generating jets and ejected droplets. These droplets play important roles in: - **Aromatic transport** in champagne and sparkling beverages. - **Pathogen and aerosol spread** in contaminated water or biological fluids (coughing, sneezing). - **Cloud formation** through sea spray in the atmosphere. - **Geophysical processes**, such as mudpots or volcanic lakes involving complex rheology.",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - The Phenomenon",
    "content": "When the bubble film ruptures, a \u201chole\u201d forms in the thin liquid interface. Surface tension drives capillary waves that converge at the bottom of the cavity, shooting liquid upward in a narrow jet. This jet eventually breaks into droplets, as observed in: - **Champagne**: Enhancing aroma and flavor perception. - **Contaminated water**: Ejecting micro-droplets that can carry pathogens. - **Viscoplastic mud**: Where the yield stress of the medium significantly alters jet formation and droplet size. - **Viscoelastic fluids**: Such as mucosalivary fluids during sneezing or coughing. Extensive studies have addressed bubble bursting in Newtonian fluids (e.g., water). However, **non-Newtonian media**\u2014including **viscoplastic** (mud, clay suspensions) and **viscoelastic** (polymeric solutions, mucosal fluids)\u2014pose open research questions due to their complex rheological behavior.",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#the-phenomenon",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - Proposed Approach: This combined proposal...",
    "content": "This combined proposal integrates numerical simulations with potential experimental validation to capture the entire process: 1. **Fundamental Two-Phase Flow** - Implement and validate two-phase flow simulations (e.g., in [Basilisk C](http://basilisk.fr)) for bubble dynamics, jet formation, and droplet ejection in Newtonian fluids. 2. **Non-Newtonian Rheology** - Extend the code to handle **generalized Newtonian** and **viscoelastic** models. - Explore how capillary waves and cavity collapse are altered by viscoplastic or viscoelastic effects. 3. **Comparison & Validation** - Compare numerical results against known scaling laws [e.g., Duchemin et al. (2002), Walls et al. (2015), Deike et al. (2018)] and experimental data from ongoing parallel experiments. 4. **Applications & Implications** - Relate findings to **aroma transport** in champagne, **aerosol generation** in pathogen-laden fluids, and **cloud formation** via marine aerosol. - Draw analogies to droplet formation in **coughing/sneezing**, focusing on the role of viscoelasticity in droplet sizes and distribution.",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#proposed-approach",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - Skills & What You Will Learn",
    "content": "- **Fluid Dynamics Fundamentals** Develop an in-depth understanding of multiphase flows, capillary-driven phenomena, and wave\u2013interface interactions. - **Rheology** Learn how non-Newtonian properties (viscoplasticity, viscoelasticity) influence flow and droplet formation. - **Computational Techniques** Gain experience using open-source codes (e.g., Basilisk C) for high-resolution simulations, parameter sweeps, and data analysis. - **Collaboration** Work alongside experimentalists, compare numerical and laboratory results, and interact with theorists modeling related flows.",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#skills-what-you-will-learn",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - Supervision",
    "content": "| **Supervisor** | **Email** | **Office** | |-----------------------------|---------------------------------------------|---------------------------| | **Ayush Dixit** | [a.k.dixit@utwente.nl](mailto:a.k.dixit@utwente.nl) | Meander 250 | | **Coen Verschuur** | [c.i.verschuur@utwente.nl](mailto:c.i.verschuur@utwente.nl) | Meander 114B | | **Dr. Vatsal Sanjay** | [vatsalsanjay@gmail.com](mailto:vatsalsanjay@gmail.com) | Meander 246B | | **Dr. Alexandros Oratis** | [a.t.oratis@utwente.nl](mailto:a.t.oratis@utwente.nl) | TU Delft | | **Assis. Prof. Dr. Maziyar (Mazi) Jalaal** | [m.jalaal@uva.nl](mailto:m.jalaal@uva.nl) | University of Amsterdam | | **Prof. Dr. Detlef Lohse** | [d.lohse@utwente.nl](mailto:d.lohse@utwente.nl) | Meander 261 | Feel free to reach out to any of the listed supervisors for more details.",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#supervision",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Bursting bubbles complex - Key References",
    "content": "- Deike, L., et al. (2018). *Dynamics of jets produced by bursting bubbles.* - Duchemin, L., et al. (2002). *Jet formation in bubble bursting.* - Ghabache, E., et al. (2016). *Evaporation of droplets from bursting bubbles.* - Gordillo, J. M. (2019). *Capillary waves and jet formation in bubble collapse.* - Lhuissier, H., & Villermaux, E. (2012). *Bursting bubble film droplets.* - Walls, P. L. L., et al. (2015). *Jet drops from bursting bubbles: How gravity and viscosity couple to inhibit droplet production.* - Walls, A. C., et al. (2017). *Viscoelastic effects in droplet formation.* - Bourouiba, L. (2021). *Fluid dynamics of disease transmission.* - Sanjay, V., Lohse, D., & Jalaal, M. (2021). *Non-Newtonian bubble collapse in mudpots.*",
    "url": "https://blogs.comphy-lab.org/Bursting-bubbles-complex/#key-references",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Surface Element Parameterization",
    "content": "> [!tldr] TL;DR > Surface parameterization is a powerful mathematical technique for describing fluid interfaces using coordinates $(u,v)$ that map a 2D parameter space onto 3D surfaces. The tangent vectors $\\mathbf{x}_u = \\partial\\mathbf{x}/\\partial u$ and $\\mathbf{x}_v = \\partial\\mathbf{x}/\\partial v$ define the local surface geometry and are tangent to curves of constant $v$ and $u$, respectively. The normal vector to the surface is calculated as $\\mathbf{n} = (\\mathbf{x}_u \\times \\mathbf{x}_v)/|\\mathbf{x}_u \\times \\mathbf{x}_v|$. This framework enables mathematical analysis of surface metrics like curvature and area, which are essential for understanding interfacial phenomena in multiphase flows, bubble dynamics, and capillary effects.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#surface-element-parameterization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Introduction to Surface Parameterization",
    "content": "Interfaces between fluids represent some of the most fascinating and complex phenomena in fluid dynamics. From the gentle ripples on a pond to the intricate dynamics of bubble coalescence, these interfaces require precise mathematical descriptions to understand their behavior. At the heart of this description lies surface parameterization, a technique that allows us to map coordinates from a two-dimensional parameter space onto a three-dimensional surface. ![](Surface-parameterization-1741712767672.png) Figure 1. A parameterized surface element showing coordinate lines and the tangent plane. In fluid dynamics, we frequently encounter \"sharp\" interfaces\u2014surfaces that separate distinct fluid phases, across which physical properties may change discontinuously. This post explores the mathematical framework for describing such interfaces and how we characterize their geometric properties.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#introduction-to-surface-parameterization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Parameterization Basics",
    "content": "A three-dimensional fluid interface can be mathematically represented by a vector function: $$\\mathbf{x}(u,v) = (x(u,v), y(u,v), z(u,v))$$ Here, $u$ and $v$ are parameters that serve as coordinates on the surface, much like latitude and longitude on Earth's surface. Each point on the interface corresponds to a unique pair of values $(u,v)$ within the parameter domain. > [!note] Parametric vs. Explicit Representation > While some simple surfaces can be described explicitly (e.g., $z = f(x,y)$), parametric representation offers greater flexibility for describing complex shapes, especially those with overhangs or multiple-valued functions.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#parameterization-basics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Iso-Parameter Curves",
    "content": "When we hold one parameter constant while varying the other, we trace curves on the surface known as iso-parameter curves: - **Iso-$u$ curves**: Created by keeping $u$ constant and varying $v$ - **Iso-$v$ curves**: Created by keeping $v$ constant and varying $u$ These curves form a coordinate grid on the surface, as illustrated in Figure 2.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#iso-parameter-curves",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Defining Tangent Vectors: When we differentiate...",
    "content": "When we differentiate the position vector $\\mathbf{x}(u,v)$ with respect to the surface coordinates, we obtain two fundamental tangent vectors: $$\\mathbf{x}_u = \\frac{\\partial\\mathbf{x}}{\\partial u} \\quad \\text{and} \\quad \\mathbf{x}_v = \\frac{\\partial\\mathbf{x}}{\\partial v}$$ These vectors have precise geometric interpretations: - $\\mathbf{x}_u$ is tangent to iso-$v$ curves (curves where $v$ is constant) - $\\mathbf{x}_v$ is tangent to iso-$u$ curves (curves where $u$ is constant) This is visualized below: ![Figure 2](Surface-parameterization-1741713152627.png) Figure 2, taken from [G. Tryggvason, R. Scardovelli & S.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#defining-tangent-vectors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Defining Tangent Vectors: Zaleski, Direct numerical...",
    "content": "Zaleski, Direct numerical simulations of gas-liquid multiphase flows, Cambridge University Press (2011)](https://books.google.es/books?hl=en&lr=&id=nY5bjSYq-AEC&oi=fnd&pg=PR9&dq=%5BBook-Zaleski%5D_Direct+Numerical+Simulations+of+Gas+Liquid+Multiphase+Flows.pdf&ots=TpFXIKxNaj&sig=g-xqzt5uACGx-SYIMhvOwAVtz6U&redir_esc=y#v=onepage&q&f=false) > [!important] Key Insight > The tangent vector $\\mathbf{x}_u$ points in the direction of increasing $u$ along curves of constant $v$, not perpendicular to iso-$u$ curves. Similarly, $\\mathbf{x}_v$ points in the direction of increasing $v$ along curves of constant $u$. This can be a source of confusion: $\\mathbf{x}_u$ is tangent to curves where $v$ is constant, not to curves where $u$ is constant. This is because when you move along a curve where $v$ is fixed, you're varying the $u$ parameter.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#defining-tangent-vectors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - The Surface Normal Vector",
    "content": "With two tangent vectors defined at each point, we can determine the normal vector to the surface through their cross product: $$\\mathbf{n} = \\frac{\\mathbf{x}_u \\times \\mathbf{x}_v}{|\\mathbf{x}_u \\times \\mathbf{x}_v|}$$ This unit normal vector is perpendicular to both tangent vectors and thus perpendicular to the surface itself. The normal vector is crucial for calculating quantities like surface curvature and for determining the direction of surface tension forces.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#the-surface-normal-vector",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Differential Area Element",
    "content": "The differential area element $dA$ on the surface is related to the parameters $du$ and $dv$ through: $$dA = |\\mathbf{x}_u \\times \\mathbf{x}_v| \\, du \\, dv$$ The term $|\\mathbf{x}_u \\times \\mathbf{x}_v|$ represents the local scaling factor between the parameter space and the physical surface.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#differential-area-element",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - First Fundamental Form",
    "content": "The first fundamental form characterizes distances and areas on the surface: $$ds^2 = E \\, du^2 + 2F \\, du \\, dv + G \\, dv^2$$ where: - $E = \\mathbf{x}_u \\cdot \\mathbf{x}_u$ - $F = \\mathbf{x}_u \\cdot \\mathbf{x}_v$ - $G = \\mathbf{x}_v \\cdot \\mathbf{x}_v$ These coefficients completely determine the metric properties of the surface. > [!note] Orthogonal Parameterization > When $F = \\mathbf{x}_u \\cdot \\mathbf{x}_v = 0$, we have an orthogonal parameterization, meaning that the iso-parameter curves intersect at right angles. This often simplifies calculations.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#first-fundamental-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Mean and Gaussian Curvature",
    "content": "The mean curvature $H$ and Gaussian curvature $K$ are invariant properties of the surface that characterize its local shape: $$H = \\frac{1}{2}(\\kappa_1 + \\kappa_2) \\quad \\text{and} \\quad K = \\kappa_1 \\kappa_2$$ where $\\kappa_1$ and $\\kappa_2$ are the principal curvatures. The mean curvature is particularly important in fluid interfaces due to the Young-Laplace equation: $$\\Delta p = 2\\gamma H$$ which relates the pressure difference $\\Delta p$ across an interface to the surface tension $\\gamma$ and mean curvature $H$.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#mean-and-gaussian-curvature",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Shape Characterization",
    "content": "The local shape of a surface element can be categorized based on its curvature: - Elliptic points: $K > 0$ (bowl-shaped) - Hyperbolic points: $K < 0$ (saddle-shaped) - Parabolic points: $K = 0$, $H \\neq 0$ (cylindrical) - Flat points: $K = 0$, $H = 0$ (planar) These classifications help us understand the geometric behavior of interfaces in various fluid dynamics scenarios.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#shape-characterization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Numerical Implementation Considerations: Methods",
    "content": "When implementing surface parameterization in computational fluid dynamics, several approaches are commonly used: 1. **Finite Element Method**: Elements are defined on the parameter space and mapped to the physical surface 2. **Level Set Method**: Implicit representation of the interface as a level set of a function 3. **Front Tracking Method**: Explicit tracking of interface points with dynamic remeshing > [!important] Numerical Stability > The choice of parameterization can significantly impact numerical stability. Orthogonal parameterizations often provide better conditioning for numerical solvers.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#numerical-implementation-considerations",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Numerical Implementation Considerations: Code snippets utilize...",
    "content": "Code snippets utilize these concepts for calculating surface properties: ```c /** * @brief Calculates surface curvature from parametric representation * @param xu First tangent vector * @param xv Second tangent vector * @param xuu Second derivative with respect to u * @param xuv Mixed second derivative * @param xvv Second derivative with respect to v * @return Mean curvature value */ double mean_curvature(Vector xu, Vector xv, Vector xuu, Vector xuv, Vector xvv) { Vector n = normalize(cross_product(xu, xv)); double E = dot_product(xu, xu); double F = dot_product(xu, xv); double G = dot_product(xv, xv); double L = dot_product(xuu, n); double M = dot_product(xuv, n); double N = dot_product(xvv, n); return (E*N - 2*F*M + G*L)/(2*(E*G - F*F)); } ```",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#numerical-implementation-considerations",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Conclusion and Future Directions: Surface parameterization provides...",
    "content": "Surface parameterization provides a powerful mathematical framework for analyzing fluid interfaces. By defining a mapping between a 2D parameter space and a 3D surface, we gain access to precise geometric tools for calculating properties like curvature, area, and normal vectors. In research, these concepts have proven invaluable for understanding phenomena ranging from capillary waves in bubble coalescence to complex rheological behaviors in non-Newtonian fluids. Future work will continue to leverage these mathematical tools to explore increasingly complex interfacial dynamics across various fluid systems. For researchers working in this field, mastering surface parameterization is essential for both theoretical understanding and computational implementation.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#conclusion-and-future-directions",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Conclusion and Future Directions: The framework outlined...",
    "content": "The framework outlined in this post serves as a foundation for more advanced topics in multiphase fluid dynamics. > [!question] Food for Thought > Consider how different choices of surface parameterization might impact numerical stability and accuracy in simulating multiphase flows. What advantages might orthogonal parameterizations offer in specific fluid dynamics problems?",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#conclusion-and-future-directions",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - More resources",
    "content": "| [GitHub](https://github.com/comphy-lab/fluid-interfaces-notes) | [Demo](https://youtu.be/NmvCVsiEZIA) | [License](https://github.com/comphy-lab/fluid-interfaces-notes/blob/main/LICENSE) | | :---------------------------------------------------------------------: | :----------------------------------: | :----------------------------------------------------------------------------------------: |",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#more-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Surface parameterization - Further reading",
    "content": "[1] > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Mar 11, 2025 > Date modified:: Mar 11, 2025 at 14:26 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Surface-parameterization/#further-reading",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Gauss law of electrostatics: > [!important]- Pre-requisites...",
    "content": "> [!important]- Pre-requisites > I assume a working knowledge of > * Electric field $\\vec{E}$. > * [[Geometric description of electric field]] > * [[What is electric field flux?]] > * What is the electric field created by a point change $q$? > $E = q/(4\\pi\\varepsilon_0r^2)$ > * [[Principle of superposition of electric fields]] > [!tldr] TL;DR > Gauss\u2019 law states that the net electric flux through any closed surface is proportional to the total charge enclosed inside it. Its integral form, $\\oint \\vec{E} \\cdot d\\vec{A} = q_{\\text{in}}/\\varepsilon_0$, is most practically used with high\u2010symmetry geometries (spherical, cylindrical, planar). Even though it might seem universal, using it directly for complex geometries often requires additional methods. The differential form, $\\vec{\\nabla} \\cdot \\vec{E} = \\rho/\\varepsilon_0$, underpins charge\u2010field relationships in Maxwell\u2019s equations.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#gauss-law-of-electrostatics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Gauss law of electrostatics: Key insights include:...",
    "content": "Key insights include: _flux remains invariant if charges stay within the boundary_, and _external charges yield zero net flux through a given surface_. Applications to spherical shells, infinite planes, and wires highlight its computational utility. However, without symmetry, one typically reverts to direct integration or other approaches. Often, one of the first wonders students encounter in electrostatics is the deceptively simple yet powerful Gauss' law. I still recall my own initial surprise when I realized flux through any closed surface enclosing a single charge remained the same, no matter how oddly shaped that surface was. In this post, I hope to convey that same amazement while walking you through the essential details and derivations.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#gauss-law-of-electrostatics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Question we ask: which of the following three surfaces will see the maximum flux of $\\vec{E}$ pass through itself?",
    "content": "![fig1](20250121002320090_Gauss%20law%20of%20Electrostatics.png) Fig. A cone, a sphere, and a batman symbol (enclose it in the front and the back) encircle a lonely charge of magnitude $q$. Which of the three will experience maximum eleectric field flux passing through them? This is perhaps the most counterintuitive result of the Gauss law. > [!question] Try it yourself > Instead of taking my (well, Gauss') word for it, try finding the flux through the cone and the circle by integrating the dot product of the local electric field and the area (note that for cone, we must account for both the lateral and the base area). Once you find the solution, make a PR at the GitHub repository please show all intermediate steps.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#question-we-ask-which-of-the-following-three-surfaces-will-see-the-maximum-flux-of-vece-pass-through-itself",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - General form of Gauss' law",
    "content": "> [!tldr] Main statement of Gauss' law > The flux of electric field $\\vec{E}$ though a closed surface (known as the Gaussian surface) is equal to the amount of change enclosed by that surface. $\\int_A\\vec{E}\\cdot\\vec{n}dA = q_{\\text{in}}/\\varepsilon_0$, $\\vec{E}$ is the electric field, $n$ is the normal vector to the area element $dA$, $q_{\\text{in}}$ is the change enclosed inside the Gaussian surface and $\\varepsilon_0$ is the [[permittivity of free space]]. > * In the differential form, it is identical to: > $\\vec{\\nabla}\\cdot\\vec{E} = \\rho/\\varepsilon_0$, where $\\rho$ is the local electric changed density. Let us define the flux as: $$ \\Phi = \\int_A\\vec{E}\\cdot d\\vec{A} = \\int_A\\vec{E}\\cdot \\hat{n}dA $$ Then, $$ \\int_A\\vec{E}\\cdot \\hat{n}dA = \\frac{q_{\\text{in}}}{\\varepsilon_0} $$ Of course, $q_\\text{in}$ is $$ q_\\text{in} = \\int_A\\sigma dA = \\int_V\\rho dV, $$ where $\\sigma$ and $\\rho$ are the surface and volumetric change densities, respectively.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#general-form-of-gauss-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Proof:",
    "content": "> [!caution] > I leave it upto you to decide if the following derivations are the proofs or merely consistency checks for the Gauss' law.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#proof",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Special case of spherical Gaussian surface enclosing a single charge:",
    "content": "![|500](20250121013316786_Gauss%20law%20of%20Electrostatics.png) Electric field by a point change: $$ \\vec{E} = \\frac{q}{4\\pi\\varepsilon_0r^2}\\hat{r} $$ Flux through a sphere of radius $r$, $$ \\Phi = E\\hat{r}\\cdot\\hat{r}A = EA = \\frac{q}{4\\pi\\varepsilon_0r^2}4\\pi r^2 = \\frac{q}{\\varepsilon_0} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#special-case-of-spherical-gaussian-surface-enclosing-a-single-charge",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Arbitary Gaussian surface enclosing a single charge:",
    "content": "![|750](20250121013334249_Gauss%20law%20of%20Electrostatics.png) Electric field by a point change: $$ \\vec{E} = \\frac{q}{4\\pi\\varepsilon_0r^2}\\hat{r} $$ Local flux at the indicated location: $$ d\\Phi = E\\hat{r}\\cdot\\hat{n}dA = \\frac{q}{4\\pi\\varepsilon_0r^2}\\cos\\alpha\\,dA = \\frac{q}{4\\pi\\varepsilon_0}\\frac{\\cos\\alpha\\,dA}{r^2} $$ Here, $\\cos\\alpha\\,dA/r^2 = d\\Omega$ is in fact the solid angle subtended by the local area element. $$ \\Phi = \\int d\\Phi = \\int_\\Omega\\frac{q}{4\\pi\\varepsilon_0}d\\Omega $$ The solid angle $\\Omega$ integrates to give $4\\pi$ resulting in $$ \\Phi = \\frac{q}{\\varepsilon_0} $$ ---",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#arbitary-gaussian-surface-enclosing-a-single-charge",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Consequences of Gauss' law: > [!danger] Displace...",
    "content": "> [!danger] Displace the charge all you want, it won\u2019t change the flux > The flux of $\\vec{E}$ only depends on the amount of charge contained inside a Gaussian surface and not on whether or not the charge is moving inside the space enclosed by this Gaussian surface. **Remarkable property:** If charges are moved around **but do not cross** the boundary of $A$, the flux of $E$ through $A$ remains **unchanged**. Despite this unchanging flux, the field $E$ itself can undergo substantial modifications everywhere else.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#consequences-of-gauss-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Consequences of Gauss' law: Conversely, if charges...",
    "content": "Conversely, if charges **do** cross the boundary of $A$, the flux through $A$ will generally change. > [!danger] A charge outside the Gaussian surface imparts net zero flux in that control surface > It is easier to see by construction that electric field lines coming out of a charge outside a Gaussian surface will pass straight through without creating any global flux. ![|750](20250121023006325_Gauss%20law%20of%20Electrostatics.png) > [!danger] On the impossibility of equilibrium in electrostatics In any electrostatic field, a charge cannot be in [stable equilibrium](https://en.wikipedia.org/wiki/Mechanical_equilibrium). A single point charge $q$ cannot remain in stable equilibrium under the electrostatic influence of other, fixed charges in vacuum. Can you think of a scenario? Say, we do. And now, let us enclose this $q$ within a small closed surface $A$. For $q$ to be in stable equilibrium, the net electric field from all other charges must point inward everywhere on $A$.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#consequences-of-gauss-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Consequences of Gauss' law: Such an inward...",
    "content": "Such an inward field is critical to create a restoring force for any small displacement of $q$. However, Gauss\u2019s theorem tells us that the total electric flux through $A$ must be zero if no net charge (creating this electrostatic field) is contained inside $A$. This zero flux requirement forces the field to have both inward and outward components on the surface, contradicting the need for a purely inward field. Hence, no purely electrostatic arrangement of external charges can hold a point charge in stable equilibrium in a vacuum. ![|250](20250121015925070_Gauss%20law%20of%20Electrostatics.png)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#consequences-of-gauss-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Symmetries to the rescue",
    "content": "Now, one of the best ways to make Gauss\u2019 law practical is by using symmetry arguments. Below are three major symmetry cases that come in handy.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#symmetries-to-the-rescue",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Plannar symmetry",
    "content": "![|750](20250121033252912_Gauss%20law%20of%20Electrostatics.png) Consider an infinite sheet with uniform surface\u2010charge density $\\sigma$. By symmetry, the electric field must point perpendicular to the sheet and have the same magnitude on either side (left-right symmetry). Select a \"pillbox\" (a short cylinder) that straddles the sheet as your Gaussian surface. The flux then emerges through the two circular faces only; there is no flux through the curved surface because $\\vec{E}$ is parallel there. The integral form of Gauss\u2019s law yields $$ 2\\,E\\,A \\;=\\; \\frac{\\sigma\\,A}{\\varepsilon_0} $$ $$ \\quad\\Longrightarrow\\quad E \\;=\\; \\frac{\\sigma}{2\\,\\varepsilon_0}. $$ Hence, an infinite charged plane produces a constant electric field whose magnitude depends solely on $\\sigma$.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#plannar-symmetry",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Special case:",
    "content": "![[plates.png]] When **two** parallel sheets carry equal and opposite surface\u2010charge densities $+\\sigma$ and $-\\sigma$, superposition implies that the fields from each sheet **add** in the region between them and **cancel** outside. Specifically, in the space between the plates, each sheet contributes $\\sigma/(2\\,\\varepsilon_0)$ in the **same** direction, giving a total $$ E_{\\text{between}} \\;=\\; \\frac{\\sigma}{\\varepsilon_0}. $$ Outside the plates, the fields from the two sheets have opposite directions and thus cancel to zero, assuming the plates are large compared to their separation. This configuration approximates the uniform field of a parallel\u2010plate capacitor.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#special-case",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Cyliindrical symmetry",
    "content": "![|750](20250121033734979_Gauss%20law%20of%20Electrostatics.png) Consider an infinitely long wire with a uniform linear charge density $\\lambda$. By symmetry, the electric field $\\vec{E}$ at distance $r$ from the wire must point radially outward and have constant magnitude on a coaxial cylindrical surface of radius $r$. Let us choose this coaxial cylinder as our Gaussian surface (length L). The flux is through the curved surface only; both end caps see $\\vec{E}$ parallel to their planes and hence yield no net contribution. Applying Gauss\u2019s law, $$ E \\,(2\\pi r L) \\;=\\; \\frac{\\lambda\\,L}{\\varepsilon_0} $$ $$\\quad\\Longrightarrow\\quad E \\;=\\; \\frac{\\lambda}{2\\pi \\varepsilon_0\\,r}. $$ The field diminishes as $1/r$ from the wire.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#cyliindrical-symmetry",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Spherical symmetry",
    "content": "Here, let us consider two cases: 1. uniformly charged sphere with charge density $\\rho$ and 2. a thin spherical shell with change $q$. Both have a radius of $a$. Also, assume $\\frac{4\\pi a^3}{3}\\rho = q$. ![|750](20250121035211075_Gauss%20law%20of%20Electrostatics.png)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#spherical-symmetry",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - For $r > a$:",
    "content": "Here, the Gaussian surface contains the entire spherical object inside it. So, in both cases, the Gaussian surface sees a total charge of $q$. Consequently, $$ E = \\frac{q}{4\\pi\\varepsilon_0r^2} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#for-r-a",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - For $r < a$:",
    "content": "* *Shell:* Charge enclosed inside the shell for $r [!note] Note > To play with the above plots, see: [[Gauss-law-of-electrostatics.ipynb]]",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#for-r-a",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - A critique of the Gauss' law in the non-local form",
    "content": "One might wonder: is Gauss' law too good to be true for complicated geometries? Below, I share a brief critique.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#a-critique-of-the-gauss-law-in-the-non-local-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Illusion of Generality",
    "content": "The integral form, $$ \\int_A \\vec{E} \\cdot d\\vec{A} = \\frac{q_\\text{in}}{\\varepsilon_0}, $$ can give a misleading impression that it solves _any_ electrostatic field problem elegantly. While it is indeed general as a statement of charge\u2013field relationships, _practical_ usage relies heavily on symmetry arguments to simplify the surface integral.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#illusion-of-generality",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Dependence on Symmetry",
    "content": "Gauss\u2019s integral theorem is most effective when the field and geometry exhibit high symmetry (e.g., spherical, cylindrical, or planar). In such cases, one can choose a closed surface $A$ where the electric field $\\vec{E}$ is either constant in magnitude or zero over different parts of the surface. This makes the flux integral collapse to a simple multiplication, thus giving a direct link between enclosed charge and field magnitude.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#dependence-on-symmetry",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Limitations in Complex Geometries",
    "content": "For configurations lacking these symmetries\u2014such as a uniformly charged disk or other irregular charge distributions\u2014no straightforward closed surface simplifies the flux integral. In these scenarios, one must resort to more laborious methods, like direct integration of Coulomb\u2019s law or employing the local (differential) form combined with suitable boundary conditions. > [!faq] Note: > Of course, let us be very clear that the above critique is only about the non-local form (or integral formulation) of Gauss' law. If we use the more general differential form (or together with the Maxwell's laws of electromagnetism, the above limitations do not apply).",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#limitations-in-complex-geometries",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Some food for throught: Gauss' law is...",
    "content": "Gauss' law is agnostic to the number of dimensions in the problem. In this note, we mainly looked at cases in 3D. Now, think about living in a 2D space. Answer the following: 1. How does the Coulomb's law change in 2D? 2. Adapt Gauss\u2019s law to a 2D problem, where **flux** becomes a line integral around a closed loop. Consider a point charge qqq in a 2D plane. Choose a circle of radius $r$ around the charge as the \"Gaussian\" boundary. Compute the total radial component of $\\vec{E}$ along this circle and show that it is proportional to $q/\\varepsilon_0$ (with an appropriate constant reflecting 2D geometry). 3. For a hypothetical \"4D\" space, the electric field of a point charge might scale differently with distance.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#some-food-for-throught",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Some food for throught: Use dimensional analysis...",
    "content": "Use dimensional analysis to argue how Gauss\u2019s law might look there, and what the \"closed surface\u201d would mean in 4D. **Hint:** Highlight the dimension-agnostic idea that flux = enclosed charge/$\\varepsilon_0$\u200b remains structurally the same, although radius-dependencies of $\\vec{E}$ and definitions of \"surface\" change with dimension. **Note:** To submit answers to the questions above or in case you find a mistake in this note, please feel free to open a pull request at the repository: [link to repository](https://github.com/comphy-lab/CoMPhy-Lab-Blogs).",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#some-food-for-throught",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Integral form:",
    "content": "In this post, we encountered Gauss law in integral form as, $$ \\oint_A \\vec{E} \\cdot d\\vec{A} \\;=\\; \\frac{q_{\\text{in}}}{\\epsilon_0}, $$ where $\\vec{E}$ is the electric field, $q_{\\text{in}}$ is the total charge enclosed by $A$, and $\\epsilon_0$ is the permittivity of free space.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#integral-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Relate enclosed charge to charge density.",
    "content": "The enclosed charge can be expressed in terms of the volume charge density $\\rho$ using a volume integral: $$ q_{\\text{in}} \\;=\\; \\int_{V} \\rho \\, dV. $$ Here, $V$ is the volume bounded by the surface \\(S\\).",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#relate-enclosed-charge-to-charge-density",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Apply the divergence theorem: Rewrite the left...",
    "content": "Rewrite the left side of Gauss\u2019s law using the divergence theorem (also known as Gauss\u2019s divergence theorem): $$ \\oint_A \\vec{E} \\cdot d\\vec{A} \\;=\\; \\int_{V} \\vec{\\nabla} \\cdot \\vec{E} \\; dV. $$ > [!signifigance] Gauss' divergence therorem > This is yet another significant contribution from Gauss. It relates volume integrals to fluxes at the boundaries. This theorem is more generally used throughout the Physics literature. For example, simplifying integrals in Rayleigh$-$B\u00e9nard convection or in Taylor$-$Culick retractions. > $$ \\oint_A\\boldsymbol{F\\cdot}d\\boldsymbol{A} = \\int_{V}\\boldsymbol{\\nabla\\cdot F}\\;dV $$ > **Rate of change of a physical quantity** (see [[Relationship between rate of change of a physical quantity and its divergence]]) in a volume is tied directly to its net flux across the boundary of that volume. More generally, in fluid mechanics, this principle underpins conservation laws such as mass, momentum, or energy.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#apply-the-divergence-theorem",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Apply the divergence theorem: Thus, $$ \\int_{V}...",
    "content": "Thus, $$ \\int_{V} \\vec{\\nabla} \\cdot \\vec{E} \\; dV \\;=\\; \\frac{1}{\\epsilon_0} \\int_{V} \\rho \\; dV. $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#apply-the-divergence-theorem",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Conclude the differential form",
    "content": "Because this equation must hold for any volume $V$, the integrands themselves must be equal at every point in space: $$ \\vec{\\nabla} \\cdot \\vec{E} \\;=\\; \\frac{\\rho}{\\epsilon_0}. $$ This is Gauss\u2019s law in **differential form**. It states that the divergence of the electric field at a point is proportional to the local charge density at that point.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#conclude-the-differential-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Significance to Maxwell's laws of electromagnetism",
    "content": "The Gauss' law of electrostatics is one of the special cases of Maxwell's laws of electromagnetism.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#significance-to-maxwells-laws-of-electromagnetism",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Gauss's Law (Electric):",
    "content": "$$ \\vec{\\nabla} \\cdot \\vec{E} = \\frac{\\rho}{\\varepsilon_0} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#gausss-law-electric",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Faraday's Law of Induction:",
    "content": "$$ \\vec{\\nabla} \\times \\vec{E} = -\\frac{\\partial \\vec{B}}{\\partial t} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#faradays-law-of-induction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Amp\u00e8re\u2013Maxwell Law:",
    "content": "$$ \\vec{\\nabla} \\times \\vec{B} = \\mu_0 \\vec{J} + \\mu_0 \\varepsilon_0 \\frac{\\partial \\vec{E}}{\\partial t} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#amp\u00e8remaxwell-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Gauss's Law (Electric):",
    "content": "$$ \\oint \\vec{E} \\cdot d\\vec{A} = \\frac{q_\\text{in}}{\\varepsilon_0} $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#gausss-law-electric",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Faraday's Law of Induction:",
    "content": "$$ \\oint \\vec{E} \\cdot d\\vec{\\ell} = -\\frac{d}{dt}\\left(\\int \\vec{B} \\cdot d\\vec{A}\\right) $$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#faradays-law-of-induction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Amp\u00e8re\u2013Maxwell Law:: Conclusion",
    "content": "$$ \\oint \\vec{B} \\cdot d\\vec{\\ell} = \\mu_0 I_\\text{in} + \\mu_0 \\varepsilon_0 \\frac{d}{dt}\\left(\\int \\vec{E} \\cdot d\\vec{A}\\right) $$ > [!summary] Conclusion > That brings us to the end of this reflective overview of Gauss' law and its place within Maxwell's equations. Even though the symmetrical geometries often steal the spotlight, the underlying message is that Gauss' law is deeply fundamental\u2014tied intimately to how charges shape and define the electric field around them. I hope these notes, with their many examples, help you see both its elegance and its limitations. > [!info] Info > Thanks for reading, and feel free to dive deeper (or suggest improvements) via the [GitHub repository](https://github.com/comphy-lab/CoMPhy-Lab-Blogs)! --- > [!testy] Some side notes: > * To explore some history, see: [[History-of-Gauss]] > * Here, we discuss a lot about Gaussian surfaces.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#amp\u00e8remaxwell-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gauss law of electrostatics - Amp\u00e8re\u2013Maxwell Law:: The fluid dynamicist...",
    "content": "The fluid dynamicist in me cannot help but point out that a [[Gaussian surface is very similar to the control volume in fluid mechanics]]. \ud83d\udca1 --- > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 25, 2025 at 14:22 > [!link] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Gauss law of Electrostatics/#amp\u00e8remaxwell-law",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Relationship between rate of change of a physical quantity and its divergence - Relationship between rate of change of a physical quantity and its divergence",
    "content": "For a conserved quantity (like mass, momentum, or energy), the local rate of change within a volume is directly linked to the divergence of its flux. In particular, conservation laws often take the form: $$\\frac{\\partial \\phi}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0$$ where $\\phi$ is the density of the conserved quantity and $\\mathbf{J}$ is its flux. Integrating over a volume and applying the divergence theorem: $$\\int_V \\frac{\\partial \\phi}{\\partial t} \\, dV + \\oint_{\\partial V} \\mathbf{J}\\cdot d\\mathbf{A} = 0$$ shows that the rate of change of $\\phi$ in that volume (the first term) is exactly balanced by the net flux across the boundary (the second term). Thus, $\\nabla \\cdot \\mathbf{J}$ encapsulates the `source` or `sink` behavior within the volume and is intimately connected to how $\\phi$ changes over time.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Relationship between rate of change of a physical quantity and its divergence/#relationship-between-rate-of-change-of-a-physical-quantity-and-its-divergence",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "What is electric field flux?",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:06 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/What is electric field flux?/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "What is electric field flux? - What is electric field flux?",
    "content": "![|750](20250121024948930_What%20is%20electric%20field%20flux_.png) $$ \\Phi = A\\vec{E}\\cdot\\hat{n} = AE\\cos\\alpha $$",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/What is electric field flux?/#what-is-electric-field-flux",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Permittivity of free space",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:05 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/permittivity of free space/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "Permittivity of free space - Permittivity of free space",
    "content": "In Gauss\u2019s law, $\\varepsilon$ the permittivity of free space. It quantifies how an electric field propagates through a vacuum. In the standard form of Gauss\u2019s law, $\\oint \\mathbf{E}\\cdot d\\mathbf{A} \\;=\\; \\frac{Q_{\\text{enc}}}{\\varepsilon_0},$ appears as the proportionality constant relating the net electric flux through a closed surface to the total charge enclosed. Numerically, $\\varepsilon_0 \\approx 8.854 \\times 10^{-12}\\,\\mathrm{F/m}$. It also factors into the relationship between the speed of light $c$, the vacuum permeability $\\mu_0$, and itself, via $c = \\frac{1}{\\sqrt{\\varepsilon_0\\,\\mu_0}}$.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/permittivity of free space/#permittivity-of-free-space",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Gaussian surface is very similar to the control volume in fluid mechanics",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:03 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Gaussian surface is very similar to the control volume in fluid mechanics/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "Gaussian surface is very similar to the control volume in fluid mechanics - Gaussian surface is very similar to the control volume in fluid mechanics",
    "content": "They are closely related in a mathematical sense. In [[Gauss law of Electrostatics|Gauss\u2019s law for electrostatics]], one picks a closed surface\u2014the Gaussian surface\u2014to evaluate the net electric flux and relate it to enclosed charge via the divergence theorem. In fluid mechanics, one defines a control volume (with a control surface) to analyze fluxes of mass, momentum, or energy. Both rely on the same underlying integral theorem (the divergence theorem) to connect fluxes through the surface to sources or sinks within the volume. The physical interpretations differ\u2014charge density for electromagnetism versus mass or momentum for fluid flow\u2014but the conceptual framework is very similar.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Gaussian surface is very similar to the control volume in fluid mechanics/#gaussian-surface-is-very-similar-to-the-control-volume-in-fluid-mechanics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History of gauss",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:04 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/History-of-Gauss/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "History of gauss - History of Gauss (and one recent event):: Carl Friedrich Gauss...",
    "content": "Carl Friedrich Gauss (1777\u20131855) was a brilliant mathematician who made breakthroughs in just about every area of math and physics you can think of\u2013he crunched numbers like a prodigy even as a kid, later proved key theorems in algebra and laid the groundwork for number theory, geometry, and analysis. Beyond math, he helped calculate the orbit of the dwarf planet Ceres, co-invented an early telegraph, and teamed up with physicist **Wilhelm Weber** to measure and model the Earth\u2019s magnetic field. His name is attached to many concepts, including \"Gauss\u2019s law\" (topic of this blog) in electromagnetism, which is a cornerstone in understanding electric fields. Gauss\u2019s relentless curiosity earned him the nickname \"the Prince of Mathematicians,\u201d and his work remains at the heart of modern science and engineering.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/History-of-Gauss/#history-of-gauss-and-one-recent-event",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History of gauss - History of Gauss (and one recent event):: Even today\u2014nearly two...",
    "content": "Even today\u2014nearly two centuries after his death\u2014people still visit his grave in G\u00f6ttingen to pay homage (see figure below, \ud83d\ude09). ![|250](_Media/20250120200507219_Gauss%20law%20of%20Electrostatics.png) Fig. Potrait made availale by Johann Christian August Schwartz - Carl Friedrich Gauss 1777-1855. Ausstellung zum 200. Geburtstag. St\u00e4dtisches Museum G\u00f6ttingen. 16. Januar bis 13. M\u00e4rz 1977. G\u00f6ttingen, 1977, Frontispiz., Public Domain, Link ![|250](_Media/20250120200806664_Gauss%20law%20of%20Electrostatics.png) Fig. Even after (almost) 200 years of his death, people still visit the grave of Carl Friedrich Gauss in G\u00f6ettingen to pay homage to the master.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/History-of-Gauss/#history-of-gauss-and-one-recent-event",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Principle of superposition of electric fields",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:05 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Principle of superposition of electric fields/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "Principle of superposition of electric fields - Principle of Superposition of Electric Fields",
    "content": "The electric field from multiple sources is the vector sum of the individual fields at each point. If charges create electric fields $\\vec{E}_1$, $\\vec{E}_2$, $\\dots$, then the total field is given by: $$ \\vec{E}_{\\text{total}} = \\vec{E}_1 + \\vec{E}_2 + \\cdots $$ This linear superposition implies that each charge\u2019s field contribution adds without altering the others\u2019 fields, enabling straightforward calculation of net electric fields from complex charge distributions.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Principle of superposition of electric fields/#principle-of-superposition-of-electric-fields",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Geometric description of electric field",
    "content": "> [!significance] Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 21, 2025 at 11:03 CET",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Geometric description of electric field/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "Geometric description of electric field - Geometric description of electric field",
    "content": "* **Field Lines**: Draw lines so that at each point, their tangent matches the direction of $\\vec{E}$ * **Density**: The number of lines per unit area (normal to the lines) is proportional to $\\|\\vec{E}\\|$. * **Direction**: Arrows on the lines indicate the direction of $\\vec{E}$. * **Interpretation**: This visual map shows both the direction and magnitude of $\\vec{E}$ across space.",
    "url": "https://blogs.comphy-lab.org/_AtomicNotes/Geometric description of electric field/#geometric-description-of-electric-field",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Herschel\u2013Bulkley formulation for non-Newtonian flows",
    "content": "> [!tldr] TL;DR > The **Herschel\u2013Bulkley** model unifies Newtonian, Bingham, and power-law fluids via a yield stress and a strain-rate-dependent viscosity. An \ufffc$\\epsilon$-regularization ensures stable computations and recovers simpler models (Newtonian, Bingham) by tuning model parameters. Dimensionless groups (e.g., the plasto-capillary number \ufffc and the effective Ohnesorge) capture the interplay of fluid rheology, capillarity, and flow scales. Implementation details are provided, along with references, open-source code, and demonstrations of bubble-burst simulations in viscoplastic media.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#herschelbulkley-formulation-for-non-newtonian-flows",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Features:",
    "content": "* Yield stress $\\tau_y$ * Power law dependance on the strain rate * Shear thinning for $n 1$. * Bingham model for $n = 1$. * Newtonian fluid for $n = 1$ and $\\tau_y = 0$.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#features",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - $\\varepsilon$-formulation: $$ \\boldsymbol{\\tau} =...",
    "content": "$$ \\boldsymbol{\\tau} = \\tau_{y}\\,\\boldsymbol{\\mathcal{I}} \\;+\\; K\\left(2\\boldsymbol{\\mathcal{D}}\\right)^{n} = 2\\biggl[\\frac{\\tau_{y}}{2\\|\\boldsymbol{\\mathcal{D}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + K\\,\\bigl(2\\|\\boldsymbol{\\mathcal{D}}\\|+\\epsilon\\bigr)^{n-1} \\biggr]\\boldsymbol{\\mathcal{D}}. $$ Normalizing stresses with $\\gamma/R_0$, length with $R_0$, and velocity with $\\sqrt{\\gamma/\\rho_lR_0}$... $$ \\boldsymbol{\\tilde{\\tau}} = 2\\biggl[\\frac{\\mathcal{J}}{2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + Oh_K\\,\\bigl(2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\epsilon\\bigr)^{n-1} \\biggr]\\boldsymbol{\\tilde{\\mathcal{D}}}. $$ Here, the effective Ohnesorge is $$ Oh_K = \\frac{K}{\\sqrt{\\rho_l^n\\gamma^{2-n}R_0^{3n-2}}} $$ The plasto-capillary number $\\mathcal{J}$ is $$\\mathcal{J} = \\frac{\\tau_yR_0}{\\gamma}$$ One can easily see that putting $n = 1$ recovers the Bingham model with $Oh = \\eta_l/\\sqrt{\\rho_l\\gamma R_0}$.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#varepsilon-formulation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - $\\varepsilon$-formulation: Additionally, with $n...",
    "content": "Additionally, with $n = 1$ & $\\mathcal{J}$ = 0, the model will give a `Newtonian` response.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#varepsilon-formulation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Calculate the norm of the deformation tensor $\\boldsymbol{\\mathcal{D}}$:: $$\\mathcal{D}_{11} = \\frac{\\partial...",
    "content": "$$\\mathcal{D}_{11} = \\frac{\\partial u_r}{\\partial r}$$ $$\\mathcal{D}_{22} = \\frac{u_r}{r}$$ $$\\mathcal{D}_{13} = \\frac{1}{2}\\left( \\frac{\\partial u_r}{\\partial z}+ \\frac{\\partial u_z}{\\partial r}\\right)$$$$\\mathcal{D}_{31} = \\frac{1}{2}\\left( \\frac{\\partial u_z}{\\partial r}+ \\frac{\\partial u_r}{\\partial z}\\right)$$ $$\\mathcal{D}_{33} = \\frac{\\partial u_z}{\\partial z}$$ $$\\mathcal{D}_{12} = \\mathcal{D}_{23} = 0.$$ The second invariant is $\\mathcal{D}_2=\\sqrt{\\mathcal{D}_{ij}\\mathcal{D}_{ij}}$ (this is the Frobenius norm) $$\\mathcal{D}_2^2= \\mathcal{D}_{ij}\\mathcal{D}_{ij}= \\mathcal{D}_{11}\\mathcal{D}_{11} + \\mathcal{D}_{22}\\mathcal{D}_{22} + \\mathcal{D}_{13}\\mathcal{D}_{31} + \\mathcal{D}_{31}\\mathcal{D}_{13} + \\mathcal{D}_{33}\\mathcal{D}_{33}$$ **Note:** $\\|\\mathcal{D}\\| = D_2/\\sqrt{2}$.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#calculate-the-norm-of-the-deformation-tensor-boldsymbolmathcald",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Calculate the norm of the deformation tensor $\\boldsymbol{\\mathcal{D}}$:: We use the...",
    "content": "We use the formulation as given in [Balmforth et al. (2013)](https://www.annualreviews.org/doi/pdf/10.1146/annurev-fluid-010313-141424) [1], who use the strain rate tensor $\\boldsymbol{\\dot{\\mathcal{S}}}$ which and its norm $\\sqrt{\\frac{1}{2}\\dot{\\mathcal{S}_{ij}}\\dot{\\mathcal{S}_{ij}}}$. Of course, given $\\dot{\\mathcal{S}}_{ij}=2 D_{ij}$.",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#calculate-the-norm-of-the-deformation-tensor-boldsymbolmathcald",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Calculate the equivalent viscosity",
    "content": "Factorizing with $2 \\mathcal{D}_{ij}$ to obtain an equivalent viscosity $$\\eta_{\\text{eff}} = \\frac{\\mathcal{J}}{2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + Oh_K\\,\\bigl(2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\epsilon\\bigr)^{n-1} $$ In this formulation, $\\varepsilon$ is a small number to ensure numerical stability. The term $$\\frac{\\tau_y}{\\varepsilon} + ...$$is equivalent to the $\\mu_{max}$ of the previous (v1.0, see: [GitHub](https://github.com/VatsalSy/Bursting-Bubble-In-a-Viscoplastic-Medium)) formulation [2]. **Note:** The fluid flows always, it is not a solid, but a very viscous fluid. Reproduced from: [P.-Y. Lagr\u00e9e's Sandbox](http://basilisk.fr/sandbox/M1EMN/Exemples/bingham_simple.c). Here, we use a face implementation of the regularisation method, described [here](http://basilisk.fr/sandbox/vatsal/GenaralizedNewtonian/Couette_NonNewtonian.c). ---",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#calculate-the-equivalent-viscosity",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - Video showcasing a typical simulation of bubble bursting in a Herschel\u2013Bulkley fluid medium",
    "content": "[Open on YouTube](https://youtu.be/NmvCVsiEZIA)",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#video-showcasing-a-typical-simulation-of-bubble-bursting-in-a-herschelbulkley-fluid-medium",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - More resources",
    "content": "| [GitHub](https://github.com/comphy-lab/BurstingBubble_Herschel-Bulkley) | [Demo](https://youtu.be/NmvCVsiEZIA) | [License](https://github.com/comphy-lab/BurstingBubble_Herschel-Bulkley/blob/main/LICENSE) | [Latest Changes](https://github.com/comphy-lab/BurstingBubble_Herschel-Bulkley/commits/main) | [[Herschel\u2013Bulkley formulation.pdf\\|pdf]] | | :---------------------------------------------------------------------: | :----------------------------------: | :----------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------------------: | ----------------------------------------- |",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#more-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Herschel\u2013bulkley formulation - References",
    "content": "[1] N. J. Balmforth, I. A. Frigaard, and G. Ovarlez, \u201cYielding to Stress: Recent Developments in Viscoplastic Fluid Mechanics,\u201d _Annu. Rev. Fluid Mech._, vol. 46, pp. 121\u2013146, Jan. 2014, doi: [10.1146/annurev-fluid-010313-141424](https://doi.org/10.1146/annurev-fluid-010313-141424). [2] V. Sanjay, D. Lohse, and M. Jalaal, \u201cBursting bubble in a viscoplastic medium,\u201d _J. Fluid Mech._, vol. 922, p. A2, 2021. > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Dec 31, 2024 > Date modified:: Jan 26, 2025 at 11:50 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Code-Documentations/Herschel\u2013Bulkley formulation/#references",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Transforming physics research into development impact",
    "content": "The Commonwealth Split-site PhD Scholarship offers an exceptional opportunity for **doctoral candidates** from developing Commonwealth countries to spend **12 months** conducting research at Durham University while maintaining their PhD registration at their home institution. As one of the UK's top physics departments with confirmed Commonwealth Scholarship Commission (CSC) partnership status, Durham provides world-class facilities and expertise perfectly aligned with development-focused research. This guide, prepared by the Computational Matter Physics (CoMPhy) Lab, will help prospective applicants understand this prestigious opportunity and prepare competitive applications.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#transforming-physics-research-into-development-impact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Who can apply and from where",
    "content": "The scholarship targets PhD candidates from **42 eligible low and middle-income Commonwealth countries** as classified by the OECD Development Assistance Committee. For a full list of eligible countries, please visit [the list of countries](https://cscuk.fcdo.gov.uk/scholarships/commonwealth-split-site-scholarships-for-low-and-middle-income-countries/).",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#who-can-apply-and-from-where",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Eligibility: Context",
    "content": "Source: [link](https://cscuk.fcdo.gov.uk/scholarships/commonwealth-split-site-scholarships-for-low-and-middle-income-countries/) To be eligible, you must already be **registered for a PhD at a university in one of these countries** by September. Academic requirements include holding at least an upper second-class (2:1) honours degree, or a lower second-class degree plus a relevant Master's qualification. Crucially, you must demonstrate that you cannot afford UK study without this scholarship. There are no age limits, but you must be a citizen or have refugee status in an eligible country and have been residing there for at least two years before applying. The most critical eligibility requirement is the **institutional link between your home university and Durham University**. This must be a formal partnership at the departmental or institutional level - not merely a collaboration between individual researchers.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#eligibility",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Eligibility: Both your home...",
    "content": "Both your home supervisor and proposed Durham University supervisor must provide supporting statements detailing this partnership.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#eligibility",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Navigate the application timeline and process: Applications usually open...",
    "content": "Applications usually open annually in **October and close in mid-December** (16:00 GMT) [Britishcouncil](https://study-uk.britishcouncil.org/scholarships-funding/commonwealth-scholarships). For example, for the 2025/26 cycle, applications have already closed on December 16, 2024, with results expected by July 2025 for September 2025 start. Mark these dates for future cycles as the timeline remains consistent yearly. The application process is **entirely online through CSC Central**, the official CSC application system. You apply directly \u2014 no nomination from your university or government is required. Start your application at least 6 months before the deadline to allow time for securing supervisor agreements, gathering documents, and crafting your proposal. Your application journey involves first identifying a Durham University supervisor whose research aligns with your interests, then confirming the institutional link exists between universities.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#navigate-the-application-timeline-and-process",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Navigate the application timeline and process: Next, secure supporting...",
    "content": "Next, secure supporting statements from both supervisors and gather all required documents. Complete the online application including your research proposal and development impact statement. Upload all documents in the correct format (PDF preferred, maximum 5MB per file) and ensure your referees submit their references by the deadline.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#navigate-the-application-timeline-and-process",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Compile essential documentation: Documentation requirements are...",
    "content": "Documentation requirements are strict - missing or incomplete documents render applications ineligible. You'll need a **passport or national ID** showing your photograph, date of birth, and country of citizenship. Academic documents include complete transcripts for all higher education qualifications with certified English translations if needed [official website](https://cscuk.fcdo.gov.uk/scholarships/commonwealth-split-site-scholarships-for-low-and-middle-income-countries/). Reference requirements include **two academic references** submitted directly by referees through the online system, plus supporting statements from both your home supervisor and proposed Durham Universty supervisor. These supervisor statements are critical they must be on institutional letterhead, signed, and explicitly detail the institutional partnership between universities. Without both statements confirming the institutional link, your application will be considered ineligible.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#compile-essential-documentation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Compile essential documentation: Additional documents include...",
    "content": "Additional documents include your detailed research proposal, a four-part development impact statement, employment history if applicable, and up to 10 publications or prizes if relevant. While no specific English language test is required, all documents must be in English.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#compile-essential-documentation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Understanding your funding package",
    "content": "The scholarship provides comprehensive financial support for your 12-month UK stay. **Monthly stipend rates for 2025/26** are 1378 GBP for most UK locations or 1690 GBP for London universities. Based on Durham's location, you'll receive the standard rate, which adequately covers living costs in this historic city where accommodation ranges from 174-262 GBP per week in university housing [Link 1](https://uniacco.com/blog/cost-of-living-in-durham) [Link 2](https://en.uhomes.com/uk/durham). **Full tuition fees** are covered through Durham's part-funding agreement with CSC - you pay nothing. The scholarship includes return economy airfare from your home country to the UK, a warm clothing allowance, and a study travel grant for research-related travel. There are also special provisions. Please visit [Financial assistance, official webpage](https://cscuk.fcdo.gov.uk/scholarships/commonwealth-split-site-scholarships-for-low-and-middle-income-countries/) for details.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#understanding-your-funding-package",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Establishing crucial institutional links: The institutional link...",
    "content": "The institutional link requirement is the most common reason for application rejection. Your universities must have a **formal partnership beyond individual researcher collaboration**. Acceptable links include memoranda of understanding between institutions, departmental collaboration agreements, joint research projects, staff exchange programs, or established student mobility frameworks. Durham Physics has existing partnerships with several Commonwealth universities through various research networks. At the CoMPhy Lab, we maintain collaborations in computational multiphase physics. When approaching us, clearly indicate your home university's existing relationship with Durham University or propose how such a partnership could be established. Both supervisors must provide detailed statements explaining the nature of the institutional partnership, any history of collaboration, shared resources or facilities, and future partnership plans.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#establishing-crucial-institutional-links",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Establishing crucial institutional links: These statements must...",
    "content": "These statements must demonstrate that the link exists at an organizational level, not just between individuals. Consider having your department head or international office confirm the partnership formally.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#establishing-crucial-institutional-links",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Crafting a development-focused proposal: Your proposal must...",
    "content": "Your proposal must demonstrate clear development impact while maintaining scientific excellence. Our research aligns perfectly with several **CSC development themes**, particularly `Science and Technology for Development` through our work in #TODO. Structure your development impact statement in four parts. - First, **identify the problem** (200 words) by linking your research to global, national, and local development challenges. Use recent statistics from credible sources and connect to your chosen CSC theme. For CoMPhy-Lab research interests, this might involve `energy access statistics, technology gaps, or infrastructure challenges in your home country` #TODO. - Second, explain **skill application** (200 words) by detailing specific capabilities you'll gain at Durham University and how you'll apply them post-award. Be specific about organizations you'll work with and implementation strategies.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#crafting-a-development-focused-proposal",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Crafting a development-focused proposal: Results",
    "content": "For CoMPhy Lab research, this could include computational modeling skills, #TODO - Third, outline **expected outcomes** (200 words) with specific, measurable results over 1-5 years. Identify clear beneficiary groups and quantify impact where possible. For instance, #TODO improved solar cell efficiency could provide electricity to specific communities, or quantum sensing applications could enhance medical diagnostics in underserved areas. - Finally, describe **impact measurement** (100 words) including data collection methods, key performance indicators, and reporting mechanisms. Show how you'll track and demonstrate the real-world impact of your research.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#crafting-a-development-focused-proposal",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Meeting selection criteria for success: Selection panels evaluate...",
    "content": "Selection panels evaluate applications using three equally weighted criteria, each accounting for 33% of your score [link](https://cscuk.fcdo.gov.uk/advice-for-applicants/). - **Academic merit** assessment considers your degree classifications, research publications, and academic trajectory. While the minimum is a 2:1 degree, successful candidates often have first-class honours or distinction-level Master's degrees. Your referees should specifically address your intellectual capacity and research potential. - **Development impact** evaluation examines how clearly you articulate home country needs, the realism of your impact plans, and alignment with CSC themes. Successful applications demonstrate deep understanding of local contexts and propose achievable, measurable outcomes.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#meeting-selection-criteria-for-success",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Meeting selection criteria for success: Generic statements about...",
    "content": "Generic statements about \"helping development\" fail \u2014 be specific about who benefits and how. - **Research proposal quality** assessment focuses on scientific rigor, innovation, feasibility, and contribution to both knowledge and development. Your proposal should be accessible to non-specialist reviewers while maintaining scholarly standards. With success rates typically 5-10%, only the strongest applications combining all three elements succeed.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#meeting-selection-criteria-for-success",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Post-scholarship commitments and opportunities",
    "content": "Accepting this scholarship commits you to **return home within one month** of completion. CSC cannot support visa extensions, postdoctoral positions, or remaining for graduation ceremonies. This return requirement ensures you apply your UK-gained knowledge for home country development. You'll join a vibrant **lifelong alumni network** with immediate access to regional Commonwealth Scholar groups and ongoing engagement opportunities [British council link](https://www.britishcouncil.in/study-uk/scholarships/commonwealth-scholarships).",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#post-scholarship-commitments-and-opportunities",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Your path forward: The Commonwealth Split-site...",
    "content": "The Commonwealth Split-site PhD Scholarship represents a transformative opportunity to advance both your research career and your home country's development. Start preparing now for the next application cycle by identifying potential Durham supervisors whose research aligns with your interests and development goals. Contact your home university's international office to explore or establish institutional links with Durham. Begin drafting your research proposal and development impact statement, seeking feedback from mentors and previous Commonwealth Scholars. Connect with the CoMPhy Lab through our website to explore supervision possibilities in computational physics, materials science, or quantum applications. We particularly welcome proposals addressing energy access, sustainable materials, quantum technologies for development, climate modeling, or computational solutions to development challenges.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#your-path-forward",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Commonwealth split site phd scholarships - Your path forward: Class Definition",
    "content": "Our established CSC partnership, world-class facilities, supportive environment, and commitment to development-focused research make Durham an ideal choice for your Commonwealth Split-site PhD experience. Remember that successful applications balance scientific excellence with genuine development commitment. Your research should advance knowledge while creating measurable impact in your home country. With thorough preparation, clear development focus, and strong institutional support, you can join the select group of Commonwealth Scholars using physics to drive positive change across the developing world.",
    "url": "https://blogs.comphy-lab.org/Join-Us/Commonwealth-Split-site-PhD-Scholarships/#your-path-forward",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Seminar uiuc abstract - Can polymeric flows be the Drosophila of continuum mechanics?: > [!significance] Details...",
    "content": "> [!significance] Details > Speaker:: [Vatsal Sanjay](https://vatsalsanjay.com) ([CoMPhy Lab](https://comphy-lab.org)) > Seminar:: Fluid seminar, University of Illinois Urbana-Champaign (UIUC) > > When:: Thu. January 30, 2025 at **1600h CST (2300h AMS time)**. > How to attend:: Online, please email Vatsal ([vatsalsanjay@gmail.com](mailto:vatsalsanjay@gmail.com)) Polymeric liquids provide a tunable testbed to explore unsteady, nonlinear continuum mechanics by systematically varying the amount and type of polymers. We explore how such systems can probe a continuum of behaviors from Newtonian flows to elastically dominated regimes, making polymeric flows effectively the \"Drosophila\" of unsteady continuum mechanics. This talk will demonstrate how adding polymers modifies instabilities in three canonical free-surface flows: sheets punctured by holes (Taylor\u2013Culick retraction), bursting bubbles that emit droplets, and Worthington jets formed by impact.",
    "url": "https://blogs.comphy-lab.org/Talks/Seminar-UIUC-abstract/#can-polymeric-flows-be-the-drosophila-of-continuum-mechanics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Seminar uiuc abstract - Can polymeric flows be the Drosophila of continuum mechanics?: Elastic stresses either...",
    "content": "Elastic stresses either create new singularities or suppress known ones, leading to distinct regimes in parameter space. Numerical simulations and complementary experiments reveal how polymer relaxation time and modulus determine free-surface morphologies, droplet sizes, and jet velocities, with implications for aerosol generation and fluid processing. By unifying concepts from fluid and solid mechanics, these results provide broad insight into controlling interfacial flows in manufacturing, pathogen transport, and beyond. ![Singularities](_Media/20250119213726033_Seminar-UIUC-abstract.png) [[Seminar-UIUC-abstract.pdf|abstract in .pdf]] > [!info]- Metadata > Posted by:: Vatsal > Date published:: 2025-01-19 > Date modified:: Jan 27, 2025 at 08:03 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Talks/Seminar-UIUC-abstract/#can-polymeric-flows-be-the-drosophila-of-continuum-mechanics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 06 30_conference vpflow abstract - Taming singularities: yield-stress regularization in bubble-bursting: > [!significance] Speaker...",
    "content": "> [!significance] Speaker > [Vatsal Sanjay](https://vatsalsanjay.com) ([CoMPhy Lab](https://comphy-lab.org)) Capillary collapse of a bursting bubble is a canonical inertio-capillary singularity: the retracting rim launches a wave packet that focuses at the cavity base, driving a high-speed Worthington jet and, classically, droplets. Non-Newtonian physics rewrites this script. For example, yield stress and elasticity tame these waves and the jet and often suppress them [1]. Using high-fidelity simulations carried out with _MultiRheoFlow_ (https://comphy-lab.org/MultiRheoFlow/) $-$ a new open-source Basilisk C framework for interfacial flows with arbitrary rheology $-$ we explore how viscoplasticity and its elastoviscoplastic extension regularizes the singular flow. Yield stress intercepts the collapsing wavepacket, arrests curvature blow-up, and suppresses Worthington jetting [2]. In contrast, elasticity relaxation can reopen a singular path, reinstating a solitary jet or droplet [3].",
    "url": "https://blogs.comphy-lab.org/Talks/2025-06-30_Conference-VPflow-abstract/#taming-singularities-yield-stress-regularization-in-bubble-bursting",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 06 30_conference vpflow abstract - Taming singularities: yield-stress regularization in bubble-bursting: By tracking curvature...",
    "content": "By tracking curvature histories, kinetic\u2013plastic energy exchange, and stoppage times, we build a compact regime map that exposes the mechanical routes by which non-linear rheology regularizes free-surface singularities. The findings extend beyond bubbles, offering a template for predicting and controlling singular events in yield-stress and other complex fluids. ![[../_Media/2025-06-30_Conference-VPflow-abstract-1749493868724.png]] Fig. Worthington jet vs. elastoviscoplastic medium, adapted from [1]. > [!info]- Metadata > Posted by:: Vatsal > Date published:: 2025-06-09 > Date modified:: Jun 9, 2025 at 20:28 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab) ---",
    "url": "https://blogs.comphy-lab.org/Talks/2025-06-30_Conference-VPflow-abstract/#taming-singularities-yield-stress-regularization-in-bubble-bursting",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 06 30_conference vpflow abstract - References",
    "content": "[1] A. G. Balasubramanian, V. Sanjay, M. Jalaal, R. Vinuesa, and O. Tammisola, \u201cBursting bubble in an elasto-viscoplastic medium,\u201d _J. Fluid Mech._, vol. 1001, p. A9, Dec. 2024, doi: [10.1017/jfm.2024.1073](https://doi.org/10.1017/jfm.2024.1073) [2] V. Sanjay, D. Lohse, and M. Jalaal, \u201cBursting bubble in a viscoplastic medium,\u201d _J. Fluid Mech._, vol. 922, p. A2, 2021, doi: [10.1017/jfm.2021.489](https://doi.org/10.1017/jfm.2021.489) [3] A. K. Dixit, A. Oratis, K. Zinelis, D. Lohse, and V. Sanjay, \u201cViscoelastic Worthington jets and droplets produced by bursting bubbles,\u201d _J. Fluid Mech._, vol. 1010, p. A2, May 2025, doi: [10.1017/jfm.2025.237](https://doi.org/10.1017/jfm.2025.237). [[2025-06-30_Conference-VPflow-abstract.pdf|this page in .pdf]]",
    "url": "https://blogs.comphy-lab.org/Talks/2025-06-30_Conference-VPflow-abstract/#references",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Seminar durham abstract - Can polymeric flows be the Drosophila of continuum mechanics?: > [!significance] Speaker...",
    "content": "> [!significance] Speaker > [Vatsal Sanjay](https://vatsalsanjay.com) ([CoMPhy Lab](https://comphy-lab.org)) Polymeric liquids provide a tunable testbed to explore unsteady, nonlinear continuum mechanics by systematically varying the amount and type of polymers. We explore how such systems can probe a continuum of behaviors from Newtonian flows to elastically dominated regimes, making polymeric flows effectively the \"Drosophila\" of unsteady continuum mechanics. This talk will demonstrate how adding polymers modifies instabilities in three canonical free-surface flows: sheets punctured by holes (Taylor\u2013Culick retraction), bursting bubbles that emit droplets, and Worthington jets formed by impact. Elastic stresses either create new singularities or suppress known ones, leading to distinct regimes in parameter space.",
    "url": "https://blogs.comphy-lab.org/Talks/Seminar-Durham-abstract/#can-polymeric-flows-be-the-drosophila-of-continuum-mechanics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Seminar durham abstract - Can polymeric flows be the Drosophila of continuum mechanics?: JavaScript",
    "content": "Numerical simulations and complementary experiments reveal how polymer relaxation time and modulus determine free-surface morphologies, droplet sizes, and jet velocities, with implications for aerosol generation and fluid processing. By unifying concepts from fluid and solid mechanics, these results provide broad insight into controlling interfacial flows in manufacturing, pathogen transport, and beyond. ![[_Media/Durham.png|How do polymeric flows influence classical hydrodyna ic singularities?]] > [!info]- Metadata > Posted by:: Vatsal > Date published:: 2025-02-21 > Date modified:: Feb 21, 2025 at 07:23 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab) [[Seminar-Durham-abstract.pdf|this page in .pdf]]",
    "url": "https://blogs.comphy-lab.org/Talks/Seminar-Durham-abstract/#can-polymeric-flows-be-the-drosophila-of-continuum-mechanics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Thesis viscous free surface flows",
    "content": "> [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab) > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: > Date modified::",
    "url": "https://blogs.comphy-lab.org/Blog/Thesis-Viscous Free-Surface Flows/",
    "type": "blog_content",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Executive Summary",
    "content": "Arrowhead structures, nicknamed \"narwhals,\" were initially discovered as coherent patterns in elastoinertial turbulence (EIT) simulations. While these structures provided valuable insights into polymer-flow interactions $-$ they can be the pathway to explain elastoinertial turbulence $-$ recent research reveals they might be artifacts of 2D simulations that become unstable in realistic 3D flows. > [!abstract] Key Points Overview > - Coherent structures could explain the pathway to elastoinertial turbulence. > - Arrowhead (one such traveling wave coherent solution of viscoelastic channel flow) structures are unstable in 3D flows > - Lack of experimental validation. > - Numerical artifacts play significant role $-$ presence or lack of polymeric diffusion. > - Transient appearances may still influence flow dynamics.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#executive-summary",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Problem Statement",
    "content": "- **Central Issue:** The existence and significance of arrowhead structures in elastoinertial turbulence. - **Importance:** Understanding these structures could reveal fundamental mechanisms of polymer-flow interactions and turbulence development.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#problem-statement",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Historical note",
    "content": "The two Phys. Rev. Lett. outline the exact traveling wave solutions $-$ now commonly called arrowheads or narwhals. ![|750](_Media/Arrowheads-in-elastoinertial-turbulence-1740331019797.png) [J. Page, Y. Dubief & R. R. Kerswell, Phys. Rev. Lett., 125:15, 154501 (2020)](https://doi.org/10.1103/PhysRevLett.125.154501) ![](_Media/Arrowheads-in-elastoinertial-turbulence-1740331094800.png) [A. Morozov, Phys. Rev. Lett., 129:1, 017801 (2022)](https://doi.org/10.1103/PhysRevLett.129.017801)",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#historical-note",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Methodology",
    "content": "The research community has employed multiple approaches to study arrowhead structures: > [!method] Research Methods > - 2D and 3D numerical simulations > - Linear stability analysis > - Flow visualization experiments > - Polymer diffusion modeling",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#methodology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - What are arrowheads?: **Elastoinertial turbulence (EIT)**...",
    "content": "**Elastoinertial turbulence (EIT)** is a chaotic flow state in dilute polymer solutions that arises when fluid inertia and polymer elasticity jointly drive instabilities. In this regime, simulations have revealed distinctive **arrowhead-shaped coherent structures** (nicknamed \u201cnarwhal\u201d structures for their horn-like appearance). These are highly organized patterns embedded within the turbulence, consisting of a polymer stress distribution coupled with a vortical flow pattern. An arrowhead structure has * **Localized polymer stretch:** a thin sheet of highly stretched polymer (high elastic stress) forming a triangular, arrowhead-like region spanning from the near-wall area to the channel center (symmetric about the mid-plane). * **Flanking vortices:** a pair of counter-rotating vortices on either side of this polymer sheet.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#what-are-arrowheads",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - What are arrowheads?: These vortices pull...",
    "content": "These vortices pull fluid (and polymers) up from the walls toward the center, feeding and elongating the polymer-rich \u201chorn\u201d of the arrowhead. * **Coherent propagation:** the structure travels downstream as a **traveling wave**, maintaining its shape over time rather than dissipating like a random eddy.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#what-are-arrowheads",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Why do arrowheads form?: Arrowhead structures emerge...",
    "content": "Arrowhead structures emerge from a flow instability driven by polymer elasticity. At high Weissenberg number ($Wi$, dimensionless stress relaxation time $-$ high $Wi$ imply strong elastic effects) and moderate Reynolds number ($Re$), an otherwise laminar channel flow becomes unstable to disturbances at the channel center. This **center-mode instability** begins as a pattern of vortices and polymer stretch in the middle of the channel, which grows and nonlinearly saturates into the arrowhead form. Above a critical $Wi$, the flow spontaneously develops arrowhead patterns; at higher $Wi$, these patterns persist and can dominate as a stable wave. At sufficiently large $Wi$, the chaotic EIT can give way to a single steady arrowhead state, indicating that this coherent structure becomes a stable attractor when elasticity dominates. **Polymer\u2013flow coupling:** The self-sustaining nature of an arrowhead comes from a feedback loop between polymer stretching and fluid motion.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#why-do-arrowheads-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Why do arrowheads form?: The polymer\u2019s evolution...",
    "content": "The polymer\u2019s evolution equation captures this interplay: $$ \\frac{D \\mathbf{C}}{Dt} = \\mathbf{C}\\cdot(\\nabla \\mathbf{u})^T + (\\nabla \\mathbf{u})\\cdot \\mathbf{C} - \\frac{1}{Wi}(\\mathbf{C} - \\mathbf{I}) $$ where $C$ is the polymer conformation tensor. In an arrowhead, the vortex pair generates strong shear and extensional flow that continuously amplifies polymer stretch along its arms. Because relaxation is slow at high $Wi$, a persistent high-tension polymer zone forms instead of relaxing away. That stretched-polymer zone exerts elastic stress back on the fluid, reinforcing the vortices that created it. Thus the vortices and polymer sheet sustain each other: the flow keeps the polymers stretched, and the polymer tension keeps the flow organized in the arrowhead pattern.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#why-do-arrowheads-form",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Different types of arrowheads",
    "content": "![](_Media/Arrowheads-in-elastoinertial-turbulence-1740342415364.png) Fig. Different realizations of arrowheads. Figure taken from [Y. Dubief, J. Page, R. R. Kerswell, V. E. Terrapon & V. Steinberg, Phys. Rev. Fluids, 7:7, 073301 (2022)](https://arxiv.org/pdf/2006.06770)",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#different-types-of-arrowheads",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Why are arrowheads important?",
    "content": "Identifying arrowhead structures can be pivotal for understanding EIT. They are the viscoelastic analog of coherent structures in Newtonian turbulence (like near-wall streaks and rolls), providing a clear `skeleton` for the turbulence. This shows that EIT is not just random; it is built around repeatable polymer\u2013flow patterns. Arrowhead structures also showcase a new route to sustain turbulence: they show that **elastic forces can maintain complex flow structures even at Reynolds numbers where a Newtonian flow would stay laminar**. Finally, they offer a bridge between regimes, connecting purely elastic turbulence ($Re \u2248 0$) with elastoinertial turbulence at higher $Re$ with $Wi \\gg 1$.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#why-are-arrowheads-important",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Numerical vs. Experimental Evidence: Do Arrowheads Exist in 3D or in Reality?: A critical question...",
    "content": "A critical question is whether these arrowhead structures are present in **3D flows** and experiments, or if they are artifacts of idealized 2D simulations. It has been claimed \u2013 and largely supported by evidence \u2013 that a single arrowhead wave _disappears_ in fully 3D simulations and has never been observed in experiments. Recent studies confirm that in a 3D domain, an arrowhead (narwhal) state is **linearly unstable** and quickly breaks down into turbulence. Morozov and co-workers performed a linear stability analysis of the 2D travelling-wave solution and found it unstable to spanwise perturbations when embedded in a 3D domain ([M. Lellep, M. Linkmann & A. Morozov, Proc. Natl. Acad. Sci., 121:9, e2318851121 (2024)](https://doi.org/10.1073/pnas.2318851121)). In other words, _\u201cunlike 2D, in 3D the narwhal in a channel appears to become unstable, leading to chaotic flows\u201d_.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#numerical-vs-experimental-evidence-do-arrowheads-exist-in-3d-or-in-reality",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Numerical vs. Experimental Evidence: Do Arrowheads Exist in 3D or in Reality?: This means that...",
    "content": "This means that a coherent arrowhead structure cannot persist as a steady state in a wide 3D channel; it inevitably triggers its own demise into disordered motion. Indeed, direct 3D simulations of EIT show the flow filled with multiscale, transient structures rather than a single arrowhead. The characteristic structures of 3D EIT are **sheet-like regions of high polymer stretch** and streamwise vortices (often aligned in the spanwise direction) $\u2013$ no long-lived arrowhead pattern is evident. Experimentally, too, **no** arrowhead or narwhal-shaped structures have been directly observed. Laboratory studies (using techniques like flow visualization or velocimetry in polymer solutions) report chaotic fluctuations and elastic \u201csheets\u201d of polymer stretch, but not a stable arrowhead wave. For example, experimental and high-Reynolds 3D DNS studies show polymers stretched in thin sheets inclined to the flow and emerging vortex tubes, with **no mention of a sustained arrowhead** structure.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#numerical-vs-experimental-evidence-do-arrowheads-exist-in-3d-or-in-reality",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Numerical vs. Experimental Evidence: Do Arrowheads Exist in 3D or in Reality?: Recent research largely...",
    "content": "Recent research largely _supports_ these claims. The consensus is that the arrowhead/narwhal is a **2D artifact** in the sense that it cannot survive the spanwise degrees of freedom of a real 3D flow. Additionally, **no experimental evidence** of arrowheads has emerged, despite the intensive study of EIT in channels and pipes over the past decade \u2013 reinforcing the idea that such structures, if they form, are immediately disrupted in real flows. However, recent findings do _nuance_ this picture: even though a **stable** narwhal does not exist in 3D, researchers have noted that **transient** arrowhead-like patterns can _appear fleetingly_ within a 3D turbulent flow. For instance, simulations of low-Re viscoelastic turbulence sometimes display instantaneous polymer-stress contours resembling the arrowhead shape ([J. R. C. King, R. J. Poole, C. P. Fonte & S. J. Lind, arXiv:2501.09421 (2025)](https://arxiv.org/abs/2501.09421)).",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#numerical-vs-experimental-evidence-do-arrowheads-exist-in-3d-or-in-reality",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Numerical vs. Experimental Evidence: Do Arrowheads Exist in 3D or in Reality?: Summary",
    "content": "These transient appearances suggest that the arrowhead solution still exists as an organizing saddle or ephemeral structure in phase space, even if it\u2019s not sustained. In summary, the latest evidence indicates that arrowhead/narwhal structures **do not persist** in fully 3D EIT or experiments \u2013 they are replaced by more complex chaotic dynamics \u2013 but they may manifest momentarily, hinting that they influence the flow as part of its underlying state space (rather than as an observable steady feature).",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#numerical-vs-experimental-evidence-do-arrowheads-exist-in-3d-or-in-reality",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Role of Diffusion, Resolution, and Modeling Choices: Physical Feature or Numerical Artifact?: The formation and...",
    "content": "The formation and persistence of arrowhead structures are highly sensitive to modeling choices like polymer diffusion and domain dimensionality, raising the question of whether these structures are genuine physical features or numerical artifacts. **Polymer stress diffusion** in particular plays a pivotal role. In simulations of viscoelastic fluids (Oldroyd-B or FENE-P models), a small artificial diffusion term is often added to the polymer constitutive equations for numerical stability. Recent work showed that even an _infinitesimal_ polymer diffusion can qualitatively change the flow\u2019s stability characteristics. [M. Beneitez, J. Page, Y. Dubief & R. R. Kerswell, J. Fluid Mech., 981, A30 (2024)](https://doi.org/10.1017/jfm.2024.50) discovered a _polymer diffusive instability (PDI)_: with a nonzero diffusion, the laminar flow becomes linearly unstable, producing a small-scale traveling wave at the wall as the primary bifurcation.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#role-of-diffusion-resolution-and-modeling-choices-physical-feature-or-numerical-artifact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Role of Diffusion, Resolution, and Modeling Choices: Physical Feature or Numerical Artifact?: Notably, this instability...",
    "content": "Notably, this instability does _not_ exist when polymer diffusion is strictly zero \u2013 the base flow would be linearly stable in the absence of diffusion. The implication is that the arrowhead structure in 2D simulations can arise from the PDI \u2013 essentially a numerical artifact of including diffusion. The diffusive term \u201ctriggers\u201d a finite-amplitude arrowhead-like wave that would not naturally appear at that parameter set without diffusion. In reality, molecular diffusion of polymers is extremely small, so such an instability might never dominate the transition; the flow could bypass it via a subcritical route. Thus, one must be cautious: the beautiful arrowhead patterns seen in some simulations may owe their existence to an unphysically large diffusion or other numerical regularization. In that sense, they are partly a _numerical artifact_. **Numerical resolution** and dimensionality further affect arrowhead formation.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#role-of-diffusion-resolution-and-modeling-choices-physical-feature-or-numerical-artifact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Role of Diffusion, Resolution, and Modeling Choices: Physical Feature or Numerical Artifact?: Insufficient resolution can...",
    "content": "Insufficient resolution can introduce excessive numerical diffusion (smoothing out small scales), potentially _artificially stabilizing_ a large-scale structure like the arrowhead. Likewise, restricting the simulation to 2D (as was done in the initial arrowhead studies) removes the 3D disturbances that would break up the arrowhead. The 2D assumption is a strong modeling simplification that essentially _locks in_ the coherent structure. As [M. Lellep, M. Linkmann & A. Morozov, Proc. Natl. Acad. Sci., 121:9, e2318851121 (2024)](https://doi.org/10.1073/pnas.2318851121) note, one cannot draw reliable conclusions about EIT dynamics from strictly 2D simulations. In 2D, the narwhal is \u201cbenign\u201d and can remain as a steady state, but this is sustained only because the normal 3D instability modes are disallowed. In a fully resolved 3D simulation, that arrowhead state sits on a razor\u2019s edge \u2013 any slight spanwise perturbation will cause it to oscillate or breakdown.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#role-of-diffusion-resolution-and-modeling-choices-physical-feature-or-numerical-artifact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Role of Diffusion, Resolution, and Modeling Choices: Physical Feature or Numerical Artifact?: Thus, the arrowhead\u2019s...",
    "content": "Thus, the arrowhead\u2019s longevity in 2D is not reflective of physical reality; it\u2019s a consequence of an artificially constrained simulation. On the other hand, it\u2019s too strong to dismiss arrowheads entirely as a \u201cmere artifact.\u201d They are _mathematically legitimate_ nonlinear solutions of the viscoelastic flow equations (even if attained under special conditions) and they capture real physics \u2013 notably, a mechanism of polymer stretching and feedback. The consensus view is that arrowhead/narwhal structures are **embedded but unstable** features of the real system. They are \u201creal\u201d solutions, but one that the unconstrained system will only transiently visit. Diffusion and other numerical choices can exaggerate their prominence. In summary, high-fidelity simulations indicate that arrowheads do **not** represent a permanent physical flow pattern; rather, they are a byproduct of low-dimensional or diffusive modeling that nonetheless offer insight into the polymer\u2013flow interactions in EIT.",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#role-of-diffusion-resolution-and-modeling-choices-physical-feature-or-numerical-artifact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Conclusion: Recent research converges...",
    "content": "Recent research converges on a nuanced view of arrowhead (narwhal) structures in EIT. They were a landmark discovery as a coherent viscoelastic wave, and they have deepened our insight into polymer\u2013flow interactions. However, both simulations and theory now indicate that they are **transient players** in fully developed 3D turbulence rather than the primary architects of it. In fact, the energy transfer analysis between flow and polymer reveals that both chaotic regimes maintain through the same near-wall mechanism, independent of the weak arrowhead structure. These findings indicate that the arrowhead represents a passive flow structure, detached from the self-sustaining mechanics of elastic turbulence inertia (EIT) ([M. Beneitez, J. Page, Y. Dubief & R. R. Kerswell, J. Fluid Mech., 981, A30 (2024)](https://doi.org/10.1017/jfm.2024.50)).",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Arrowheads in elastoinertial turbulence - Conclusion: The community\u2019s focus...",
    "content": "The community\u2019s focus has shifted to how such structures populate the state space and trigger transitions, rather than expecting them to appear as steady patterns in experiments. Ongoing work continues to unravel the multi-stage transition to elastic and elasto-inertial turbulence $\u2013$ with arrowhead/narwhal waves serving as a valuable piece of the puzzle, albeit one with clear limitations. This critical understanding ensures that we appreciate the arrowhead structures for what they are: insightful and pedagogical solutions that illuminate EIT\u2019s mechanics, but ultimately unstable in the wild chaos of real 3D turbulence. --- > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Feb 24, 2025 > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab), [Blogs](https://blogs.comphy-lab.org)",
    "url": "https://blogs.comphy-lab.org/Blog/Arrowheads in elastoinertial turbulence/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Stokes waves of arbitrary order: Context",
    "content": "Vatsal Sanjay ([https://comphy-lab.org](https://comphy-lab.org)), CoMPhy Lab, Physics of Fluids, Univ.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#stokes-waves-of-arbitrary-order",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Stokes waves of arbitrary order: Function Definition",
    "content": "Twente $$\\eta(x)=a\\sum_{n=1}^{N}\\left[c_{n}\\,\\epsilon^{n}\\,\\cos\\bigl(nkx\\bigr)\\right],$$ where the function $c_n$ is $$ c_{n} = \\frac{(2n - 1)!!}{2^{n-1}\\,n!}.$$ ```c /** * @brief Calculates the Stokes coefficient for nth order wave * @param n Order of the wave * @return Coefficient value based on double factorial calculation */ double stokes_coefficient (int n) { if (n == 1) return 1.0; int k = 2*n - 1; double double_factorial = 1.0; for (int i = 1; i <= k; i += 2) double_factorial *= i; return double_factorial / (pow(2,(n-1)) * tgamma(n+1)); } /** * @brief Calculates the surface elevation for Stokes wave * @param x Horizontal position * @param a Wave amplitude * @param k Wave number * @param order Order of Stokes expansion * @return Surface elevation at position x */ double eta_stokes (double x, double a, double k, int order) { double eta = 0.0; double epsilon = k*a; for (int n = 1; n <= order; n++) { double c = stokes_coefficient(n); eta += c * pow(epsilon, n)*cos(n*k*x); } return eta * a; } ```",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#stokes-waves-of-arbitrary-order",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Problem Statement",
    "content": "How to describe nonlinear waves? - With a particular emphasis on extending the accuracy and applicability of wave theories for ocean engineering. The primary focus is to address periodic standing waves and Stokes waves, which are critical for understanding wave interactions in shallow and deep water regimes. Central to this is determining coefficients and analytical solutions for arbitrary-order expansions.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#problem-statement",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Methodology",
    "content": "- [[fentonNumericalMethodsNonlinear1999|Fenton (1999)]] emphasizes numerical solutions for nonlinear problems, including high-order Fourier methods for wave field expansions and their convergence properties. [@fentonNumericalMethodsNonlinear1999] - [[fentonNonlinearWaveTheories1990|Fenton (1990)]] extends nonlinear wave theories with cnoidal and Stokes theories to fifth-order expansions, using Fourier techniques for enhanced computational accuracy. [@fentonNonlinearWaveTheories1990] ![schematic-of-problem](_Media/Stokes%20waves_arbitary%20order-20241225034827809.png) Both employ polynomial and trigonometric expansions for solving boundary conditions and streamline the application of nonlinear theories in various wave contexts.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#methodology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Key Findings",
    "content": "1. **Equation of Arbitrary Order Standing Waves**: The governing expressions for surface elevation and velocity components leverage Fourier series expansions or hyperbolic functions, depending on the wave height and wavelength regime: - Standing wave elevation, $\\eta(x, t)$, approximates multiple harmonics where coefficients stem from iterative numerical techniques. - Stokes coefficients for arbitrary-order expansions use factorial-based formulas for precise amplitude corrections. 2. **Numerical Accuracy**: - Both methods demonstrate high accuracy when wave heights and wavelengths align with their regimes of validity, but overlap regions where neither theory performs optimally exist. - The fifth-order Stokes expansion offers excellent performance for waves with moderate wavelengths, while cnoidal approximations excel for shallow water waves.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#key-findings",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Implications",
    "content": "The work advances computational methods to extend the precision of nonlinear wave predictions, enabling: - Safer and more cost-effective coastal structure designs. - Improved models for wave propagation over complex seabeds.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#implications",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Recommendations",
    "content": "One option is to use **mixed-order Stokes-cnoidal** expansions for transitional regimes and refine computational methods for boundary conditions in breaking wave scenarios.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#recommendations",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Conclusion",
    "content": "Both approaches present robust solutions for their respective regimes but highlight the need for further refinement in transitional wavelength-depth conditions. ---",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Key Takeaways",
    "content": "- \ud83c\udf0a **Stokes Theory Excellence**: Best for deep water waves where wavelength-depth ratios are small. - \ud83c\udf0d **Cnoidal Theory for Shallow Water**: Ideal for long waves with large wavelength-depth ratios. - \ud83d\udd17 **Overlap Regions**: Transitional wave conditions (e.g., intermediate wavelength-depth ratios) challenge accuracy for both theories. - \ud83e\uddee **Numerical Methods' Power**: Fourier approximations enhance precision across nonlinear wave calculations. - \ud83d\udcc8 **Wave Breaking Limits**: Experiments suggest practical wave heights rarely approach theoretical maxima. - \ud83d\udc68 **Streamline Accuracy**: Velocity and pressure fields computed with Stokes and cnoidal methods align closely with Fourier-derived benchmarks. **One-line summary**: High-order Stokes and cnoidal theories provide accurate tools for nonlinear wave modeling, but computational refinements remain necessary for transitional regimes. ---",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#key-takeaways",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - Arbitrary Order Standing Wave Equation",
    "content": "A general formula for Stokes coefficients of the \\(n\\)-th order wave, as described in the texts, resembles: ```c double stokes_coefficient(int n) { if (n == 1) return 1.0; double double_factorial = 1.0; for (int i = 1; i <= 2*n - 1; i += 2) double_factorial *= i; return double_factorial / (pow(2, n - 1) * tgamma(n + 1)); } ``` And for the surface elevation of Stokes waves: ```c double eta_stokes(double x, double a, double k, int order) { double eta = 0.0; double epsilon = k * a; for (int n = 1; n <= order; n++) { double c = stokes_coefficient(n); eta += c * pow(epsilon, n) * cos(n * k * x); } return eta * a; } ``` These computations involve harmonic terms, with coefficients determined iteratively or analytically, ensuring convergence and numerical stability.",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#arbitrary-order-standing-wave-equation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - For dispersion relation in higher order: For the 0th...",
    "content": "For the 0th order: $$\\omega_0 = \\sqrt{gk},$$ Corrections for higher order gives $$\\frac{\\omega}{\\omega_0} = 1 + \\tfrac12\\epsilon^{2} + \\tfrac38\\epsilon^{4} + \\tfrac{5}{16}\\epsilon^{6} + \\tfrac{35}{128}\\epsilon^{8} +\\dots$$ * This is order `8`. - The trick here is how to calculate higher order coefficients. - Ref. - Stokes (1847), for the original perturbation approach [@stokes1847theory] - Longuet-Higgins [@longuet-higginsNewIntegralRelations1984] and other related works. - Lamb (1932): See Chapter 9 (especially art. 246\u2013250). Although Lamb typically writes out the celerity expansions $(c = \\omega / k)$, the frequency version is equivalent. [@Lamb1932] - **Most Importantly** $$c^2 = 1 + h^2 + \\frac{4}{3}h^4 + \\frac{17}{9}h^6 - \\frac{22}{9}h^8 + \\dots$$where $h = ak$ [[schwartzComputerExtensionAnalytic1974#^e59b15|page 11]] of [@schwartzComputerExtensionAnalytic1974].",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#for-dispersion-relation-in-higher-order",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Stokes waves_arbitary order - For dispersion relation in higher order: High\u2010order expansions of...",
    "content": "High\u2010order expansions of the Stokes dispersion relation up to ($\\epsilon^8$) have been verified numerically by Schwartz (1974). -> A good place for review is Annu. Rev. Fluid Mech. by L. W. Schwartz and J. D. Fenton [@schwartzStronglyNonlinearWaves1982] -> The code at [@sanjayComphylabStandingnonlinearwavesStanding2024] implements the above formulation for calculating the dispersion relation as a function of $ak$. It also uses the initial condition mentioned at the top of this document as the initial condition for the direct numerical simulations. ![[Stokes waves_arbitary order-20250125232439287.png]] ---",
    "url": "https://blogs.comphy-lab.org/Blog/Stokes waves_arbitary order/#for-dispersion-relation-in-higher-order",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - From Newtonian Beginnings to Viscoelastic Surprises (Historical Context): Early studies of...",
    "content": "Early studies of bubble bursting (dating back to at least the early 20th century) focused on Newtonian fluids and laid the groundwork for understanding the bursting mechanism. Pioneering experiments by A.M. Worthington over a century ago captured photographs of jets formed by collapsing cavities, essentially visualizing the birth of the Worthington jet phenomenon. By the mid-20th century, scientists recognized that bursting bubbles were important in nature \u2013 for instance, generating sea spray aerosols and even transporting microorganisms. These studies assumed _ideal_ liquids like pure water, and by the late 1900s the physics was well-charted: when a bubble\u2019s cap ruptures, a bowl-shaped cavity is left in the surface. Capillary waves travel down the cavity\u2019s sides and converge at the cavity\u2019s bottom, shooting a high-speed jet upward, which then often pinches off droplets. This Newtonian paradigm was the default for a long time. However, real-world liquids aren\u2019t always Newtonian.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#from-newtonian-beginnings-to-viscoelastic-surprises-historical-context",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - From Newtonian Beginnings to Viscoelastic Surprises (Historical Context): Examples",
    "content": "Sea water, for example, is full of **surfactants** and organic matter; foods and biofluids can be **viscoelastic** (think of saliva or mucus which stretches like a weak elastic goo). Researchers gradually realized that these non-Newtonian traits could change the bubble-bursting outcome. A key turning point came in the 1990s. In 1996, J.M. Cheny and K. Walters carried out experiments with water mixed with a tiny amount of polymer (on the order of only tens of parts per million). To everyone\u2019s surprise, the addition of a **viscoelastic** agent (the polymer) dramatically altered the jet: even such a small polymer concentration reduced the jet height by roughly an order of magnitude. In other words, the normally tall, spire-like jet seen in pure water became stunted. This was a clear indication that something beyond ordinary viscosity \u2013 namely elastic stresses introduced by the polymer \u2013 was influencing the process.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#from-newtonian-beginnings-to-viscoelastic-surprises-historical-context",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - From Newtonian Beginnings to Viscoelastic Surprises (Historical Context): This historical milestone...",
    "content": "This historical milestone demonstrated that the classical Newtonian model was not the whole story, sparking fresh interest in bubble bursting under non-Newtonian conditions. Over the following years, interest in _complex fluids_ grew, but only recently have we begun to see a flurry of studies examining bubble bursting in fluids with additives like polymers. The motivation is clear: **bubbles burst in nature and industry under all kinds of fluid conditions**, so understanding how phenomena like elasticity alter the outcome is crucial. Our current work fits into this evolving narrative by using simulations to dig deeper into those viscoelastic effects that intrigued researchers since the late 20th century.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#from-newtonian-beginnings-to-viscoelastic-surprises-historical-context",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - Viscoelastic Effects in Prior Studies: What Do We Know?: Several experimental and...",
    "content": "Several experimental and computational studies have set the stage for our current investigation by exploring how viscoelasticity changes the bursting-bubble dynamics. Building on the early findings of Cheny and Walters (1996), later researchers quantified and expanded those observations. Cheny and Walters had shown that introducing a small amount of polymer (roughly 50 ppm of a long-chain polymer in water) could drastically shrink the burst-induced jet. This **jet height suppression** implied that elastic stresses (even if the fluid had just a \u201cdash\u201d of polymer) were counteracting the forces that typically drive a tall jet. Fast-forward to recent years: Rodr\u00edguez-D\u00edaz _et al._ (2023) carried out bubble-burst experiments with **weakly viscoelastic** polymer solutions and uncovered a nuanced effect. They observed that at an _optimal_ polymer concentration (around 25 ppm in their case), the tiny amount of polymer actually made the jet _faster_. How?",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#viscoelastic-effects-in-prior-studies-what-do-we-know",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - Viscoelastic Effects in Prior Studies: What Do We Know?: The polymer molecules...",
    "content": "The polymer molecules at the interface dampened the small ripples on the collapsing cavity (the short-wavelength capillary waves), leading to a smoother, more focused collapse. Smoothing out those ripples caused the liquid to shoot upward more directly, enhancing the jet\u2019s velocity. In other words, a little elasticity at the interface ironed out disturbances that would normally waste energy, thus the jet came out quicker and slightly more forceful. However, when Rodr\u00edguez-D\u00edaz _et al._ increased the polymer concentration further, the story changed. Higher polymer content introduced stronger **bulk elastic effects** \u2013 essentially the liquid became noticeably stretchy or resistant to fast flow. In those cases, the rising jet often **failed to produce the usual top droplet at all**. The fluid\u2019s elastic resistance to stretching (sometimes called **extensional thickening**) prevented the jet from necking and breaking up into a drop.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#viscoelastic-effects-in-prior-studies-what-do-we-know",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - Viscoelastic Effects in Prior Studies: What Do We Know?: Summary - JavaScript",
    "content": "In summary, their experiments showed a viscoelastic sweet spot where a little elasticity boosts the jet, and a regime where too much elasticity chokes off droplet formation. Other studies have echoed these findings. Very recent work by Cabalgante-Corrales _et al._ (2025) further confirmed that beyond a certain elasticity threshold, **droplet emission can be completely suppressed**. In their observations, if the polymer relaxation time (a measure of how long the fluid\u2019s elastic stresses persist) is sufficiently large compared to the timescale of the jet formation, no droplets are emitted at all \u2013 the jet essentially forms a single column that retracts without snapping off a small drop. This threshold can be described in terms of a dimensionless **Weissenberg number** (which compares the polymer\u2019s relaxation time to the jet\u2019s characteristic time scale); when it exceeds a value on the order of 0.5, the fluid\u2019s elasticity dominates the breakup process.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#viscoelastic-effects-in-prior-studies-what-do-we-know",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - Viscoelastic Effects in Prior Studies: What Do We Know?: All these prior...",
    "content": "All these prior studies, from 1996 to 2025, consistently point to the fact that even _weak_ viscoelasticity can profoundly influence the outcome of a bursting bubble. They provided clues like **droplet suppression** and **capillary-wave damping** that any complete theory or model must explain.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#viscoelastic-effects-in-prior-studies-what-do-we-know",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - How Our Simulations Build on These Insights: Our current study...",
    "content": "Our current study uses high-fidelity numerical simulations to explore bubble bursting in viscoelastic liquids, helping to clarify the mechanisms behind the experimental observations above. By employing an **Oldroyd-B viscoelastic model** (a common model for polymer solutions) in a Volume-of-Fluid simulation framework, we can control and vary the fluid\u2019s key properties systematically \u2013 something difficult to do in experiments. We map out a range of conditions in terms of dimensionless groups (like the _elasto-capillary number_ and _Deborah number_, which relate to polymer elasticity and relaxation time) to see how each influences the jet and droplet outcome. Essentially, these simulations let us rewind, pause, and inspect the bursting process in ways a high-speed camera cannot: we can look at the tension in the fluid, the distribution of polymer stresses, and test \u201cwhat-if\u201d scenarios by dialing elasticity up or down independently of other factors.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#how-our-simulations-build-on-these-insights",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - How Our Simulations Build on These Insights: What we found...",
    "content": "What we found corroborates many of the past experimental findings while also providing a clearer picture of why they happen. For instance, our simulations show that introducing a small amount of polymer indeed **dampens the high-frequency capillary waves** on the collapsing bubble cavity, much like Rodr\u00edguez-D\u00edaz _et al._ noted. We can directly see the interface becoming smoother in the simulation, which in turn leads to a more coherent jet that can even travel faster than it would in pure water. On the other hand, when we crank up the viscoelastic effects (by increasing polymer concentration or elasticity in the simulation), the jet\u2019s behavior changes dramatically. The jet tends to be thicker and more stable \u2013 so stable, in fact, that it doesn\u2019t break up into a droplet at the tip. This matches the **droplet suppression** regime reported in experiments.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#how-our-simulations-build-on-these-insights",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - How Our Simulations Build on These Insights: In the simulations,...",
    "content": "In the simulations, we observe that the polymer stresses accumulate during the cavity collapse and jet rise, and if those stresses are high enough, they counteract the necking that would normally pinch off a droplet. The result is a jet that simply subsides back without spraying droplets. By varying the fluid\u2019s relaxation time, we can pinpoint the threshold at which this happens, supporting the idea that there is a critical viscoelastic relaxation timescale beyond which the droplet never forms. In short, our simulations **extend the insights of earlier works** by providing a full-field view of the flow and isolating the roles of different effects. They confirm that the viscoelastic phenomena observed by Cheny & Walters, Rodr\u00edguez-D\u00edaz _et al._, and others are not just experimental quirks, but fundamental aspects of the physics when polymers are present.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#how-our-simulations-build-on-these-insights",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - How Our Simulations Build on These Insights: Examples",
    "content": "Moreover, the simulations help untangle the interplay between viscous and elastic forces: for example, we find there\u2019s a trade-off between a fluid\u2019s viscosity and its elasticity in setting the jet speed and whether a droplet pinches off. This kind of systematic exploration would be challenging in a lab but is feasible in a simulation, allowing us to fill gaps in the understanding.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#how-our-simulations-build-on-these-insights",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - Concluding Thoughts: Bubble bursting might...",
    "content": "Bubble bursting might last only a few milliseconds, but as research over the decades has shown, it\u2019s a rich and complex phenomenon \u2013 especially when you venture beyond ordinary liquids. Historically, scientists figured out the basics in simple fluids, establishing a baseline for how jets and droplets form after a burst. The addition of polymers and other non-Newtonian effects then revealed new twists: slower, stubbier jets or no droplets at all under the right conditions. By comparing past experiments and new simulations, we now have a much clearer picture of _why_ those twists occur. **Viscoelasticity**, in essence, adds a kind of \u201cmemory\u201d to the liquid: the fluid remembers being stretched and fights back, which can either smooth out the jet formation or halt the droplet breakup \u2013 or both. For a scientifically curious reader or an early-career researcher, the take-home message is that **even a dash of polymer can tip the balance** of forces during a bubble burst.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#concluding-thoughts",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - Concluding Thoughts: This means traditional...",
    "content": "This means traditional Newtonian models need adjustments when dealing with real-world fluids. Our study contributes to this evolving understanding by not only confirming the experimental observations in a controlled setting but also by quantifying the thresholds and mechanisms at play. Going forward, these insights could inform everything from predicting oceanic spray in various water conditions to designing industrial processes (or even culinary tricks) where bubble bursting is a factor. The humble bubble, when combined with a bit of polymer physics, continues to teach us new fluid dynamics \u2013 a beautiful example of how revisiting a classic problem with fresh eyes can lead to deeper knowledge. **References:** _(The cited works correspond to the following)_ - Cheny, J.M. & Walters, K. (1996). Extravagant viscoelastic effects in the Worthington jet experiment. _J.",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#concluding-thoughts",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "History worthington jets from bursting bubbles - Concluding Thoughts: Context",
    "content": "Non-Newtonian Fluid Mech._ **67**, 125\u2013135. - Rodr\u00edguez-D\u00edaz, P., Rubio, M., Montanero, J.M., Ga\u00f1\u00e1n-Calvo, A.M. & Cabezas, M.G. (2023). Bubble bursting in a weakly viscoelastic liquid. _J. Fluid Mech._ **954**, A20. - Cabalgante-Corrales, C., Mu\u00f1oz-S\u00e1nchez, B.N., Ferrera, C., Fuster, D. & Sevilla, A. (2025). Viscoelastic effects on jet drop formation in bubble bursting. _Phys. Rev. Fluids_ **10**, 013603. (supporting information on droplet suppression) - _Additional references on bubble bursting in Newtonian and complex fluids are cited in-line above (e.g., Worthington\u2019s early work, studies by Ghabache et al. 2014/2016 on champagne bubbles, etc.), illustrating the progression from classical to modern understanding._",
    "url": "https://blogs.comphy-lab.org/Blog/History-Worthington-jets-from-bursting-bubbles/#concluding-thoughts",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - James G. Oldroyd: Life, Work, and Legacy in Rheology",
    "content": "![](../_Media/James%20G.%20Oldroyd-1741128879880.png) > Portrait and bio sketch of James G. Oldroyd. Slide taken from John Hinch's talk on _Oldroyd B, and not A?_",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#james-g-oldroyd-life-work-and-legacy-in-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Early Life and Education: James Gardner Oldroyd...",
    "content": "James Gardner Oldroyd (25 April 1921 \u2013 22 November 1982) demonstrated exceptional mathematical aptitude in Bradford, England. He entered Bradford Grammar School at age 10, matriculating in nine subjects by age 14. Unable to advance immediately to university due to his youth, he dedicated four years in sixth form to developing mathematical expertise while acquiring fluency in German and French. In 1939, Oldroyd secured a state scholarship to Trinity College, Cambridge, where he established an exemplary academic record. He received the Rouse Ball Prize in 1941 and the Mayhew Prize in 1942 as Cambridge's outstanding student in applied mathematics, graduating with first-class honors. Oldroyd maintained strong academic affiliations with Trinity College post-graduation, returning as a research scholar (1945\u201346) and securing a junior fellowship (1947).",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#early-life-and-education",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Early Life and Education: During this period,...",
    "content": "During this period, he completed his PhD thesis titled *\u201cA mathematical discussion of some rheological problems,\u201d* with guidance and critiques from W. R. Dean (of *Dean flow* fame) and Alan H. Wilson. Dean and Wilson $-$ both Cambridge trained mathematicians significantly influenced Oldroyd's approach to fluid mechanics and solid mechanics. His doctoral work (PhD awarded 1949) established fundamental principles in non-Newtonian fluid mechanics, culminating in his Cambridge Sc.D. in 1958 for his substantial contributions to the field [^1].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#early-life-and-education",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: World War II...",
    "content": "World War II interrupted Oldroyd\u2019s academic pursuits but also broadened his experience. From 1942 to 1945 he worked at the Ministry of Supply in Aberporth, Wales, conducting rocket research for Britain\u2019s war effort. This foray into applied physics and engineering gave him practical insight into fluid and material behavior under extreme conditions. After the war, Oldroyd transitioned back to research in emerging areas of fluid mechanics. In 1945 he joined the Fundamental Research Laboratory of **Courtaulds** in Maidenhead, a major industrial lab focused on artificial fibers and polymers [^2]. Notably, his former Cambridge tutor, Alan H. Wilson, had also moved to Courtaulds, and likely helped recruit Oldroyd to this innovative environment [^1]. At Courtaulds, Oldroyd worked closely with experimental rheologists **D. J. Strawbridge** and **B. A. Toms**, who were investigating the unusual flow behavior of polymer solutions [^2].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: Examples",
    "content": "These collaborations exposed Oldroyd to cutting-edge rheometry and puzzling phenomena \u2013 for example, B. A. Toms had just discovered the drag reduction effect (later called the *Toms effect*) where tiny polymer additives dramatically lower turbulent friction. Oldroyd became fascinated by such non-Newtonian effects and even suggested early on that *wall slip* at the pipe boundary might explain Toms\u2019s observations [^3]. This period at Courtaulds was formative: it immersed Oldroyd in real-world rheological problems, from the processing of viscose fibers to the oddities of polymer solution flows, inspiring him to seek a deeper theoretical framework for these `elastic` liquids. Oldroyd\u2019s first publications in the late 1940s already show him tackling non-Newtonian fluid mechanics with a blend of mathematical rigor and practical insight.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: He initially focused...",
    "content": "He initially focused on *viscoplasticity*, analyzing the flow of **Bingham solids** (materials that behave as a solid until a yield stress is exceeded when they flow). In 1947, while still in Cambridge, he published a series of papers on the *plastic flow of Bingham materials*, developing a `rational formulation` of their equations of flow and solving flow problems between moving cylinders. These early works, drawn from his dissertation, addressed how yield-stress fluids deform, essentially bridging solid plasticity and fluid flow. By 1949, Oldroyd had broadened his scope to other types of non-Newtonian fluids: he examined steady laminar flows in non-Newtonian liquids and noted anomalies like pressure gradients in pipe flow that couldn\u2019t be explained by classical viscosity alone. He even proposed experimental methods to detect wall slip and other flow peculiarities at the first International Congress on Rheology in 1948 [^1].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: These experiences convinced...",
    "content": "These experiences convinced Oldroyd that a unifying theoretical description for *complex fluids* was needed \u2013 one that could encompass the behavior of elastic liquids (polymer solutions), viscous suspensions, and even solids with memory. This realization set the stage for his groundbreaking work in 1950.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: In 1950, James...",
    "content": "In 1950, James G. Oldroyd published what is now considered **\u201cprobably the most important single paper in theoretical rheology.\u201d**[^6] Titled *\u201cOn the Formulation of Rheological Equations of State,\u201d*[^4] this paper established the basic principles for mathematical models of complex fluids. Oldroyd addressed a fundamental issue: existing viscoelastic models at the time (such as the Jeffreys model) were not *frame-invariant* \u2013 their predictions could depend on the observer\u2019s frame of reference, which is unphysical [^5]. Influenced by earlier work of Sir Harold Jeffreys and by a 1946 study of bitumen by H. Fr\u00f6hlich and R. Sack, Oldroyd recognized that the way one computes the time-derivative of stress in a flowing material is crucial. In essence, he argued that when a material element moves, rotates, and deforms, the rate-of-change of stress must be evaluated in a *convected frame* moving with the material.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: Definitions",
    "content": "To achieve this, Oldroyd introduced two new definitions of the stress derivative \u2013 the **upper-convected** and **lower-convected** time derivatives \u2013 which account for material rotation and stretching in different ways: > Lower convective Oldroyd derivative: > $$ \\stackrel{\\triangle}{A} = \\frac{DA}{Dt} + \\mathbf{A} \\cdot (\\nabla \\mathbf{u})^T + \\nabla \\mathbf{u} \\cdot \\mathbf{A}. $$ > Upper convective Oldroyd derivative: > $$ \\stackrel{\\nabla}{A} = \\frac{DA}{Dt} - \\mathbf{A} \\cdot (\\nabla \\mathbf{u})^T - \\nabla \\mathbf{u} \\cdot \\mathbf{A}. $$ Applying these ideas, Oldroyd showed that if one takes the classical *Jeffreys model* (a combination of an elastic spring and two viscous dashpots) and replaces the ordinary time derivatives with his convected derivatives, one obtains two consistent viscoelastic models [^5].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: These he called...",
    "content": "These he called \u201cModel A\u201d (using the lower-convected derivative) and \u201cModel B\u201d (using the upper-convected derivative) \u2013 known today as the **Oldroyd-A and Oldroyd-B models** [^5]. > Oldroyd-A (Lower convected derivative): > $$ \\sigma + \\tau_1 \\stackrel{\\triangle}{\\sigma} = 2\\mu^*(\\mathbf{E} + \\tau_2 \\stackrel{\\triangle}{\\mathbf{E}}),$$ > Oldroyd-B (Upper convected derivative): > $$ \\sigma + \\tau_1 \\stackrel{\\nabla}{\\sigma} = 2\\mu^*(\\mathbf{E} + \\tau_2 \\stackrel{\\nabla}{\\mathbf{E}})$$ Both models reduce to the same behavior in a stationary reference frame, but they differ in how they predict stresses in flows involving rotation or deformation of the fluid parcel. Oldroyd\u2019s 1950 paper thus laid down a clear *frame-indifference* requirement for rheological equations, a cornerstone for modern continuum mechanics of non-Newtonian fluids.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: It was a...",
    "content": "It was a bold theoretical leap that immediately gave researchers two possible constitutive equations for viscoelastic liquids. > [!danger] Note: > Oldroyd, characteristically cautious, noted that choosing between Model A and B `depends on the physics` of the material, though he offered no immediate criteria for selection [^5]. Nonetheless, the mere formulation of these models has been instructive. It provided, for the first time, a concrete mathematical language to describe fluids with both viscous and elastic characteristics (*viscoelastic* fluids) in a way that is invariant under changes of frame. This achievement earned Oldroyd international recognition \u2013 including the Gold Medal of the British Society of Rheology and a special issue of the BSR Bulletin honoring his 60th birthday [^6] \u2013 and it set the stage for much of the theoretical rheology that followed.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg\u2019s Rod-Climbing and the Preferred Model: While Oldroyd initially...",
    "content": "While Oldroyd initially presented **Models A and B** as two equally plausible formulations, subsequent insights and experiments soon favored one over the other. In the very same 1950 paper, at the end, Oldroyd himself included a telling calculation: the flow of an elastic liquid around a rotating rod. This was not an arbitrary choice \u2013 it related to a famous experiment by **Karl Weissenberg** a few years earlier. Weissenberg had observed that when a rod is rotated in a polymer solution, the fluid *climbs up* the rod against gravity (now known as the **Weissenberg effect** or rod-climbing effect) due to the elastic normal stresses generated in the fluid. Oldroyd wanted to see how his two model fluids would behave in this scenario. The result was striking: **Oldroyd-B (upper-convected)** predicted the fluid would climb the rod, matching Weissenberg\u2019s observations, whereas **Oldroyd-A (lower-convected)** predicted the opposite \u2013 the fluid would be pushed downwards (a \u201crod-dropping\u201d effect).",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg\u2019s Rod-Climbing and the Preferred Model: The latter phenomenon...",
    "content": "The latter phenomenon had never been observed in polymer fluids. Thus, by comparing both models against empirical reality, **Oldroyd-B emerged as the more physically relevant model for polymeric (viscoelastic) fluids**. As Oldroyd and others noted, the *rod-climbing test* essentially singled out Model B as the correct choice for liquids like dilute polymer solutions. Oldroyd commented that Model B should *\u201cbe favoured\u201d* in such cases, aligning with Weissenberg\u2019s findings. (Indeed, the inverse \u201crod-dipping\u201d behavior of Model A was only realized decades later in very different materials, such as dense suspensions of particles, confirming Oldroyd\u2019s intuition that the choice depends on the material\u2019s microphysics.) ![](../_Media/James%20G.%20Oldroyd-1741126421305.png) > A classic demonstration of the **Weissenberg rod-climbing effect**. A rotating rod in a viscoelastic polymer solution causes the fluid to climb up along the rod, due to positive normal stress differences.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg\u2019s Rod-Climbing and the Preferred Model: Oldroyd\u2019s upper-convected Model...",
    "content": "Oldroyd\u2019s upper-convected Model B correctly captures this effect, whereas Model A would predict a downward dip, which is not observed in polymer fluids. Figure credits: [Henry Ng and Rob Poole, University of Liverpool](https://fluids.ac.uk/gallery/zoomify/665). Beyond qualitative rod-climbing, more detailed **microstructural studies** in subsequent years reinforced the supremacy of Oldroyd-B for polymeric liquids. In the 1960s, rheologists developed molecular models of polymer solutions \u2013 envisioning long polymer molecules as tiny spring\u2013dashpot elements or \u201cdumbbells\u201d dispersed in a solvent. When **John Hinch** and others revisited Oldroyd\u2019s models in light of these developments, they found a remarkable connection: the simplest molecular model of a polymer chain in flow (the **elastic dumbbell model**) leads mathematically **directly to the Oldroyd-B constitutive equation** [^5].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg\u2019s Rod-Climbing and the Preferred Model: In other words,...",
    "content": "In other words, if one treats a polymer molecule as two beads connected by a spring dragged through a viscous solvent, the macroscopic stress evolution follows Oldroyd\u2019s upper-convected form (with the polymer\u2019s finite relaxation time corresponding to Oldroyd-B\u2019s parameters). This result explained why Oldroyd-B captured many polymer solution behaviors so well \u2013 it was essentially *derived from first principles* of polymer micro-dynamics. Oldroyd-A, in contrast, did not emerge from any analogous physical picture for flexible polymers. By the late 20th century, therefore, Oldroyd-B had become the **standard viscoelastic fluid model** for dilute polymer solutions in rheology and computational fluid dynamics, whereas Oldroyd-A largely faded from use.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg\u2019s Rod-Climbing and the Preferred Model: As John Hinch...",
    "content": "As John Hinch humorously noted, a survey of literature reveals thousands of papers employing \u201cOldroyd-B\u201d in their title or keywords, but only a handful mentioning \u201cOldroyd-A\u201d. ![](../_Media/James%20G.%20Oldroyd-1741126749363.jpeg) The reason is clear: Oldroyd-B not only passes key experimental tests but also has a firm basis in polymer molecular theory, making it the preferred tool for scientists and engineers modeling viscoelastic flows. The **legacy of Oldroyd\u2019s 1950 insight** is thus encapsulated in the ubiquity of the Oldroyd-B model \u2013 a tribute to his ability to capture the essential physics of elastic fluids in a simple equation.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: After 1950, Oldroyd...",
    "content": "After 1950, Oldroyd continued to build on his framework and ventured into new problems, further cementing his status as a pioneer in rheology. In 1953, he published a notable paper on *\u201cThe elastic and viscous properties of emulsions and suspensions.\u201d* [^7] Here, Oldroyd extended his constitutive modeling to **multiphase systems**, showing how a mixture of a liquid with dispersed droplets or particles could exhibit viscoelastic behavior. He demonstrated (for a dilute emulsion of liquid droplets) that the interfacial tension of the droplets provides a restoring force against deformation, effectively giving the emulsion an elastic component [^3]. This work was an early example of **micro-rheology** \u2013 linking microscopic structure to macroscopic rheological properties \u2013 and it illustrated Oldroyd\u2019s knack for generalizing his models to diverse materials.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: JavaScript",
    "content": "He also investigated the effect of surfactant films on droplet interfaces in emulsions, recognizing that a stabilizing film could alter the combined fluid\u2019s elasticity. These studies by Oldroyd in the 1950s are considered pioneering, as they connected continuum rheology with micro-scale mechanisms in suspensions and emulsions. Oldroyd\u2019s theoretical explorations in the mid-1950s also produced insights into what we now call **\u201csecond-order fluids.\u201d** In a 1958 paper, he analyzed normal stress effects (differences in normal stresses) in steady flows of idealized viscoelastic liquids, using a general invariant formulation that included up to quadratic terms in stresses [^8]. Notably, he examined the conditions for the Weissenberg effect (rod-climbing) to occur \u201cin a positive or negative sense,\u201d essentially exploring the parameter space where a fluid would climb or dip around a rod.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: This comprehensive study...",
    "content": "This comprehensive study brought clarity to how **non-Newtonian normal stresses** arise in shear and rotational flows, and it introduced what became known as the **Oldroyd 8-constant model** (a generalized linear viscoelastic model with eight material constants). Such work laid the groundwork for later researchers like Coleman, Noll, and Rivlin, who in the same era were developing the modern continuum mechanics of fluids. Oldroyd\u2019s approach was always characterized by careful attention to invariant formulation (he cited the earlier convected-coordinate ideas of F. Hencky and others [^3]) and by a desire to keep models as simple as possible while capturing the essential physics. In 1961, he published a survey in *Rheologica Acta* on *\u201cthe hydrodynamics of materials whose rheological properties are complicated,\u201d* [^9] reflecting on how to extend classical hydrodynamics to fluids with memory and elasticity.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: He even ventured...",
    "content": "He even ventured into esoteric territory by exploring constitutive equations in a general relativistic context (a 1970 paper on equations of state in general relativity [^10]), showing the breadth of his mathematical curiosity. Throughout the 1960s and 1970s, Oldroyd remained an active, though not prolific, author. He was selective in his publications, preferring depth over quantity \u2013 in nearly 40 years he published fewer than 30 papers [^1], mostly as a single author. Yet those papers are dense with ideas that continued to influence rheology. He developed a theory of **viscoplastic boundary layers**. He also revisited thermodynamics and continuum mechanics, searching for rheological models consistent with the laws of thermodynamics (as seen in his 1976 reflections).",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: Even in his...",
    "content": "Even in his final years, Oldroyd continued to synthesize his lifetime of insights: his last paper, published posthumously in 1984, was titled *\u201cAn approach to non-Newtonian fluid mechanics,\u201d*[^11] offering a grand overview of the field - a treat to read for our generation.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Oldroyd\u2019s influence extended...",
    "content": "Oldroyd\u2019s influence extended beyond his written work; he was also a guiding figure and mentor in the rheology community. In 1953, the same year he took up a professorship, he served as **Treasurer of the 2nd International Congress of Rheology** held in Cambridge [^2] \u2013 a gathering of the world\u2019s top rheologists. He later became President of the British Society of Rheology (BSR) from 1955 to 1957, helping to shape the direction of rheological research in the UK [^12]. Oldroyd had moved to academia in 1953 as Professor of Mathematics at the University of Wales, Swansea, where he also headed the Applied Mathematics Department from 1957. In 1965, he was appointed Professor at Liverpool University, eventually becoming Head of the Department of Applied Mathematics and Theoretical Physics there [^2]. In these roles, Oldroyd supervised a small number of doctoral students \u2013 notably **Kenneth Walters**, who completed his PhD under Oldroyd at Swansea.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Walters would go...",
    "content": "Walters would go on to become a prominent rheologist himself (co-founding the *Journal of Non-Newtonian Fluid Mechanics* in 1976) and later reminisced that although Oldroyd guided only *\u201chalf a dozen\u201d* PhD students, his impact on them \u2013 and on the field \u2013 was profound [^13]. Oldroyd\u2019s students and colleagues admired his deep physical intuition and his knack for reducing complex problems to their core elements. Amusingly, Walters recalled that Oldroyd was *\u201cno sportsman,\u201d* yet somehow many of his research students were star cricket players \u2013 a coincidence that Oldroyd, with his gentle humor, tolerated even if he didn\u2019t share their sporting enthusiasm [^13]. In recognition of his scientific contributions, Oldroyd received numerous honors. Cambridge University awarded him the **Adams Prize in 1964**, one of its highest accolades in mathematics, for his work on the mechanics of non-Newtonian fluids.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: The British Society...",
    "content": "The British Society of Rheology bestowed upon him its **Gold Medal** in 1984 (the year after what would have been Oldroyd\u2019s retirement), celebrating a lifetime of achievement in rheology [^2]. Tributes poured in as he reached his 60th birthday in 1981 \u2013 the BSR dedicated a special issue of its bulletin to him, and luminaries like professor R. B. Bird lauded Oldroyd\u2019s contributions.[^6] In fact, at the 1988 International Congress on Rheology in Sydney, Bob Bird gave an opening lecture entitled *\u201cThe Two JG\u2019s\u201d* in honor of **J. G. Oldroyd** and **J. G. Kirkwood** \u2013 comparing Oldroyd, the continuum mechanician, and Kirkwood, the molecular theorist, as two giants who bridged the gap between macroscopic and microscopic understandings of fluid behavior [^1]. This was a testament to how Oldroyd\u2019s work, particularly the Oldroyd-B model, had become a cornerstone that linked molecular theory with continuum modeling. Unfortunately, James G.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Oldroyd\u2019s life was...",
    "content": "Oldroyd\u2019s life was cut short in 1982 \u2013 he died suddenly of an apparent heart attack while on his way to the university in Liverpool [^2] \u2013 but his legacy endures vibrantly. His name is forever attached to the **Oldroyd-B model**, a staple in rheology textbooks and simulations, and his ideas on convected derivatives underpin all modern viscoelastic fluid theories. In computational fluid dynamics and engineering today, Oldroyd\u2019s models are routinely used to simulate polymer processing, biological fluid flows, and complex material behavior, enabling predictions of how materials will respond under flow with both viscous and elastic forces at play. In hindsight, John Hinch and other colleagues note that Oldroyd\u2019s genius was in formulating simple yet physically sound models \u2013 *\u201cthe first twelve pages\u201d* of his 1950 paper, as Bob Bird once remarked, *contained the seeds of an entire field*.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: By following a...",
    "content": "By following a historical narrative from classical mechanics to modern rheology, Oldroyd essentially wrote the chapter that connects **Isaac Newton\u2019s** fluid (ideal viscous) to **James Clerk Maxwell\u2019s** elastic solid, and in doing so, he helped create the science of rheology as we know it. His work evolved from early studies of idealized plastic solids to the elegant Oldroyd-B equation, reflecting a consistent vision: to understand and predict the behavior of materials that are not purely solid nor liquid, but something in between. This vision, shaped by great mentors, wartime experiences, industrial collaboration, and personal insight, makes James G. Oldroyd a towering figure in the history of rheology and fluid mechanics \u2013 one whose influence is still climbing upward, much like the fluid on Weissenberg\u2019s spinning rod. [^1]: I. A. Frigaard, G. H. McKinley, R. J. Poole & K.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Walters, Editorial for...",
    "content": "Walters, Editorial for special issue on \"Oldroyd at 100: Celebrating the impact of JG Oldroyd on non-Newtonian fluid mechanics\", J. Non-Newtonian Fluid Mech., 301, 104749 (2022), [Link](https://nnf.mit.edu/sites/default/files/publications/files/Oldroyd_SI_Editorial_FINAL.pdf). [^2]: James G. Oldroyd \u2013 Wikipedia: [German](https://de.wikipedia.org/wiki/James_G._Oldroyd) and [English](https://en.wikipedia.org/wiki/James_G._Oldroyd). [^3]: R. I. Tanner & K. Walters, Rheology: An Historical Perspective, Elsevier (1998). [Link](https://bit.ly/4bohW0t). [^4]: J. G. Oldroyd, On the formulation of rheological equations of state, Proc. R. Soc. Lond. A, 200:1063, 523-541 (1950) [^5]: J. Hinch & O. Harlen, Oldroyd B, and not A?, J. Non-Newtonian Fluid Mech., 298, 104668 (2021) [link](http://www.damtp.cam.ac.uk/user/hinch/publications/Oldroyd12b.pdf#:~:text=Sack%20%281946%29%20,would%20climb%20the%20rod%2C%20as). [^6]: #TODO needs citation and wikipedia is not it [^7]: J. G.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Oldroyd, The elastic...",
    "content": "Oldroyd, The elastic and viscous properties of emulsions and suspensions, Proc. R. Soc. Lond. A, 218:1132, 122-132 (1953) [^8]: J. G. Oldroyd, Non-Newtonian effects in steady motion of some idealized elastico-viscous liquids, Proc. R. Soc. Lond. A, 245:1241, 278-297 (1958). [^9]: J. G. Oldroyd, The hydrodynamics of materials whose rheological properties are complicated, Rheol. Acta, 1:4, 337-344 (1961) [^10]: J. G. Oldroyd, Equations of state of continuous matter in general relativity, Proc. R. Soc. Lond. A, 316:1524, 1-28 (1970) [^11]: J. G. Oldroyd, An approach to non-Newtonian fluid mechanics, J.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Context",
    "content": "Non-Newtonian Fluid Mech., 14, 9-46 (1984) [^12]: [Former BSR Presidents - British Society of Rheology](https://www.bsr.org.uk/pages/former-bsr-presidents#:~:text=Image%3A%20Photo%20of%20Oldroyd) [^13]: [Oral History Interviews, Kenneth Walters - American Institute of Physics](https://www.aip.org/history-programs/niels-bohr-library/oral-histories/47534#:~:text=match%20at%20L1785%20The%20amazing,Fluid%20Mechanics%2C%E2%80%99%E2%80%99%20Journal%20of%20Non)",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - James G. Oldroyd: Life, Work, and Legacy in Rheology",
    "content": "![Portrait of James G. Oldroyd|1066x24](_Media/James%20G.%20Oldroyd-1741128879880.png) > Portrait and bio sketch of James G. Oldroyd. Slide taken from John Hinch's talk on _Oldroyd B, and not A?_",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#james-g-oldroyd-life-work-and-legacy-in-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Early Life and Education: During this period,...",
    "content": "During this period, he completed his PhD thesis titled _\"A mathematical discussion of some rheological problems,\"_ with guidance and critiques from W. R. Dean (of _Dean flow_ fame) and Alan H. Wilson. Dean and Wilson\u2014both Cambridge-trained mathematicians\u2014significantly influenced Oldroyd's approach to fluid mechanics and solid mechanics. His doctoral work (PhD awarded 1949) established fundamental principles in non-Newtonian fluid mechanics, culminating in his Cambridge Sc.D. in 1958 for his substantial contributions to the field [^1].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#early-life-and-education",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: World War II...",
    "content": "World War II interrupted Oldroyd's academic pursuits but also broadened his experience. From 1942 to 1945 he worked at the Ministry of Supply in Aberporth, Wales, conducting rocket research for Britain's war effort. This foray into applied physics and engineering gave him practical insight into fluid and material behavior under extreme conditions. After the war, Oldroyd transitioned back to research in emerging areas of fluid mechanics. In 1945 he joined the Fundamental Research Laboratory of **Courtaulds** in Maidenhead, a major industrial lab focused on artificial fibers and polymers [^2]. Notably, his former Cambridge tutor, Alan H. Wilson, had also moved to Courtaulds, and likely helped recruit Oldroyd to this innovative environment [^1]. At Courtaulds, Oldroyd worked closely with experimental rheologists **D. J. Strawbridge** and **B. A. Toms**, who were investigating the unusual flow behavior of polymer solutions [^2].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: Examples",
    "content": "These collaborations exposed Oldroyd to cutting-edge rheometry and puzzling phenomena \u2013 for example, B. A. Toms had just discovered the drag reduction effect (later called the _Toms effect_) where tiny polymer additives dramatically lower turbulent friction. Oldroyd became fascinated by such non-Newtonian effects and even suggested early on that _wall slip_ at the pipe boundary might explain Toms's observations [^3]. This period at Courtaulds was formative: it immersed Oldroyd in real-world rheological problems, from the processing of viscose fibers to the oddities of polymer solution flows, inspiring him to seek a deeper theoretical framework for these `elastic` liquids. Oldroyd's first publications in the late 1940s already show him tackling non-Newtonian fluid mechanics with a blend of mathematical rigor and practical insight.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: He initially focused...",
    "content": "He initially focused on _viscoplasticity_, analyzing the flow of **Bingham solids** (materials that behave as a solid until a yield stress is exceeded when they flow). In 1947, while still in Cambridge, he published a series of papers on the _plastic flow of Bingham materials_, developing a `rational formulation` of their equations of flow and solving flow problems between moving cylinders. These early works, drawn from his dissertation, addressed how yield-stress fluids deform, essentially bridging solid plasticity and fluid flow. By 1949, Oldroyd had broadened his scope to other types of non-Newtonian fluids: he examined steady laminar flows in non-Newtonian liquids and noted anomalies like pressure gradients in pipe flow that couldn't be explained by classical viscosity alone. He even proposed experimental methods to detect wall slip and other flow peculiarities at the first International Congress on Rheology in 1948 [^1].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Wartime Work and the Path to Rheology: These experiences convinced...",
    "content": "These experiences convinced Oldroyd that a unifying theoretical description for _complex fluids_ was needed \u2013 one that could encompass the behavior of elastic liquids (polymer solutions), viscous suspensions, and even solids with memory. This realization set the stage for his groundbreaking work in 1950.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#wartime-work-and-the-path-to-rheology",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: In 1950, James...",
    "content": "In 1950, James G. Oldroyd published what is now considered **\"probably the most important single paper in theoretical rheology.\"**[^6] Titled _\"On the Formulation of Rheological Equations of State,\"_[^4] this paper established the basic principles for mathematical models of complex fluids. Oldroyd addressed a fundamental issue: existing viscoelastic models at the time (such as the Jeffreys model) were not _frame-invariant_ \u2013 their predictions could depend on the observer's frame of reference, which is unphysical [^5]. Influenced by earlier work of Sir Harold Jeffreys and by a 1946 study of bitumen by H. Fr\u00f6hlich and R. Sack, Oldroyd recognized that the way one computes the time-derivative of stress in a flowing material is crucial. In essence, he argued that when a material element moves, rotates, and deforms, the rate-of-change of stress must be evaluated in a _convected frame_ moving with the material.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: Definitions",
    "content": "To achieve this, Oldroyd introduced two new definitions of the stress derivative \u2013 the **upper-convected** and **lower-convected** time derivatives \u2013 which account for material rotation and stretching in different ways: > Lower convective Oldroyd derivative: $$ \\stackrel{\\triangle}{A} = \\frac{DA}{Dt} + \\mathbf{A} \\cdot (\\nabla \\mathbf{u})^T + \\nabla \\mathbf{u} \\cdot \\mathbf{A}. $$ > Upper convective Oldroyd derivative: $$ \\stackrel{\\nabla}{A} = \\frac{DA}{Dt} - \\mathbf{A} \\cdot (\\nabla \\mathbf{u})^T - \\nabla \\mathbf{u} \\cdot \\mathbf{A}. $$ Applying these ideas, Oldroyd showed that if one takes the classical _Jeffreys model_ (a combination of an elastic spring and two viscous dashpots) and replaces the ordinary time derivatives with his convected derivatives, one obtains two consistent viscoelastic models [^5].",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: These he called...",
    "content": "These he called \"Model A\" (using the lower-convected derivative) and \"Model B\" (using the upper-convected derivative) \u2013 known today as the **Oldroyd-A and Oldroyd-B models** [^5]. > Oldroyd-A (Lower convected derivative): > $$ \\sigma + \\tau_1 \\stackrel{\\triangle}{\\sigma} = 2\\mu^*(\\mathbf{E} + \\tau_2 \\stackrel{\\triangle}{\\mathbf{E}}),$$ > Oldroyd-B (Upper convected derivative): > $$ \\sigma + \\tau_1 \\stackrel{\\nabla}{\\sigma} = 2\\mu^*(\\mathbf{E} + \\tau_2 \\stackrel{\\nabla}{\\mathbf{E}})$$ Both models reduce to the same behavior in a stationary reference frame, but they differ in how they predict stresses in flows involving rotation or deformation of the fluid parcel. Oldroyd's 1950 paper thus laid down a clear _frame-indifference_ requirement for rheological equations, a cornerstone for modern continuum mechanics of non-Newtonian fluids.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - The 1950 Breakthrough: Formulating Rheological Equations of State: It was a...",
    "content": "It was a bold theoretical leap that immediately gave researchers two possible constitutive equations for viscoelastic liquids. > [!danger] Note: Oldroyd, characteristically cautious, noted that choosing between Model A and B `depends on the physics` of the material, though he offered no immediate criteria for selection [^5]. Nonetheless, the mere formulation of these models has been instructive. It provided, for the first time, a concrete mathematical language to describe fluids with both viscous and elastic characteristics (_viscoelastic_ fluids) in a way that is invariant under changes of frame. This achievement earned Oldroyd international recognition \u2013 including the Gold Medal of the British Society of Rheology and a special issue of the BSR Bulletin honoring his 60th birthday [^6] \u2013 and it set the stage for much of the theoretical rheology that followed.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#the-1950-breakthrough-formulating-rheological-equations-of-state",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg's Rod-Climbing and the Preferred Model: While Oldroyd initially...",
    "content": "While Oldroyd initially presented **Models A and B** as two equally plausible formulations, subsequent insights and experiments soon favored one over the other. In the very same 1950 paper, at the end, Oldroyd himself included a telling calculation: the flow of an elastic liquid around a rotating rod. This was not an arbitrary choice \u2013 it related to a famous experiment by **Karl Weissenberg** a few years earlier. Weissenberg had observed that when a rod is rotated in a polymer solution, the fluid _climbs up_ the rod against gravity (now known as the **Weissenberg effect** or rod-climbing effect) due to the elastic normal stresses generated in the fluid. Oldroyd wanted to see how his two model fluids would behave in this scenario. The result was striking: **Oldroyd-B (upper-convected)** predicted the fluid would climb the rod, matching Weissenberg's observations, whereas **Oldroyd-A (lower-convected)** predicted the opposite \u2013 the fluid would be pushed downwards (a \"rod-dropping\" effect).",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg's Rod-Climbing and the Preferred Model: The latter phenomenon...",
    "content": "The latter phenomenon had never been observed in polymer fluids. Thus, by comparing both models against empirical reality, **Oldroyd-B emerged as the more physically relevant model for polymeric (viscoelastic) fluids**. As Oldroyd and others noted, the _rod-climbing test_ essentially singled out Model B as the correct choice for liquids like dilute polymer solutions. Oldroyd commented that Model B should _\"be favoured\"_ in such cases, aligning with Weissenberg's findings. (Indeed, the inverse \"rod-dipping\" behavior of Model A was only realized decades later in very different materials, such as dense suspensions of particles, confirming Oldroyd's intuition that the choice depends on the material's microphysics.) ![Weissenberg rod-climbing effect](_Media/James%20G.%20Oldroyd-1741126421305.png) > A classic demonstration of the **Weissenberg rod-climbing effect**.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg's Rod-Climbing and the Preferred Model: A rotating rod...",
    "content": "A rotating rod in a viscoelastic polymer solution causes the fluid to climb up along the rod, due to positive normal stress differences. Oldroyd's upper-convected Model B correctly captures this effect, whereas Model A would predict a downward dip, which is not observed in polymer fluids. Figure credits: [Henry Ng and Rob Poole, University of Liverpool](https://fluids.ac.uk/gallery/zoomify/665). Beyond qualitative rod-climbing, more detailed **microstructural studies** in subsequent years reinforced the supremacy of Oldroyd-B for polymeric liquids. In the 1960s, rheologists developed molecular models of polymer solutions \u2013 envisioning long polymer molecules as tiny spring\u2013dashpot elements or \"dumbbells\" dispersed in a solvent.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg's Rod-Climbing and the Preferred Model: When **John Hinch**...",
    "content": "When **John Hinch** and others revisited Oldroyd's models in light of these developments, they found a remarkable connection: the simplest molecular model of a polymer chain in flow (the **elastic dumbbell model**) leads mathematically **directly to the Oldroyd-B constitutive equation** [^5]. In other words, if one treats a polymer molecule as two beads connected by a spring dragged through a viscous solvent, the macroscopic stress evolution follows Oldroyd's upper-convected form (with the polymer's finite relaxation time corresponding to Oldroyd-B's parameters). This result explained why Oldroyd-B captured many polymer solution behaviors so well \u2013 it was essentially _derived from first principles_ of polymer micro-dynamics. Oldroyd-A, in contrast, did not emerge from any analogous physical picture for flexible polymers.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Oldroyd-A vs. Oldroyd-B: Weissenberg's Rod-Climbing and the Preferred Model: By the late...",
    "content": "By the late 20th century, therefore, Oldroyd-B had become the **standard viscoelastic fluid model** for dilute polymer solutions in rheology and computational fluid dynamics, whereas Oldroyd-A largely faded from use. As John Hinch humorously noted, a survey of literature reveals thousands of papers employing \"Oldroyd-B\" in their title or keywords, but only a handful mentioning \"Oldroyd-A\". ![Polymer solution model](https://claude.ai/chat/_Media/James%20G.%20Oldroyd-1741126749363.jpeg) The reason is clear: Oldroyd-B not only passes key experimental tests but also has a firm basis in polymer molecular theory, making it the preferred tool for scientists and engineers modeling viscoelastic flows. The **legacy of Oldroyd's 1950 insight** is thus encapsulated in the ubiquity of the Oldroyd-B model \u2013 a tribute to his ability to capture the essential physics of elastic fluids in a simple equation.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#oldroyd-a-vs-oldroyd-b-weissenbergs-rod-climbing-and-the-preferred-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: After 1950, Oldroyd...",
    "content": "After 1950, Oldroyd continued to build on his framework and ventured into new problems, further cementing his status as a pioneer in rheology. In 1953, he published a notable paper on _\"The elastic and viscous properties of emulsions and suspensions.\"_ [^7] Here, Oldroyd extended his constitutive modeling to **multiphase systems**, showing how a mixture of a liquid with dispersed droplets or particles could exhibit viscoelastic behavior. He demonstrated (for a dilute emulsion of liquid droplets) that the interfacial tension of the droplets provides a restoring force against deformation, effectively giving the emulsion an elastic component [^3]. This work was an early example of **micro-rheology** \u2013 linking microscopic structure to macroscopic rheological properties \u2013 and it illustrated Oldroyd's knack for generalizing his models to diverse materials.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: JavaScript",
    "content": "He also investigated the effect of surfactant films on droplet interfaces in emulsions, recognizing that a stabilizing film could alter the combined fluid's elasticity. These studies by Oldroyd in the 1950s are considered pioneering, as they connected continuum rheology with micro-scale mechanisms in suspensions and emulsions. Oldroyd's theoretical explorations in the mid-1950s also produced insights into what we now call **\"second-order fluids.\"** In a 1958 paper, he analyzed normal stress effects (differences in normal stresses) in steady flows of idealized viscoelastic liquids, using a general invariant formulation that included up to quadratic terms in stresses [^8]. Notably, he examined the conditions for the Weissenberg effect (rod-climbing) to occur \"in a positive or negative sense,\" essentially exploring the parameter space where a fluid would climb or dip around a rod.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: This comprehensive study...",
    "content": "This comprehensive study brought clarity to how **non-Newtonian normal stresses** arise in shear and rotational flows, and it introduced what became known as the **Oldroyd 8-constant model** (a generalized linear viscoelastic model with eight material constants). Such work laid the groundwork for later researchers like Coleman, Noll, and Rivlin, who in the same era were developing the modern continuum mechanics of fluids. Oldroyd's approach was always characterized by careful attention to invariant formulation (he cited the earlier convected-coordinate ideas of F. Hencky and others [^3]) and by a desire to keep models as simple as possible while capturing the essential physics. In 1961, he published a survey in _Rheologica Acta_ on _\"the hydrodynamics of materials whose rheological properties are complicated,\"_ [^9] reflecting on how to extend classical hydrodynamics to fluids with memory and elasticity.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Later Contributions and Evolving Work: Even in his...",
    "content": "Even in his final years, Oldroyd continued to synthesize his lifetime of insights: his last paper, published posthumously in 1984, was titled _\"An approach to non-Newtonian fluid mechanics,\"_[^11] offering a grand overview of the field - a treat to read for our generation.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#later-contributions-and-evolving-work",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Oldroyd's influence extended...",
    "content": "Oldroyd's influence extended beyond his written work; he was also a guiding figure and mentor in the rheology community. In 1953, the same year he took up a professorship, he served as **Treasurer of the 2nd International Congress of Rheology** held in Cambridge [^2] \u2013 a gathering of the world's top rheologists. He later became President of the British Society of Rheology (BSR) from 1955 to 1957, helping to shape the direction of rheological research in the UK [^12]. Oldroyd had moved to academia in 1953 as Professor of Mathematics at the University of Wales, Swansea, where he also headed the Applied Mathematics Department from 1957. In 1965, he was appointed Professor at Liverpool University, eventually becoming Head of the Department of Applied Mathematics and Theoretical Physics there [^2]. In these roles, Oldroyd supervised a small number of doctoral students \u2013 notably **Kenneth Walters**, who completed his PhD under Oldroyd at Swansea.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Walters would go...",
    "content": "Walters would go on to become a prominent rheologist himself (co-founding the _Journal of Non-Newtonian Fluid Mechanics_ in 1976) and later reminisced that although Oldroyd guided only _\"half a dozen\"_ PhD students, his impact on them \u2013 and on the field \u2013 was profound [^13]. Oldroyd's students and colleagues admired his deep physical intuition and his knack for reducing complex problems to their core elements. Amusingly, Walters recalled that Oldroyd was _\"no sportsman,\"_ yet somehow many of his research students were star cricket players \u2013 a coincidence that Oldroyd, with his gentle humor, tolerated even if he didn't share their sporting enthusiasm [^13]. In recognition of his scientific contributions, Oldroyd received numerous honors. Cambridge University awarded him the **Adams Prize in 1964**, one of its highest accolades in mathematics, for his work on the mechanics of non-Newtonian fluids.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: The British Society...",
    "content": "The British Society of Rheology bestowed upon him its **Gold Medal** in 1984 (the year after what would have been Oldroyd's retirement), celebrating a lifetime of achievement in rheology [^2]. Tributes poured in as he reached his 60th birthday in 1981 \u2013 the BSR dedicated a special issue of its bulletin to him, and luminaries like professor R. B. Bird lauded Oldroyd's contributions [^6]. In fact, at the 1988 International Congress on Rheology in Sydney, Bob Bird gave an opening lecture entitled _\"The Two JG's\"_ in honor of **J. G. Oldroyd** and **J. G. Kirkwood** \u2013 comparing Oldroyd, the continuum mechanician, and Kirkwood, the molecular theorist, as two giants who bridged the gap between macroscopic and microscopic understandings of fluid behavior [^1]. This was a testament to how Oldroyd's work, particularly the Oldroyd-B model, had become a cornerstone that linked molecular theory with continuum modeling. Unfortunately, James G.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: Oldroyd's life was...",
    "content": "Oldroyd's life was cut short in 1982 \u2013 he died suddenly of an apparent heart attack while on his way to the university in Liverpool [^2] \u2013 but his legacy endures vibrantly. His name is forever attached to the **Oldroyd-B model**, a staple in rheology textbooks and simulations, and his ideas on convected derivatives underpin all modern viscoelastic fluid theories. In computational fluid dynamics and engineering today, Oldroyd's models are routinely used to simulate polymer processing, biological fluid flows, and complex material behavior, enabling predictions of how materials will respond under flow with both viscous and elastic forces at play. In hindsight, John Hinch and other colleagues note that Oldroyd's genius was in formulating simple yet physically sound models \u2013 _\"the first twelve pages\"_ of his 1950 paper, as Bob Bird once remarked, _contained the seeds of an entire field_.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "James g. oldroyd - Influence on the Rheology Community and Honors: By following a...",
    "content": "By following a historical narrative from classical mechanics to modern rheology, Oldroyd essentially wrote the chapter that connects **Isaac Newton's** fluid (ideal viscous) to **James Clerk Maxwell's** elastic solid, and in doing so, he helped create the science of rheology as we know it. His work evolved from early studies of idealized plastic solids to the elegant Oldroyd-B equation, reflecting a consistent vision: to understand and predict the behavior of materials that are not purely solid nor liquid, but something in between. This vision, shaped by great mentors, wartime experiences, industrial collaboration, and personal insight, makes James G. Oldroyd a towering figure in the history of rheology and fluid mechanics \u2013 one whose influence is still climbing upward, much like the fluid on Weissenberg's spinning rod. [^1]: I. A. Frigaard, G. H. McKinley, R. J. Poole & K.",
    "url": "https://blogs.comphy-lab.org/Blog/James G. Oldroyd/#influence-on-the-rheology-community-and-honors",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - The role of viscosity on drop impact forces on non-wetting surfaces: From Raindrops to Inkjet Printing: When a liquid...",
    "content": "When a liquid drop hits a surface, the impact creates fascinating fluid dynamics that are crucial for applications ranging from inkjet printing to agricultural sprays. In this work, we uncover how a liquid's viscosity dramatically affects the forces generated during these impacts. Let's explore the key findings. ![[_Media/JFM-viscous-drop-impact-blog-1740211822831.png]] > [!tldr] TL;DR > Viscosity alters the forces a liquid drop exerts when it strikes a non-wetting surface, shifting the balance from inertia-dominated (like water) to enhanced viscous effects (like honey). Two force peaks arise: one at the initial impact and another tied to the Worthington jet just before bounce. Dimensionless numbers (Weber and Ohnesorge) govern these regimes, showing why higher-viscosity drops can yield unexpectedly large forces.",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#the-role-of-viscosity-on-drop-impact-forces-on-non-wetting-surfaces-from-raindrops-to-inkjet-printing",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - The role of viscosity on drop impact forces on non-wetting surfaces: From Raindrops to Inkjet Printing: Summary",
    "content": "The findings unify scaling laws across viscosities, guiding applications in printing, agriculture, and beyond, and pointing to future inquiries on soft surfaces and non-Newtonian fluids. > [!summary] Podcast >",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#the-role-of-viscosity-on-drop-impact-forces-on-non-wetting-surfaces-from-raindrops-to-inkjet-printing",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - The Basics: What Happens When a Drop Hits a Surface?",
    "content": "> [!note] Key Point > On a non-wetting surface, a drop goes through distinct phases: impact, spreading, retracting, and sometimes bouncing off. During this process, the surface experiences varying forces that can now be precisely measured and predicted. The impact process reveals two distinct force peaks: 1. An initial peak when the drop first hits 2. A second peak just before the drop potentially bounces off What makes this especially interesting is how these forces change based on two key properties: - Weber number ($We = \\rho V_0^2D_0/\\gamma$): Measures the dimensionless kinetic energy of the impacting drop. - Ohnesorge number ($Oh = \\eta/\\sqrt{\\rho\\gamma D_0}$): Represents the dimensionless viscosity of the impacting drop.",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#the-basics-what-happens-when-a-drop-hits-a-surface",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - The First Impact: A Tale of Two Regimes",
    "content": "> [!important] First Peak Findings > The study reveals that the first impact force follows distinctly different patterns depending on the liquid's viscosity: > - For low viscosity liquids (like water), the force mainly depends on inertia > - For high viscosity liquids (like honey), viscous effects create stronger forces than expected",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#the-first-impact-a-tale-of-two-regimes",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Low Viscosity Behavior",
    "content": "For liquids with low viscosity ($Oh < 0.1$), the first impact force ($F_1$) scales with the inertial force: $$ F_1 \\sim \\rho V_0^2D_0^2 $$ where $\\rho$ is density, $V_0$ is impact velocity, and $D_0$ is drop diameter. This relationship holds remarkably well for viscosities up to 100 times that of water!",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#low-viscosity-behavior",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - High Viscosity Surprises",
    "content": "When viscosity becomes significant ($Oh > 0.1$), the force increases beyond what inertia alone would predict: $$ F_1 \\sim \\rho V_0^2D_0^2\\sqrt{Oh} $$ This enhancement occurs because viscous forces resist the drop's deformation, leading to higher impact pressures.",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#high-viscosity-surprises",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - The Second Peak: Worthington Jets and Bouncing",
    "content": "> [!note] Worthington Jet > The second force peak coincides with a fascinating phenomenon called a Worthington jet - a thin liquid column that can shoot upward just before the drop bounces off. The second peak reveals an intricate balance between different forces: - For low viscosity and high speed impacts: Force scales with inertia - For low speed impacts: Surface tension dominates - At a special condition ($We \\approx 9$, $Oh < 0.01$): A `singular` jet forms with surprisingly high forces ![[_Media/JFM-viscous-drop-impact-blog-1740211923766.png]]",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#the-second-peak-worthington-jets-and-bouncing",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Practical Implications",
    "content": "> [!important] Applications > These findings have direct applications in: > - Inkjet printing: Controlling droplet behavior > - Agricultural sprays: Optimizing pesticide application > - Respiratory disease transmission: Understanding droplet impacts > - Industrial cooling: Enhancing heat transfer through controlled droplet impacts",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#practical-implications",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Future Research Directions",
    "content": "This work opens several interesting avenues for future investigation: - Unifying theories for maximum spread diameter across all viscosities - Understanding impact forces on soft or compliant surfaces - Extending findings to non-Newtonian fluids like polymer solutions",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#future-research-directions",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Technical Significance",
    "content": "> [!note] For the technically inclined > The study provides a comprehensive framework for predicting impact forces through dimensionless numbers and scaling laws. For researchers working in this field, the paper presents new scaling laws that unify previous observations and provide a foundation for future work. The careful experimental validation combined with theoretical analysis makes this a significant contribution to our understanding of drop impact dynamics. > [!faq] Original Paper > V. Sanjay, B. Zhang, C. Lv & D. Lohse, The role of viscosity on drop impact forces, J. Fluid Mech., 1004, A6 (2025) [Open Access](https://doi.org/10.1017/jfm.2024.982).",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#technical-significance",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Cover of J. Fluid Mech. vol 1004",
    "content": "![[_Media/JFM-viscous-drop-impact-blog-1740211513533.jpg]]",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#cover-of-j-fluid-mech-vol-1004",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2025 jfm viscous drop impact - Videos",
    "content": "--- > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Feb 22, 2025 > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab), [Blogs](https://blogs.comphy-lab.org)",
    "url": "https://blogs.comphy-lab.org/Blog/2025-JFM-viscous-drop-impact/#videos",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Features of capillary waves during asymmetric bubble coalescence: > [!tldr] TL;DR...",
    "content": "> [!tldr] TL;DR > During the coalescence of bubbles with different sizes, the **speed** of the ensuing capillary waves remains almost unchanged and scales with the inertio\u2010capillary velocity. However, the strength (or curvature) of these waves depends on the bubble size ratio. In the equal\u2010sized case, the wave curvature diminishes and then plateaus, whereas for highly asymmetric (large vs. tiny) bubbles, the curvature initially decreases but then rebounds sharply due to the changing geometry. Two **approximate** scaling laws emerge for the strongest wave curvature: \ufffc in the low\u2010viscosity limit and \ufffc in the moderate\u2010to\u2010higher viscosity regime. Experimental data diverge somewhat from these simple power laws, indicating a need for refined models to explain the distinct curvature behavior at low Ohnesorge numbers. ![Fig-1_schematic](_Media/20250112214056729_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 1. Schematic of asymmetric coalescence of bubbles.",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#features-of-capillary-waves-during-asymmetric-bubble-coalescence",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Features of capillary waves during asymmetric bubble coalescence: Following the coalescnece,...",
    "content": "Following the coalescnece, train of capillary waves travel on the surface of both bubbles.",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#features-of-capillary-waves-during-asymmetric-bubble-coalescence",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Control parameters",
    "content": "**Ohnesorge number** (ratio of the inertio-capillary and inertio-viscous timescales) $$ Oh = \\frac{\\eta_l}{\\sqrt{\\rho_l\\gamma R_0}} $$ **Asymmetry parameter** (ratio of the radii of the two bubbles) $$ \\chi = \\frac{R}{r} $$",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#control-parameters",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Coalescence of equal sized bubbles ($R = r$)",
    "content": "[Open on YouTube](https://youtu.be/Bm4qC0BSGkc)",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#coalescence-of-equal-sized-bubbles-r-r",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Coalescence of tiny bubbles with extremely large ones ($R \\gg r$)",
    "content": "[Open on YouTube](https://youtu.be/QbQ4wrTjTks)",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#coalescence-of-tiny-bubbles-with-extremely-large-ones-r-gg-r",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Looking at the speed of the capillary waves",
    "content": "> [!important] > The velocity of this capillary waves still scales with the inertio-capillary velocity! ![Fig-2_waveTrajectory](_Media/20250112214130458_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 2. Trajectory of the capillary waves during coalescence of same sized bubbles ($R = r$). Different colors represent different Ohnesorge numbers $Oh$. ![Fig-3_waveSpeed](_Media/20250112214151030_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 3. Trajectory of the capillary waves during coalescence of same unequal sized bubbles with $R \\gg r$. Different colors represent different Ohnesorge numbers $Oh$. > [!note] > Infact the velocity hardly changes from $R = r$ to $R \\gg r$",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#looking-at-the-speed-of-the-capillary-waves",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Strength of capillary waves for $R = r$",
    "content": "Although the speed of capillary waves remain the same. There can be differences in the strength of the waves. ![Fig-4_capillary-waves-Same-sized](_Media/20250112214226072_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 4. The curvature of the strongest capillary wave decreases in time and then saturates to a constant value. This is different from what happens at $R \\gg r$, ![Fig-5_capillary-waves-champagne-bubbles](_Media/20250112214243110_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 5. The curvature of the strongest capillary wave decreases in time, reaches a minima, and then increases sharply as the bubble cavity configuration changes (see video above, and also see [1]).",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#strength-of-capillary-waves-for-r-r",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Can we understand this change in curvature?: Results",
    "content": "Given the asymmetry at $R \\gg r$, the waves have this feature to come back up and the curvature increases whereas for $R = r$ symmetry of the problem results in no significant geometry change following flow focussing and the curvature does not further increase. Looking at the balance between the kinetic energy (generated immediately following the coalescence event), $$ \\frac{d}{d\\tau}\\int_{\\Omega_\\kappa}\\frac{\\rho V^2}{2}d\\Omega_\\kappa \\sim 2\\eta\\int_{\\Omega_\\eta}\\left(\\boldsymbol{\\mathcal{D}:\\mathcal{D}}\\right)d\\Omega_\\eta $$ **Note:** Here, we balance the kinetic energy of the capillary waves (across volume $\\Omega_\\kappa$) with viscous dissipation across the bulk volume $\\Omega_\\eta$ where velocity gradients are non-zero.",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#can-we-understand-this-change-in-curvature",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Can we understand this change in curvature?: Consequently, the volume...",
    "content": "Consequently, the volume scale associated with the kinetic energy carried by the waves is $\\Omega_\\kappa \\sim R\\kappa^{-2}$ and the dissipation volume scales as $\\Omega_\\eta \\sim R\\delta_\\eta^2$ where $\\delta_\\eta$ is the viscous boundary layer attached to the free-surface where velocity gradients are highest (see the videos above, the dark regions in visocus dissipation function characterize $\\Omega_\\eta$ and high velocity regions indicate $\\Omega_\\kappa$) $$ \\frac{1}{\\tau}\\rho V^2 R\\kappa^{-2} \\sim \\eta\\left(\\frac{V}{\\kappa^{-1}}\\right)^2R\\delta^2 $$ Rearranging the above equation, we can find the time scale associated with this transfer process: $$ \\tau \\sim \\frac{\\rho}{\\eta}\\frac{\\kappa^{-4}}{\\delta^2} $$",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#can-we-understand-this-change-in-curvature",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - Rearranging the expression and substituting inertio-capillary timescale",
    "content": "$$ \\kappa^4\\delta^2 \\sim \\frac{\\rho}{\\eta}\\sqrt{\\frac{\\gamma}{\\rho R^3}} $$ Normalize both sides by $R^2$, $$ \\tilde{\\kappa}^4\\tilde{\\delta}^2 \\sim \\frac{\\sqrt{\\rho\\gamma R}}{\\eta} $$",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#rearranging-the-expression-and-substituting-inertio-capillary-timescale",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - In the low viscosity limit,",
    "content": "$\\delta \\sim \\kappa^{-1}$, which giving $$ \\tilde{\\kappa} \\sim Oh^{-1/2} $$",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#in-the-low-viscosity-limit",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - In moderate high viscosity limit,: $$ \\delta \\sim...",
    "content": "$$ \\delta \\sim \\sqrt{\\frac{\\eta}{\\rho}t} = \\sqrt{\\frac{\\eta}{\\rho}\\left(\\frac{\\rho\\kappa^{-3}}{\\gamma}\\right)^{1/2}} $$ **Rearranging the expression and filling in the general equation relating $\\kappa$ and $\\delta$ gives** $$ \\tilde{\\kappa}^{5/2} \\sim \\frac{\\rho\\gamma R}{\\eta^2} $$ or, $$ \\tilde{\\kappa} \\sim Oh^{-4/5} $$ ![Fig-6_curvatureAndOh-R](_Media/20250112214304930_Features-of-capillary-waves-during-asymmetric-bubble-coalescence.png) Figure 6. Minumum curvature of the strongest capillary wave as a function of the Ohnesorge number and the radii ratio of the two bubbles. The two scaling relations developed above are reasonable but the deviations observed in the data leave room for improvement. > [!cite] Note: > The scaling laws developed here are also described in detail in [2] So, why does the radii ratio influence the curvature strongly but not the wave speed? **Unfortunately,** this is still an open question.",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#in-moderate-high-viscosity-limit",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - In moderate high viscosity limit,: The hand-wavy argument...",
    "content": "The hand-wavy argument is given in this document (including the geometric and asymmetry arguments) but the scaling laws developed here only work approximately and clearly the data for $Oh \\to 0$ shows deviation in curvature. #foodForThought",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#in-moderate-high-viscosity-limit",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - More resources: Context",
    "content": "| [GitHub](https://github.com/VatsalSy/Asymmetries-in-coalescence) | [License](https://github.com/VatsalSy/Asymmetries-in-coalescence/blob/main/LICENSE) | [Latest Changes](https://github.com/VatsalSy/Asymmetries-in-coalescence/commits/main) | [[Features-of-capillary-waves-during-asymmetric-bubble-coalescence.pdf\\|pdf]] | | :--------------------------------------------------------------: | :---------------------------------------------------------------------------------: | :-----------------------------------------------------------------------------------: | ----------------------------------------------------------------------------- | [1] V. Sanjay, D. Lohse, and M. Jalaal, \u201cBursting bubble in a viscoplastic medium,\u201d _J. Fluid Mech._, vol. 922, p. A2, 2021. [2] J. M. Gordillo and J. Rodr\u00edguez-Rodr\u00edguez, \u201cCapillary waves control the ejection of bubble bursting jets,\u201d _J.",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#more-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Features of capillary waves during asymmetric bubble coalescence - More resources: Context",
    "content": "Fluid Mech._, vol. 867, pp. 556\u2013571, May 2019, doi: [10.1017/jfm.2019.161](https://doi.org/10.1017/jfm.2019.161). > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 12, 2025 > Date modified:: Jan 26, 2025 at 11:50 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Blog/Features-of-capillary-waves-during-asymmetric-bubble-coalescence/#more-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Computational Multiphase Flows with Basilisk: From Champagne Bubbles to Drop Impact",
    "content": "> [!tldr] TL;DR > This tutorial explores computational approaches to multiphase flow phenomena using Basilisk's axisymmetric framework. We examine five progressively complex simulations: bubble bursting, drop impact on pools, drop impact on solid surfaces, liquid lens equilibrium, and heated drop impact. Each simulation incorporates different physical aspects \u2013 surface tension, inertia, viscosity, thermal effects \u2013 characterized by dimensionless parameters including Ohnesorge, Bond, Weber, and Froude numbers. Through these simulations, we develop practical skills in handling complex interfaces, implementing boundary conditions, and visualizing flow features using adaptive mesh refinement techniques specifically designed for multiphase problems.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#computational-multiphase-flows-with-basilisk-from-champagne-bubbles-to-drop-impact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Introduction: In this tutorial,...",
    "content": "In this tutorial, we explore multiphase flow phenomena through computational simulations using the Basilisk framework. Multiphase flows \u2013 involving interactions between different fluids or phases \u2013 represent some of the most complex and visually striking phenomena in fluid dynamics. From bursting bubbles in champagne to raindrops impacting puddles, these phenomena are ubiquitous in both natural processes and industrial applications.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Introduction: Building on our...",
    "content": "Building on our previous work with heat conduction ([[1st-workingAssignment]]) and single-phase flows ([[2nd-workingAssignment]]), we now tackle the additional complexity introduced by fluid interfaces, surface tension, and multiple interacting phases. > [!info] Learning Objectives > - Implement and analyze axisymmetric multiphase flow simulations > - Understand key dimensionless parameters governing multiphase dynamics > - Develop skills in handling complex interfaces and boundary conditions > - Visualize and interpret dynamic interface evolution > - Apply adaptive mesh refinement strategies for multiphase problems > - Extend simulations to incorporate thermal effects Throughout this tutorial, we'll progress through five core simulation cases: 1. Bubble bursting at a free surface 2. Drop impact on a liquid pool 3. Drop impact on a solid surface 4. Equilibrium of liquid lenses 5.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Introduction: Heated drop impact...",
    "content": "Heated drop impact on a solid surface Each case introduces new physical aspects and numerical challenges, providing a comprehensive overview of computational multiphase fluid dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.1 Drop Impact on a Liquid Pool (3-DropImpactOnPool.c): When a liquid...",
    "content": "When a liquid drop impacts a pool of the same liquid, complex dynamics unfold including crater formation, capillary wave propagation, crown formation, and potential splashing or bubble entrapment. > [!tldr] Problem Statement > Simulate the axisymmetric impact of a liquid drop onto a pool of the same liquid. Key dimensionless parameters include: > > - **Froude number (Fr)**: $\\text{Fr} = \\frac{U^2}{gD}$ Ratio of inertial to gravitational forces > > - **Galilei number (Ga)**: $\\text{Ga} = \\frac{\\rho g D^3}{\\mu^2}$ Ratio of gravitational to viscous forces > > - **Bond number (Bo)**: $\\text{Bo} = \\frac{\\rho g D^2}{\\sigma}$ Ratio of gravitational to surface tension forces > > > Where $U$ is impact velocity, $D$ is drop diameter, $g$ is gravity, $\\mu$ is viscosity, $\\rho$ is density, and $\\sigma$ is surface tension.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#11-drop-impact-on-a-liquid-pool-3-dropimpactonpoolc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.1 Drop Impact on a Liquid Pool (3-DropImpactOnPool.c): C/C++ Code",
    "content": "The implementation includes several advanced techniques: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // NS solver with centered discretization #define FILTERED 1 // Enable filtered VOF for stability #include \"two-phase.h\" // Two-phase flow solver #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension forces #include \"reduced.h\" // Reduced gravity formulation ``` A key feature of this simulation is the use of a tracer field to track the drop liquid even after it merges with the pool: ```c scalar tagDrop[]; // Tracer to identify the drop liquid event init(t = 0) { if (!restore(file = \"dump\")){ // Initialize the fluid configuration: // - Combined shape of drop and pool using union of: // - Drop: circle centered at (Hint,0) with radius 1 // - Pool: half-plane where x [!note] Reduced Gravity Formulation > The simulation uses the \"reduced.h\" module, which implements a more efficient approach to handling pressure in the presence of gravity.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#11-drop-impact-on-a-liquid-pool-3-dropimpactonpoolc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.1 Drop Impact on a Liquid Pool (3-DropImpactOnPool.c): Instead of solving...",
    "content": "Instead of solving for the total pressure, it solves for the reduced pressure: $p' = p - \\rho g z$. This approach provides better numerical stability for low-Froude-number flows.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#11-drop-impact-on-a-liquid-pool-3-dropimpactonpoolc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.2 Drop Impact on Solid Surfaces (3-DropImpactOnSolids.c): Drop impact on...",
    "content": "Drop impact on solid surfaces exhibits different dynamics compared to pool impact, with spreading, possible rebound, and various splashing behaviors depending on the parameters. > [!tldr] Problem Statement > Simulate the axisymmetric impact of a liquid drop on a solid surface.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#12-drop-impact-on-solid-surfaces-3-dropimpactonsolidsc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.2 Drop Impact on Solid Surfaces (3-DropImpactOnSolids.c): Key dimensionless parameters...",
    "content": "Key dimensionless parameters include: > > - **Weber number (We)**: $\\text{We} = \\frac{\\rho U^2 D}{\\sigma}$ Ratio of inertial to surface tension forces > > - **Ohnesorge number (Oh)**: $\\text{Oh} = \\frac{\\mu}{\\sqrt{\\rho \\sigma D}}$ Ratio of viscous forces to inertial and surface tension forces > > - **Bond number (Bo)**: $\\text{Bo} = \\frac{\\rho g D^2}{\\sigma}$ Ratio of gravitational to surface tension forces > The boundary conditions for the solid wall are implemented as: ```c // Left boundary: solid wall (no-slip and no flux) u.t[left] = dirichlet(0.0); // Tangential velocity = 0 (no-slip) f[left] = dirichlet(0.0); // Volume fraction = 0 (solid wall) // Right boundary: outflow condition u.n[right] = neumann(0.); // Zero gradient for normal velocity p[right] = dirichlet(0.0); // Reference pressure = 0 ``` The drop is initialized with a downward velocity and positioned slightly above the wall: ```c event init(t = 0){ if(!restore(file = \"dump\")){ // Refine mesh near the drop interface refine((R2Drop(x,y) [!important] Dissipation-Based Refinement > This simulation includes an advanced refinement criterion based on the local dissipation rate: > > ```c > foreach(){ > // Calculate velocity gradient components in cylindrical coordinates > double D11 = (u.y[0,1] - u.y[0,-1])/(2*Delta); > double D22 = (u.y[]/max(y,1e-20)); > double D33 = (u.x[1,0] - u.x[-1,0])/(2*Delta); > double D13 = 0.5*((u.y[1,0] - u.y[-1,0] + u.x[0,1] - u.x[0,-1])/(2*Delta)); > > // Calculate dissipation rate (sum of squares of strain rates) > double D2 = (sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13)); > D2c[] = f[]*D2; // Dissipation rate in the drop phase > } > ``` > > This ensures that regions with high energy dissipation (typically near the spreading front and stagnation point) are well-resolved.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#12-drop-impact-on-solid-surfaces-3-dropimpactonsolidsc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.3 Heated Drop Impact (3-HeatedDropImpact.c): This advanced simulation...",
    "content": "This advanced simulation extends the drop impact problem to include thermal effects, modeling the heat transfer that occurs when a cold drop impacts a heated surface. > [!tldr] Problem Statement > Simulate the thermal-fluid dynamics of a cold liquid drop impacting a heated solid surface.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#13-heated-drop-impact-3-heateddropimpactc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 1.3 Heated Drop Impact (3-HeatedDropImpact.c): In addition to...",
    "content": "In addition to the mechanical parameters (We, Oh, Bo), the simulation includes thermal parameters: > > - Prandtl number (Pr = \u03bd/\u03b1): Ratio of momentum diffusivity to thermal diffusivity > - Thermal diffusivity ratio (D1/D2): Ratio of thermal diffusivities between the phases The simulation solves both the Navier-Stokes equations and the heat transfer equation: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // NS solver with centered discretization #define FILTERED // Use filtered VOF advection #include \"two-phase-thermal.h\" // Two-phase flow with heat transfer #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension model #include \"reduced.h\" // Reduced gravity approach ``` The thermal boundary conditions specify a constant heat flux from the hot substrate to the cold drop: ```c // Thermal boundary condition: constant heat flux from the hot substrate T[left] = neumann(10.0); // Fixed positive temperature gradient (heating the cold drop) ``` Physical properties include thermal diffusivity for both phases: ```c // Drop phase (1) properties rho1 = 1.0; // Density of drop (reference value) mu1 = Ohd/sqrt(We); // Viscosity derived from Ohnesorge number D1 = 1.0; // Thermal diffusivity of drop (reference value) // Surrounding phase (2) properties rho2 = Rho21; // Density ratio (air/water) mu2 = Ohs/sqrt(We); // Viscosity derived from Ohnesorge number D2 = 1e-3; // Thermal diffusivity ratio (air/water ~ 10^-3) ``` > [!note] Thermal Gradients and Adaptive Refinement The adaptive mesh refinement criteria now include temperature gradients alongside interface position, curvature, and velocity gradients: > > ```c > adapt_wavelet((scalar *){f, KAPPA, u.x, u.y, D2c, T}, > (double[]){fErr, KErr, VelErr, VelErr, DissErr, TErr}, > MAXlevel, MINlevel); > ``` > > This ensures that thermal boundary layers and temperature gradients are properly resolved.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#13-heated-drop-impact-3-heateddropimpactc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 2.2 Physical Background",
    "content": "When a bubble reaches a free surface, a thin film separates it from the surrounding atmosphere. This film eventually ruptures, leading to capillary waves traveling along the interface, followed by the collapse of the cavity and potentially the ejection of droplets. This phenomenon is relevant to numerous natural and industrial processes: - Aerosol production from ocean waves - Champagne bubbles and carbonated beverages - Volcanic eruptions - Industrial foaming processes > [!note] Key Physical Parameters Two dimensionless numbers primarily govern bubble bursting dynamics: > > - **Ohnesorge number (Oh)**: $\\text{Oh} = \\frac{\\mu}{\\sqrt{\\rho \\sigma R}}$ Relates viscous forces to inertial and surface tension forces > > - **Bond number (Bo)**: $\\text{Bo} = \\frac{\\rho g R^2}{\\sigma}$ Relates gravitational forces to surface tension forces > > > Where $\\mu$ is viscosity, $\\rho$ is density, $\\sigma$ is surface tension, $R$ is bubble radius, and $g$ is gravitational acceleration.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#22-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 2.2 Implementing Bubble Bursting (3-BurstingBubbles.c): C/C++ Code",
    "content": "The simulation uses Basilisk's axisymmetric framework to model the bursting process: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // NS solver with centered discretization #define FILTERED // Smear density and viscosity jumps for stability #include \"two-phase.h\" // Two-phase flow solver #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension forces ``` The bubble is initially defined using a pre-calculated equilibrium shape (based on the Bond number) that balances surface tension and gravitational forces: ```c event init (t = 0) { if (!restore (file = dumpFile)){ // Read initial shape from data file char filename[60]; sprintf(filename,\"Bo%5.4f.dat\",Bond); FILE * fp = fopen(filename,\"rb\"); // Generate distance field from shape coordinates coord* InitialShape; InitialShape = input_xy(fp); fclose (fp); scalar d[]; distance (d, InitialShape); // Refine mesh around interface while (adapt_wavelet ((scalar *){f, d}, (double[]){1e-8, 1e-8}, MAXlevel).nf); // Convert distance field to volume fraction vertex scalar phi[]; foreach_vertex(){ phi[] = -(d[] + d[-1] + d[0,-1] + d[-1,-1])/4.; } fractions (phi, f); } } ``` > [!important] Adaptive Mesh Refinement The simulation uses multiple criteria for mesh refinement to accurately resolve the interface dynamics: > > ```c > event adapt(i++){ > // Calculate interface curvature for refinement criterion > scalar KAPPA[]; > curvature(f, KAPPA); > > // Refine mesh based on multiple criteria > adapt_wavelet ((scalar *){f, u.x, u.y, KAPPA}, > (double[]){fErr, VelErr, VelErr, KErr}, > MAXlevel, MAXlevel-6); > } > ``` > > This adaptive approach concentrates computational resources where they're needed most: at the interface, in regions of high curvature, and in areas with significant velocity gradients.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#22-implementing-bubble-bursting-3-burstingbubblesc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 2.2 Implementing Bubble Bursting (3-BurstingBubbles.c): The simulation tracks...",
    "content": "The simulation tracks the kinetic energy to monitor the dynamics and determine when the system has reached a quasi-steady state: ```c event logWriting (i++) { // Calculate total kinetic energy (with axisymmetric integration) double ke = 0.; foreach (reduction(+:ke)){ ke += (2*pi*y)*(0.5*rho(f[])*(sq(u.x[]) + sq(u.y[])))*sq(Delta); } // Output to log and check for convergence/divergence fprintf (ferr, \"%d %g %g %g\\n\", i, dt, t, ke); // Check for energy explosion (instability) if (ke > 1e2 && i > 1e1){ fprintf(ferr, \"The kinetic energy blew up. Stopping simulation\\n\"); return 1; } // Check for near-static conditions (completion) if (ke 1e1){ fprintf(ferr, \"kinetic energy too small now! Stopping!\\n\"); return 1; } } ```",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#22-implementing-bubble-bursting-3-burstingbubblesc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 2.3 Expected Results",
    "content": "For low Ohnesorge numbers (low viscosity), we expect to see: 1. Rapid retraction of the film after rupture 2. Capillary waves traveling along the interface 3. Formation of a central jet (Worthington jet) 4. Possible pinch-off of droplets from the jet For higher Ohnesorge numbers (higher viscosity), viscous damping suppresses these features, resulting in a more gradual collapse of the cavity.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#23-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 3.1 Three-Phase Systems (3-EquilibriumOfLiquidLenses.c): A liquid lens...",
    "content": "A liquid lens forms when a drop of one liquid sits at the interface between another liquid and a gas. The equilibrium shape is determined by the balance of surface tension forces at the three-phase contact line. > [!tldr] Problem Statement S > imulate the equilibrium shape of a liquid lens at the interface between two immiscible fluids. The system consists of three phases: > > 1. Dispersed phase (labeled as phase 1) > 2. Water drop (labeled as phase 2) > 3. Air (labeled as phase 3) > > Surface tension coefficients between the three pairs of phases determine the equilibrium contact angles according to the Neumann triangle condition.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#31-three-phase-systems-3-equilibriumofliquidlensesc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 3.1 Three-Phase Systems (3-EquilibriumOfLiquidLenses.c): C/C++ Code",
    "content": "This simulation uses Basilisk's three-phase flow solver: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // Centered finite-volume Navier-Stokes solver #define FILTERED // Enable property filtering for stability #include \"three-phase.h\" // Three-phase interface tracking #include \"tension.h\" // Surface tension model ``` Surface tension coefficients are defined between each pair of phases: ```c // Set surface tension coefficients between phase pairs f1.sigma = 1.0; // Surface tension: dispersed phase-air (\u03c3\u2081\u2083, reference value) f2.sigma = 52/16; // Surface tension: dispersed phase-water drop (\u03c3\u2081\u2082 \u2248 3.25) // Note: The effective surface tension between water and air (\u03c3\u2082\u2083) will be: // \u03c3\u2082\u2083 = \u03c3\u2081\u2083 + \u03c3\u2081\u2082 = 1.0 + 52/16 = 4.25 // This satisfies the ideal precursor film assumption (Neumann triangle) ``` The initial configuration puts a water drop slightly below the interface between the dispersed phase and air: ```c event init(t = 0){ if(!restore (file = \"dump\")){ // Refine mesh around the water drop for better resolution refine(sq(x+1.025) + sq(y) 0 is air fraction(f1, -x); // Update the boundary conditions boundary ((scalar *){f1, f2}); } } ``` > [!important] Neumann Triangle and Contact Angles The equilibrium contact angles at the three-phase junction are determined by the balance of surface tension forces, known as the Neumann triangle condition: > > $$\\frac{\\sigma_{12}}{\\sin\\theta_3} = \\frac{\\sigma_{23}}{\\sin\\theta_1} = \\frac{\\sigma_{13}}{\\sin\\theta_2}$$ > > Where $\\sigma_{ij}$ is the surface tension between phases $i$ and $j$, and $\\theta_k$ is the angle in phase $k$. > > In this simulation, we've set $\\sigma_{13} = 1.0$ and $\\sigma_{12} = 3.25$, resulting in specific equilibrium contact angles at the three-phase junction.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#31-three-phase-systems-3-equilibriumofliquidlensesc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Part 4: Exercises and Extensions",
    "content": "Now that we've explored the fundamentals of these multiphase flow simulations, let's develop your skills further with some practical exercises.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#part-4-exercises-and-extensions",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 4.1 Bubble Bursting Exercise",
    "content": "> [!task] Exercise: Investigating Ohnesorge Number Effects > > Modify the bubble bursting simulation to explore different Ohnesorge numbers: > > 1. Run simulations with Oh = 1e-3, 1e-2, and 1e-1, keeping Bo constant > 2. Track and compare the following: > - Maximum jet height > - Time to first droplet pinch-off (if it occurs) > - Maximum kinetic energy during the process > 3. Create plots showing these metrics as functions of Oh > 4. Explain the physical mechanisms behind the observed trends > > This exercise will help you understand how viscosity affects capillary-inertial dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#41-bubble-bursting-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 4.2 Drop Impact Exercise",
    "content": "> [!task] Exercise: Comparing Pool and Solid Surface Impact > > Conduct a comparative study between drop impact on a pool and on a solid surface: > > 1. Set up equivalent simulations for both scenarios: > - Use the same Weber number and Ohnesorge number > - Match other parameters (domain size, resolution, etc.) > 2. Track and compare the following: > - Maximum spread diameter > - Crater depth (for pool impact) > - Energy dissipation rate > 3. Visualize the differences in flow patterns using streamlines or velocity magnitude contours > 4. Explain why the outcomes differ based on the underlying physics > > Hint: Pay special attention to the boundary conditions and how they affect momentum transfer.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#42-drop-impact-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - 4.3 Advanced Exercise: Thermal Effects",
    "content": "> [!task] Exercise: Temperature-Dependent Surface Tension > > Modify the heated drop impact simulation to include temperature-dependent surface tension: > > 1. Implement the linear relationship: $\\sigma(T) = \\sigma_0(1 - \\gamma(T - T_0))$ > - $\\sigma_0$ is the reference surface tension at temperature $T_0$ > - $\\gamma$ is the temperature coefficient (typically positive) > 2. Run simulations with $\\gamma = 0$ (constant surface tension) and $\\gamma = 0.01$ (temperature-dependent) > 3. Analyze how Marangoni effects (surface tension gradients) affect the spreading dynamics > 4. Visualize temperature and velocity fields to identify regions where thermal effects are most significant > > This extension introduces thermocapillary phenomena, which are important in many industrial processes.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#43-advanced-exercise-thermal-effects",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Part 5: Implementation Tips and Best Practices: Based on our...",
    "content": "Based on our exploration of these multiphase simulations, here are some key insights and best practices: > [!tip] Multiphase Simulation Tips > > 1. **Interface resolution**: Always ensure sufficient resolution near interfaces, especially in regions of high curvature. The `adapt_wavelet()` function with appropriate error thresholds is crucial. > > 2. **Numerical stability**: For high-density and viscosity ratios (typical in air-water systems), use: > > - The `FILTERED` option to smooth property jumps > - The `navier-stokes/conserving.h` module for better momentum conservation > - Appropriate timestep limitations (CFL 3. **Boundary conditions**: Pay careful attention to boundary conditions, especially for solid surfaces. Use `dirichlet()` and `neumann()` appropriately. > > 4. **Initial conditions**: Start with a well-resolved and physically reasonable initial condition.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#part-5-implementation-tips-and-best-practices",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Part 5: Implementation Tips and Best Practices: For drop impact,...",
    "content": "For drop impact, position the drop slightly above the surface. > > 5. **Convergence monitoring**: Track relevant physical quantities (kinetic energy, interface position) to determine when the simulation has reached a quasi-steady state. > > 6. **Parameter sensitivity**: Multiphase flows can be sensitive to small parameter changes. Conduct parameter sweeps to understand the system behavior. > > [!important] Dimensionless Parameters > > Understanding the key dimensionless parameters is essential for characterizing multiphase flows: > > - **Weber number (We)**: Inertia vs. surface tension > - **Ohnesorge number (Oh)**: Viscosity vs. inertia and surface tension > - **Bond number (Bo)**: Gravity vs. surface tension > - **Froude number (Fr)**: Inertia vs. gravity > - **Capillary number (Ca)**: Viscosity vs. surface tension > > These parameters form a framework for classifying and predicting multiphase flow behavior across different scales and fluid properties.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#part-5-implementation-tips-and-best-practices",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Conclusion: In this tutorial,...",
    "content": "In this tutorial, we've explored a range of fascinating multiphase flow phenomena through computational simulations using Basilisk. From bubble bursting to heated drop impact, these simulations capture complex interfacial dynamics that would be challenging to study experimentally. Key insights from our exploration include: 1. The importance of surface tension in driving capillary-inertial phenomena 2. The role of viscosity in damping interfacial oscillations and jet formation 3. The complex interplay between solid boundaries and fluid interfaces 4. The additional complexity introduced by thermal effects 5.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Conclusion: Methods",
    "content": "The power of adaptive mesh refinement in efficiently resolving multiscale features These multiphase flow simulations demonstrate the capability of modern computational methods to capture complex physics with remarkable detail, providing insights into phenomena that occur too quickly or at scales too small for easy experimental observation. > [!question] Further Exploration > > Consider these questions for deeper investigation: > > 1. How would adding surfactants affect bubble bursting or drop impact dynamics? > 2. What happens when the drop and pool liquids have different properties (e.g., immiscible liquids)? > 3. How do contact angle effects influence drop impact on solid surfaces? > 4. What role does the ambient gas play in drop impact phenomena? > 5.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "3rd workingassignment - Conclusion: How would phase...",
    "content": "How would phase change (evaporation or solidification) alter these dynamics? > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com/) > Date published:: March 12, 2025 > Date modified:: March 12, 2025 at 09:30 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - Advantages of Basilisk Over Vanilla C for Computational Fluid Dynamics",
    "content": "After examining the implementation of heat conduction problems in both vanilla C and Basilisk, several significant advantages of using Basilisk become apparent. This document outlines these benefits to help new users understand why Basilisk is a powerful tool for computational fluid dynamics (CFD) simulations.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#advantages-of-basilisk-over-vanilla-c-for-computational-fluid-dynamics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 1. Simplified Domain and Grid Management",
    "content": "**Vanilla C:** - Requires manual definition of grid points, cell spacings, and domain extents - Needs explicit calculation of physical coordinates for each point - Requires manual array allocation and deallocation **Basilisk:** - Simple declaration of domain parameters (`L0`, `X0`, `N`) - Automatic grid generation and management - No need for explicit memory allocation/deallocation for grid points",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#1-simplified-domain-and-grid-management",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 2. Declarative Boundary Conditions",
    "content": "**Vanilla C:** - Requires explicit functions to apply boundary conditions - Boundary conditions must be repeatedly applied during solution - Error-prone due to manual indexing **Basilisk:** - Declarative boundary conditions using a simple, intuitive syntax: ```c T[left] = dirichlet(0.0); T[right] = dirichlet(1.0); ``` - Applied automatically during computation",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#2-declarative-boundary-conditions",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 3. Event-Based Programming Model",
    "content": "**Vanilla C:** - Procedural, sequential code execution - Complex control flow for time-stepping, initialization, and output - Difficult to separate logical components **Basilisk:** - Event-based programming model that separates concerns: - `event init` for initialization - `event integration/marching` for time stepping - `event end` for final output - Events can be scheduled to occur at specific times or intervals - Cleaner, more modular code structure",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#3-event-based-programming-model",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 4. Automatic Time Step Management",
    "content": "**Vanilla C:** - Manual implementation of time step calculations - Explicit checks to ensure numerical stability (CFL condition) - Manual logic to hit specific output times exactly **Basilisk:** - Automatic time step management with `dtnext(DT)` - Built-in tools for maintaining numerical stability - Events can be scheduled at specific times with `t += tsnap`",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#4-automatic-time-step-management",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 5. Stencil Operations and Spatial Discretization",
    "content": "**Vanilla C:** - Explicit array indexing for neighbor access - Manual implementation of finite difference/volume stencils - Error-prone due to index arithmetic **Basilisk:** - Intuitive stencil notation: `T[1]`, `T[-1]` for neighbors - `foreach()` iterator for grid traversal without manual indexing - Automatic handling of boundary conditions during stencil operations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#5-stencil-operations-and-spatial-discretization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 6. Reduced Boilerplate Code",
    "content": "**Vanilla C:** - Lengthy implementations even for simple problems - Requires explicit implementations of utility functions - Verbose memory management **Basilisk:** - Significantly shorter code for equivalent functionality - Built-in functions for common operations - Less cognitive load due to reduced complexity",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#6-reduced-boilerplate-code",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 7. Scalar Field Declaration and Management",
    "content": "**Vanilla C:** - Manual array allocation for each field - Explicit memory management to prevent leaks - No standard methods for field operations **Basilisk:** - Simple scalar field declaration: `scalar T[]` - Automatic memory management - Built-in methods for field operations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#7-scalar-field-declaration-and-management",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 8. Flux Computation and Conservative Formulation",
    "content": "**Vanilla C:** - Manual flux computation at interfaces - Error-prone implementation of conservation laws - Complex indexing for interface values **Basilisk:** - Simplified flux computation with stencil notation - Natural expression of conservation laws - Automatic handling of flux boundary conditions",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#8-flux-computation-and-conservative-formulation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - 9. Extensibility and Library Integration",
    "content": "**Vanilla C:** - Limited reusability of code components - Need to reimplement common algorithms - Difficult to extend to more complex problems **Basilisk:** - Modular design allows easy extension - Rich library of pre-implemented physics modules - Natural pathway to more complex simulations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#9-extensibility-and-library-integration",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1 conduction takeaways - Conclusion",
    "content": "The Basilisk computational environment provides significant advantages over vanilla C for fluid dynamics simulations. By abstracting away the implementation details of grid management, boundary conditions, and numerical methods, Basilisk allows researchers and engineers to focus on the physics of their problems rather than the computational details. This leads to more readable, maintainable, and correct code with significantly less development effort. The comparison of the heat conduction examples shows that equivalent problems can be solved with much less code in Basilisk, while simultaneously providing a more intuitive and robust framework for extending to more complex physical phenomena.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1-conduction-takeaways/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - Think before you compute",
    "content": "- Conservation laws and the numerical solution of the Navier\u2013Stokes equations - Transport equations - *Brief intro to Basilisk coding framework*",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#think-before-you-compute",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - First coding steps",
    "content": "- Implementing basic transport equations in Basilisk C. - Using headers in Basilisk, modular code structure, problem setup, and compilation - [1st Working Assignment](1st-workingAssignment)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#first-coding-steps",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - Next coding steps",
    "content": "- Solving Navier\u2013Stokes equations in Basilisk C: [2nd Working Assignment](2nd-workingAssignment.md)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#next-coding-steps",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - Interface Dynamics",
    "content": "- Interface tracking methods (VoF, level set, phase-field approaches) and numerical strategies - Hands-on tutorial with interface-tracking to a simple two-phase problem: [3rd Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/3rd-workingAssignment)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#interface-dynamics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - Non-Newtonian flows",
    "content": "- Non-Newtonian flows: viscoelasticity. - Coding exercises for viscoelastic fluids: [4th Working Assignment](https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#non-newtonian-flows",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "0 readme - Special topics",
    "content": "- Three-phase flows. - Holey Sheets. - Contact line dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/0-README/#special-topics",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Non-Newtonian flows with Basilisk",
    "content": "> [!tldr] TL;DR > This assignment explores computational approaches to viscoelastic fluid dynamics using Basilisk. We investigate four advanced multiphase flow phenomena involving complex rheology: bursting bubbles in polymer solutions, viscoplastic drop impact, soft material impacts, and Taylor-Culick retraction of viscoelastic filaments. Each simulation incorporates non-Newtonian behavior characterized by dimensionless parameters including Weissenberg, Deborah, Ohnesorge, and elasto-capillary numbers. Through these simulations, we develop practical skills in implementing log-conformation formulations for numerical stability, handling complex interfaces with adaptive mesh refinement, and visualizing rheologically complex flows. This assignment represents the culmination of our computational fluid dynamics progression, building on earlier work with heat conduction, single-phase flows, and simple multiphase systems.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#non-newtonian-flows-with-basilisk",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Introduction: In this final...",
    "content": "In this final assignment, we explore the fascinating world of viscoelastic fluid dynamics using computational simulations. Viscoelastic materials\u2014from polymer solutions to biological fluids, food products, and advanced materials\u2014exhibit both viscous (fluid-like) and elastic (solid-like) properties, leading to complex and often counterintuitive behaviors. Understanding these behaviors is crucial for applications ranging from inkjet printing and food processing to biological systems and advanced manufacturing. Building on our previous work with heat conduction ([[1st-workingAssignment]]), single-phase flows ([[2nd-workingAssignment]]), and simple multiphase flows ([[3rd-workingAssignment]]), we now tackle the additional complexity introduced by non-Newtonian rheology, viscoelasticity, and viscoplasticity.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Introduction: These phenomena represent...",
    "content": "These phenomena represent some of the most challenging aspects of computational fluid dynamics, requiring specialized numerical techniques for stable and accurate simulations. > [!info] Learning Objectives > > - Understand key mathematical models for viscoelastic and viscoplastic fluid behavior > - Implement log-conformation formulations for numerical stability in viscoelastic simulations > - Analyze how elasticity affects interfacial dynamics in multiphase flows > - Apply adaptive mesh refinement strategies to resolve complex interface evolution > - Develop skills in visualizing and interpreting non-Newtonian flow phenomena > - Relate dimensionless parameters to physical behaviors in complex fluids Throughout this assignment, we'll explore four complex multiphase flow simulations: 1. Bursting bubbles in viscoelastic media 2. Viscoplastic drop impact on a solid surface 3. Soft impact dynamics with viscoelastic fluids 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Introduction: Taylor-Culick retraction of...",
    "content": "Taylor-Culick retraction of viscoelastic filaments Each case presents unique physical phenomena and numerical challenges, providing a comprehensive overview of computational approaches to viscoelastic fluid dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 1: Viscoelastic Fluid Fundamentals",
    "content": "Before diving into specific simulations, let's establish the mathematical framework for understanding viscoelastic fluid behavior.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-1-viscoelastic-fluid-fundamentals",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 1.1 Constitutive Equations for Complex Fluids: Traditional Newtonian fluids...",
    "content": "Traditional Newtonian fluids are characterized by a linear relationship between stress and strain rate, governed by a constant viscosity: $$\\boldsymbol{\\tau} = \\mu \\dot{\\boldsymbol{\\gamma}}$$ where $\\boldsymbol{\\tau}$ is the stress tensor, $\\mu$ is the viscosity, and $\\dot{\\boldsymbol{\\gamma}}$ is the strain rate tensor. For non-Newtonian fluids, this relationship becomes more complex: 1. **Viscoplastic fluids (e.g., Bingham plastics, Herschel-Bulkley fluids)** exhibit a yield stress $\\tau_y$ that must be exceeded before flow occurs: $$\\boldsymbol{\\tau} = \\begin{cases} \\tau_{y}\\frac{\\dot{\\boldsymbol{\\gamma}}}{|\\dot{\\boldsymbol{\\gamma}}|} + K|\\dot{\\boldsymbol{\\gamma}}|^{n-1}\\dot{\\boldsymbol{\\gamma}}, & \\text{if } |\\boldsymbol{\\tau}| > \\tau_y \\ \\dot{\\boldsymbol{\\gamma}} = 0, & \\text{if } |\\boldsymbol{\\tau}| \\leq \\tau_y \\end{cases} $$ 2. **Viscoelastic fluids** exhibit memory effects, with stress depending on the deformation history.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#11-constitutive-equations-for-complex-fluids",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 1.1 Constitutive Equations for Complex Fluids: A common model...",
    "content": "A common model is the Oldroyd-B model: $$\\boldsymbol{\\tau} + \\lambda \\overset{\\nabla}{\\boldsymbol{\\tau}} = \\mu \\left( \\dot{\\boldsymbol{\\gamma}} + \\lambda_r \\overset{\\nabla}{\\dot{\\boldsymbol{\\gamma}}} \\right)$$ where $\\lambda$ is the relaxation time, $\\lambda_r$ is the retardation time, and $\\overset{\\nabla}{\\boldsymbol{\\tau}}$ denotes the upper-convected derivative of the stress tensor.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#11-constitutive-equations-for-complex-fluids",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 1.2 Key Dimensionless Parameters: Several dimensionless parameters...",
    "content": "Several dimensionless parameters characterize the behavior of complex fluids: 1. **Weissenberg number (Wi)**: Ratio of elastic to viscous forces $$\\text{Wi} = \\lambda \\dot{\\gamma}$$ where $\\lambda$ is the relaxation time and $\\dot{\\gamma}$ is a characteristic strain rate 2. **Deborah number (De)**: Ratio of material relaxation time to observation time $$\\text{De} = \\frac{\\lambda}{t_{\\text{obs}}}$$ 3. **Elasticity number (El)**: Ratio of elastic to inertial effects $$\\text{El} = \\frac{\\text{Wi}}{\\text{Re}} = \\frac{\\lambda \\mu}{\\rho L^2}$$ 4. **Ohnesorge number (Oh)**: Ratio of viscous forces to inertial and surface tension forces $$\\text{Oh} = \\frac{\\mu}{\\sqrt{\\rho \\sigma L}}$$ 5. **Plasto-capillary number (J)**: Ratio of yield stress to capillary pressure $$\\mathcal{J} = \\frac{\\tau_y R_0}{\\sigma}$$ > [!note] Numerical Challenge Simulating viscoelastic flows presents significant numerical challenges, particularly at high Weissenberg numbers (known as the \"high Weissenberg number problem\").",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#12-key-dimensionless-parameters",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 1.2 Key Dimensionless Parameters: Methods",
    "content": "Traditional numerical methods often fail due to the loss of positive-definiteness of the conformation tensor. The log-conformation approach we'll use in these simulations addresses this issue by working with the logarithm of the conformation tensor, ensuring numerical stability.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#12-key-dimensionless-parameters",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 1.3 The Log-Conformation Approach",
    "content": "In our simulations, we employ the log-conformation approach, which transforms the conformation tensor $\\mathbf{A}$ logarithmically: $$\\mathbf{\\Psi} = \\log(\\mathbf{A})$$ The evolution equation is then solved for $\\mathbf{\\Psi}$ rather than directly for $\\mathbf{A}$, which ensures that the reconstructed conformation tensor remains positive-definite. This approach significantly improves numerical stability, especially for high Weissenberg number flows. The total stress in the fluid is the sum of the Newtonian solvent contribution and the polymer stress: $$\\boldsymbol{\\tau} = \\mu_s (\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T) + \\mathbf{G}(\\mathbf{A} - \\mathbf{I})$$ where $\\mu_s$ is the solvent viscosity, $\\mathbf{G}$ is the elastic modulus, and $\\mathbf{I}$ is the identity tensor.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#13-the-log-conformation-approach",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 2: Bursting Bubbles in Viscoelastic Media",
    "content": "Our first simulation explores the dynamics of bubble bursting in viscoelastic fluids, a phenomenon that differs significantly from the Newtonian case due to elastic memory effects.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-2-bursting-bubbles-in-viscoelastic-media",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 2.1 Physical Description: When a bubble...",
    "content": "When a bubble reaches a free surface, the thin film separating it from the surrounding atmosphere eventually ruptures. This triggers a series of events: 1. Capillary waves travel along the interface 2. The bubble cavity collapses 3. A central jet may form and rise upward (Worthington jet) 4. Depending on conditions, the jet may break into droplets In viscoelastic fluids, elastic stresses dramatically alter these dynamics, often leading to enhanced jet formation and reduced droplet breakup due to elastic resistance to extensional deformation. > [!tldr] Problem Statement Simulate the bursting of a bubble at the interface between a viscoelastic fluid and air, examining how elasticity affects the jet dynamics and potential droplet formation.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#21-physical-description",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 2.1 Physical Description: Key dimensionless parameters...",
    "content": "Key dimensionless parameters include: > > - **Deborah number (De)**: Ratio of relaxation time to flow time scale > - **Elasto-capillary number (Ec)**: Ratio of elastic forces to surface tension > - **Ohnesorge number (Oh)**: Ratio of viscous forces to inertial and capillary forces > - **Bond number (Bond)**: Ratio of gravitational forces to surface tension",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#21-physical-description",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 2.2 Implementation Details: C/C++ Code",
    "content": "The simulation uses Basilisk's axisymmetric framework with a log-conformation approach for viscoelasticity: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // Main Navier-Stokes solver // Viscoelastic model implementation #if !_SCALAR #include \"log-conform-viscoelastic.h\" // Tensor implementation #else #include \"log-conform-viscoelastic-scalar-2D.h\" // Scalar implementation #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" // Two-phase flow with viscoelasticity #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension forces ``` The bubble is initialized using a pre-calculated equilibrium shape that balances surface tension and gravitational forces: ```c event init (t = 0) { if (!restore (file = dumpFile)){ // Read initial shape from data file char filename[60]; sprintf(filename,\"Bo%5.4f.dat\",Bond); FILE * fp = fopen(filename,\"rb\"); // Generate distance field from shape coordinates coord* InitialShape; InitialShape = input_xy(fp); fclose (fp); // Compute signed distance function scalar d[]; distance (d, InitialShape); // Refine mesh based on distance function while (adapt_wavelet ((scalar *){f, d}, (double[]){1e-8, 1e-8}, MAXlevel).nf); // Convert distance function to volume fraction vertex scalar phi[]; foreach_vertex(){ phi[] = -(d[] + d[-1] + d[0,-1] + d[-1,-1])/4.; } fractions (phi, f); } } ``` Physical properties are specified based on the dimensionless parameters: ```c // Density ratio (liquid : gas = 1000:1) rho1 = 1., rho2 = 1e-3; // Gas phase Ohnesorge number Oha = 2e-2 * Oh; // Viscosity from Ohnesorge numbers mu1 = Oh, mu2 = Oha; // Polymer relaxation time (liquid has elasticity, gas does not) lambda1 = De; lambda2 = 0.; // Elastic modulus (liquid is viscoelastic, gas is not) G1 = Ec; G2 = 0.; // Surface tension coefficient f.sigma = 1.0; ``` > [!important] Adaptive Mesh Refinement The simulation uses multiple criteria for mesh refinement to accurately resolve the interface dynamics: > > ```c > event adapt(i++){ > // Calculate interface curvature for refinement criterion > scalar KAPPA[]; > curvature(f, KAPPA); > > // Adapt mesh based on multiple criteria > adapt_wavelet ((scalar *){f, u.x, u.y, conform_p.x.x, conform_p.y.y, > conform_p.y.x, conform_qq, KAPPA}, > (double[]){fErr, VelErr, VelErr, AErr, AErr, AErr, AErr, KErr}, > MAXlevel, MAXlevel-6); > } > ``` > > This adaptive approach concentrates computational resources where they're needed most: at the interface, in regions of high curvature, areas with significant velocity gradients, and regions with rapidly varying conformation tensor components.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#22-implementation-details",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 2.3 Expected Results: Results",
    "content": "For Newtonian fluids (De = 0), bubble bursting typically results in: 1. Rapid retraction of the film 2. Formation of capillary waves 3. Collapse of the cavity 4. Potential formation of a Worthington jet 5. Possible droplet pinch-off from the jet For viscoelastic fluids (De > 0), we expect to observe: 1. Enhanced jet formation due to elastic stresses 2. Delayed or suppressed droplet pinch-off 3. Longer and thinner jets at high Deborah numbers 4. Beads-on-a-string morphology for moderate elasticity > [!task] Exercise: Investigating Deborah Number Effects > > Modify the bubble bursting simulation to explore different Deborah numbers: > > 1. Run simulations with De = 0 (Newtonian), De = 1 (moderate elasticity), and De = 10 (high elasticity), keeping other parameters constant > 2. Track and compare: > - Maximum jet height > - Time to first droplet pinch-off (if it occurs) > - Jet morphology (thickness, length, shape) > 3.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#23-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 2.3 Expected Results: Explain the physical...",
    "content": "Explain the physical mechanisms behind the observed differences > > This exercise will help you understand how elastic memory affects interfacial dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#23-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 3: Viscoplastic Drop Impact",
    "content": "Our second simulation investigates the dynamics of a viscoplastic (yield-stress fluid) drop impacting a solid surface.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-3-viscoplastic-drop-impact",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 3.1 Physical Background: When a viscoplastic...",
    "content": "When a viscoplastic drop impacts a surface, its behavior differs significantly from Newtonian drops due to the yield stress, which creates unyielded (solid-like) regions within the fluid. Key features include: 1. Initial deformation driven by inertia 2. Formation of unyielded regions where stress falls below the yield stress 3. Limited spreading compared to Newtonian drops 4. Potential formation of a solid-like cap at the drop apex 5. Asymmetric retractions and frozen interfaces after impact > [!tldr] Problem Statement Simulate the axisymmetric impact of a viscoplastic drop onto a solid surface.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#31-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 3.1 Physical Background: Key dimensionless parameters...",
    "content": "Key dimensionless parameters include: > > - **Weber number (We)**: $\\text{We} = \\frac{\\rho U^2 D}{\\sigma}$ Ratio of inertial to surface tension forces > - **Ohnesorge number (Oh)**: $\\text{Oh} = \\frac{\\mu}{\\sqrt{\\rho \\sigma D}}$ Ratio of viscous to inertial and surface tension forces > - **Plasto-capillary number (J)**: $\\mathcal{J} = \\frac{\\tau_yR_0}{\\sigma}$ Ratio of yield stress to capillary pressure",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#31-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 3.2 Mathematical Formulation",
    "content": "For the viscoplastic fluid, we employ the Herschel-Bulkley model with regularization: $$ \\boldsymbol{\\tau} = 2\\biggl[\\frac{\\mathcal{J}}{2|\\boldsymbol{\\mathcal{D}}|+\\epsilon} + \\mathcal{O}h (2|\\boldsymbol{\\mathcal{D}}|+\\epsilon)^{n-1}\\biggr]\\boldsymbol{\\mathcal{D}} $$ where: - $\\boldsymbol{\\mathcal{D}}$ is the deformation rate tensor - $|\\boldsymbol{\\mathcal{D}}|$ is its second invariant - $\\epsilon$ is a regularization parameter - $n$ is the power law index (n = 1 for Bingham model) - $\\mathcal{J}$ is the dimensionless yield stress - $\\mathcal{O}h$ is the Ohnesorge number The regularization ensures numerical stability by avoiding the mathematical singularity at zero deformation rate.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#32-mathematical-formulation",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 3.3 Implementation Details: C/C++ Code",
    "content": "The simulation leverages a modified two-phase flow solver for viscoplastic fluids: ```c #include \"axi.h\" #include \"navier-stokes/centered.h\" #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVP-HB.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #include \"reduced.h\" ``` Boundary conditions specify a solid wall at the left boundary: ```c // Left boundary: solid wall (no-slip and no flux) u.t[left] = dirichlet(0.0); // Tangential velocity = 0 (no-slip) f[left] = dirichlet(0.0); // Volume fraction = 0 (solid wall) ``` The drop is initialized with a downward velocity and positioned slightly above the wall: ```c event init (t = 0) { if (!restore (file = dumpFile)){ refine((R2Drop(x, y) [!important] Adaptive Refinement Strategy The simulation employs a sophisticated adaptive refinement strategy that changes based on the simulation stage: > > ```c > event adapt(i++){ > if (t // Early impact phase: focus on interface and velocity fields > adapt_wavelet ((scalar *){f, u.x, u.y}, > (double[]){fErr, VelErr, VelErr}, > MAXlevel); > } else { > // Later stages: add refinement based on curvature and deformation > scalar KAPPA[], D2c[]; > curvature(f, KAPPA); > foreach() { > // Calculate deformation tensor components > double D11 = (u.y[0,1] - u.y[0,-1])/(2*Delta); > double D22 = (u.y[]/y); > double D33 = (u.x[1,0] - u.x[-1,0])/(2*Delta); > double D13 = 0.5*((u.y[1,0] - u.y[-1,0] + u.x[0,1] - u.x[0,-1])/(2*Delta)); > double D2 = (sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13)); > D2c[] = f[]*(D2); // Deformation rate in the drop phase > } > adapt_wavelet ((scalar *){f, u.x, u.y, KAPPA, D2c}, > (double[]){fErr, VelErr, VelErr, KAPPAErr, D2Err}, > MAXlevel); > } > } > ``` > > This strategy ensures fine resolution near the interface and in regions of high deformation, which is critical for accurately capturing the yield surfaces where the stress transitions across the yield threshold.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#33-implementation-details",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 3.4 Expected Results",
    "content": "For viscoplastic drops, the impact dynamics depend strongly on the plasto-capillary number J: 1. **Low J (J 1)**: Minimal deformation, approaching solid-like behavior A key feature to observe is the formation of unyielded regions where the stress falls below the yield stress. These regions behave as solid-like domains embedded within the flowing fluid. > [!task] Exercise: Non-Newtonian Impact Dynamics > > Compare viscoplastic drop impact with Newtonian drop impact: > > 1. Run simulations with J = 0 (Newtonian), J = 0.1 (moderate yield stress), and J = 0.5 (high yield stress) > 2. Compare: > - Maximum spread factor (ratio of maximum diameter to initial diameter) > - Final equilibrium shape > - Locations of unyielded regions (where applicable) > 3. Plot the spread factor vs. time for each case on a single graph > 4. Explain how yield stress affects the impact dynamics > > This exercise will help you understand how yield stress modifies impact behavior compared to Newtonian fluids.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#34-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 4: Soft Impact Dynamics with Viscoelastic Fluids",
    "content": "Our third simulation explores the dynamics of viscoelastic drop impact, focusing on the effects of elasticity on the impact behavior.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-4-soft-impact-dynamics-with-viscoelastic-fluids",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 4.1 Physical Background",
    "content": "When a viscoelastic drop impacts a surface, elastic stresses can lead to behaviors not seen in Newtonian impacts: 1. Enhanced rebound due to elastic energy storage and recovery 2. Suppression of satellite droplet formation 3. Extended filament formation during rebound 4. Complex fingering patterns during spreading 5. Beads-on-a-string morphology in retracting filaments > [!tldr] Problem Statement Simulate the impact of a viscoelastic drop on a solid surface, examining how elasticity affects the impact dynamics. Key dimensionless parameters include: > > - **Weber number (We)**: Ratio of inertial to surface tension forces > - **Ohnesorge number (Oh)**: Ratio of viscous to inertial and surface tension forces > - **Weissenberg number (Wi)**: Ratio of elastic to viscous forces > - **Elasticity number (El)**: Ratio of elastic to inertial effects > - **Bond number (Bo)**: Ratio of gravitational to surface tension forces",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#41-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 4.2 Implementation Details: C/C++ Code",
    "content": "The simulation uses a similar framework to the bubble bursting case, with axisymmetric formulation and log-conformation approach: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // Main Navier-Stokes solver // Viscoelastic model implementation #if !_SCALAR #include \"log-conform-viscoelastic.h\" // Tensor implementation #else #include \"log-conform-viscoelastic-scalar-2D.h\" // Scalar implementation #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" // Two-phase flow with viscoelasticity #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension implementation ``` The drop is initialized as a sphere approaching the axis of symmetry (which represents the impact surface in the axisymmetric formulation): ```c event init (t = 0) { if (!restore (file = dumpFile)){ // Refine mesh around interface refine((R2Drop(x, y) [!note] Scalar vs.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#42-implementation-details",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 4.2 Implementation Details: Tensor Implementation The...",
    "content": "Tensor Implementation The code provides two options for implementing viscoelasticity: > > 1. **Tensor Implementation**: Full anisotropic stresses, physically accurate but computationally intensive > 2. **Scalar Implementation**: Simplified model, faster but less accurate for complex flows > > The tensor implementation tracks the full conformation tensor, while the scalar implementation uses a simplified approach that captures the main features while being computationally more efficient.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#42-implementation-details",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 4.3 Expected Results: Viscoelastic drop impact...",
    "content": "Viscoelastic drop impact exhibits several distinctive behaviors compared to Newtonian impact: 1. **Weissenberg = 0 (Newtonian)**: Standard impact dynamics with spreading, potential rebound depending on Oh and We 2. **Low Weissenberg**: Enhanced rebound due to elastic recovery 3. **Moderate Weissenberg**: Formation of extended filaments during rebound 4. **High Weissenberg**: Dramatic enhancement of rebound with possible beads-on-a-string formation in filaments > [!task] Exercise: Elasticity Effects on Impact > > Investigate how elasticity affects drop impact behavior: > > 1. Run simulations with Wi = 0 (Newtonian), Wi = 1 (moderate elasticity), and Wi = 10 (high elasticity) > 2. For each case, track: > - Maximum spread factor > - Rebound height (if applicable) > - Time evolution of kinetic and elastic energy > 3. Visualize the stress distribution during impact for different Wi values > 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#43-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 4.3 Expected Results: Explain the physical...",
    "content": "Explain the physical mechanisms behind the observed differences > > This exercise will help you understand how elasticity modifies impact dynamics through storage and recovery of elastic energy.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#43-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 5: Taylor-Culick Viscoelastic Retraction",
    "content": "Our final simulation explores the capillary-driven retraction of a viscoelastic fluid filament, known as Taylor-Culick flow.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-5-taylor-culick-viscoelastic-retraction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 5.1 Physical Background: When a cylindrical...",
    "content": "When a cylindrical fluid filament with a free surface is suddenly released, surface tension causes it to retract. For Newtonian fluids, the retraction velocity reaches a constant value known as the Taylor-Culick velocity: $$v_{TC} = \\sqrt{\\frac{2\\sigma}{\\rho h}}$$ where $\\sigma$ is the surface tension, $\\rho$ is the density, and $h$ is the filament thickness. For viscoelastic fluids, the retraction dynamics are more complex due to elastic effects: 1. Initial acceleration phase similar to Newtonian fluids 2. Development of a bulbous end that grows as it collects fluid 3. Formation of a neck behind the bulbous end 4. Potential development of beads-on-a-string morphology 5. Modified retraction velocity due to elastic stresses > [!tldr] Problem Statement Simulate the retraction of a viscoelastic fluid filament under capillary action, examining how elasticity affects the retraction dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#51-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 5.1 Physical Background: Key dimensionless parameters...",
    "content": "Key dimensionless parameters include: > > - **Deborah number (De)**: Ratio of relaxation time to capillary time > - **Ohnesorge number (Oh)**: Ratio of viscous to inertial and capillary forces > - **Elasticity number (El)**: Ratio of elastic to inertial effects",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#51-physical-background",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 5.2 Implementation Details: C/C++ Code",
    "content": "The simulation uses the axisymmetric framework with log-conformation approach for viscoelasticity: ```c #include \"axi.h\" // Axisymmetric coordinates #include \"navier-stokes/centered.h\" // Main Navier-Stokes solver // Viscoelastic model implementation #if !_SCALAR #include \"log-conform-viscoelastic.h\" // Tensor implementation #else #include \"log-conform-viscoelastic-scalar-2D.h\" // Scalar implementation #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" // Two-phase flow with viscoelasticity #include \"navier-stokes/conserving.h\" // Conservative momentum advection #include \"tension.h\" // Surface tension implementation ``` The initial configuration consists of a cylindrical filament with a hemispherical cap: ```c event init(t = 0){ if(!restore (file = dumpFile)){ // Refine grid near the interface refine(x [!important] Length Scales In this simulation, there are two important length scales: > > 1. `h0`: The filament thickness, set to 1.0 (the characteristic length) > 2. `hole0`: The initial distance of the hemispherical cap from the origin, also set to 1.0 > > These dimensions determine the initial geometry of the filament, which affects the subsequent retraction dynamics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#52-implementation-details",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 5.3 Expected Results: The retraction dynamics...",
    "content": "The retraction dynamics of viscoelastic filaments show distinctive behaviors: 1. **Newtonian (De = 0)**: Formation of a bulbous end with diameter approximately twice the filament thickness, constant retraction velocity 2. **Low Deborah Number**: Similar to Newtonian but with slightly modified bulbous end shape and retraction velocity 3. **Moderate Deborah Number**: Formation of a neck behind the bulbous end, potential development of beads-on-a-string morphology 4. **High Deborah Number**: Dramatic modification of retraction dynamics, with strong elastic resistance to extensional deformation in the neck region > [!task] Exercise: Viscoelastic Filament Retraction > > Investigate how viscoelasticity affects filament retraction: > > 1. Run simulations with De = 0 (Newtonian), De = 1 (moderate elasticity), and De = 10 (high elasticity) > 2. For each case, track: > - Retraction velocity over time > - Bulbous end diameter > - Neck formation and evolution (where applicable) > 3.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#53-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 5.3 Expected Results: Compare the observed...",
    "content": "Compare the observed retraction velocity with the theoretical Taylor-Culick velocity > 4. Explain how elasticity modifies the retraction dynamics through extensional rheology > > This exercise will help you understand how elasticity affects capillary-driven flows, particularly through resistance to extensional deformation.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#53-expected-results",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Part 6: Numerical Considerations for Viscoelastic Simulations",
    "content": "Simulating viscoelastic flows presents unique numerical challenges that require special attention:",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#part-6-numerical-considerations-for-viscoelastic-simulations",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 6.1 The High Weissenberg Number Problem",
    "content": "As mentioned earlier, traditional numerical methods often fail at high Weissenberg numbers due to the loss of positive-definiteness of the conformation tensor. This manifests as: 1. Unbounded growth of stress values 2. Numerical instabilities 3. Simulation divergence The log-conformation approach addresses this by: 1. Working with the logarithm of the conformation tensor 2. Ensuring the reconstructed tensor remains positive-definite 3. Allowing stable simulations at much higher Weissenberg numbers",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#61-the-high-weissenberg-number-problem",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 6.2 Adaptive Mesh Refinement Strategies",
    "content": "Effective adaptive mesh refinement is critical for viscoelastic simulations. Key refinement criteria include: 1. **Interface location**: Captured by volume fraction gradients 2. **Velocity gradients**: Important for capturing flow features 3. **Interface curvature**: Critical for surface tension effects 4. **Conformation tensor gradients**: Essential for capturing elastic stress variations Balancing these criteria is important for efficiency and accuracy.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#62-adaptive-mesh-refinement-strategies",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 6.3 Multiphase Interface Treatment",
    "content": "For multiphase viscoelastic simulations, proper treatment of interfaces is crucial: 1. **Filtered approach**: Smooths property jumps across interfaces for numerical stability 2. **Conservative formulation**: Ensures momentum conservation during rapid interface deformation 3. **Tension model**: Accurately captures surface tension forces",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#63-multiphase-interface-treatment",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - 6.4 Stability Tips",
    "content": "Based on experience with these simulations, here are some tips for ensuring stability: 1. Use a sufficiently small CFL number (typically 0.1 or less) 2. Start with a moderate Weissenberg/Deborah number and gradually increase 3. Ensure sufficient mesh resolution near interfaces and regions of high stress gradients 4. Monitor energy conservation and stress growth for early signs of instability 5. Use the tensor implementation for complex flows, switching to scalar only when necessary for performance > [!tip] Debugging Strategy If your viscoelastic simulation becomes unstable: > > 1. Check the kinetic energy for exponential growth > 2. Examine the conformation tensor components for unbounded growth > 3. Reduce the time step (lower CFL number) > 4. Increase mesh resolution near problematic regions > 5. Consider reducing the Weissenberg/Deborah number temporarily > 6. Ensure boundary conditions are properly implemented",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#64-stability-tips",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Conclusion: In this assignment,...",
    "content": "In this assignment, we've explored the fascinating world of computational viscoelastic fluid dynamics through four complex multiphase flow simulations. These simulations demonstrate the rich and often counterintuitive behaviors that emerge when elastic and viscoplastic effects are introduced into fluid flows. Key insights from our exploration include: 1. The critical importance of specialized numerical techniques (like the log-conformation approach) for stable viscoelastic simulations 2. The profound impact of elasticity on interfacial dynamics, from enhanced jet formation in bubble bursting to modified retraction behavior in filaments 3. The formation of unyielded regions in viscoplastic flows, creating complex solid-fluid transitions 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Conclusion: The challenges and...",
    "content": "The challenges and strategies for adaptive mesh refinement in flows with multiple time and length scales These complex fluid simulations represent the culmination of our progression through computational fluid dynamics, building on earlier foundations in heat conduction, single-phase flows, and simple multiphase systems. The techniques and insights gained are applicable to a wide range of real-world phenomena, from polymer processing and food science to biological flows and advanced manufacturing. > [!question] Further Exploration > > Consider these questions for deeper investigation: > > 1. How would viscoelasticity and viscoplasticity interact in a combined model (e.g., an elasto-viscoplastic fluid)? > 2. What role does fluid microstructure play in determining macroscopic rheological behavior? > 3. How could these models be extended to incorporate temperature-dependent properties? > 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "4th workingassignment - Conclusion: What experimental techniques...",
    "content": "What experimental techniques could validate the computational predictions made by these simulations? > 5. How might machine learning approaches be used to develop more accurate constitutive models for complex fluids? > [!significance]- Metadata Author:: [Vatsal Sanjay](https://vatsalsanjay.com/) Date published:: March 12, 2025 Date modified:: March 12, 2025 at 10:15 CET > [!meta] Back to main website [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/4th-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - Computational Fluid Dynamics with Basilisk: From Poiseuille Flow to Rayleigh-B\u00e9nard Convection",
    "content": "> [!tldr] TL;DR > This assignment explores fundamental fluid dynamics problems using Basilisk, progressing from simple Poiseuille flow to complex Rayleigh-B\u00e9nard convection. We study both Newtonian and non-Newtonian (Bingham) fluids, examine lid-driven cavity flow with flow visualization, and conclude with thermal convection simulation. The hands-on exercises with incrementally complex implementations help develop practical CFD skills while exploring rich physical phenomena, all through Basilisk's efficient simulation framework.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#computational-fluid-dynamics-with-basilisk-from-poiseuille-flow-to-rayleigh-b\u00e9nard-convection",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - Introduction: In this working...",
    "content": "In this working class, we'll explore advanced fluid dynamics simulations using the Basilisk framework. Building on our previous work with heat conduction ([[1st-workingAssignment]]), we'll now tackle more complex fluid flow problems that incorporate viscosity, non-Newtonian behavior, and thermal effects. > [!info] Learning Objectives > > - Implement and analyze Poiseuille flow simulations for Newtonian and non-Newtonian fluids > - Understand the lid-driven cavity benchmark problem and its implementation > - Extend simulations with flow visualization techniques > - Explore thermal convection through the Rayleigh-B\u00e9nard configuration > - Develop skills in modifying Basilisk code for different physical scenarios Throughout this tutorial, we'll follow a logical progression from simple to complex simulations: 1. Poiseuille flow with Newtonian fluids 2. Poiseuille flow with Bingham/non-Newtonian fluids 3. Lid-driven cavity with Newtonian fluids 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - Introduction: Lid-driven cavity with...",
    "content": "Lid-driven cavity with Bingham fluids (exercise) 5. Flow visualization in lid-driven cavity 6. Rayleigh-B\u00e9nard convection (exercise)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 1.1 Newtonian Poiseuille Flow (2-Poiseuille-flow-Newtonian.c): Let's begin with...",
    "content": "Let's begin with a fundamental fluid mechanics problem: Poiseuille flow with a Newtonian fluid. > [!tldr] Problem Statement > Solve for the steady-state velocity profile in a planar Poiseuille flow with a constant pressure gradient $-\\frac{dp}{dx} = 1$ and constant viscosity $\\mu_0$. For a Newtonian fluid, the analytical solution is a parabolic profile: $u(y) = \\frac{1}{2\\mu_0}y(h-y)$, where $h=1.0$ is the channel height.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#11-newtonian-poiseuille-flow-2-poiseuille-flow-newtonianc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 1.1 Newtonian Poiseuille Flow (2-Poiseuille-flow-Newtonian.c): C/C++ Code",
    "content": "The code uses Basilisk's Navier-Stokes solver to find the steady-state solution: ```c #include \"navier-stokes/centered.h\" // Global parameters char file_name[80]; double mu_0 = 1.0; // Constant viscosity (Newtonian) int max_iter = 1e4; // Maximum iterations #define DT_MAX (1e-3) // Maximum timestep // Initialization event event init(t = 0) { // Set constant Newtonian viscosity const scalar mu_const[] = mu_0; mu = mu_const; // Pressure gradient (-dp/dx = 1) const face vector mdpdx[] = {1.0, 0.0}; a = mdpdx; // Initialize velocity field at rest foreach() { u.x[] = 0; u.y[] = 0; un[] = 0; } } ``` > [!note] Key Implementation Details > > - The domain is a unit square with periodic left/right boundaries > - No-slip boundary at the bottom ($u=0$) > - Slip boundary at the top (zero-gradient) > - Constant horizontal pressure gradient of 1.0 > - Viscosity is set to a constant value (Newtonian fluid) > - Convergence is monitored by tracking changes in the velocity field At steady state, the simulation produces a parabolic velocity profile that can be compared with the analytical solution: ```c event end(t = end) { FILE *fp = fopen(\"profile.dat\", \"w\"); // Sample the velocity profile along the x-midpoint foreach_col(0) { // Calculate exact solution: u(y) = (1/2\u03bc) * y * (h-y) double y = y; double u_exact = (1.0/(2.0*mu_0)) * y * (L0-y); double error = fabs((u.x[] - u_exact)/u_exact); fprintf(fp, \"%g %g %g %g\\n\", y, u.x[], u_exact, error); } } ```",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#11-newtonian-poiseuille-flow-2-poiseuille-flow-newtonianc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 1.2 Non-Newtonian Poiseuille Flow (2-Poiseuille-flow-Bingham.c): Next, we'll extend...",
    "content": "Next, we'll extend our simulation to handle generalized Newtonian fluids, including Bingham plastics and power-law fluids. > [!tldr] Problem Statement > Solve for the steady-state velocity profile in a planar Poiseuille flow with a constant pressure gradient for a generalized Newtonian fluid that follows the Herschel-Bulkley model: $\\tau = \\tau_y + K(\\dot{\\gamma})^n$, where: > > - $\\tau_y$ is the yield stress > - $K$ is the consistency index > - $n$ is the power-law exponent > - $\\dot{\\gamma}$ is the strain rate The generalized Newtonian model can represent: - Newtonian fluid: $\\tau_y = 0$, $n = 1$ - Power-law fluid: $\\tau_y = 0$, $n \\neq 1$ - Bingham plastic: $\\tau_y > 0$, $n = 1$ - Herschel-Bulkley: $\\tau_y > 0$, $n \\neq 1$ The most important addition in this code is the calculation of the viscosity at each face based on the strain rate tensor: ```c event properties(i++) { foreach_face() { // Calculate deformation tensor components at face centers double D11 = (u.x[] - u.x[-1,0]); double D22 = ((u.y[0,1] - u.y[0,-1]) + (u.y[-1,1] - u.y[-1,-1])) / 4.0; double D12 = 0.5 * (((u.x[0,1] - u.x[0,-1]) + (u.x[-1,1] - u.x[-1,-1])) / 4.0 + (u.y[] - u.y[-1,0])); // Calculate second invariant double D2 = sqrt(sq(D11) + sq(D22) + 2.0 * sq(D12)) / Delta; // Calculate effective viscosity double mu_temp; if (D2 > 0.0) { double temp = tau_y / (sqrt(2.0) * D2) + mu_0 * exp((n - 1.0) * log(D2 / sqrt(2.0))); mu_temp = min(temp, mu_max); } else { if (tau_y > 0.0 || n [!important] Mathematical Background For generalized Newtonian fluids, the stress tensor is related to the deformation tensor by: > > $$\\boldsymbol{\\tau} = 2 \\mu_{eq} \\boldsymbol{\\mathcal{D}}$$ > > where the equivalent viscosity $\\mu_{eq}$ for a Herschel-Bulkley fluid is: > > $$\\mu_{eq} = \\frac{\\tau_y}{2|\\boldsymbol{\\mathcal{D}}|} + K|\\boldsymbol{\\mathcal{D}}|^{n-1}$$ > > To prevent numerical instability when $|\\boldsymbol{\\mathcal{D}}| \\approx 0$, we use regularization: > > 1.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#12-non-newtonian-poiseuille-flow-2-poiseuille-flow-binghamc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 1.2 Non-Newtonian Poiseuille Flow (2-Poiseuille-flow-Bingham.c): Compute viscosity as...",
    "content": "Compute viscosity as normal where strain rate is non-zero > 2. Cap the viscosity at $\\mu_{max}$ where needed > 3. Handle special cases for different values of $\\tau_y$ and $n$ This code allows us to study how different fluid models affect the velocity profile, from the parabolic profile of Newtonian fluids to the plug flow region characteristic of Bingham plastics.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#12-non-newtonian-poiseuille-flow-2-poiseuille-flow-binghamc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 2.1 Newtonian Lid-Driven Cavity (2-LidDrivenCavity-Newtonian.c): The lid-driven cavity...",
    "content": "The lid-driven cavity is a classic benchmark problem in computational fluid dynamics. > [!tldr] Problem Statement > Solve for the steady-state flow in a square cavity with a moving top lid. The fluid is Newtonian with a constant viscosity, and all walls have no-slip boundary conditions except for the top wall, which moves at a constant velocity $u = 1$.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#21-newtonian-lid-driven-cavity-2-liddrivencavity-newtonianc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 2.1 Newtonian Lid-Driven Cavity (2-LidDrivenCavity-Newtonian.c): C/C++ Code",
    "content": "The simulation setup is straightforward: ```c #include \"navier-stokes/centered.h\" // Constants #define LEVEL 8 // Grid refinement level #define MAXDT (1e-4) // Maximum timestep #define ERROR (1e-6) // Convergence error threshold // Boundary conditions // Top moving wall (lid) u.t[top] = dirichlet(1); // Other no-slip boundaries u.t[bottom] = dirichlet(0); u.t[left] = dirichlet(0); u.t[right] = dirichlet(0); ``` > [!note] Lid-Driven Cavity Characteristics The lid-driven cavity flow exhibits several key features: > > - Primary vortex in the center of the cavity > - Secondary corner vortices at low Reynolds numbers > - Benchmark for testing numerical schemes > - Reynolds number defined as Re = \u03c1UL/\u03bc = 1/\u03bc (with \u03c1=1, U=1, L=1) > > At low Reynolds numbers (high viscosity), the flow reaches a steady state with well-defined vortex structures. As Re increases, the flow becomes increasingly complex.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#21-newtonian-lid-driven-cavity-2-liddrivencavity-newtonianc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 2.2 Lid-Driven Cavity with Flow Visualization (2-LidDrivenCavity-Newtonian-dieInjection.c): C/C++ Code",
    "content": "To better visualize the flow patterns, we can add a passive tracer (dye) to the simulation: ```c #include \"navier-stokes/centered.h\" #include \"die-injection.h\" // Die injection parameters event init (t = 0) { // Set constant viscosity for Newtonian fluid mu = muv; // Initialize velocity field foreach() { u.x[] = 0; u.y[] = 0; un[] = 0; } } int main() { // Initialize grid and parameters init_grid(1<<LEVEL); L0 = 1.0; origin(-0.5, -0.5); DT = MAXDT; TOLERANCE = 1e-5; CFL = 0.25; // Die injection parameters tInjection = 0.05; // Inject the die after flow is established xInjection = 0.00; // X position (center of cavity) yInjection = 0.40; // Y position (center of cavity) // Run simulation run(); } ``` The `die-injection.h` header defines a scalar field that is transported with the flow: ```c // Define the scalar field for the die scalar T[]; scalar * tracers = {T}; // Initialize the die tracer to zero everywhere event init (t = 0) { foreach() T[] = 0.0; } // Inject the die at the specified time event inject_die (t = tInjection) { foreach() { double dist = sqrt(sq(x - xInjection) + sq(y - yInjection)); if (dist <= dieRadius) T[] = 1.0; } } ``` This tracer provides a clear visualization of the flow structures and their evolution over time, revealing the complex patterns that develop in the lid-driven cavity.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#22-lid-driven-cavity-with-flow-visualization-2-liddrivencavity-newtonian-dieinjectionc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 3.1 Modifying 2-LidDrivenCavity-Bingham.c for exercise: For the first...",
    "content": "For the first exercise, I recommend modifying the lid-driven cavity simulation for Bingham fluids. Here are some suggestions for redacting parts of the code: > [!task] Exercise: Implement Bingham Plastic Model in Lid-Driven Cavity > > In this exercise, you'll modify the lid-driven cavity code to simulate a Bingham plastic fluid. Complete the missing parts of the code to: > > 1. Calculate the deformation tensor components at face centers > 2. Compute the second invariant of the deformation tensor > 3. Implement the regularized Bingham viscosity model > 4. Apply the viscosity at cell faces > > You should run simulations with different yield stress values to observe how the flow structure changes.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#31-modifying-2-liddrivencavity-binghamc-for-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 3.1 Modifying 2-LidDrivenCavity-Bingham.c for exercise: Context",
    "content": "Code: [2-LidDrivenCavity-Bingham_QUES.c](https://github.com/comphy-lab/Basilisk-101/blob/main/testCases/2-LidDrivenCavity-Bingham_QUES.c) ```c event properties(i++) { foreach_face() { // TODO: Calculate deformation tensor components double D11 = /* Your code here */; double D22 = /* Your code here */; double D12 = /* Your code here */; // TODO: Calculate second invariant (D2) double D2 = /* Your code here */; double mu_local; if (D2 > 0.) { // TODO: Implement regularized Bingham model double temp = /* Your code here */; mu_local = /* Your code here */; } else { // Handle zero strain rate case mu_local = (tauy > 0.0) ? mumax : MU_0; } // Apply viscosity muv.x[] = fm.x[] * (mu_local); } } ``` 1. Observe and explain the formation of unyielded regions (plug flow) 2. Compare streamline patterns for different yield stress values 3. Investigate convergence behavior as yield stress increases 4.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#31-modifying-2-liddrivencavity-binghamc-for-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 3.1 Modifying 2-LidDrivenCavity-Bingham.c for exercise: Plot velocity profiles...",
    "content": "Plot velocity profiles across horizontal or vertical sections > [!hint] Solution Hints: > > - Deformation tensor components must be calculated from velocity gradients > - Second invariant: $D_2 = \\sqrt{D_{ij}D_{ij}}$ > - Bingham model: $\\mu = \\tau_y/(2D_2) + \\mu_0$, with regularization to prevent division by zero > - Remember to use the appropriate spatial averaging for face-centered calculations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#31-modifying-2-liddrivencavity-binghamc-for-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 3.2 Modifying 2-Rayleigh-Benard.c for Exercise: > [!task] Exercise:...",
    "content": "> [!task] Exercise: Implement Rayleigh-B\u00e9nard Convection > > In this exercise, you'll implement a simulation of Rayleigh-B\u00e9nard convection using the Boussinesq approximation. Complete the missing parts of the code to: > > 1. Set up the domain and boundary conditions > 2. Initialize the temperature field with a small perturbation > 3. Implement the buoyancy force in the acceleration event > 4. Set up temperature diffusion > 5. Calculate and monitor the Nusselt number > > You'll explore how the Rayleigh number affects convection patterns. - [2-Rayleigh-Benard.c](https://github.com/comphy-lab/Basilisk-101/blob/main/testCases/2-Rayleigh-Benard.c) - [convection-Boussinesq_QUES.h](https://github.com/comphy-lab/Basilisk-101/blob/main/src-local/convection-Boussinesq_QUES.h) Additional challenges: 1. Calculating and plotting the Rayleigh number vs. number of convection cells 2. Investigating the effect of aspect ratio on convection patterns 3.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#32-modifying-2-rayleigh-benardc-for-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 3.2 Modifying 2-Rayleigh-Benard.c for Exercise: Measuring the critical...",
    "content": "Measuring the critical Rayleigh number where convection begins 4. Implementing different thermal boundary conditions > [!hint] Solution Hints: > > - The Boussinesq approximation adds a buoyancy term to the y-momentum equation > - Temperature should be initialized with a linear profile plus a small random perturbation > - The acceleration term should be: $a_y = g\\beta(T-T_0)$ > - Use the diffusion() function from diffusion.h for temperature evolution > - The Nusselt number can be calculated from the vertical heat flux at the boundaries",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#32-modifying-2-rayleigh-benardc-for-exercise",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 4.1 Common Basilisk Patterns",
    "content": "Throughout these simulations, you'll notice some common patterns in Basilisk code: > [!note] Common Basilisk Patterns > > 1. **Grid initialization**: > > ```c > init_grid(1 ``` > > 2. **Boundary conditions**: > > ```c > u.t[top] = dirichlet(1); // Tangential velocity > u.n[bottom] = dirichlet(0); // Normal velocity > ``` > > 3. **Events for different stages**: > > ```c > event init(t = 0) { ... } // Initialization > event properties(i++) { ... } // Property updates > event integration/marching(i++) { ... } // Time stepping > event logfile(i += 100) { ... } // Logging > ``` > > 4. **Grid traversal with foreach()**: > > ```c > foreach() { > // Operation on each cell > } > foreach_face() { > // Operation on each face > } > ``` > > 5. **Convergence monitoring**: > > ```c > double du = change(u.x, un); > if (du ``` >",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#41-common-basilisk-patterns",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - 4.2 Tips for Successful Simulations",
    "content": "Here are some tips to help you succeed with these simulations: > [!tip] Simulation Tips > > - **Timestep selection**: For explicit schemes, ensure the timestep satisfies the relevant stability criterion (e.g., CFL condition) > > - **Convergence monitoring**: Always check convergence by tracking changes in key variables > > - **Grid resolution**: Start with a coarse grid for quick tests, then refine for accuracy > > - **Boundary conditions**: Double-check that boundary conditions are correctly implemented > > - **Regularization parameters**: For non-Newtonian fluids, choose appropriate regularization parameters to balance accuracy and stability > > - **Initial conditions**: Use appropriate initial conditions to avoid unnecessary transients > > - **Output frequency**: Balance output frequency with computational resources and storage needs >",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#42-tips-for-successful-simulations",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "2nd workingassignment - Conclusion",
    "content": "> [!question] Further Exploration > > Once you've completed the basic exercises, consider these extensions: > > 1. How does the convergence behavior change with increasing yield stress in Bingham fluids? > > 2. Can you identify the critical Rayleigh number where convection cells first appear? > > 3. How would you modify the lid-driven cavity to include temperature effects (thermally-driven cavity)? > > 4. What happens if you implement an oscillating lid velocity instead of constant velocity? > > 5. Can you extend the Poiseuille flow simulation to include time-dependent pressure gradients? > > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com/) > Date published:: March 11, 2025 > Date modified:: March 11, 2025 at 08:48 CET > [!meta] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/2nd-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - GitHub repository",
    "content": "[Click here](https://github.com/comphy-lab/Basilisk-101) > [!tldr] TL;DR: > Heat Conduction Simulation Tutorial This tutorial walks through implementing heat conduction simulations, starting with basic vanilla C implementations and progressing to more powerful Basilisk C versions. We build from 1D steady-state problems to 2D, annular, and axisymmetric geometries, demonstrating how Basilisk's domain-specific language dramatically simplifies code while adding powerful features like adaptive mesh refinement and embedded boundaries. The tutorial includes eight progressive simulation cases, showing how the same physics can be implemented with increasingly sophisticated numerical methods, and concludes with custom post-processing tools for data extraction and visualization. Basilisk ultimately reduces hundreds of lines of vanilla C code to concise, readable implementations that handle complex geometries with minimal effort.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#github-repository",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Introduction: This guide walks...",
    "content": "This guide walks you through implementing heat conduction simulations using both vanilla C and the Basilisk framework. We'll progress from simple steady-state problems to more complex transient simulations in multiple dimensions, highlighting the advantages of Basilisk for computational fluid dynamics (CFD) and heat transfer applications. > [!info] Learning Objectives > > - Implement basic heat conduction solvers in vanilla C > - Transition to equivalent implementations in Basilisk C > - Understand the advantages of Basilisk's domain-specific language > - Develop simulations with increasing complexity (1D \u2192 2D \u2192 axisymmetric) > - Appreciate how Basilisk simplifies numerical methods implementation > - Learn to analyze and visualize simulation results with post-processing tools Throughout this tutorial, we'll follow a logical progression across eight core simulation cases: 1. Steady-state heat conduction in vanilla C (`1-conduction-simple.c`) 2.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Introduction: Transient heat conduction...",
    "content": "Transient heat conduction in vanilla C (`1-conduction-transient.c`) 3. Steady-state heat conduction in Basilisk (`1-conduction-simple-basilisk.c`) 4. Transient heat conduction in Basilisk (fill-in exercise) (`1-conduction-transient-basilisk.c`) 5. Enhanced transient solution with diffusion module (`1-conduction-transient-basilisk-withHeaders.c`) 6. 2D heat conduction (`1-conduction-2D.c`) 7. Heat conduction in an annulus (`1-conduction-2D-annulus.c`) 8. Axisymmetric heat conduction (`1-conduction-Axi.c`) After completing the simulations, we'll also cover how to post-process and visualize the results using custom tools.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#introduction",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 1.1 Steady-State Heat Conduction (1-conduction-simple.c): JavaScript",
    "content": "We'll begin with a fundamental 1D steady-state heat conduction problem in vanilla C. > [!tldr] Problem Statement Solve the steady-state heat equation: $$\\frac{d^2 T}{dx^2} = 0$$ Subject to Dirichlet boundary conditions: > > - $T(0) = 0$ > - $T(1) = 1$ > > The analytical solution is the linear profile $T(x) = x$.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#11-steady-state-heat-conduction-1-conduction-simplec",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 1.1 Steady-State Heat Conduction (1-conduction-simple.c): Let's examine the...",
    "content": "Let's examine the key elements of this implementation: ```c // Domain discretization #define N 11 // Number of grid points #define MAX_ITER 10000 // Maximum number of iterations #define TOL 1e-10 // Convergence tolerance // Core iterative solver using Gauss-Seidel method double update_interior_points(double t_current[N], double t_new[N]) { int i; double error = 0.0; double diff; for (i = 1; i error) { error = diff; } } return error; } ``` This implementation uses the Gauss-Seidel iterative method with a central difference approximation for the second derivative: $$T_{i} \\approx \\frac{T_{i-1} + T_{i+1}}{2}$$ > [!note] Key Implementation Details > > - Arrays for storing current and new temperature values > - Explicit boundary condition application > - Manual iteration until convergence > - Manual memory management > - Explicit file I/O for results",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#11-steady-state-heat-conduction-1-conduction-simplec",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 1.2 Transient Heat Conduction (1-conduction-transient.c): Next, we'll look...",
    "content": "Next, we'll look at a 1D transient heat conduction problem in vanilla C. > [!tldr] Problem Statement Solve the transient heat equation: $$\\frac{\\partial T}{\\partial t} = \\frac{\\partial^2 T}{\\partial x^2}$$ With no-flux boundary conditions and an initial condition approximating a Dirac delta function. > > The analytical solution is a Gaussian profile that spreads over time: $$T(x,t) = \\frac{1}{2\\sqrt{\\pi t}}e^{-x^2/4t}$$ Key aspects of this implementation: ```c // Compute heat fluxes at cell interfaces void compute_fluxes(double *temperature, double *flux, double dx) { flux[0] = 0.0; // Left boundary (no flux) flux[N] = 0.0; // Right boundary (no flux) for (int i = 0; i [!note] Key Implementation Details > > - Explicit time-stepping scheme (forward Euler) > - Manual computation of fluxes at cell interfaces > - Explicit handling of boundary conditions > - Stability condition for time step ($dt \\leq dx^2/2$) > - Manual memory management and array allocation > - Explicit file I/O for snapshots and results",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#12-transient-heat-conduction-1-conduction-transientc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Exercise 1: Modify the Vanilla C Code",
    "content": "> [!task] Suggested Tasks > > 1. Modify `1-conduction-simple.c` to solve a 2D steady-state problem > - Add a second spatial dimension to the grid > - Update the Gauss-Seidel iteration for 2D > - Modify the boundary conditions for all four edges > 2. Modify `1-conduction-transient.c` to use a different initial condition > - Replace the Dirac delta with a Gaussian profile: $T(x,0) = e^{-x^2/\\sigma^2}$ > - Compare the numerical and analytical solutions at different times",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#exercise-1-modify-the-vanilla-c-code",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 2.1 Steady-State Heat Conduction in Basilisk (1-conduction-simple-basilisk.c): C/C++ Code",
    "content": "Now let's examine the equivalent steady-state problem implemented in Basilisk C. ```c #include \"grid/cartesian1D.h\" #include \"run.h\" // Declare scalar field for temperature scalar T[]; T[left] = dirichlet(0.0); T[right] = dirichlet(1.0); int main() { // Domain setup L0 = 1.0; // Domain length X0 = 0.0; // Left boundary N = 200; // Number of cells // Set the timestep based on stability criterion DT = (L0/N)*(L0/N)/2; // Create output directory char comm[80]; sprintf (comm, \"mkdir -p intermediate\"); system(comm); // Run simulation run(); } // Time integration using explicit finite volume method event marching (i++) { foreach() { // Proper heat equation time stepping T[] += DT*(T[1] - 2*T[] + T[-1])/(Delta*Delta); } } ``` > [!important] Basilisk Advantages > > - Simplified domain and grid setup > - Declarative boundary conditions > - Event-based programming model > - Intuitive stencil operations with `T[1]` and `T[-1]` > - Automatic handling of grid traversal with `foreach()` > - Significantly reduced code length with the same functionality",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#21-steady-state-heat-conduction-in-basilisk-1-conduction-simple-basiliskc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 2.2 Understanding Basilisk's Event System",
    "content": "Basilisk uses an event-based programming model that separates concerns: - `event init (t = 0)`: Initialization at t=0 - `event marching/integration (i++)`: Time integration at each step - `event end (t = end)`: Final operations at the end of the simulation Events can also be scheduled at specific times or intervals: ```c // Execute every 0.1 time units event writingFiles (t = 0.0; t += 0.1; t [!note] Event Scheduling Syntax The event scheduling syntax in Basilisk follows this pattern: > > ```c > event name (condition) { ... } > ``` > > Where condition can be: > > - `t = 0` - Single execution at t=0 > - `i++` - Every iteration > - `t += tsnap` - At regular time intervals > - `t = end` - At the end of simulation > - Combinations like `t = 0; t += 0.1; t < 1.0` for repeated execution",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#22-understanding-basilisks-event-system",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Exercise 2: Understand Basilisk Code Structure",
    "content": "> [!task] Tasks > > 1. Compare the structure and length of `1-conduction-simple.c` and `1-conduction-simple-basilisk.c` > - How many lines of code are in each? > - Which sections of code are simplified or eliminated in the Basilisk version? > 2. Identify the advantages of the Basilisk implementation > - List at least three specific advantages > - For each advantage, explain how it simplifies code development or maintenance > 3. Modify `1-conduction-simple-basilisk.c` to output the relative error > - Add code to calculate and print the error relative to the analytical solution > - Use the formula: $error = |T_{numerical} - T_{analytical}|/|T_{analytical}|$",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#exercise-2-understand-basilisk-code-structure",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 3.1 Fill-in-the-Blanks Exercise (1-conduction-transient-basilisk.c): Let's implement the...",
    "content": "Let's implement the transient heat equation in Basilisk.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#31-fill-in-the-blanks-exercise-1-conduction-transient-basiliskc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 3.1 Fill-in-the-Blanks Exercise (1-conduction-transient-basilisk.c): C/C++ Code",
    "content": "Here's a template with some parts for you to fill in: ```c #include \"grid/cartesian1D.h\" #include \"run.h\" // Declare scalar field for temperature scalar T[]; // Simulation parameters #define EPS 0.1 // Width of initial temperature peak #define tmax 1.0 #define tsnap 0.1 int main() { // Domain setup L0 = 10.0; // Domain length X0 = -L0/2; // Left boundary N = 200; // Number of cells // Set the timestep based on stability criterion (CFL condition) // dt = dx^2/2 for explicit scheme DT = (L0/N)*(L0/N)/2; // Create output directory char comm[80]; sprintf (comm, \"mkdir -p intermediate\"); system(comm); // Run simulation run(); } /** * Initialize temperature field * * Sets up a \"Dirac delta\" approximated by a thin rectangle * centered at x=0 with total integral = 1. */ event init (t = 0) { foreach() T[] = (fabs(x) [!hint] Stability Condition (K value) The stability condition for the 1D heat equation with explicit Euler time-stepping requires: $$dt \\leq \\frac{dx^2}{2}$$ So K = 2 is the appropriate value to ensure numerical stability. > [!hint] Understanding The Heat Equation Discretization The heat equation $\\frac{\\partial T}{\\partial t} = \\frac{\\partial^2 T}{\\partial x^2}$ can be discretized in two steps: > > 1.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#31-fill-in-the-blanks-exercise-1-conduction-transient-basiliskc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 3.1 Fill-in-the-Blanks Exercise (1-conduction-transient-basilisk.c): Compute heat fluxes...",
    "content": "Compute heat fluxes at cell interfaces: $q_{i+1/2} = -\\frac{T_{i+1}-T_i}{\\Delta x}$ > 2. Update temperature based on flux divergence: $\\frac{dT_i}{dt} = -\\frac{q_{i+1/2}-q_{i-1/2}}{\\Delta x}$ > > In Basilisk's staggered grid, `q[]` is at cell faces while `T[]` is at cell centers.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#31-fill-in-the-blanks-exercise-1-conduction-transient-basiliskc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Part 4: Enhanced Transient Solution with Diffusion Module: C/C++ Code",
    "content": "Now let's look at an enhanced implementation using Basilisk's built-in diffusion module. ```c #include \"grid/multigrid1D.h\" /* Multigrid solver is required by diffusion.h */ #include \"run.h\" #include \"diffusion.h\" // Declare scalar field for temperature scalar T[]; // Boundary conditions // The diffusion solver will use homogeneous Neumann conditions by default T[left] = neumann(0.); T[right] = neumann(0.); // Simulation parameters #define EPS 0.1 // Width of initial temperature peak #define tmax 1.0 #define tsnap 0.1 int main() { // Domain setup L0 = 10.0; // Domain length X0 = -L0/2; // Left boundary N = 10000; // Number of cells // We can use a larger timestep with the implicit solver // compared to the explicit version which requires dt = dx^2/2 DT = 0.01; // Create output directory char comm[80]; sprintf (comm, \"mkdir -p intermediate\"); system(comm); // Run simulation run(); } /** * Initialize temperature field */ event init (t = 0) { foreach() T[] = (fabs(x) [!important] Advantages of Using diffusion.h > > - **Implicit time stepping** allows for much larger timesteps > - **Unconditional stability** removes the CFL restriction > - **Higher accuracy** due to careful implementation of boundary conditions > - **Multigrid acceleration** for faster convergence > - **Adaptive mesh refinement** compatible > - **Handles complex geometries** through embedded boundaries",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#part-4-enhanced-transient-solution-with-diffusion-module",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 5.1 2D Heat Conduction (1-conduction-2D.c)",
    "content": "Now, let's extend our simulations to two dimensions. > [!tldr] Problem Statement Solve the 2D transient heat equation: $$\\frac{\\partial T}{\\partial t} = \\nabla^2 T$$ With Dirichlet boundary conditions: > > - $T = 1$ on the top boundary > - $T = 0$ on all other boundaries Key aspects of the 2D implementation: ```c #include \"run.h\" #include \"diffusion.h\" // Declare scalar field for temperature scalar T[]; // Boundary conditions T[top] = dirichlet(1.); T[bottom] = dirichlet(0.); T[left] = dirichlet(0.); T[right] = dirichlet(0.); int main() { // Domain setup L0 = 10.0; // Domain length X0 = -L0/2; // Left boundary Y0 = -L0/2; // Bottom boundary init_grid (1 [!note] 2D Implementation Notes > > - Similar structure to 1D, but now using a 2D grid > - Uses `init_grid(1 - Boundary conditions for all four sides > - Implicit diffusion solver works in any dimension > - Added adaptive mesh refinement with `adapt_wavelet()`",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#51-2d-heat-conduction-1-conduction-2dc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 5.2 Heat Conduction in an Annulus (1-conduction-2D-annulus.c): Let's look at...",
    "content": "Let's look at a more complex geometry: heat conduction in an annular domain. > [!tldr] Annulus Problem Solve the transient heat equation in an annular domain: $$\\frac{\\partial T}{\\partial t} = \\nabla^2 T$$ With Dirichlet boundary conditions: > > - $T = 1$ on inner boundary (r = 1) > - $T = 0$ on outer boundary (r = 4) ```c #include \"run.h\" #include \"embed.h\" #include \"diffusion.h\" scalar T[]; // Define inner and outer radii #define INNER_RADIUS 1.0 #define OUTER_RADIUS 4.0 event init (t = 0) { // Define annular geometry using embedded boundaries solid (cs, fs, difference (sq(OUTER_RADIUS) - sq(x) - sq(y), sq(INNER_RADIUS) - sq(x) - sq(y))); // Set boundary conditions T[embed] = dirichlet (sq(x) + sq(y) 0. ? 1.0 : 0.0; // Diffusion only in fluid cells // Solve the diffusion equation while respecting embedded boundaries mgd = diffusion (T, dt, D); } ``` > [!important] Embedded Boundaries > > - `embed.h` provides tools for defining complex geometries > - `solid()` creates the embedded boundary using a level-set function > - `difference()` creates the annular region by subtracting two circles > - Boundary conditions are applied using `T[embed]` > - `fs.x[]` restricts diffusion to the fluid domain",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#52-heat-conduction-in-an-annulus-1-conduction-2d-annulusc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 5.3 Axisymmetric Heat Conduction (1-conduction-Axi.c)",
    "content": "Finally, let's look at an axisymmetric problem. > [!tldr] Axisymmetric Problem Solve the heat equation in cylindrical coordinates with axisymmetry: $$\\frac{\\partial T}{\\partial t} = \\frac{1}{r}\\frac{\\partial}{\\partial r}(r\\frac{\\partial T}{\\partial r}) + \\frac{\\partial^2 T}{\\partial z^2}$$ With boundary conditions: > > - Gaussian heat flux at r=0 (left boundary) > - $T = 0$ on top and right boundaries ```c #include \"axi.h\" #include \"run.h\" #include \"diffusion.h\" scalar T[]; int main() { // Domain setup L0 = 10.0; // Domain length X0 = -L0/2; // Left boundary init_grid (1 [!note] Axisymmetric Features > > - `axi.h` handles the axisymmetric formulation automatically > - In axisymmetric coordinates, `y` represents the radial direction (r) > - `fm.x[]` includes the metric terms for the axisymmetric Laplacian > - Neumann boundary with Gaussian profile at r=0 (left boundary) > - All the complexity of cylindrical coordinates is handled by Basilisk",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#53-axisymmetric-heat-conduction-1-conduction-axic",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Exercise 4: Advanced Heat Conduction Problems",
    "content": "> [!task] Tasks > > 1. Modify the 2D heat conduction problem > - Change boundary conditions to have a sinusoidal temperature on top: `T[top] = dirichlet(sin(\u03c0*x/L0))` > - Compare the steady-state solution with the new boundary condition > 2. Experiment with the annulus problem > - Try different inner and outer radius values > - Implement a time-dependent boundary condition on the inner boundary > 3. Extend the axisymmetric problem > - Add a heat source term using `source(T, dt)` > - Visualize the results with different flux profiles",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#exercise-4-advanced-heat-conduction-problems",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Part 6: Post-Processing and Visualization",
    "content": "After running simulations, we need tools to extract and visualize the results. We'll use two key tools: 1. `getData-generic-heatEq.c` - A Basilisk program to extract data from simulation snapshots 2. `Video-generic-heatEq.py` - A Python script to create visualizations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#part-6-post-processing-and-visualization",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 6.1 Extracting Data with getData-generic-heatEq.c: C/C++ Code",
    "content": "This Basilisk utility reads simulation snapshots and extracts field data for visualization: ```c // getData-generic-heatEq.c #include \"utils.h\" #include \"output.h\" scalar T[]; scalar cs[] = {1}; char filename[80]; int nx, ny, len; double xmin, ymin, xmax, ymax, Deltax, Deltay; scalar * list = NULL; int main(int a, char const *arguments[]) { // Parse command line arguments sprintf (filename, \"%s\", arguments[1]); // Snapshot file xmin = atof(arguments[2]); ymin = atof(arguments[3]); // Domain min xmax = atof(arguments[4]); ymax = atof(arguments[5]); // Domain max ny = atoi(arguments[6]); // Number of points in y // Add fields to extract list = list_add (list, T); list = list_add (list, cs); // Restore the snapshot restore (file = filename); // Calculate grid parameters FILE * fp = ferr; Deltay = (double)((ymax-ymin)/(ny)); nx = (int)((xmax - xmin)/Deltay); Deltax = (double)((xmax-xmin)/(nx)); len = list_len(list); // Allocate memory for field data double ** field = (double **) matrix_new (nx, ny+1, len*sizeof(double)); // Extract data through interpolation for (int i = 0; i [!note] How getData-generic-heatEq.c Works > > 1.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#61-extracting-data-with-getdata-generic-heateqc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 6.1 Extracting Data with getData-generic-heatEq.c: Reads a simulation...",
    "content": "Reads a simulation snapshot file > 2. Takes domain extents and resolution as input > 3. Restores the simulation state > 4. Interpolates field values onto a regular grid > 5. Outputs coordinates and field values to stderr > > This approach allows flexible post-processing of any Basilisk simulation.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#61-extracting-data-with-getdata-generic-heateqc",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 6.2 Visualization with Video-generic-heatEq.py",
    "content": "The Python script processes the extracted data and creates visualizations: ```python",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#62-visualization-with-video-generic-heateqpy",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Example of key components from Video-generic-heatEq.py: Python Function",
    "content": "def gettingfield(filename, zmin, zmax, rmin, rmax, nr): # Run the getData utility and capture its output exe = [\"./getData-generic-heatEq\", filename, str(zmin), str(rmin), str(zmax), str(rmax), str(nr)] p = sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode(\"utf-8\") temp2 = temp1.split(\"\\n\") # Parse the output into arrays Rtemp, Ztemp, Ttemp, cstemp = [], [], [], [] for n1 in range(len(temp2)): temp3 = temp2[n1].split(\" \") if temp3 == ['']: pass else: Ztemp.append(float(temp3[0])) Rtemp.append(float(temp3[1])) Ttemp.append(float(temp3[2])) cstemp.append(float(temp3[3])) # Convert to numpy arrays and reshape R = np.asarray(Rtemp) Z = np.asarray(Ztemp) T = np.asarray(Ttemp) cs = np.asarray(cstemp) nz = int(len(Z)/nr) R.resize((nz, nr)) Z.resize((nz, nr)) T.resize((nz, nr)) cs.resize((nz, nr)) return R, Z, T, cs, nz def process_timestep(ti, caseToProcess, folder, tsnap, GridsPerR, rmin, rmax, zmin, zmax, lw): # Calculate time and filenames t = tsnap * ti place = f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\" name = f\"{folder}/{int(t*1000):08d}.png\" # Extract data nr = int(GridsPerR * rmax) R, Z, T, cs, nz = gettingfield(place, zmin, zmax, rmin, rmax, nr) # Create visualization fig, ax = plt.subplots() fig.set_size_inches(19.20, 10.80) # Mask regions outside the fluid domain T = np.ma.masked_where(cs != 1.0, T) # Plot temperature field cntrl1 = ax.imshow(T, cmap=\"coolwarm\", interpolation='Bilinear', origin='lower', extent=[-rminp, -rmaxp, zminp, zmaxp], vmax=1.0, vmin=0.0) # Add colorbar and save cb1 = fig.add_axes([l-0.04, b, 0.03, h]) c1 = plt.colorbar(cntrl1, cax=cb1, orientation='vertical') c1.set_label(r'$T$', fontsize=TickLabel, labelpad=5) plt.savefig(name, bbox_inches=\"tight\") plt.close() ``` > [!important] Visualization Process > > 1.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#example-of-key-components-from-video-generic-heateqpy",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Example of key components from Video-generic-heatEq.py: For each timestep:...",
    "content": "For each timestep: > - Call `getData-generic-heatEq` to extract data > - Parse the output into NumPy arrays > - Create a plot using matplotlib > - Add appropriate colorbars and labels > - Save as an image file > 2. Parallelization: > - Uses Python's multiprocessing to handle multiple timesteps simultaneously > - Significantly speeds up the visualization process for large simulations",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#example-of-key-components-from-video-generic-heateqpy",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - 6.3 Running the Post-Processing Pipeline",
    "content": "To visualize your simulation results, follow these steps: 1. Compile the data extraction utility: ```bash basilisk1d getData-generic-heatEq.c -o getData-generic-heatEq ``` 2. Run the visualization script with appropriate parameters: ```bash python Video-generic-heatEq.py --CPUs=4 --nGFS=100 --GridsPerR=128 \\ --ZMAX=4.0 --RMAX=4.0 --ZMIN=-4.0 --RMIN=-4.0 --tsnap=1.0 \\ --caseToProcess=1-conduction-2D-annulus --folderToSave=Video ``` 3. Create a video from the generated images (optional): ```bash ffmpeg -framerate 10 -pattern_type glob -i 'Video/*.png' -c:v libx264 -pix_fmt yuv420p video.mp4 ``` > [!tip] Customizing Visualizations You can adjust the visualization parameters to highlight different aspects of your results: > > - Change the colormap using the `cmap` parameter in `ax.imshow()` > - Adjust the value range with `vmin` and `vmax` > - Modify the plot layout or add additional subplots > - Include contour lines with `ax.contour()`",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#63-running-the-post-processing-pipeline",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Conclusion: Throughout this tutorial,...",
    "content": "Throughout this tutorial, we've progressed from simple 1D steady-state heat conduction problems in vanilla C to complex geometries and dimensions using Basilisk C. The key takeaways include: 1. Basilisk significantly reduces the complexity and verbosity of numerical simulation code 2. The event-based programming model provides a clean separation of concerns 3. Basilisk's domain-specific language makes numerical methods more intuitive 4. Built-in modules like `diffusion.h` and `embed.h` provide powerful, optimized solvers 5. Extending to higher dimensions and complex geometries is straightforward 6.",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - Conclusion: Results",
    "content": "Post-processing tools are essential for analyzing and interpreting simulation results > [!tip] Next Steps > > - Explore other physical phenomena like advection-diffusion > - Implement variable diffusion coefficients (e.g., temperature-dependent) > - Combine with Navier-Stokes solvers for natural convection problems > - Add source terms for heat generation > - Experiment with more complex geometries using the embedded boundary method > - Create interactive visualizations using tools like Plotly or ParaView",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#conclusion",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - References and Resources: Context",
    "content": "- [Basilisk Documentation](http://basilisk.fr/Front%20Page) - [Embedded Boundaries in Basilisk](http://basilisk.fr/src/embed.h) - [Diffusion Module Documentation](http://basilisk.fr/src/diffusion.h) - [Axisymmetric Coordinates](http://basilisk.fr/src/axi.h) - [Adaptive Mesh Refinement](http://basilisk.fr/src/adapt.h) - [Basilisk View for Visualization](http://basilisk.fr/src/view.h) > [!question] Need Help?",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#references-and-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "1st workingassignment - References and Resources: If you encounter...",
    "content": "If you encounter issues with any of the exercises, please check: > > - Code syntax and structure > - Boundary condition implementation > - Event scheduling and dependencies > - Numerical stability considerations > > Feel free to open an issue on the GitHub repository if you need further assistance. > [!info] Info > Thanks for reading, and feel free to dive deeper (or suggest improvements) via the [GitHub repository](https://github.com/comphy-lab/CoMPhy-Lab-Blogs)! --- > [!significance]- Metadata > Author:: [Vatsal Sanjay](https://vatsalsanjay.com) > Date published:: Jan 21, 2025 > Date modified:: Jan 25, 2025 at 14:22 > [!link] Back to main website > [Home](https://comphy-lab.org/), [Team](https://comphy-lab.org/team), [Research](https://comphy-lab.org/research), [Github](https://github.com/comphy-lab)",
    "url": "https://blogs.comphy-lab.org/Lecture-Notes/Basilisk101/1st-workingAssignment/#references-and-resources",
    "type": "blog_section",
    "priority": 3
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Test documentation: Lid...",
    "content": "Test documentation: Lid driven cavity using dye injection This repository contains the computational framework and tools for multiphase fluid dynamics simulations based on the Basilisk C framework. The codebase specializes in the simulation and analysis of lid driven cavity flow with dye injection. Documentation The full documentation for this project is available at comphy-lab.org/documentationWeb/ . This website contains detailed explanations of the code, examples, and usage instructions. Overview The codebase implements a classical lid driven cavity flow problem with dye injection using the Basilisk CFD library with custom implementations for specific dye injection including.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Repository Structure basilisk/src/...",
    "content": "Repository Structure basilisk/src/ - Core Basilisk CFD library (reference only, do not modify) simulationCases/ - Test cases for simulation LidDrivenCavity-Newtonian-dyeInjection.c - Lid-driven cavity with dye injection src-local/ - Custom header files extending Basilisk functionality dye-injection.h - Dye injection for flow visualization postProcess/ - Project-specific post-processing tools LidDrivenCavity-Newtonian-dyeInjection.ipynb - Jupyter notebook for analysis and visualization LidDrivenCavity-Newtonian-dyeInjection.py - Python script for post-processing getData-LidDriven.c - Data extraction utility src-local/ Directory The src-local/ directory contains custom header files that extend the base Basilisk functionality: dye-injection.h : Implements a circular tracer (dye) injection for flow visualization with: Configurable injection time and position Circular dye region with adjustable radius Integration with Basilisk\u2019s tracer module for advection postProcess/ Directory The postProcess/ directory provides tools for analyzing and visualizing simulation results: LidDrivenCavity-Newtonian-dyeInjection.ipynb : Jupyter notebook that: Provides interactive analysis of simulation results Visualizes dye transport in the cavity Contains both code and documentation in a single document Allows for reproducible analysis workflow LidDrivenCavity-Newtonian-dyeInjection.py : Python script for generating visualizations that: Processes simulation timesteps in parallel Creates two-panel plots showing dye concentration and velocity magnitude Adds streamlines to visualize flow patterns Uses \u2018getData-LidDriven\u2019 utility to extract field data getData-LidDriven.c : C utility that extracts and processes numerical data from simulation output files simulationCases/ Directory The simulationCases/ directory contains simulation configurations: LidDrivenCavity-Newtonian-dyeInjection.c : Main simulation case that implements: Classical lid-driven cavity flow for a Newtonian fluid Configurable Reynolds number (default: Re = 1) Dye injection in the upper center of the cavity at t=0.05 Adaptive grid with level 8 refinement Proper boundary conditions for the moving lid and no-slip walls Regular snapshot generation for visualization Getting Started Prerequisites Basilisk C installed ( Installation instructions ) C compiler (gcc recommended) Make build system Python 3 with pip for documentation generation BeautifulSoup4 for HTML processing (included in requirements.txt) Scientific visualization tools (optional: ParaView, Gnuplot, etc.) Installation Clone this repository: git clone https://github.com/username/comphy-lab.git cd comphy-lab Make sure Basilisk is properly installed and the BASILISK environment variable is set.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Install Python dependencies...",
    "content": "Install Python dependencies (uses a virtual environment): # This will automatically set up a virtual environment and install dependencies # like BeautifulSoup4 for HTML processing ./reset_install_requirements.sh # To activate the virtual environment for manual commands: source .venv/bin/activate Compile a test case to verify the setup: cd simulationCases make test_name.tst Usage Compiling Simulation Files Basic compilation: qcc -autolink file.c -o executable -lm Compilation with custom headers: qcc -I $PWD /src-local -autolink file.c -o executable -lm Running Simulations Run a compiled executable: ./executable Execute a specific test case: cd simulationCases && make test_name.tst Post-Processing The postProcess/ directory contains tools for post-processing simulation results: Visualization Generation : Automated generation of two-panel plots showing: Dye concentration with coolwarm colormap Velocity magnitude with viridis colormap Streamlines to visualize flow patterns Data Extraction : Utility to extract numerical data from simulation output files Parallel Processing : Multi-core processing of simulation timesteps for efficient visualization LaTeX Integration : Formatted plots with mathematical notation using LaTeX Code Style Guidelines Indentation : 2 spaces (no tabs) Line length : 80 characters maximum Documentation : Use markdown in comments starting with /** .",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Do not use...",
    "content": "Do not use * in comments.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Spacing : Space...",
    "content": "Spacing : Space after commas, spaces around operators (+, -) Files : Core functionality in .h headers, tests in .c files Naming : Snake_case for variables, camelCase for functions Error handling : Return values with stderr messages Example Here\u2019s the actual lid-driven cavity flow with dye injection implementation: #include \"navier-stokes/centered.h\" #include \"dye-injection.h\" // Constants #define LEVEL 8 // Grid refinement level #define MAXDT ( 1e-4 ) // Maximum timestep // Global variables int imax = 1e5 ; // Maximum iterations double tmax = 1.0 ; // Maximum simulation time double tsnap = 0.01 ; // Time interval between snapshots double end = 2.0 ; // End time for simulation // Scalar field for convergence check scalar un []; // Previous x-velocity const face vector muv [] = { 1.0 , 1.0 }; // Face-centered viscosity field /** ## Boundary Conditions */ // Top moving wall (lid) u . t [ top ] = dirichlet ( 1 ); // Other no-slip boundaries u . t [ bottom ] = dirichlet ( 0 ); u . t [ left ] = dirichlet ( 0 ); u . t [ right ] = dirichlet ( 0 ); /** ## Initialization */ event init ( t = 0 ) { // Set constant viscosity for Newtonian fluid mu = muv ; // Initialize velocity field foreach () { u . x [] = 0 ; u . y [] = 0 ; un [] = 0 ; } dump ( file = \"start\" ); } /** ## Snapshot Generation Save snapshots at regular intervals for flow visualization */ event writingFiles ( t = 0. ; t += tsnap ; t < tmax + tsnap ) { char filename [ 100 ]; sprintf ( filename , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = filename ); } int main () { // Initialize grid and parameters init_grid ( 1 << LEVEL ); L0 = 1.0 ; origin (- 0.5 , - 0.5 ); DT = MAXDT ; TOLERANCE = 1e-5 ; CFL = 0.25 ; // Store current velocity for convergence check foreach () { un [] = u . x []; } // dye injection parameters tInjection = 0.05 ; // Inject the dye after flow is established xInjection = 0.00 ; // X position (center of cavity) yInjection = 0.40 ; // Y position (upper center of cavity) // Create a folder for simulation snapshots char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Run simulation run (); } Contributing Fork the repository Create your feature branch ( git checkout -b feature/amazing-feature ) Commit your changes ( git commit -m 'Add some amazing feature' ) Push to the branch ( git push origin feature/amazing-feature ) Open a Pull Request Reporting Issues and Feature Requests We use GitHub Issues to track bugs, feature requests, and example requests for this repository.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: When creating an...",
    "content": "When creating an issue, please select the appropriate template to help us address your needs efficiently. Issue Templates Bug Report: Report here For problems with installation, compilation, or running code.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Please include: Detailed...",
    "content": "Please include: Detailed description of the issue Your environment (OS, compiler version) Steps to reproduce Expected vs. actual behavior Error messages and logs Code snippets or files that demonstrate the issue Feature/Topic Request: Report here - For requesting specific topics or functionality - New examples or tutorials - Additional functionality in the codebase - Improvements to existing materials Example Request: Report here - For requesting specific examples that demonstrate: - Particular Basilisk features - Solutions to common problems - Implementation of specific physics or numerical methods General Question: Report here - For any other questions How to Create an Issue Go to the \u201cIssues\u201d tab in the GitHub repository Click the \u201cNew Issue\u201d button Select the appropriate template from the options Fill in the required information according to the template Add relevant labels if available Submit the issue License This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details.",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection: Context",
    "content": "Acknowledgments S. Popinet & collaborators, Basilisk C, http://basilisk.fr (Last accessed: June 2025) (2013-2025) Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/LidDrivenCavity-Newtonian-dyeInjection.ipynb postProcess/LidDrivenCavity-Newtonian-dyeInjection.py postProcess/getData-LidDriven.c simulationCases simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c simulationCases/Makefile src-local src-local/dye-injection.h",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "gitclone https://github.com/username/comphy-lab.gitcdcomphy-lab",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "# This will automatically set up a virtual environment and install dependencies# like BeautifulSoup4 for HTML processing./reset_install_requirements.sh# To activate the virtual environment for manual commands:source.venv/bin/activate",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Test documentation: Lid driven cavity using dye injection | Test documentation: Lid driven cavity using dye injection - C/C++ Code: C/C++ Code",
    "content": "#include\"navier-stokes/centered.h\"#include\"dye-injection.h\"// Constants#define LEVEL8// Grid refinement level#define MAXDT(1e-4)// Maximum timestep// Global variablesintimax=1e5;// Maximum iterationsdoubletmax=1.0;// Maximum simulation timedoubletsnap=0.01;// Time interval between snapshotsdoubleend=2.0;// End time for simulation// Scalar field for convergence checkscalar un[];// Previous x-velocityconstface vector muv[]={1.0,1.0};// Face-centered viscosity field/**## Boundary Conditions*/// Top moving wall (lid)u.t[top]=dirichlet(1);// Other no-slip boundariesu.t[bottom]=dirichlet(0);u.t[left]=dirichlet(0);u.t[right]=dirichlet(0);/**## Initialization*/event init(t=0){// Set constant viscosity for Newtonian fluidmu=muv;// Initialize velocity fieldforeach(){u.x[]=0;u.y[]=0;un[]=0;}dump(file=\"start\");}/**## Snapshot GenerationSave snapshots at regular intervals for flow visualization*/event writingFiles(t=0.;t+=tsnap;t<tmax+tsnap){charfilename[100];sprintf(filename,\"intermediate/snapshot-%5.4f\",t);dump(file=filename);}intmain(){// Initialize grid and parametersinit_grid(1<<LEVEL);L0=1.0;origin(-0.5,-0.5);DT=MAXDT;TOLERANCE=1e-5;CFL=0.25;// Store current velocity for convergence checkforeach(){un[]=u.x[];}// dye injection parameterstInjection=0.05;// Inject the dye after flow is establishedxInjection=0.00;// X position (center of cavity)yInjection=0.40;// Y position (upper center of cavity)// Create a folder for simulation snapshotscharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Run simulationrun();}",
    "url": "https://comphy-lab.org/documentationWeb/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Test documentation: Lid driven cavity using dye injection: Context",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # tested on MacOS only.",
    "url": "https://comphy-lab.org/documentationWeb/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Test documentation: Lid driven cavity using dye injection: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue. # modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk # Check if --hard flag is passed HARD_RESET = \\f alse if [[ \" \\$ 1\" == \"--hard\" ]]; then HARD_RESET = \\t rue fi # Function to install basilisk install_basilisk() { darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make -k make } # Remove project config always rm -rf .project_config # Check if basilisk needs to be installed if [[ \" \\$ HARD_RESET\" == true ]] || [[ ! -d \"basilisk\" ]]; then echo \"Installing basilisk...\" rm -rf basilisk install_basilisk else echo \"Using existing basilisk installation...\" cd basilisk/src fi # Setup environment variables echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config # Check if qcc is working properly echo \"\\nChecking qcc installation...\" if ! qcc --version > /dev/null 2 >& 1 ; then echo \"\\033[0;31mError: qcc is not working properly.\\033[0m\" echo \"Please ensure you have Xcode Command Line Tools installed.\" echo \"You can install them by running: xcode-select --install\" echo \"For more details, visit: http://basilisk.fr/src/INSTALL\" exit 1 else echo \"\\033[0;32mqcc is properly installed.\\033[0m\" qcc --version fi",
    "url": "https://comphy-lab.org/documentationWeb/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Test documentation: Lid driven cavity using dye injection - Code Example: #!/bin/zsh# tested on...",
    "content": "#!/bin/zsh# tested on MacOS only.",
    "url": "https://comphy-lab.org/documentationWeb/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Test documentation: Lid driven cavity using dye injection - Code Example: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue.# modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basilisk# Check if --hard flag is passedHARD_RESET=\\falseif[[\"\\$1\"==\"--hard\"]];thenHARD_RESET=\\truefi# Function to install basiliskinstall_basilisk(){darcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake-kmake}# Remove project config alwaysrm-rf.project_config# Check if basilisk needs to be installedif[[\"\\$HARD_RESET\"==true]]||[[!-d\"basilisk\"]];thenecho\"Installing basilisk...\"rm-rfbasiliskinstall_basiliskelseecho\"Using existing basilisk installation...\"cdbasilisk/srcfi# Setup environment variablesecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config# Check if qcc is working properlyecho\"\\nChecking qcc installation...\"if!qcc--version>/dev/null2>&1;thenecho\"\\033[0;31mError: qcc is not working properly.\\033[0m\"echo\"Please ensure you have Xcode Command Line Tools installed.\"echo\"You can install them by running: xcode-select --install\"echo\"For more details, visit: http://basilisk.fr/src/INSTALL\"exit1elseecho\"\\033[0;32mqcc is properly installed.\\033[0m\"qcc--versionfi",
    "url": "https://comphy-lab.org/documentationWeb/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases LidDrivenCavity-Newtonian-dyeInjection.c This simulation models a lid-driven cavity flow for a Newtonian fluid with constant viscosity and includes dye inject... Makefile ifeq (\\$(wildcard ../.projectconfig),) \\$(error '../.projectconfig not found') endif BASILISK := \\$(shell . ../.proje...",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Test documentation: Lid driven cavity using dye injection",
    "content": "simulationCases/Makefile See raw file Makefile # Check if .project_config exists ifeq ( \\$ ( wildcard ../.project_config ) , ) \\$ ( error \"../.project_config not found\" ) endif BASILISK := \\$ ( shell . ../.project_config && echo \\$\\$ BASILISK ) ifeq ( \\$ ( strip \\$ ( BASILISK )) , ) \\$ ( error \"BASILISK not set in .project_config\" ) endif CFLAGS += -O2 -disable-dimensions CFLAGS += -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local .PHONY: fix-permissions # Fix permissions for runtest script fix-permissions: @chmod +x \\$ ( BASILISK ) /src/runtest # Make all test targets depend on fix-permissions %.tst: fix-permissions include \\$ ( BASILISK ) /Makefile.defs",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/Makefile.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Test documentation: Lid driven cavity using dye injection - Code Example: Context",
    "content": "# Check if .project_config existsifeq(\\$(wildcard../.project_config),)\\$(error\"../.project_config not found\")endifBASILISK:=\\$(shell. ../.project_config&&echo\\$\\$BASILISK)ifeq(\\$(strip\\$(BASILISK)),)\\$(error\"BASILISK not set in .project_config\")endifCFLAGS+=-O2-disable-dimensionsCFLAGS+=-I\\$(PWD)/src-local-I\\$(PWD)/../src-local.PHONY:fix-permissions# Fix permissions for runtest scriptfix-permissions:@chmod+x\\$(BASILISK)/src/runtest# Make all test targets depend on fix-permissions%.tst:fix-permissionsinclude\\$(BASILISK)/Makefile.defs",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/Makefile.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection: Context",
    "content": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c See raw file Lid-Driven Cavity Flow of a Newtonian Fluid with dye Injection This simulation models a lid-driven cavity flow for a Newtonian fluid with constant viscosity and includes dye injection for flow visualization. This extends the classic benchmark case with a passive tracer to visualize flow patterns.",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection: Parameters Reynolds number:...",
    "content": "Parameters Reynolds number: \\(Re = \\frac{\\rho U L}{\\mu} = \\frac{1}{\\mu} \\quad \\text{(with } \\rho=1, U=1, L=1\\text{)}\\) We use \\(\\mu = 1.0\\) by default (Re = 1) dye injection at t=0.05 in the upper center of the cavity #include \"navier-stokes/centered.h\" #include \"dye-injection.h\" // Constants #define LEVEL 8 // Grid refinement level #define MAXDT ( 1e-4 ) // Maximum timestep // Global variables int imax = 1e5 ; // Maximum iterations double tmax = 1.0 ; // Maximum simulation time double tsnap = 0.01 ; // Time interval between snapshots double end = 2.0 ; // End time for simulation // Scalar field for convergence check scalar un []; // Previous x-velocity const face vector muv [] = { 1.0 , 1.0 }; // Face-centered viscosity field Boundary Conditions // Top moving wall (lid) u . t [ top ] = dirichlet ( 1 ); // Other no-slip boundaries u . t [ bottom ] = dirichlet ( 0 ); u . t [ left ] = dirichlet ( 0 ); u . t [ right ] = dirichlet ( 0 ); // uf.n[left] = 0; // uf.n[right] = 0; // uf.n[top] = 0; // uf.n[bottom] = 0; Initialization event init ( t = 0 ) { // Set constant viscosity for Newtonian fluid mu = muv ; // Initialize velocity field foreach () { u . x [] = 0 ; u . y [] = 0 ; un [] = 0 ; } dump ( file = \"start\" ); } Snapshot Generation Save snapshots at regular intervals for flow visualization event writingFiles ( t = 0. ; t += tsnap ; t < tmax + tsnap ) { char filename [ 100 ]; sprintf ( filename , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = filename ); } Logs simulation progress and convergence details.",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection: On each iteration,...",
    "content": "On each iteration, this event updates the stored x-velocity field for convergence checking and logs the current iteration number, timestep (dt), simulation time (t), and the convergence error (difference between the current and previous x-velocity fields) to the log file. event logfile ( i ++; i <= imax ) { foreach () { un [] = u . x []; } fprintf ( ferr , \"i = %d : dt = %g , t = %g , err = %g\\n \" , i , dt , t , change ( u . x , un )); } Outputs final simulation results for visualization. When the simulation reaches the end time, this event outputs the final state of simulation fields to a file named \u201cresults\u201d for post-processing and visualization. event end ( t = end ) { // Output fields in a format suitable for visualization dump ( file = \"results\" ); } Entry point for the lid-driven cavity flow simulation with dye injection.",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection: Initializes the computational...",
    "content": "Initializes the computational grid and simulation parameters (domain size, timestep, tolerance, and CFL condition), and stores the initial velocity field for convergence monitoring.",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection: Configures dye injection...",
    "content": "Configures dye injection settings by defining the injection time and location, creates a directory for saving intermediate simulation snapshots, and triggers the simulation run. @return int Exit status code (typically 0 upon successful completion). int main () { // Initialize grid and parameters init_grid ( 1 << LEVEL ); L0 = 1.0 ; origin (- 0.5 , - 0.5 ); DT = MAXDT ; TOLERANCE = 1e-5 ; CFL = 0.25 ; // Store current velocity for convergence check foreach () { un [] = u . x []; } // dye injection parameters tInjection = 0.05 ; // Inject the dye after flow is established xInjection = 0.00 ; // X position (center of cavity) yInjection = 0.40 ; // Y position (center of cavity) // Create a folder named intermediate where all the simulation snapshots are stored. char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Run simulation run (); }",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - C/C++ Code",
    "content": "#include\"navier-stokes/centered.h\"#include\"dye-injection.h\"// Constants#define LEVEL8// Grid refinement level#define MAXDT(1e-4)// Maximum timestep// Global variablesintimax=1e5;// Maximum iterationsdoubletmax=1.0;// Maximum simulation timedoubletsnap=0.01;// Time interval between snapshotsdoubleend=2.0;// End time for simulation// Scalar field for convergence checkscalar un[];// Previous x-velocityconstface vector muv[]={1.0,1.0};// Face-centered viscosity field",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "// Top moving wall (lid)u.t[top]=dirichlet(1);// Other no-slip boundariesu.t[bottom]=dirichlet(0);u.t[left]=dirichlet(0);u.t[right]=dirichlet(0);// uf.n[left]   = 0;// uf.n[right]  = 0;// uf.n[top]    = 0;// uf.n[bottom] = 0;",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "event init(t=0){// Set constant viscosity for Newtonian fluidmu=muv;// Initialize velocity fieldforeach(){u.x[]=0;u.y[]=0;un[]=0;}dump(file=\"start\");}",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "event writingFiles(t=0.;t+=tsnap;t<tmax+tsnap){charfilename[100];sprintf(filename,\"intermediate/snapshot-%5.4f\",t);dump(file=filename);}",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "event logfile(i++;i<=imax){foreach(){un[]=u.x[];}fprintf(ferr,\"i =%d: dt =%g, t =%g, err =%g\\n\",i,dt,t,change(u.x,un));}",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "event end(t=end){// Output fields in a format suitable for visualizationdump(file=\"results\");}",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c | Test documentation: Lid driven cavity using dye injection - Code Example: intmain(){// Initialize grid...",
    "content": "intmain(){// Initialize grid and parametersinit_grid(1<<LEVEL);L0=1.0;origin(-0.5,-0.5);DT=MAXDT;TOLERANCE=1e-5;CFL=0.25;// Store current velocity for convergence checkforeach(){un[]=u.x[];}// dye injection parameterstInjection=0.05;// Inject the dye after flow is establishedxInjection=0.00;// X position (center of cavity)yInjection=0.40;// Y position (center of cavity)// Create a folder named intermediate where all the simulation snapshots are stored.charcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Run simulationrun();}",
    "url": "https://comphy-lab.org/documentationWeb/simulationCases/LidDrivenCavity-Newtonian-dyeInjection.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files dye-injection.h This module introduces a circular tracer (dye) into the flow at a specified time and location. The dye then advects w...",
    "url": "https://comphy-lab.org/documentationWeb/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/dye-injection.h | Test documentation: Lid driven cavity using dye injection: Context",
    "content": "src-local/dye-injection.h See raw file dye Injection for Flow Visualization This module introduces a circular tracer (dye) into the flow at a specified time and location. The dye then advects with the flow, allowing visualization of flow patterns. This is useful for visualizing complex flow structures in simulations like lid-driven cavity flow.",
    "url": "https://comphy-lab.org/documentationWeb/src-local/dye-injection.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/dye-injection.h | Test documentation: Lid driven cavity using dye injection: C/C++ Code",
    "content": "Parameters tInjection : time at which to inject the dye xInjection , yInjection : position where the dye is injected dyeRadius : radius of the circular dye #include \"tracer.h\" // dye tracer parameters (can be overridden by the user) double tInjection = 0.1 ; // Default injection time double xInjection = 0.0 ; // Default X-position for injection double yInjection = 0.0 ; // Default Y-position for injection double dyeRadius = 0.05 ; // Default radius of the circular dye // Define the scalar field for the dye scalar T []; scalar * tracers = { T }; // Initialize the dye tracer to zero everywhere event init ( t = 0 ) { foreach () T [] = 0.0 ; } // Inject the dye at the specified time event inject_dye ( t = tInjection ) { fprintf ( stderr , \"Injecting dye at t = %g , position = ( %g , %g ), radius = %g\\n \" , t , xInjection , yInjection , dyeRadius ); // Set dye concentration to 1.0 within the circular region foreach () { double dist = sqrt ( sq ( x - xInjection ) + sq ( y - yInjection )); if ( dist <= dyeRadius ) T [] = 1.0 ; } }",
    "url": "https://comphy-lab.org/documentationWeb/src-local/dye-injection.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/dye-injection.h | Test documentation: Lid driven cavity using dye injection - C/C++ Code: C/C++ Code",
    "content": "#include\"tracer.h\"// dye tracer parameters (can be overridden by the user)doubletInjection=0.1;// Default injection timedoublexInjection=0.0;// Default X-position for injectiondoubleyInjection=0.0;// Default Y-position for injectiondoubledyeRadius=0.05;// Default radius of the circular dye// Define the scalar field for the dyescalar T[];scalar*tracers={T};// Initialize the dye tracer to zero everywhereevent init(t=0){foreach()T[]=0.0;}// Inject the dye at the specified timeevent inject_dye(t=tInjection){fprintf(stderr,\"Injecting dye at t =%g, position = (%g,%g), radius =%g\\n\",t,xInjection,yInjection,dyeRadius);// Set dye concentration to 1.0 within the circular regionforeach(){doubledist=sqrt(sq(x-xInjection)+sq(y-yInjection));if(dist<=dyeRadius)T[]=1.0;}}",
    "url": "https://comphy-lab.org/documentationWeb/src-local/dye-injection.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection: Context",
    "content": "postProcess/getData-LidDriven.c See raw file getting Data from simulation snapshot Author Vatsal Sanjay Email: vatsalsy@comphy-lab.org CoMPhy Lab Physics of Fluids Department Last updated: Mar 8, 2025 #include \"utils.h\" #include \"output.h\" #include \"poisson.h\" vector u []; char filename [ 1000 ]; int nx , ny , len ; double xmin , ymin , xmax , ymax , Deltax , Deltay ; scalar T [], vel [], psi [], omega []; scalar * list = NULL ; Main entry point for processing fluid dynamics simulation data. This function validates the command-line arguments and initializes the simulation by reading in the file name and domain parameters (xmin, ymin, xmax, ymax, ny). It registers the necessary scalar fields (T, vel, psi), restores simulation data, applies Dirichlet boundary conditions for both the velocity and streamfunction, computes the velocity magnitude and vorticity, and then solves the Poisson equation to update the streamfunction.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection: Finally, it calculates...",
    "content": "Finally, it calculates grid spacing and interpolates the scalar fields over the designated grid. Command-line arguments: arguments[0]: Program name. arguments[1]: Filename of the simulation snapshot. arguments[2]: Lower bound (xmin) of the x-domain. arguments[3]: Lower bound (ymin) of the y-domain. arguments[4]: Upper bound (xmax) of the x-domain. arguments[5]: Upper bound (ymax) of the y-domain. arguments[6]: Number of grid points along the y-direction (ny).",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection: C/C++ Main",
    "content": "Return Returns 1 if the argument validation fails; otherwise, the program proceeds with simulation processing. int main ( int a , char const * arguments []) { if ( a != 7 ) { fprintf ( ferr , \"Error: Expected 6 arguments \\n \" ); fprintf ( ferr , \"Usage: %s <filename> <xmin> <ymin> <xmax> <ymax> <ny> \\n \" , arguments [ 0 ]); return 1 ; } sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); list = list_add ( list , T ); list = list_add ( list , vel ); list = list_add ( list , psi ); /* Actual run and codes! */ restore ( file = filename ); // Top moving wall u . t [ top ] = dirichlet ( 1 ); For the other no-slip boundaries this gives u . t [ bottom ] = dirichlet ( 0 ); u . t [ left ] = dirichlet ( 0 ); u . t [ right ] = dirichlet ( 0 ); // solve for the streamfunction psi [ top ] = dirichlet ( 0 ); psi [ bottom ] = dirichlet ( 0 ); psi [ left ] = dirichlet ( 0 ); psi [ right ] = dirichlet ( 0 ); foreach () { vel [] = sqrt ( sq ( u . x [])+ sq ( u . y [])); } foreach () { omega [] = ( u . y [ 1 ] - u . y [- 1 ] - u . x [ 0 , 1 ] + u . x [ 0 ,- 1 ])/( 2. * Delta ); psi [] = 0. ; } poisson ( psi , omega ); FILE * fp = ferr ; Deltay = ( double )(( ymax - ymin )/( ny )); // fprintf(ferr, \"%g\\n\", Deltay); nx = ( int )(( xmax - xmin )/ Deltay ); // fprintf(ferr, \"%d\\n\", nx); Deltax = ( double )(( xmax - xmin )/( nx )); // fprintf(ferr, \"%g\\n\", Deltax); len = list_len ( list ); // fprintf(ferr, \"%d\\n\", len); double ** field = ( double **) matrix_new ( nx , ny + 1 , len * sizeof ( double )); for ( int i = 0 ; i < nx ; i ++) { double x = Deltax *( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay *( j + 1. / 2 ) + ymin ; int k = 0 ; for ( scalar s in list ){ field [ i ][ len * j + k ++] = interpolate ( s , x , y ); } } } for ( int i = 0 ; i < nx ; i ++) { double x = Deltax *( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay *( j + 1. / 2 ) + ymin ; fprintf ( fp , \" %g %g \" , x , y ); int k = 0 ; for ( scalar s in list ){ fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } fflush ( fp ); fclose ( fp ); matrix_free ( field ); }",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"poisson.h\"vector u[];charfilename[1000];intnx,ny,len;doublexmin,ymin,xmax,ymax,Deltax,Deltay;scalar T[],vel[],psi[],omega[];scalar*list=NULL;",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection - Code Example",
    "content": "intmain(inta,charconst*arguments[]){if(a!=7){fprintf(ferr,\"Error: Expected 6 arguments\\n\");fprintf(ferr,\"Usage:%s<filename> <xmin> <ymin> <xmax> <ymax> <ny>\\n\",arguments[0]);return1;}sprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);list=list_add(list,T);list=list_add(list,vel);list=list_add(list,psi);/*Actual run and codes!*/restore(file=filename);// Top moving wallu.t[top]=dirichlet(1);",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-LidDriven.c | Test documentation: Lid driven cavity using dye injection - Code Example: Context",
    "content": "u.t[bottom]=dirichlet(0);u.t[left]=dirichlet(0);u.t[right]=dirichlet(0);// solve for the streamfunctionpsi[top]=dirichlet(0);psi[bottom]=dirichlet(0);psi[left]=dirichlet(0);psi[right]=dirichlet(0);foreach(){vel[]=sqrt(sq(u.x[])+sq(u.y[]));}foreach(){omega[]=(u.y[1]-u.y[-1]-u.x[0,1]+u.x[0,-1])/(2.*Delta);psi[]=0.;}poisson(psi,omega);FILE*fp=ferr;Deltay=(double)((ymax-ymin)/(ny));// fprintf(ferr, \"%g\\n\", Deltay);nx=(int)((xmax-xmin)/Deltay);// fprintf(ferr, \"%d\\n\", nx);Deltax=(double)((xmax-xmin)/(nx));// fprintf(ferr, \"%g\\n\", Deltax);len=list_len(list);// fprintf(ferr, \"%d\\n\", len);double**field=(double**)matrix_new(nx,ny+1,len*sizeof(double));for(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y);}}}for(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;fprintf(fp,\"%g%g\",x,y);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}fflush(fp);fclose(fp);matrix_free(field);}",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/getData-LidDriven.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData-LidDriven.c Vatsal Sanjay Email: vatsalsy@comphy-lab.org CoMPhy Lab Physics of Fluids Department Last updated: Mar 8, 2025 ~~~c LidDrivenCavity-Newtonian-dyeInjection.ipynb Import all relevant libraries. LidDrivenCavity-Newtonian-dyeInjection.py Rtemp, Ztemp, Ttemp, veltemp, Psitemp = [],[],[],[], [] for n1 in range(len(temp2)): temp3 = temp2[n1].split(' ') if ...",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: Import Statements",
    "content": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py See raw file import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter from mpl_toolkits.axes_grid1 import make_axes_locatable import argparse # Add at top with other imports import multiprocessing as mp from functools import partial matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' def gettingfield(filename, zmin, zmax, rmin, rmax, nr): Extract simulation field data from a simulation file. This function executes the external program \u201cgetData-LidDriven\u201d with the given simulation file and boundary parameters to extract numerical data for axial and radial coordinates, temperature, velocity, and stream function.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: The output is...",
    "content": "The output is parsed into NumPy arrays, reshaped to a (nz, nr) grid based on the number of radial grid points (nr), rotated 90\u00b0 counterclockwise, and flipped vertically to ensure the correct orientation for further processing. It returns the processed field arrays along with the total number of axial grid points (nz). Args: filename: Path to the simulation data file. zmin: Minimum axial coordinate. zmax: Maximum axial coordinate. rmin: Minimum radial coordinate. rmax: Maximum radial coordinate. nr: Number of grid points in the radial direction.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: Returns: tuple: A...",
    "content": "Returns: tuple: A tuple containing: - R (numpy.ndarray): 2D array of radial coordinate values. - Z (numpy.ndarray): 2D array of axial coordinate values. - T (numpy.ndarray): 2D array of temperature values. - vel (numpy.ndarray): 2D array of velocity values. - psi (numpy.ndarray): 2D array of stream function values. - nz (int): Number of grid points in the axial direction. exe = [ \"./getData-LidDriven\" , filename, str (zmin), str (rmin), str (zmax), str (rmax), str (nr)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, Ttemp, veltemp, Psitemp = [],[],[],[], [] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) Ttemp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) Psitemp.append( float (temp3[ 4 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) T = np.asarray(Ttemp) vel = np.asarray(veltemp) psi = np.asarray(Psitemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) T.resize((nz, nr)) vel.resize((nz, nr)) psi.resize((nz, nr)) # rotate the arrays by 90 degrees R = np.rot90(R, k = 1 ) Z = np.rot90(Z, k = 1 ) T = np.rot90(T, k = 1 ) vel = np.rot90(vel, k = 1 ) psi = np.rot90(psi, k = 1 ) # flip the array R = np.flip(R, axis = 0 ) Z = np.flip(Z, axis = 0 ) T = np.flip(T, axis = 0 ) vel = np.flip(vel, axis = 0 ) psi = np.flip(psi, axis = 0 ) return R, Z, T, vel, psi, nz # ---------------------------------------------------------------------------------------------------------------------- def process_timestep(ti, caseToProcess, folder, tsnap, GridsPerR, rmin, rmax, zmin, zmax, lw): Generates and saves a two-panel plot for a simulation timestep.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: Calculates the simulation...",
    "content": "Calculates the simulation time using the timestep index and a time increment, then retrieves field data from an intermediate snapshot file. Creates a figure with two subplots\u2014one displaying the dye color (with a coolwarm heat map) and the other showing velocity magnitude (with a viridis heat map). Both panels include domain boundaries and streamlines for the stream function.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: Function Definition",
    "content": "If the snapshot file is missing or the output image already exists, the function prints a warning and exits. t = tsnap * ti place = f\" { caseToProcess } /intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" # Check if the file exists if not os.path.exists(place): print ( f\" { place } File not found!\" ) return # if name exits, return if os.path.exists(name): print ( f\" { name } already exists!\" ) return # if folder does not exist, create it if not os.path.exists(folder): os.makedirs(folder) # Calculate number of grid points in r-direction based on domain size nr = int (GridsPerR * rmax) # Extract field data from the simulation file R, Z, T, vel, psi, nz = gettingfield(place, zmin, zmax, rmin, rmax, nr) # Get actual domain bounds from the data zminp, zmaxp, rminp, rmaxp = Z. min (), Z. max (), R. min (), R. max () # Set up the figure with two subplots AxesLabel, TickLabel = 50 , 20 fig, (ax1, ax2) = plt.subplots( 1 , 2 , figsize = ( 24 , 11 ), constrained_layout = True ) # First subplot - Rate of Strain Tensor (D2) # Draw domain boundaries ax1.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax1.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax1.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax1.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Plot the dye with a heat map cntrl1 = ax1.pcolormesh(Z, R, T, cmap = \"coolwarm\" , edgecolor = 'face' , vmax = 1 , vmin = 0 ) # Add streamlines using the stream function ax1.contour(Z, R, psi, 20 , colors = 'black' , linewidths = 2 ) # Configure the first subplot ax1.set_aspect( 'equal' ) ax1.set_xlim(rmin, rmax) ax1.set_ylim(zmin, zmax) ax1.set_title( r'Rate of Strain Tensor' , fontsize = TickLabel) # Add colorbar to the first subplot divider1 = make_axes_locatable(ax1) cax1 = divider1.append_axes( \"right\" , size = \"5%\" , pad = 0.1 ) c1 = plt.colorbar(cntrl1, cax = cax1) c1.set_label( r' $ log_ {10} ( \\| \\m athcal{D}_{ij} \\| ) $ ' , fontsize = TickLabel, labelpad = 5 ) c1.ax.tick_params(labelsize = TickLabel) # Second subplot - Velocity Magnitude # Draw domain boundaries ax2.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax2.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax2.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax2.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Plot velocity magnitude with viridis colormap cntrl2 = ax2.pcolormesh(Z, R, vel, cmap = \"viridis\" , edgecolor = 'face' , vmax = 1 , vmin = 0 ) # Add streamlines using the stream function ax2.contour(Z, R, psi, 20 , colors = 'black' , linewidths = 2 ) # Configure the second subplot ax2.set_aspect( 'equal' ) ax2.set_xlim(rmin, rmax) ax2.set_ylim(zmin, zmax) ax2.set_title( r'Velocity Magnitude' , fontsize = TickLabel) # Add colorbar to the second subplot divider2 = make_axes_locatable(ax2) cax2 = divider2.append_axes( \"right\" , size = \"5%\" , pad = 0.1 ) c2 = plt.colorbar(cntrl2, cax = cax2) c2.set_label( r'Velocity' , fontsize = TickLabel, labelpad = 5 ) c2.ax.tick_params(labelsize = TickLabel) # Turn off axes for cleaner visualization ax1.axis( 'off' ) ax2.axis( 'off' ) plt.savefig(name, bbox_inches = 'tight' ) # Display the figure plt.close() def main(): # Get number of CPUs from command line argument, or use all available Parses command-line arguments and processes simulation timesteps in parallel.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection: Reads simulation and...",
    "content": "Reads simulation and processing parameters from the command line, prepares the output directory, and uses a multiprocessing pool to generate visualizations for each simulation timestep concurrently. parser = argparse.ArgumentParser() parser.add_argument( '--CPUs' , type = int , default = mp.cpu_count(), help = 'Number of CPUs to use' ) parser.add_argument( '--nGFS' , type = int , default = 150 , help = 'Number of restart files to process' ) parser.add_argument( '--GridsPerR' , type = int , default = 512 , help = 'Number of grids per R' ) parser.add_argument( '--ZMAX' , type = float , default = 0.5 , help = 'Maximum Z value' ) parser.add_argument( '--RMAX' , type = float , default = 0.5 , help = 'Maximum R value' ) parser.add_argument( '--ZMIN' , type = float , default =- 0.5 , help = 'Minimum Z value' ) parser.add_argument( '--RMIN' , type = float , default =- 0.5 , help = 'Minimum R value' ) parser.add_argument( '--tsnap' , type = float , default = 0.01 , help = 'Time snap' ) parser.add_argument( '--caseToProcess' , type = str , default = '../simulationCases/LidDrivenCavity-Newtonian-dyeInjection' , help = 'Case to process' ) parser.add_argument( '--folderToSave' , type = str , default = 'LidDrivenCavity-Newtonian-dyeInjection' , help = 'Folder to save' ) args = parser.parse_args() num_processes = args.CPUs nGFS = args.nGFS tsnap = args.tsnap ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN RMIN = args.RMIN rmin, rmax, zmin, zmax = [RMIN, RMAX, ZMIN, ZMAX] GridsPerR = args.GridsPerR lw = 2 folder = args.folderToSave caseToProcess = args.caseToProcess if not os.path.isdir(folder): os.makedirs(folder) # Create a pool of worker processes with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments process_func = partial(process_timestep, caseToProcess = caseToProcess, folder = folder, tsnap = tsnap, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw) # Map the process_func to all timesteps pool. map (process_func, range (nGFS)) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection - Code Example: Methods",
    "content": "importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterfrommpl_toolkits.axes_grid1importmake_axes_locatableimportargparse# Add at top with other importsimportmultiprocessingasmpfromfunctoolsimportpartialmatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'defgettingfield(filename, zmin, zmax, rmin, rmax, nr):",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection - Code Example: Context",
    "content": "exe=[\"./getData-LidDriven\", filename,str(zmin),str(rmin),str(zmax),str(rmax),str(nr)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, Ttemp, veltemp, Psitemp=[],[],[],[], []forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))Ttemp.append(float(temp3[2]))veltemp.append(float(temp3[3]))Psitemp.append(float(temp3[4]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)T=np.asarray(Ttemp)vel=np.asarray(veltemp)psi=np.asarray(Psitemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))T.resize((nz, nr))vel.resize((nz, nr))psi.resize((nz, nr))# rotate the arrays by 90 degreesR=np.rot90(R, k=1)Z=np.rot90(Z, k=1)T=np.rot90(T, k=1)vel=np.rot90(vel, k=1)psi=np.rot90(psi, k=1)# flip the arrayR=np.flip(R, axis=0)Z=np.flip(Z, axis=0)T=np.flip(T, axis=0)vel=np.flip(vel, axis=0)psi=np.flip(psi, axis=0)returnR, Z, T, vel, psi, nz# ----------------------------------------------------------------------------------------------------------------------defprocess_timestep(ti, caseToProcess, folder, tsnap, GridsPerR, rmin, rmax, zmin, zmax, lw):",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection - Code Example: Context",
    "content": "t=tsnap*tiplace=f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"# Check if the file existsifnotos.path.exists(place):print(f\"{place}File not found!\")return# if name exits, returnifos.path.exists(name):print(f\"{name}already exists!\")return# if folder does not exist, create itifnotos.path.exists(folder):os.makedirs(folder)# Calculate number of grid points in r-direction based on domain sizenr=int(GridsPerR*rmax)# Extract field data from the simulation fileR, Z, T, vel, psi, nz=gettingfield(place, zmin, zmax, rmin, rmax, nr)# Get actual domain bounds from the datazminp, zmaxp, rminp, rmaxp=Z.min(), Z.max(), R.min(), R.max()# Set up the figure with two subplotsAxesLabel, TickLabel=50,20fig, (ax1, ax2)=plt.subplots(1,2, figsize=(24,11), constrained_layout=True)# First subplot - Rate of Strain Tensor (D2)# Draw domain boundariesax1.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)ax1.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax1.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax1.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Plot the dye with a heat mapcntrl1=ax1.pcolormesh(Z, R, T, cmap=\"coolwarm\", edgecolor='face', vmax=1, vmin=0)# Add streamlines using the stream functionax1.contour(Z, R, psi,20, colors='black', linewidths=2)# Configure the first subplotax1.set_aspect('equal')ax1.set_xlim(rmin, rmax)ax1.set_ylim(zmin, zmax)ax1.set_title(r'Rate of Strain Tensor', fontsize=TickLabel)# Add colorbar to the first subplotdivider1=make_axes_locatable(ax1)cax1=divider1.append_axes(\"right\", size=\"5%\", pad=0.1)c1=plt.colorbar(cntrl1, cax=cax1)c1.set_label(r'$log_{10}(\\|\\mathcal{D}_{ij}\\|)$', fontsize=TickLabel, labelpad=5)c1.ax.tick_params(labelsize=TickLabel)# Second subplot - Velocity Magnitude# Draw domain boundariesax2.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)ax2.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax2.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax2.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Plot velocity magnitude with viridis colormapcntrl2=ax2.pcolormesh(Z, R, vel, cmap=\"viridis\", edgecolor='face', vmax=1, vmin=0)# Add streamlines using the stream functionax2.contour(Z, R, psi,20, colors='black', linewidths=2)# Configure the second subplotax2.set_aspect('equal')ax2.set_xlim(rmin, rmax)ax2.set_ylim(zmin, zmax)ax2.set_title(r'Velocity Magnitude', fontsize=TickLabel)# Add colorbar to the second subplotdivider2=make_axes_locatable(ax2)cax2=divider2.append_axes(\"right\", size=\"5%\", pad=0.1)c2=plt.colorbar(cntrl2, cax=cax2)c2.set_label(r'Velocity', fontsize=TickLabel, labelpad=5)c2.ax.tick_params(labelsize=TickLabel)# Turn off axes for cleaner visualizationax1.axis('off')ax2.axis('off')plt.savefig(name, bbox_inches='tight')# Display the figureplt.close()defmain():# Get number of CPUs from command line argument, or use all available",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.py | Test documentation: Lid driven cavity using dye injection - Code Example: Context",
    "content": "parser=argparse.ArgumentParser()parser.add_argument('--CPUs',type=int, default=mp.cpu_count(),help='Number of CPUs to use')parser.add_argument('--nGFS',type=int, default=150,help='Number of restart files to process')parser.add_argument('--GridsPerR',type=int, default=512,help='Number of grids per R')parser.add_argument('--ZMAX',type=float, default=0.5,help='Maximum Z value')parser.add_argument('--RMAX',type=float, default=0.5,help='Maximum R value')parser.add_argument('--ZMIN',type=float, default=-0.5,help='Minimum Z value')parser.add_argument('--RMIN',type=float, default=-0.5,help='Minimum R value')parser.add_argument('--tsnap',type=float, default=0.01,help='Time snap')parser.add_argument('--caseToProcess',type=str, default='../simulationCases/LidDrivenCavity-Newtonian-dyeInjection',help='Case to process')parser.add_argument('--folderToSave',type=str, default='LidDrivenCavity-Newtonian-dyeInjection',help='Folder to save')args=parser.parse_args()num_processes=args.CPUsnGFS=args.nGFStsnap=args.tsnapZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMINRMIN=args.RMINrmin, rmax, zmin, zmax=[RMIN, RMAX, ZMIN, ZMAX]GridsPerR=args.GridsPerRlw=2folder=args.folderToSavecaseToProcess=args.caseToProcessifnotos.path.isdir(folder):os.makedirs(folder)# Create a pool of worker processeswithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed argumentsprocess_func=partial(process_timestep, caseToProcess=caseToProcess,folder=folder, tsnap=tsnap,GridsPerR=GridsPerR, rmin=rmin, rmax=rmax,zmin=zmin, zmax=zmax, lw=lw)# Map the process_func to all timestepspool.map(process_func,range(nGFS))if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.ipynb | Test documentation: Lid driven cavity using dye injection",
    "content": "postProcess/LidDrivenCavity-Newtonian-dyeInjection.ipynb See raw file Post-processing test for Lid-Driven Cavity flow with dye injection. Jupyter Notebook: Post-processing test for Lid-Driven Cavity flow with dye injection. Download Notebook View in nbviewer Open in Colab About this notebook Import all relevant libraries. Key Features: Visualization of data and results Analysis of simulation outputs Interactive exploration of parameters Tip: For the best interactive experience, download the notebook or open it in Google Colab. Notebook Preview Notebook Preview Unavailable The notebook preview could not be loaded. This may be because: The notebook file is not yet available in the repository The nbviewer service is temporarily unavailable The repository is private or has access restrictions You can still download the notebook using the button above or view it directly through one of the external services.",
    "url": "https://comphy-lab.org/documentationWeb/postProcess/LidDrivenCavity-Newtonian-dyeInjection.ipynb.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: ElastoFlow: 2D/3D Viscoelastic...",
    "content": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework \ud83d\ude80 ElastoFlow is a state-of-the-art, open-source framework for simulating viscoelastic fluid flows in 2D and 3D, built as an extension to the Basilisk C CFD library.",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Methods",
    "content": "It implements the log-conformation method for robust, high-Weissenberg number simulations, with a focus on clarity, extensibility, and scientific rigor. \u2728 Key Features Full 3D Log-Conformation Method : Complete scalar implementation for 3D viscoelastic fluids ( log-conform-viscoelastic-scalar-3D.h ) Robust 2D/Axi Support : Scalar and tensor-based log-conformation for 2D and axisymmetric cases ( log-conform-viscoelastic-scalar-2D.h , log-conform-viscoelastic.h ) Optimized Matrix Algebra : Efficient, stable eigenvalue and tensor operations ( eigen_decomposition.h ) Advanced Initialization : Functions for pseudo vectors/tensors in 2D/3D Error Handling : Negative eigenvalue checks, eigenvalue clamping, and detailed diagnostics Performance : Simplified acceleration term calculations and optimized tensor operations Documentation : Extensive inline documentation, mathematical background, and verification notes Compatibility : GPLv3 license, fully compatible with Basilisk and previous ElastoFlow versions \ud83d\udc1b Bug Fixes (v2.5/v2.6) Corrected matrix algebra in 3D Fixed rotation tensor and eigenvalue edge cases Improved error reporting and diagnostics Enhanced axisymmetric and 2D/3D compatibility \ud83d\uddc2\ufe0f Repository Structure basilisk/src/ - # Core Basilisk CFD library (reference only, do not modify) src-local/ - # Custom viscoelastic solvers and tensor utilities log-conform-viscoelastic-scalar-3D.h - # 3D log-conformation (scalar) log-conform-viscoelastic-scalar-2D.h - # 2D/axi log-conformation (scalar) log-conform-viscoelastic.h - # 2D/axi log-conformation (tensor) two-phaseVE.h - # Two-phase viscoelastic extension eigen_decomposition.h - # 3x3 symmetric eigenvalue solver simulationCases/ - # Example/test cases and post-processing scripts dropAtomisation.c - # 3D drop atomisation simulation pinchOff.c - # Pinch-off of viscoelastic jet (2D/axi) testEigenDecomposition.c - # Eigenvalue solver test/verification dropImpact.c - # Drop impact simulation verifyWtihPlots.ipynb - # Jupyter notebook for verification/plots postProcess/ - # Project-specific post-processing tools and utilities getData-elastic-scalar2D.c - # Data extraction utility getFacet2D.c - # Facet extraction utility VideoAxi.py - # Python visualization script \ud83d\udcda Documentation docs/ \u2014 Full HTML documentation, mathematical background, and API Inline documentation in all major headers (see src-local/ ) Example simulation and post-processing scripts in simulationCases/ \ud83d\ude80 Quick Start 1.",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Prerequisites Basilisk C...",
    "content": "Prerequisites Basilisk C (included as submodule in basilisk/ ) C compiler (e.g., gcc) Python 3 (for post-processing) Optional: Jupyter for notebooks 2. Compiling & Running Simulations A. Vanilla Basilisk method: qcc -O2 -Wall -I. /src-local -disable-dimensions simulationCases/{CaseName}.c -o {CaseName} -lm ./{CaseName} B. Using the Makefile (with bview browser): CFLAGS = -DDISPLAY=-1 make simulationCases/{CaseName}.tst For interactive visualization, open the generated display.html in your browser (see Basilisk bview ). 3. Post-Processing & Analysis Python scripts and Jupyter notebooks for data extraction and visualization are in simulationCases/ (e.g., VideoAxi.py , verifyWtihPlots.ipynb ).",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Examples",
    "content": "Example utilities: getData-elastic-scalar2D.c , getFacet2D.c . \ud83d\udcdd Example: Running a 3D Drop Atomisation Simulation qcc -O2 -Wall -I. /src-local -disable-dimensions simulationCases/dropAtomisation.c -o dropAtomisation -lm ./dropAtomisation \ud83d\udd0d Technical Details Log-Conformation Method : See src-local/log-conform-viscoelastic-scalar-3D.h and src-local/log-conform-viscoelastic-scalar-2D.h for mathematical background and implementation notes. Eigenvalue Solver : src-local/eigen_decomposition.h provides robust 3x3 symmetric eigensystem routines. Two-Phase Flows : src-local/two-phaseVE.h extends Basilisk\u2019s two-phase solver for viscoelasticity. Axisymmetric/2D/3D : Use the appropriate header for your geometry (see comments in each header for guidance). \ud83e\uddd1\u200d\ud83d\udcbb Contributing See CLAUDE.md for code style and development guidelines. Issue templates and feature requests: GitHub Issue Templates Pull requests are welcome!",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Examples",
    "content": "Please document your changes and update relevant tests/examples. \ud83d\udccb License This project is licensed under the GNU GPLv3 , in line with the Basilisk codebase. \ud83d\ude4f Acknowledgments Thanks to all contributors and the Basilisk community \ud83d\udd17 References Fattal & Kupferman (2004, 2005): Log-conformation method Comminal et al. (2015): Constitutive model functions Hao & Pan (2007): Split scheme implementation Basilisk C For detailed documentation, see the docs/ folder or open docs/index.html in your browser.",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Generated Documentation Root...",
    "content": "Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/VideoAxi.py postProcess/getData-elastic-scalar2D.c postProcess/getFacet2D.c simulationCases simulationCases/dropAtomisation.c simulationCases/dropImpact.c simulationCases/pinchOff.c simulationCases/testEigenDecomposition.c simulationCases/verifyWtihPlots.ipynb src-local src-local/eigen_decomposition.h src-local/log-conform-viscoelastic-scalar-2D.h src-local/log-conform-viscoelastic-scalar-3D.h src-local/log-conform-viscoelastic.h src-local/two-phaseVE.h",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "qcc-O2-Wall-I./src-local-disable-dimensionssimulationCases/{CaseName}.c-o{CaseName}-lm./{CaseName}",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "CFLAGS=-DDISPLAY=-1makesimulationCases/{CaseName}.tst",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "qcc-O2-Wall-I./src-local-disable-dimensionssimulationCases/dropAtomisation.c-odropAtomisation-lm./dropAtomisation",
    "url": "https://comphy-lab.org/Viscoelastic3D/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # MacOS only. modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk rm -rf basilisk rm -rf .project_config darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config",
    "url": "https://comphy-lab.org/Viscoelastic3D/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#!/bin/zsh# MacOS only. modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basiliskrm-rfbasiliskrm-rf.project_configdarcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimakeecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config",
    "url": "https://comphy-lab.org/Viscoelastic3D/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Methods",
    "content": "simulationCases/dropImpact.c See raw file Drop Impact Simulation This file contains the simulation code for drop impact on a solid surface using a Volume of Fluid (VOF) method with viscoelastic fluid modeling capabilities. The simulation uses an adaptive mesh refinement approach to efficiently resolve the interface dynamics during impact. The model can handle both Newtonian and viscoelastic fluids through a log-conformation formulation for the polymeric stress tensor. Physical Model The simulation solves the Navier-Stokes equations for incompressible flow coupled with a viscoelastic constitutive equation. The interface between the two fluids is tracked using a VOF method with surface tension.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Key dimensionless parameters:...",
    "content": "Key dimensionless parameters: Weber number ( \\(We\\) ): Ratio of inertia to surface tension Ohnesorge number ( \\(Oh\\) ): Ratio of viscous to inertial and surface tension forces Deborah number ( \\(De\\) ): Ratio of relaxation time to characteristic flow time Elastocapillary number ( \\(Ec\\) ): Ratio of elastic to capillary forces @file dropImpact.c @author Vatsal Sanjay @version 0.2 @date Oct 18, 2024 // #include \"axi.h\" #include \"grid/octree.h\" // #include \"grid/quadtree.h\" #include \"navier-stokes/centered.h\" #define VANILLA 0 36 #if VANILLA #include \"log-conform-viscoelastic.h\" #define logFile \"logAxi-vanilla.dat\" 39 #else #if AXI #include \"log-conform-viscoelastic-scalar-2D.h\" #define logFile \"logAxi-scalar.dat\" 43 #else #include \"log-conform-viscoelastic-scalar-3D.h\" #define logFile \"log3D-scalar.dat\" 46 #endif #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" Simulation Parameters Timing Parameters tsnap: Time interval between snapshots (1e-2) #define tsnap ( 1e-2 ) 62 63 Numerical Error Tolerances fErr: Error tolerance in VOF function f1 (1e-3) KErr: Error tolerance in VOF curvature calculated using height function method (1e-6) VelErr: Error tolerances in velocity (1e-2) Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define fErr ( 1e-3 ) 71 #define KErr ( 1e-6 ) 72 #define VelErr ( 1e-2 ) 73 74 Domain Configuration xDist: Initial horizontal displacement of droplet center from boundary (5e-2) R2: Function to calculate squared distance from droplet center #define xDist ( 5e-2 ) 80 #define R2 ( x , y , z ) ( sq ( x - 1. - xDist ) + sq ( y ) + sq ( z )) 81 82 Boundary Conditions Dirichlet boundary condition for volume fraction at left boundary.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Note: No-slip boundary...",
    "content": "Note: No-slip boundary conditions are commented out for testing purposes. // u.t[left] = dirichlet(0.); // todo: later on use no-slip. For testing, free-slip is faster. // u.r[left] = dirichlet(0.); // todo: later on use no-slip. For testing, free-slip is faster. f [ left ] = dirichlet ( 0.0 ); Global Variables MAXlevel: Maximum level of grid refinement We: Weber number of the drop Oh: Solvent Ohnesorge number Oha: Air Ohnesorge number De: Deborah number Ec: Elasto-capillary number tmax: Maximum simulation time nameOut: Output filename for snapshots dumpFile: Filename for restart dumps int MAXlevel ; double We , Oh , Oha , De , Ec , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; Main Function Initializes the simulation parameters and grid, then starts the simulation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: C/C++ Main",
    "content": "Parameters argc: Command-line argument count argv: Command-line argument array Return Value Returns 0 on successful completion int main ( int argc , char const * argv []) { dtmax = 1e-5 ; L0 = 4.0 ; // Values taken from the terminal MAXlevel = 6 ; tmax = 3.0 ; We = 5.0 ; Oh = 1e-2 ; Oha = 1e-2 * Oh ; De = 1.0 ; Ec = 1.0 ; init_grid ( 1 << 4 ); // Create a folder named intermediate where all the simulation snapshots are stored char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file sprintf ( dumpFile , \"restart\" ); // Set fluid properties for both phases rho1 = 1.0 , rho2 = 1e-3 ; mu1 = Oh / sqrt ( We ), mu2 = Oha / sqrt ( We ); G1 = Ec / We , G2 = 0.0 ; lambda1 = De * sqrt ( We ), lambda2 = 0.0 ; f . sigma = 1.0 / We ; run (); return 0 ; } Initialization Event Sets up the initial condition for the droplet and velocity field. The event initializes a spherical droplet using the VOF method and sets an initial horizontal velocity.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: If a restart...",
    "content": "If a restart file exists, the simulation state is restored from it instead. @param t Time (set to 0 for initialization) event init ( t = 0 ) { if (! restore ( file = dumpFile )) { refine ( R2 ( x , y , z ) < ( 1.1 ) && R2 ( x , y , z ) > ( 0.9 ) && level < MAXlevel ); fraction ( f , ( 1 - R2 ( x , y , z ))); foreach () { u . x [] = - f [] * 1.0 ; } } } Adaptive Mesh Refinement Refines the computational mesh based on wavelet error estimates for the tracked fields to efficiently allocate computational resources.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: JavaScript",
    "content": "The refinement criteria track errors in: - Volume fraction field (f) - Velocity components (u.x, u.y, u.z) @param i Current iteration number event adapt ( i ++) { adapt_wavelet (( scalar *){ f , u . x , u . y , u . z }, ( double []){ fErr , VelErr , VelErr , VelErr }, MAXlevel , 4 ); } Snapshot Writing Creates periodic dumps of the simulation state for visualization and restarts. @param t Current simulation time @param tsnap Time interval between snapshots @param tmax Maximum simulation time event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Simulation Termination Outputs final simulation parameters to standard error when the simulation ends. @param t End time event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); } Simulation Logging Records simulation progress and checks for numerical stability.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "This event: 1. Calculates the total kinetic energy of the system 2. Writes simulation data to the log file 3. Checks for numerical stability based on kinetic energy values 4.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Terminates the simulation...",
    "content": "Terminates the simulation if energy values indicate instability @param i Current iteration number @return Returns 1 (terminating the simulation) if instability is detected event logWriting ( i ++) { // Calculate kinetic energy double ke = 0. ; foreach ( reduction (+: ke )) { ke += ( 2 * pi * y ) * ( 0.5 * rho ( f []) * ( sq ( u . x []) + sq ( u . y []))) * sq ( Delta ); } static FILE * fp ; if ( pid () == 0 ) { const char * mode = ( i == 0 ) ? \"w\" : \"a\" ; fp = fopen ( logFile , mode ); if ( fp == NULL ) { fprintf ( ferr , \"Error opening log file \\n \" ); return 1 ; } if ( i == 0 ) { fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( ferr , \"i dt t ke \\n \" ); fprintf ( fp , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( fp , \"i dt t ke rM \\n \" ); } fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); fflush ( fp ); fclose ( fp ); } assert ( ke > - 1e-10 ); // Stability check based on kinetic energy if ( i > 1e1 && pid () == 0 ) { if ( ke > 1e2 || ke < 1e-8 ) { const char * message = ( ke > 1e2 ) ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" : \"Kinetic energy too small now! Stopping! \\n \" ; fprintf ( ferr , \" %s \" , message ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %s \" , message ); fflush ( fp ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } }",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code: C/C++ Code",
    "content": "// #include \"axi.h\"#include\"grid/octree.h\"// #include \"grid/quadtree.h\"#include\"navier-stokes/centered.h\"#define VANILLA036#if VANILLA#include\"log-conform-viscoelastic.h\"#define logFile\"logAxi-vanilla.dat\"39#else#if AXI#include\"log-conform-viscoelastic-scalar-2D.h\"#define logFile\"logAxi-scalar.dat\"43#else#include\"log-conform-viscoelastic-scalar-3D.h\"#define logFile\"log3D-scalar.dat\"46#endif#endif#define FILTERED// Smear density and viscosity jumps#include\"two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#define fErr(1e-3)71#define KErr(1e-6)72#define VelErr(1e-2)7374",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#define xDist(5e-2)80#define R2(x,y,z)(sq(x-1.-xDist)+sq(y)+sq(z))8182",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "// u.t[left] = dirichlet(0.); // todo: later on use no-slip. For testing, free-slip is faster.// u.r[left] = dirichlet(0.); // todo: later on use no-slip. For testing, free-slip is faster.f[left]=dirichlet(0.0);",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intMAXlevel;doubleWe,Oh,Oha,De,Ec,tmax;charnameOut[80],dumpFile[80];",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intmain(intargc,charconst*argv[]){dtmax=1e-5;L0=4.0;// Values taken from the terminalMAXlevel=6;tmax=3.0;We=5.0;Oh=1e-2;Oha=1e-2*Oh;De=1.0;Ec=1.0;init_grid(1<<4);// Create a folder named intermediate where all the simulation snapshots are storedcharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart filesprintf(dumpFile,\"restart\");// Set fluid properties for both phasesrho1=1.0,rho2=1e-3;mu1=Oh/sqrt(We),mu2=Oha/sqrt(We);G1=Ec/We,G2=0.0;lambda1=De*sqrt(We),lambda2=0.0;f.sigma=1.0/We;run();return0;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event init(t=0){if(!restore(file=dumpFile)){refine(R2(x,y,z)<(1.1)&&R2(x,y,z)>(0.9)&&level<MAXlevel);fraction(f,(1-R2(x,y,z)));foreach(){u.x[]=-f[]*1.0;}}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event adapt(i++){adapt_wavelet((scalar*){f,u.x,u.y,u.z},(double[]){fErr,VelErr,VelErr,VelErr},MAXlevel,4);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: event logWriting(i++){// Calculate...",
    "content": "event logWriting(i++){// Calculate kinetic energydoubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])))*sq(Delta);}staticFILE*fp;if(pid()==0){constchar*mode=(i==0)?\"w\":\"a\";fp=fopen(logFile,mode);if(fp==NULL){fprintf(ferr,\"Error opening log file\\n\");return1;}if(i==0){fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(ferr,\"i dt t ke\\n\");fprintf(fp,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(fp,\"i dt t ke rM\\n\");}fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);fflush(fp);fclose(fp);}assert(ke>-1e-10);// Stability check based on kinetic energyif(i>1e1&&pid()==0){if(ke>1e2||ke<1e-8){constchar*message=(ke>1e2)?\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Stopping simulation\\n\":\"Kinetic energy...",
    "content": "Stopping simulation\\n\":\"Kinetic energy too small now! Stopping!\\n\";fprintf(ferr,\"%s\",message);fp=fopen(\"log\",\"a\");fprintf(fp,\"%s\",message);fflush(fp);fclose(fp);dump(file=dumpFile);return1;}}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "simulationCases/testEigenDecomposition.c See raw file 3D Matrix Diagonalization and Eigendecomposition This module implements the diagonalization of 3D symmetric matrices through eigendecomposition, allowing the computation of eigenvalues and eigenvectors for 3x3 symmetric matrices.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The implementation follows...",
    "content": "The implementation follows standard linear algebra approaches to compute \\(A = R \\times \\Lambda \\times R^T\\) where: \\(A\\) is the original symmetric matrix \\(R\\) is the orthogonal matrix of eigenvectors \\(\\Lambda\\) is the diagonal matrix of eigenvalues Numerical Parameters EPSILON: Used for floating-point comparisons to zero RELATIVE_TOLERANCE: Used for relative error checks in verification #include <stdio.h> #include <math.h> #include <stdlib.h> #include \"eigen_decomposition.h\" #define EPSILON 1e-9 24 #define RELATIVE_TOLERANCE 1e-6 25 #define sq ( x ) (( x )*( x )) 26 27 Data Structures 3D Vector Represents a 3D vector with long double precision components. typedef struct { long double x , y , z ; } pseudo_v3d ; 3D Tensor/Matrix Represents a 3x3 matrix or tensor with long double precision components. Organized as three row vectors (x, y, z). typedef struct { pseudo_v3d x , y , z ; } pseudo_t3d ; diagonalization_3D Performs eigendecomposition of a 3D symmetric matrix.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "This function computes the eigenvalues and eigenvectors of a 3x3 symmetric matrix using the eigen_decomposition function. It handles special cases where the matrix is already diagonal.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "Parameters: - Lambda: Output parameter to store the eigenvalues - R: Output parameter to store the eigenvectors as columns of R - A: Input symmetric matrix to be diagonalized The function maps the struct-based representation to arrays for computation and then maps the results back to the struct-based representation. static void diagonalization_3D ( pseudo_v3d * Lambda , pseudo_t3d * R , pseudo_t3d * A ) { // Check if the matrix is already diagonal if ( sq ( A -> x . y ) + sq ( A -> x . z ) + sq ( A -> y . z ) < 1e-15 ) { R -> x . x = R -> y . y = R -> z . z = 1. ; R -> y . x = R -> x . y = R -> z . x = R -> x . z = R -> z . y = R -> y . z = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; Lambda -> z = A -> z . z ; return ; } // Compute eigenvalues using the eigen_decomposition function double matrix [ 3 ][ 3 ] = { { A -> x . x , A -> x . y , A -> x . z }, { A -> x . y , A -> y . y , A -> y . z }, { A -> x . z , A -> y . z , A -> z . z } }; double eigenvectors [ 3 ][ 3 ]; double eigenvalues [ 3 ]; compute_eigensystem_symmetric_3x3 ( matrix , eigenvectors , eigenvalues ); // Store eigenvalues and eigenvectors with proper index mapping Lambda -> x = eigenvalues [ 0 ]; Lambda -> y = eigenvalues [ 1 ]; Lambda -> z = eigenvalues [ 2 ]; R -> x . x = eigenvectors [ 0 ][ 0 ]; R -> x . y = eigenvectors [ 0 ][ 1 ]; R -> x . z = eigenvectors [ 0 ][ 2 ]; R -> y . x = eigenvectors [ 1 ][ 0 ]; R -> y . y = eigenvectors [ 1 ][ 1 ]; R -> y . z = eigenvectors [ 1 ][ 2 ]; R -> z . x = eigenvectors [ 2 ][ 0 ]; R -> z . y = eigenvectors [ 2 ][ 1 ]; R -> z . z = eigenvectors [ 2 ][ 2 ]; } print_pseudo_t3d Prints a 3x3 matrix to standard output with formatting.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: JavaScript",
    "content": "Parameters: - name: Label for the matrix output - matrix: Pointer to the 3x3 matrix to be printed void print_pseudo_t3d ( const char * name , const pseudo_t3d * matrix ) { printf ( \" %s : \\n \" , name ); printf ( \" %12.9Lf %12.9Lf %12.9Lf\\n \" , matrix -> x . x , matrix -> x . y , matrix -> x . z ); printf ( \" %12.9Lf %12.9Lf %12.9Lf\\n \" , matrix -> y . x , matrix -> y . y , matrix -> y . z ); printf ( \" %12.9Lf %12.9Lf %12.9Lf\\n \" , matrix -> z . x , matrix -> z . y , matrix -> z . z ); printf ( \" \\n \" ); } print_pseudo_v3d Prints a 3D vector to standard output with formatting. Parameters: - name: Label for the vector output - vector: Pointer to the 3D vector to be printed void print_pseudo_v3d ( const char * name , const pseudo_v3d * vector ) { printf ( \" %s : %12.9Lf %12.9Lf %12.9Lf\\n\\n \" , name , vector -> x , vector -> y , vector -> z ); } verify_orthonormality Verifies that the eigenvectors form an orthonormal basis. This function checks two key properties of eigenvectors: 1.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Each eigenvector has...",
    "content": "Each eigenvector has unit norm (normalized) 2. Eigenvectors are mutually orthogonal (dot product is zero) Parameters: - R: Matrix containing eigenvectors as columns Returns: - 1 if eigenvectors are orthonormal - 0 otherwise, with diagnostic messages printed to stdout int verify_orthonormality ( const pseudo_t3d * R ) { for ( int i = 0 ; i < 3 ; i ++) { long double norm = sq ((( long double *) R )[ i ]) + sq ((( long double *) R )[ i + 3 ]) + sq ((( long double *) R )[ i + 6 ]); if ( fabsl ( norm - 1.0 L ) > EPSILON ) { printf ( \"Eigenvector %d is not normalized. Norm = %Lf\\n \" , i , sqrtl ( norm )); return 0 ; } for ( int j = i + 1 ; j < 3 ; j ++) { long double dot_product = (( long double *) R )[ i ] * (( long double *) R )[ j ] + (( long double *) R )[ i + 3 ] * (( long double *) R )[ j + 3 ] + (( long double *) R )[ i + 6 ] * (( long double *) R )[ j + 6 ]; if ( fabsl ( dot_product ) > EPSILON ) { printf ( \"Eigenvectors %d and %d are not orthogonal.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Dot product =...",
    "content": "Dot product = %Lf\\n \" , i , j , dot_product ); return 0 ; } } } return 1 ; } verify_diagonalization Verifies that the matrix is properly diagonalized by computing R^T * A * R and checking if it approximates a diagonal matrix with eigenvalues. Parameters: - A: Original matrix - R: Matrix of eigenvectors - Lambda: Vector of eigenvalues Returns: - 1 if diagonalization is verified - 0 otherwise, with diagnostic messages printed to stdout The function checks two properties: 1. Diagonal elements match the eigenvalues within relative tolerance 2.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: JavaScript",
    "content": "Off-diagonal elements are approximately zero int verify_diagonalization ( const pseudo_t3d * A , const pseudo_t3d * R , const pseudo_v3d * Lambda ) { pseudo_t3d temp , diagonalized ; // Compute R^T * A * R for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { (( long double *)& temp )[ i * 3 + j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++) { (( long double *)& temp )[ i * 3 + j ] += (( long double *) R )[ k * 3 + i ] * (( long double *) A )[ k * 3 + j ]; } } } for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { (( long double *)& diagonalized )[ i * 3 + j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++) { (( long double *)& diagonalized )[ i * 3 + j ] += (( long double *)& temp )[ i * 3 + k ] * (( long double *) R )[ k * 3 + j ]; } } } // Print the diagonalized matrix print_pseudo_t3d ( \"Diagonalized matrix: (R^T * A * R)\" , & diagonalized ); for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { if ( i == j ) { long double relative_error = fabsl ((( long double *)& diagonalized )[ i * 3 + j ] - (( long double *) Lambda )[ i ]) / ( fabsl ((( long double *) Lambda )[ i ]) + EPSILON ); if ( relative_error > RELATIVE_TOLERANCE ) { printf ( \"Diagonal element ( %d , %d ) does not match eigenvalue. %Lf != %Lf \" \"(relative error: %Lf ) \\n \" , i , j , (( long double *)& diagonalized )[ i * 3 + j ], (( long double *) Lambda )[ i ], relative_error ); } } else { if ( fabsl ((( long double *)& diagonalized )[ i * 3 + j ]) > EPSILON ) { printf ( \"Off-diagonal element ( %d , %d ) is not zero.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "Value = %Lf\\n \" , i , j , (( long double *)& diagonalized )[ i * 3 + j ]); } } } } return 1 ; } verify_eigenpairs Verifies that \\(A \\times v = \\lambda \\times v\\) for each eigenpair. This function checks the fundamental eigenvalue equation by: 1. Computing \\(A \\times v\\) for each eigenvector 2. Computing \\(\\lambda \\times v\\) for each eigenvector 3.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Comparing the results for approximate equality Parameters: - A: Original matrix - R: Matrix containing eigenvectors as columns - Lambda: Vector of eigenvalues Returns: - 1 if all eigenpairs are verified - 0 otherwise, with diagnostic messages printed to stdout int verify_eigenpairs ( const pseudo_t3d * A , const pseudo_t3d * R , const pseudo_v3d * Lambda ) { printf ( \"Verifying A * v = \u03bb * v for each eigenpair: \\n \" ); for ( int i = 0 ; i < 3 ; i ++) { pseudo_v3d Av = { 0 }, lambda_v = { 0 }; // Compute A * v for ( int j = 0 ; j < 3 ; j ++) { (( double *)& Av )[ j ] = (( double *) A )[ j * 3 ] * (( double *) R )[ i ] + (( double *) A )[ j * 3 + 1 ] * (( double *) R )[ i + 3 ] + (( double *) A )[ j * 3 + 2 ] * (( double *) R )[ i + 6 ]; } // Compute \u03bb * v for ( int j = 0 ; j < 3 ; j ++) { (( double *)& lambda_v )[ j ] = (( double *) Lambda )[ i ] * (( double *) R )[ i + j * 3 ]; } printf ( \"Eigenpair %d : \\n \" , i + 1 ); printf ( \"A * v = %8.4Lf %8.4Lf %8.4Lf\\n \" , Av . x , Av . y , Av . z ); printf ( \"\u03bb * v = %8.4Lf %8.4Lf %8.4Lf\\n \" , lambda_v . x , lambda_v . y , lambda_v . z ); // Check if A * v \u2248 \u03bb * v for ( int j = 0 ; j < 3 ; j ++) { if ( fabs ((( double *)& Av )[ j ] - (( double *)& lambda_v )[ j ]) > EPSILON ) { printf ( \"Mismatch for eigenpair %d , component %d\\n \" , i + 1 , j + 1 ); } } printf ( \"Verification A * v = \u03bb * v for each eigenpair done. \" \"See the messages above! \\n\\n \" ); } return 1 ; } verify_eigendecomposition Main verification function that combines all verification tests.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "This function verifies the eigendecomposition by: 1. Checking orthonormality of eigenvectors 2. Verifying diagonalization ( \\(R^T \\times A \\times R \\approx \\Lambda\\) ) 3.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Confirming the eigenpair...",
    "content": "Confirming the eigenpair equation ( \\(A \\times v = \\lambda \\times v\\) ) Parameters: - A: Original matrix - R: Matrix of eigenvectors - Lambda: Vector of eigenvalues Returns: - 1 when verification completes - Messages about verification status are printed to stdout int verify_eigendecomposition ( const pseudo_t3d * A , const pseudo_t3d * R , const pseudo_v3d * Lambda ) { if (! verify_orthonormality ( R )) { printf ( \"Eigenvectors are not orthonormal. \\n \" ); } else { printf ( \"Eigenvectors are orthonormal. \\n \" ); } printf ( \" \\n \" ); if (! verify_diagonalization ( A , R , Lambda )) { printf ( \"Matrix is not properly diagonalized. \\n \" ); } else { printf ( \"Matrix is properly diagonalized. \\n \" ); } if (! verify_eigenpairs ( A , R , Lambda )) { printf ( \"Eigenpair verification failed. \\n \" ); } else { printf ( \"Eigenpair verification passed. \\n \" ); } printf ( \"Eigendecomposition verification completed.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: See the messages...",
    "content": "See the messages above! \\n \" ); return 1 ; } verify_reconstruction Verifies that \\(A = R \\times \\Lambda \\times R^T\\) by reconstructing \\(A\\) from the eigendecomposition. This function: 1. Creates a diagonal matrix from the eigenvalues 2. Computes \\(R \\times \\Lambda \\times R^T\\) 3.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Compares the result with the original matrix \\(A\\) Parameters: - A: Original matrix - R: Matrix of eigenvectors - Lambda: Vector of eigenvalues Returns: - 1 when verification completes - Differences between original and reconstructed matrices are printed to stdout int verify_reconstruction ( const pseudo_t3d * A , const pseudo_t3d * R , const pseudo_v3d * Lambda ) { pseudo_t3d Lambda_diag , temp , A_reconstructed ; // Create diagonal matrix from Lambda for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { (( long double *)& Lambda_diag )[ i * 3 + j ] = ( i == j ) ? (( long double *) Lambda )[ i ] : 0.0 L ; } } // Compute R * Lambda for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { (( long double *)& temp )[ i * 3 + j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++) { (( long double *)& temp )[ i * 3 + j ] += (( long double *) R )[ i * 3 + k ] * (( long double *)& Lambda_diag )[ k * 3 + j ]; } } } // Compute (R * Lambda) * R^T for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { (( long double *)& A_reconstructed )[ i * 3 + j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++) { (( long double *)& A_reconstructed )[ i * 3 + j ] += (( long double *)& temp )[ i * 3 + k ] * (( long double *) R )[ j * 3 + k ]; } } } print_pseudo_t3d ( \"Reconstructed A = R * Lambda * R^T\" , & A_reconstructed ); // Compare original A with reconstructed A for ( int i = 0 ; i < 3 ; i ++) { for ( int j = 0 ; j < 3 ; j ++) { long double diff = fabsl ((( long double *) A )[ i * 3 + j ] - (( long double *)& A_reconstructed )[ i * 3 + j ]); if ( diff > EPSILON ) { printf ( \"Mismatch at ( %d , %d ): original = %Lf , reconstructed = %Lf , \" \"difference = %Lf\\n \" , i , j , (( long double *) A )[ i * 3 + j ], (( long double *)& A_reconstructed )[ i * 3 + j ], diff ); } } } printf ( \"A = R * Lambda * R^T verification completed.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: See the messages...",
    "content": "See the messages above! \\n \" ); return 1 ; } Main Function Entry point of the program that demonstrates matrix diagonalization and verification. The function: 1. Initializes a symmetric matrix A (default or from command line arguments) 2. Performs eigendecomposition to compute eigenvalues and eigenvectors 3.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Runs verification procedures to confirm the correctness of the results Command-line usage: ./program A11 A12 A13 A22 A23 A33 Where A11\u2026A33 are the elements of the symmetric matrix If no arguments are provided, a default matrix is used: A = [ 1 2 3 ] [ 2 4 5 ] [ 3 5 -6 ] Returns: - 0 on successful execution int main ( int argc , char * argv []) { pseudo_t3d A , R ; pseudo_v3d Lambda ; // Initialize A with the given values Matrix Initialization Options Uncomment one of the following blocks to use a specific test matrix: Diagonal (not identity) matrix: A.x.x = 1; A.x.y = 0; A.x.z = 0; A.y.x = 0; A.y.y = 2; A.y.z = 0; A.z.x = 0; A.z.y = 0; A.z.z = 3; Identity matrix: A.x.x = 1; A.x.y = 0; A.x.z = 0; A.y.x = 0; A.y.y = 1; A.y.z = 0; A.z.x = 0; A.z.y = 0; A.z.z = 1; Non-diagonal matrix: A.x.x = 1; A.x.y = 2; A.x.z = 3; A.y.x = 2; A.y.y = 4; A.y.z = 5; A.z.x = 3; A.z.y = 5; A.z.z = -6; Small magnitude matrix: A.x.x = 1e-6; A.x.y = 0; A.x.z = 0; A.y.x = 0; A.y.y = 1e-12; A.y.z = 0; A.z.x = 0; A.z.y = 0; A.z.z = 1e-10; Large magnitude matrix: A.x.x = 100; A.x.y = 100; A.x.z = 10; A.y.x = 100; A.y.y = 10; A.y.z = 1; A.z.x = 10; A.z.y = 1; A.z.z = 0.1; if ( argc != 7 ) { A . x . x = 1 ; A . x . y = 2 ; A . x . z = 3 ; A . y . x = 2 ; A . y . y = 4 ; A . y . z = 5 ; A . z . x = 3 ; A . z . y = 5 ; A . z . z = - 6 ; } else { // Get matrix elements from command line arguments A . x . x = atof ( argv [ 1 ]); A . x . y = atof ( argv [ 2 ]); A . x . z = atof ( argv [ 3 ]); A . y . x = atof ( argv [ 2 ]); A . y . y = atof ( argv [ 4 ]); A . y . z = atof ( argv [ 5 ]); A . z . x = atof ( argv [ 3 ]); A . z . y = atof ( argv [ 5 ]); A . z . z = atof ( argv [ 6 ]); } print_pseudo_t3d ( \"Original matrix A\" , & A ); diagonalization_3D (& Lambda , & R , & A ); print_pseudo_t3d ( \"Eigenvectors R\" , & R ); print_pseudo_v3d ( \"Eigenvalues Lambda\" , & Lambda ); verify_eigendecomposition (& A , & R , & Lambda ); // Verify that A = R * Lambda * R^T verify_reconstruction (& A , & R , & Lambda ); return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "#include<stdio.h>#include<math.h>#include<stdlib.h>#include\"eigen_decomposition.h\"#define EPSILON1e-924#define RELATIVE_TOLERANCE1e-625#define sq(x)((x)*(x))2627",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: staticvoiddiagonalization_3D(pseudo_v3d*Lambda,pseudo_t3d*R,pseudo_t3d*A){// Check if...",
    "content": "staticvoiddiagonalization_3D(pseudo_v3d*Lambda,pseudo_t3d*R,pseudo_t3d*A){// Check if the matrix is already diagonalif(sq(A->x.y)+sq(A->x.z)+sq(A->y.z)<1e-15){R->x.x=R->y.y=R->z.z=1.;R->y.x=R->x.y=R->z.x=R->x.z=R->z.y=R->y.z=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;Lambda->z=A->z.z;return;}// Compute eigenvalues using the eigen_decomposition functiondoublematrix[3][3]={{A->x.x,A->x.y,A->x.z},{A->x.y,A->y.y,A->y.z},{A->x.z,A->y.z,A->z.z}};doubleeigenvectors[3][3];doubleeigenvalues[3];compute_eigensystem_symmetric_3x3(matrix,eigenvectors,eigenvalues);// Store eigenvalues and eigenvectors with proper index mappingLambda->x=eigenvalues[0];Lambda->y=eigenvalues[1];Lambda->z=eigenvalues[2];R->x.x=eigenvectors[0][0];R->x.y=eigenvectors[0][1];R->x.z=eigenvectors[0][2];R->y.x=eigenvectors[1][0];R->y.y=eigenvectors[1][1];R->y.z=eigenvectors[1][2];R->z.x=eigenvectors[2][0];R->z.y=eigenvectors[2][1];R->z.z=eigenvectors[2][2];}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "voidprint_pseudo_t3d(constchar*name,constpseudo_t3d*matrix){printf(\"%s:\\n\",name);printf(\"%12.9Lf%12.9Lf%12.9Lf\\n\",matrix->x.x,matrix->x.y,matrix->x.z);printf(\"%12.9Lf%12.9Lf%12.9Lf\\n\",matrix->y.x,matrix->y.y,matrix->y.z);printf(\"%12.9Lf%12.9Lf%12.9Lf\\n\",matrix->z.x,matrix->z.y,matrix->z.z);printf(\"\\n\");}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "voidprint_pseudo_v3d(constchar*name,constpseudo_v3d*vector){printf(\"%s:%12.9Lf%12.9Lf%12.9Lf\\n\\n\",name,vector->x,vector->y,vector->z);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intverify_orthonormality(constpseudo_t3d*R){for(inti=0;i<3;i++){longdoublenorm=sq(((longdouble*)R)[i])+sq(((longdouble*)R)[i+3])+sq(((longdouble*)R)[i+6]);if(fabsl(norm-1.0L)>EPSILON){printf(\"Eigenvector%dis not normalized.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "Norm =%Lf\\n\",i,sqrtl(norm));return0;}for(intj=i+1;j<3;j++){longdoubledot_product=((longdouble*)R)[i]*((longdouble*)R)[j]+((longdouble*)R)[i+3]*((longdouble*)R)[j+3]+((longdouble*)R)[i+6]*((longdouble*)R)[j+6];if(fabsl(dot_product)>EPSILON){printf(\"Eigenvectors%dand%dare not orthogonal. Dot product =%Lf\\n\",i,j,dot_product);return0;}}}return1;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intverify_diagonalization(constpseudo_t3d*A,constpseudo_t3d*R,constpseudo_v3d*Lambda){pseudo_t3d temp,diagonalized;// Compute R^T * A * Rfor(inti=0;i<3;i++){for(intj=0;j<3;j++){((longdouble*)&temp)[i*3+j]=0;for(intk=0;k<3;k++){((longdouble*)&temp)[i*3+j]+=((longdouble*)R)[k*3+i]*((longdouble*)A)[k*3+j];}}}for(inti=0;i<3;i++){for(intj=0;j<3;j++){((longdouble*)&diagonalized)[i*3+j]=0;for(intk=0;k<3;k++){((longdouble*)&diagonalized)[i*3+j]+=((longdouble*)&temp)[i*3+k]*((longdouble*)R)[k*3+j];}}}// Print the diagonalized matrixprint_pseudo_t3d(\"Diagonalized matrix: (R^T * A * R)\",&diagonalized);for(inti=0;i<3;i++){for(intj=0;j<3;j++){if(i==j){longdoublerelative_error=fabsl(((longdouble*)&diagonalized)[i*3+j]-((longdouble*)Lambda)[i])/(fabsl(((longdouble*)Lambda)[i])+EPSILON);if(relative_error>RELATIVE_TOLERANCE){printf(\"Diagonal element (%d,%d) does not match eigenvalue.%Lf!=%Lf\"\"(relative error:%Lf)\\n\",i,j,((longdouble*)&diagonalized)[i*3+j],((longdouble*)Lambda)[i],relative_error);}}else{if(fabsl(((longdouble*)&diagonalized)[i*3+j])>EPSILON){printf(\"Off-diagonal element (%d,%d) is not zero.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "Value =%Lf\\n\",i,j,((longdouble*)&diagonalized)[i*3+j]);}}}}return1;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intverify_eigenpairs(constpseudo_t3d*A,constpseudo_t3d*R,constpseudo_v3d*Lambda){printf(\"Verifying A * v = \u03bb * v for each eigenpair:\\n\");for(inti=0;i<3;i++){pseudo_v3d Av={0},lambda_v={0};// Compute A * vfor(intj=0;j<3;j++){((double*)&Av)[j]=((double*)A)[j*3]*((double*)R)[i]+((double*)A)[j*3+1]*((double*)R)[i+3]+((double*)A)[j*3+2]*((double*)R)[i+6];}// Compute \u03bb * vfor(intj=0;j<3;j++){((double*)&lambda_v)[j]=((double*)Lambda)[i]*((double*)R)[i+j*3];}printf(\"Eigenpair%d:\\n\",i+1);printf(\"A * v =%8.4Lf%8.4Lf%8.4Lf\\n\",Av.x,Av.y,Av.z);printf(\"\u03bb * v =%8.4Lf%8.4Lf%8.4Lf\\n\",lambda_v.x,lambda_v.y,lambda_v.z);// Check if A * v \u2248 \u03bb * vfor(intj=0;j<3;j++){if(fabs(((double*)&Av)[j]-((double*)&lambda_v)[j])>EPSILON){printf(\"Mismatch for eigenpair%d, component%d\\n\",i+1,j+1);}}printf(\"Verification A * v = \u03bb * v for each eigenpair done. \"\"See the messages above!\\n\\n\");}return1;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intverify_eigendecomposition(constpseudo_t3d*A,constpseudo_t3d*R,constpseudo_v3d*Lambda){if(!verify_orthonormality(R)){printf(\"Eigenvectors are not orthonormal.\\n\");}else{printf(\"Eigenvectors are orthonormal.\\n\");}printf(\"\\n\");if(!verify_diagonalization(A,R,Lambda)){printf(\"Matrix is not properly diagonalized.\\n\");}else{printf(\"Matrix is properly diagonalized.\\n\");}if(!verify_eigenpairs(A,R,Lambda)){printf(\"Eigenpair verification failed.\\n\");}else{printf(\"Eigenpair verification passed.\\n\");}printf(\"Eigendecomposition verification completed.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: See the messages...",
    "content": "See the messages above!\\n\");return1;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "intverify_reconstruction(constpseudo_t3d*A,constpseudo_t3d*R,constpseudo_v3d*Lambda){pseudo_t3d Lambda_diag,temp,A_reconstructed;// Create diagonal matrix from Lambdafor(inti=0;i<3;i++){for(intj=0;j<3;j++){((longdouble*)&Lambda_diag)[i*3+j]=(i==j)?((longdouble*)Lambda)[i]:0.0L;}}// Compute R * Lambdafor(inti=0;i<3;i++){for(intj=0;j<3;j++){((longdouble*)&temp)[i*3+j]=0;for(intk=0;k<3;k++){((longdouble*)&temp)[i*3+j]+=((longdouble*)R)[i*3+k]*((longdouble*)&Lambda_diag)[k*3+j];}}}// Compute (R * Lambda) * R^Tfor(inti=0;i<3;i++){for(intj=0;j<3;j++){((longdouble*)&A_reconstructed)[i*3+j]=0;for(intk=0;k<3;k++){((longdouble*)&A_reconstructed)[i*3+j]+=((longdouble*)&temp)[i*3+k]*((longdouble*)R)[j*3+k];}}}print_pseudo_t3d(\"Reconstructed A = R * Lambda * R^T\",&A_reconstructed);// Compare original A with reconstructed Afor(inti=0;i<3;i++){for(intj=0;j<3;j++){longdoublediff=fabsl(((longdouble*)A)[i*3+j]-((longdouble*)&A_reconstructed)[i*3+j]);if(diff>EPSILON){printf(\"Mismatch at (%d,%d): original =%Lf, reconstructed =%Lf, \"\"difference =%Lf\\n\",i,j,((longdouble*)A)[i*3+j],((longdouble*)&A_reconstructed)[i*3+j],diff);}}}printf(\"A = R * Lambda * R^T verification completed.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intmain(intargc,char*argv[]){pseudo_t3d A,R;pseudo_v3d Lambda;// Initialize A with the given values",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A.x.x = 1;  A.x.y = 0; A.x.z = 0;\nA.y.x = 0; A.y.y = 2;  A.y.z = 0;\nA.z.x = 0;  A.z.y = 0;  A.z.z = 3;",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A.x.x = 1;  A.x.y = 0; A.x.z = 0;\nA.y.x = 0; A.y.y = 1;  A.y.z = 0;\nA.z.x = 0;  A.z.y = 0;  A.z.z = 1;",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A.x.x = 1;  A.x.y = 2; A.x.z = 3;\nA.y.x = 2; A.y.y = 4;  A.y.z = 5;\nA.z.x = 3;  A.z.y = 5;  A.z.z = -6;",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A.x.x = 1e-6;  A.x.y = 0; A.x.z = 0;\nA.y.x = 0; A.y.y = 1e-12;  A.y.z = 0;\nA.z.x = 0;  A.z.y = 0;  A.z.z = 1e-10;",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A.x.x = 100;  A.x.y = 100; A.x.z = 10;\nA.y.x = 100; A.y.y = 10;  A.y.z = 1;\nA.z.x = 10;  A.z.y = 1;  A.z.z = 0.1;",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "if(argc!=7){A.x.x=1;A.x.y=2;A.x.z=3;A.y.x=2;A.y.y=4;A.y.z=5;A.z.x=3;A.z.y=5;A.z.z=-6;}else{// Get matrix elements from command line argumentsA.x.x=atof(argv[1]);A.x.y=atof(argv[2]);A.x.z=atof(argv[3]);A.y.x=atof(argv[2]);A.y.y=atof(argv[4]);A.y.z=atof(argv[5]);A.z.x=atof(argv[3]);A.z.y=atof(argv[5]);A.z.z=atof(argv[6]);}print_pseudo_t3d(\"Original matrix A\",&A);diagonalization_3D(&Lambda,&R,&A);print_pseudo_t3d(\"Eigenvectors R\",&R);print_pseudo_v3d(\"Eigenvalues Lambda\",&Lambda);verify_eigendecomposition(&A,&R,&Lambda);// Verify that A = R * Lambda * R^Tverify_reconstruction(&A,&R,&Lambda);return0;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases dropAtomisation.c This file contains the simulation code for multiphase drop atomisation processes, with capabilities for both axisymme... dropImpact.c This file contains the simulation code for drop impact on a solid surface using a Volume of Fluid (VOF) method with v... pinchOff.c This file implements an axisymmetric simulation of the pinch-off dynamics of a viscoelastic liquid jet. The simulatio... testEigenDecomposition.c This module implements the diagonalization of 3D symmetric matrices through eigendecomposition, allowing the computat... verifyWtihPlots.ipynb This notebook provides visualization and analysis related to verifyWtihPlots.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "simulationCases/pinchOff.c See raw file Viscoelastic Liquid Jet Pinch-Off Simulation This file implements an axisymmetric simulation of the pinch-off dynamics of a viscoelastic liquid jet. The simulation uses a two-phase approach with log-conformation formulation for the viscoelastic stress tensor.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The model incorporates:...",
    "content": "The model incorporates: - Axisymmetric Navier-Stokes equations - Log-conformation viscoelastic constitutive model - Two-phase interface with surface tension - Adaptive mesh refinement based on interface curvature and velocity gradients File Information File: pinchOff.c Version: 0.2 Author: Vatsal Sanjay Date: Oct 18, 2024 #include \"axi.h\" // #include \"grid/octree.h\" // #include \"grid/quadtree.h\" #include \"navier-stokes/centered.h\" #define VANILLA 1 26 #if VANILLA #include \"../src-local/log-conform-viscoelastic.h\" #define logFile \"logAxi-vanilla.dat\" 29 #else #if AXI #include \"../src-local/log-conform-viscoelastic-scalar-2D.h\" #define logFile \"logAxi-scalar.dat\" 33 #else #include \"../src-local/log-conform-viscoelastic-scalar-3D.h\" #define logFile \"log3D-scalar.dat\" 36 #endif #endif #define FILTERED // Smear density and viscosity jumps #include \"../src-local/two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" ## Simulation Parameters Configuration of time steps, error tolerances, and physical parameters.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Time between snapshots...",
    "content": "Time between snapshots #define tsnap ( 1e-2 ) 53 54 ### Error Tolerances fErr: Error tolerance in volume fraction field (f1 VOF) KErr: Error tolerance in interface curvature calculation using height function VelErr: Error tolerances in velocity field Use 1e-2 for low Oh (Ohnesorge number) cases Use 1e-3 to 5e-3 for high Oh/moderate to high J cases #define fErr ( 1e-3 ) 64 #define KErr ( 1e-6 ) 65 #define VelErr ( 1e-2 ) 66 67 ### Geometry Parameters Parameters defining the initial geometry of the liquid jet #define epsilon ( 0.5 ) 73 #define R2 ( x , y , z , e ) ( sqrt ( sq ( y ) + sq ( z )) + ( e * sin ( x / 4. ))) 74 75 ## Boundary Conditions Neumann boundary condition for velocity and Dirichlet for pressure at the top u . n [ top ] = neumann ( 0.0 ); p [ top ] = dirichlet ( 0.0 ); ## Global Variables MAXlevel: Maximum level of mesh refinement Oh: Ohnesorge number for the liquid phase (solvent) Oha: Ohnesorge number for the gas phase (air) De: Deborah number - ratio of relaxation time to flow time Ec: Elasto-capillary number - ratio of elastic to capillary forces int MAXlevel ; double Oh , Oha , De , Ec , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; ## Main Function Initializes the simulation parameters and starts the simulation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Sets domain size...",
    "content": "Sets domain size Configures physical parameters (Oh, De, Ec) Initializes grid Sets up file storage Configures material properties ### Parameters - argc: Command line argument count - argv: Command line argument values ### Returns - Exit status code int main ( int argc , char const * argv []) { L0 = 2 * pi ; // Values taken from the terminal MAXlevel = 6 ; tmax = 10 ; Oh = 1e-2 ; Oha = 1e-2 * Oh ; De = 1.0 ; // 1e-1; Ec = 1.0 ; // 1e-2; init_grid ( 1 << 4 ); // Create a folder named intermediate where all the simulation snapshots are stored char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file. See writingFiles event sprintf ( dumpFile , \"restart\" ); // Set material properties rho1 = 1. , rho2 = 1e-3 ; mu1 = Oh , mu2 = Oha ; lambda1 = De , lambda2 = 0. ; G1 = Ec , G2 = 0. ; f . sigma = 1.0 ; run (); } ## Initialization Event Sets up the initial condition for the simulation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "Attempts to restore from a restart file if available Otherwise initializes the interface using the geometric function Refines the mesh around the interface ### Parameters - t: Simulation time (starts at 0) event init ( t = 0 ) { if (! restore ( file = dumpFile )) { refine ( R2 ( x , y , z , epsilon ) < ( 1 + epsilon ) && R2 ( x , y , z , epsilon ) > ( 1 - epsilon ) && level < MAXlevel ); fraction ( f , ( 1 - R2 ( x , y , z , epsilon ))); } } ## Adaptive Mesh Refinement Dynamically adjusts the mesh resolution based on interface curvature and flow features. Calculates interface curvature Refines mesh based on error criteria for volume fraction, velocity, and curvature fields ### Parameters - i: Iteration number event adapt ( i ++) { scalar KAPPA []; curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , u . x , u . y , KAPPA }, ( double []){ fErr , VelErr , VelErr , KErr }, MAXlevel , 4 ); } ## Snapshot Generation Saves the state of the simulation at regular intervals.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Creates a restart...",
    "content": "Creates a restart file for potential simulation recovery Generates a snapshot file with timestamped name ### Parameters - t: Simulation time (starts at 0, incremented by tsnap until tmax) event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } ## Simulation Termination Outputs final information when the simulation ends. Prints the maximum refinement level and Ohnesorge number ### Parameters - t: Simulation time (at end) event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , Oh %2.1e\\n \" , MAXlevel , Oh ); } ## Data Logging Records simulation statistics at each iteration.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Calculates total kinetic...",
    "content": "Calculates total kinetic energy Identifies the minimum position of the interface along the y-axis Writes data to the log file Checks for simulation stability based on kinetic energy ### Parameters - i: Iteration number ### Notes - Terminates the simulation if kinetic energy is too high (blow-up) or too low - Creates a final restart file if the simulation is terminated early event logWriting ( i ++) { // Calculate kinetic energy double ke = 0. ; foreach ( reduction (+: ke )) { ke += ( 2 * pi * y )*( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y [])+ sq ( u . z [])))* sq ( Delta ); } static FILE * fp ; if ( pid () == 0 ) { const char * mode = ( i == 0 ) ? \"w\" : \"a\" ; fp = fopen ( logFile , mode ); if ( fp == NULL ) { fprintf ( ferr , \"Error opening log file \\n \" ); return 1 ; } // Find minimum position of interface along y-axis scalar pos []; position ( f , pos , { 0 , 1 , 0 }); double ymin = statsf ( pos ). min ; // Write header for first iteration if ( i == 0 ) { fprintf ( ferr , \"Level %d , Oh %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , Oha , De , Ec ); fprintf ( ferr , \"i dt t ke ymin \\n \" ); fprintf ( fp , \"Level %d , Oh %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , Oha , De , Ec ); fprintf ( fp , \"i dt t ke ymin \\n \" ); } // Write data row fprintf ( fp , \" %d %g %g %g %g\\n \" , i , dt , t , ke , ymin ); fprintf ( ferr , \" %d %g %g %g %g\\n \" , i , dt , t , ke , ymin ); fflush ( fp ); fclose ( fp ); } // Check for negative kinetic energy (should never happen) assert ( ke > - 1e-10 ); // Check for simulation stability after a few iterations if ( i > 1e1 && pid () == 0 ) { if ( ke > 1e2 || ke < 1e-8 ) { const char * message = ( ke > 1e2 ) ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" : \"kinetic energy too small now! Stopping! \\n \" ; fprintf ( ferr , \" %s \" , message ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %s \" , message ); fflush ( fp ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } }",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code: C/C++ Code",
    "content": "#include\"axi.h\"// #include \"grid/octree.h\"// #include \"grid/quadtree.h\"#include\"navier-stokes/centered.h\"#define VANILLA126#if VANILLA#include\"../src-local/log-conform-viscoelastic.h\"#define logFile\"logAxi-vanilla.dat\"29#else#if AXI#include\"../src-local/log-conform-viscoelastic-scalar-2D.h\"#define logFile\"logAxi-scalar.dat\"33#else#include\"../src-local/log-conform-viscoelastic-scalar-3D.h\"#define logFile\"log3D-scalar.dat\"36#endif#endif#define FILTERED// Smear density and viscosity jumps#include\"../src-local/two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#define fErr(1e-3)64#define KErr(1e-6)65#define VelErr(1e-2)6667",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#define epsilon(0.5)73#define R2(x,y,z,e)(sqrt(sq(y)+sq(z))+(e*sin(x/4.)))7475",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intMAXlevel;doubleOh,Oha,De,Ec,tmax;charnameOut[80],dumpFile[80];",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intmain(intargc,charconst*argv[]){L0=2*pi;// Values taken from the terminalMAXlevel=6;tmax=10;Oh=1e-2;Oha=1e-2*Oh;De=1.0;// 1e-1;Ec=1.0;// 1e-2;init_grid(1<<4);// Create a folder named intermediate where all the simulation snapshots are storedcharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file. See writingFiles eventsprintf(dumpFile,\"restart\");// Set material propertiesrho1=1.,rho2=1e-3;mu1=Oh,mu2=Oha;lambda1=De,lambda2=0.;G1=Ec,G2=0.;f.sigma=1.0;run();}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event init(t=0){if(!restore(file=dumpFile)){refine(R2(x,y,z,epsilon)<(1+epsilon)&&R2(x,y,z,epsilon)>(1-epsilon)&&level<MAXlevel);fraction(f,(1-R2(x,y,z,epsilon)));}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);adapt_wavelet((scalar*){f,u.x,u.y,KAPPA},(double[]){fErr,VelErr,VelErr,KErr},MAXlevel,4);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, Oh%2.1e\\n\",MAXlevel,Oh);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: event logWriting(i++){// Calculate...",
    "content": "event logWriting(i++){// Calculate kinetic energydoubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])+sq(u.z[])))*sq(Delta);}staticFILE*fp;if(pid()==0){constchar*mode=(i==0)?\"w\":\"a\";fp=fopen(logFile,mode);if(fp==NULL){fprintf(ferr,\"Error opening log file\\n\");return1;}// Find minimum position of interface along y-axisscalar pos[];position(f,pos,{0,1,0});doubleymin=statsf(pos).min;// Write header for first iterationif(i==0){fprintf(ferr,\"Level%d, Oh%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,Oha,De,Ec);fprintf(ferr,\"i dt t ke ymin\\n\");fprintf(fp,\"Level%d, Oh%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,Oha,De,Ec);fprintf(fp,\"i dt t ke ymin\\n\");}// Write data rowfprintf(fp,\"%d%g%g%g%g\\n\",i,dt,t,ke,ymin);fprintf(ferr,\"%d%g%g%g%g\\n\",i,dt,t,ke,ymin);fflush(fp);fclose(fp);}// Check for negative kinetic energy (should never happen)assert(ke>-1e-10);// Check for simulation stability after a few iterationsif(i>1e1&&pid()==0){if(ke>1e2||ke<1e-8){constchar*message=(ke>1e2)?\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Stopping simulation\\n\":\"kinetic energy...",
    "content": "Stopping simulation\\n\":\"kinetic energy too small now! Stopping!\\n\";fprintf(ferr,\"%s\",message);fp=fopen(\"log\",\"a\");fprintf(fp,\"%s\",message);fflush(fp);fclose(fp);dump(file=dumpFile);return1;}}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/verifyWtihPlots.ipynb | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework",
    "content": "simulationCases/verifyWtihPlots.ipynb See raw file verifyWtihPlots.ipynb Jupyter Notebook: verifyWtihPlots.ipynb Download Notebook View in nbviewer Open in Colab About this notebook This notebook provides visualization and analysis related to verifyWtihPlots. Key Features: Visualization of data and results Analysis of simulation outputs Interactive exploration of parameters Tip: For the best interactive experience, download the notebook or open it in Google Colab. Notebook Preview Notebook Preview Unavailable The notebook preview could not be loaded. This may be because: The notebook file is not yet available in the repository The nbviewer service is temporarily unavailable The repository is private or has access restrictions You can still download the notebook using the button above or view it directly through one of the external services.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/verifyWtihPlots.ipynb.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "simulationCases/dropAtomisation.c See raw file Drop Atomisation Simulation This file contains the simulation code for multiphase drop atomisation processes, with capabilities for both axisymmetric (2D) and full 3D simulations of viscoelastic fluid dynamics.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The physics model...",
    "content": "The physics model incorporates: - Two-phase flow with sharp interface tracking - Surface tension effects (parameterized by Weber number) - Viscous effects in both phases (parameterized by Ohnesorge numbers) - Optional viscoelastic behavior (controlled by Deborah and Elasto-capillary numbers) - Adaptive mesh refinement to efficiently resolve interfaces and high gradient regions File information File: dropAtomisation.c Author: Ayush Dixit & Vatsal Sanjay Version: 5.0 Date: Oct 20, 2024 // #include \"axi.h\" #include \"grid/octree.h\" // #include \"grid/quadtree.h\" #include \"navier-stokes/centered.h\" Viscoelastic Model Configuration Different implementations of the log-conformation viscoelastic model are available depending on simulation dimensionality: - VANILLA: Original implementation (2D only) - AXI: Axisymmetric scalar implementation - 3D: Full three-dimensional scalar implementation #define VANILLA 0 // vanilla cannot do 3D #if VANILLA #include \"log-conform-viscoelastic.h\" #define logFile \"logAxi-vanilla.dat\" 39 #else #if AXI #include \"log-conform-viscoelastic-scalar-2D.h\" #define logFile \"logAxi-scalar.dat\" 43 #else #include \"log-conform-viscoelastic-scalar-3D.h\" #define logFile \"log3D-scalar.dat\" 46 #endif #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" Simulation Parameters tsnap: Time interval between simulation snapshots Error tolerances: fErr: VOF function tolerance KErr: Curvature calculation tolerance VelErr: Velocity field tolerance AErr: Conformation tensor tolerance #define tsnap ( 0.1 ) // 0.001 only for some cases. // Error tolerances #define fErr ( 1e-2 ) // Error tolerance in f1 VOF #define KErr ( 1e-4 ) // Error tolerance in VoF curvature calculated using height function #define VelErr ( 1e-2 ) // Error tolerances in velocity // Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define AErr ( 1e-3 ) // Error tolerances in conformation inside the liquid Domain and Initial Condition R2 defines a spherical distance function from point (3,0,0) #define R2 ( x , y , z ) ( sq ( x - 3. ) + sq ( y ) + sq ( z )) 80 81 Boundary Conditions Left boundary: Inflow with fixed velocity Right boundary: Outflow with zero pressure // Inflow: left u . n [ left ] = dirichlet ( 1. ); // p[left] = dirichlet(0); // Outflow: right u . n [ right ] = neumann ( 0. ); p [ right ] = dirichlet ( 0 ); Global Variables MAXlevel: Maximum refinement level We: Weber number (ratio of inertial to surface tension forces) Oh: Solvent Ohnesorge number (ratio of viscous to inertial and surface forces) Oha: Air Ohnesorge number De: Deborah number (ratio of relaxation time to flow time) Ec: Elasto-capillary number (ratio of elastic to surface tension forces) RhoInOut: Density ratio between phases tmax: Maximum simulation time int MAXlevel ; double Oh , Oha , De , We , RhoInOut , Ec , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; Main Function Initializes the simulation domain, sets physical parameters, and starts the simulation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Parameters L0: Domain...",
    "content": "Parameters L0: Domain size RhoInOut: Density ratio between phases We, Oh, Oha: Dimensionless flow parameters De, Ec: Viscoelastic parameters @param argc Number of command line arguments @param argv Array of command line arguments @return Exit status int main ( int argc , char const * argv []) { // dtmax = 1e-5; // BEWARE of this for stability issues. L0 = 20 ; init_grid ( 1 << 6 ); origin ( 0 , - L0 / #if dimension == , - L0 / #endif ); // Values taken from the terminal MAXlevel = 7 ; RhoInOut = 830. ; // Elastic parts De = 0.0 ; Ec = 0.0 ; // Newtonian parts We = 15000 ; // Based on the density of the gas Oh = 3e-3 ; // Based on the density of the liquid Oha = 0.018 * Oh ; // Based on the density of the liquid tmax = 200 ; // Create a folder named intermediate where all the simulation snapshots are stored char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: See writingFiles event...",
    "content": "See writingFiles event sprintf ( dumpFile , \"restart\" ); // Phase properties rho1 = RhoInOut , rho2 = 1e0 ; // As both densities are based on the density of the liquid, we must multiply // the Ohnesorge number by the square root of the density ratio mu1 = sqrt ( RhoInOut )* Oh / sqrt ( We ), mu2 = sqrt ( RhoInOut )* Oha / sqrt ( We ); // Elastic parts // In G1, we need to multiply by the density ratio (again, because Ec is based // on the density of the liquid but in the code it is based on the density of the gas) G1 = Ec / We , G2 = 0.0 ; // Here, lambda is essentially the Weissenberg number, so there is no density // in the expression lambda1 = De * sqrt ( We ), lambda2 = 0.0 ; // Surface tension -- the Weber number is based on the density of the gas! f . sigma = 1.0 / We ; run (); } Initialization Sets up the initial condition as a spherical drop centered at (3,0,0) with radius 1, using adaptive mesh refinement to resolve the interface.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: If a restart...",
    "content": "If a restart file exists, the simulation state is loaded from it instead. event init ( t = 0 ) { if (! restore ( file = dumpFile )) { refine ( R2 ( x , y , z ) < 1.1 && R2 ( x , y , z ) > 0.9 && level < MAXlevel ); fraction ( f , 1. - R2 ( x , y , z )); } } Adaptive Mesh Refinement Dynamically refines the computational mesh based on error criteria for: - Volume fraction (f) - Interface curvature (KAPPA) - Velocity components (u.x, u.y, u.z) This ensures optimal resolution where needed while maintaining computational efficiency in regions with smooth solutions. event adapt ( i ++) { scalar KAPPA []; curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , KAPPA , u . x , u . y #if dimension == , u . z #endif }, ( double []){ fErr , KErr , VelErr , VelErr , #if dimension == VelErr #endif }, MAXlevel , 4 ); } Simulation Snapshots Periodically saves the full state of the simulation for: - Visualization - Analysis - Restart capability Files are saved in the \u2018intermediate\u2019 directory with timestamps. event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Simulation Termination Executed at the end of the simulation to print a summary of key parameters. event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); } Logging and Monitoring Tracks simulation progress and stability by: - Computing total kinetic energy - Writing timestep information - Monitoring for stability issues - Terminating if energy becomes too high (explosion) or too low (stagnation) Log files include: - Iteration number - Time step size - Current simulation time - Total kinetic energy event logWriting ( i ++) { // Calculate total kinetic energy double ke = 0. ; foreach ( reduction (+: ke )) { ke += ( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y []) #if dimension == + sq ( u . z []) #endif ))* pow ( Delta , dimension ); } static FILE * fp ; if ( pid () == 0 ) { const char * mode = ( i == 0 ) ? \"w\" : \"a\" ; fp = fopen ( logFile , mode ); if ( fp == NULL ) { fprintf ( ferr , \"Error opening log file \\n \" ); return 1 ; } if ( i == 0 ) { fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( ferr , \"i dt t ke \\n \" ); fprintf ( fp , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( fp , \"i dt t ke rM \\n \" ); } fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); fflush ( fp ); fclose ( fp ); } assert ( ke > - 1e-10 ); // Check for simulation stability issues after initial iterations if ( i > 1e1 && pid () == 0 ) { if ( ke > 1e6 || ke < 1e-6 ) { const char * message = ( ke > 1e6 ) ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" : \"Kinetic energy too small now! Stopping! \\n \" ; fprintf ( ferr , \" %s \" , message ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %s \" , message ); fflush ( fp ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } }",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "// #include \"axi.h\"#include\"grid/octree.h\"// #include \"grid/quadtree.h\"#include\"navier-stokes/centered.h\"",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "#define VANILLA0// vanilla cannot do 3D#if VANILLA#include\"log-conform-viscoelastic.h\"#define logFile\"logAxi-vanilla.dat\"39#else#if AXI#include\"log-conform-viscoelastic-scalar-2D.h\"#define logFile\"logAxi-scalar.dat\"43#else#include\"log-conform-viscoelastic-scalar-3D.h\"#define logFile\"log3D-scalar.dat\"46#endif#endif#define FILTERED// Smear density and viscosity jumps#include\"two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#define tsnap(0.1)// 0.001 only for some cases.// Error tolerances#define fErr(1e-2)// Error tolerance in f1 VOF#define KErr(1e-4)// Error tolerance in VoF curvature calculated using height function#define VelErr(1e-2)// Error tolerances in velocity// Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J#define AErr(1e-3)// Error tolerances in conformation inside the liquid",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "// Inflow: leftu.n[left]=dirichlet(1.);// p[left] = dirichlet(0);// Outflow: rightu.n[right]=neumann(0.);p[right]=dirichlet(0);",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intMAXlevel;doubleOh,Oha,De,We,RhoInOut,Ec,tmax;charnameOut[80],dumpFile[80];",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: intmain(intargc,charconst*argv[]){// dtmax =...",
    "content": "intmain(intargc,charconst*argv[]){// dtmax = 1e-5; //  BEWARE of this for stability issues.L0=20;init_grid(1<<6);origin(0,-L0/#if dimension ==,-L0/#endif);// Values taken from the terminalMAXlevel=7;RhoInOut=830.;// Elastic partsDe=0.0;Ec=0.0;// Newtonian partsWe=15000;// Based on the density of the gasOh=3e-3;// Based on the density of the liquidOha=0.018*Oh;// Based on the density of the liquidtmax=200;// Create a folder named intermediate where all the simulation snapshots are storedcharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: See writingFiles eventsprintf(dumpFile,\"restart\");//...",
    "content": "See writingFiles eventsprintf(dumpFile,\"restart\");// Phase propertiesrho1=RhoInOut,rho2=1e0;// As both densities are based on the density of the liquid, we must multiply// the Ohnesorge number by the square root of the density ratiomu1=sqrt(RhoInOut)*Oh/sqrt(We),mu2=sqrt(RhoInOut)*Oha/sqrt(We);// Elastic parts// In G1, we need to multiply by the density ratio (again, because Ec is based// on the density of the liquid but in the code it is based on the density of the gas)G1=Ec/We,G2=0.0;// Here, lambda is essentially the Weissenberg number, so there is no density// in the expressionlambda1=De*sqrt(We),lambda2=0.0;// Surface tension -- the Weber number is based on the density of the gas!f.sigma=1.0/We;run();}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event init(t=0){if(!restore(file=dumpFile)){refine(R2(x,y,z)<1.1&&R2(x,y,z)>0.9&&level<MAXlevel);fraction(f,1.-R2(x,y,z));}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);adapt_wavelet((scalar*){f,KAPPA,u.x,u.y#if dimension ==,u.z#endif},(double[]){fErr,KErr,VelErr,VelErr,#if dimension ==VelErr#endif},MAXlevel,4);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: event logWriting(i++){// Calculate...",
    "content": "event logWriting(i++){// Calculate total kinetic energydoubleke=0.;foreach(reduction(+:ke)){ke+=(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])#if dimension ==+sq(u.z[])#endif))*pow(Delta,dimension);}staticFILE*fp;if(pid()==0){constchar*mode=(i==0)?\"w\":\"a\";fp=fopen(logFile,mode);if(fp==NULL){fprintf(ferr,\"Error opening log file\\n\");return1;}if(i==0){fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(ferr,\"i dt t ke\\n\");fprintf(fp,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(fp,\"i dt t ke rM\\n\");}fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);fflush(fp);fclose(fp);}assert(ke>-1e-10);// Check for simulation stability issues after initial iterationsif(i>1e1&&pid()==0){if(ke>1e6||ke<1e-6){constchar*message=(ke>1e6)?\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Stopping simulation\\n\":\"Kinetic energy...",
    "content": "Stopping simulation\\n\":\"Kinetic energy too small now! Stopping!\\n\";fprintf(ferr,\"%s\",message);fp=fopen(\"log\",\"a\");fprintf(fp,\"%s\",message);fflush(fp);fclose(fp);dump(file=dumpFile);return1;}}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files eigen_decomposition.h This module provides algorithms for computing eigenvalues and eigenvectors of 3x3 symmetric matrices, which are commo... log-conform-viscoelastic-scalar-2D.h Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materia... log-conform-viscoelastic-scalar-3D.h Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materia... log-conform-viscoelastic.h The implementation follows the standard log-conformation approach: 1. Uses tensor mathematics for clean formulation 2... two-phaseVE.h This is a modified version of [two-phase.h](http://basilisk.fr/src/two-phase.h). It contains the implementation of Vi...",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "src-local/eigen_decomposition.h See raw file Matrix Eigenvalue Solver This module provides algorithms for computing eigenvalues and eigenvectors of 3x3 symmetric matrices, which are commonly encountered in computational fluid dynamics, solid mechanics, and other physics-based simulations. Mathematical Background The implementation uses the Householder transformation to reduce a symmetric matrix to tridiagonal form, followed by the QL algorithm with implicit shifts to compute the eigenvalues and eigenvectors. For a 3x3 symmetric matrix, these methods are particularly efficient and numerically stable, providing accurate results even for matrices with closely spaced eigenvalues. Tridiagonalize a 3x3 Symmetric Matrix Reduces a 3x3 symmetric matrix to tridiagonal form using the Householder method, which applies a series of orthogonal transformations to eliminate elements below the subdiagonal.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Parameters: matrix[in]: Input 3x3 symmetric matrix to be tridiagonalized eigenvectors[out]: Orthogonal matrix of Householder vectors diagonal[out]: Diagonal elements of the resulting tridiagonal matrix subdiagonal[out]: Subdiagonal elements of the tridiagonal matrix Implementation Notes: The original matrix is preserved The eigenvectors matrix is initialized to identity and then transformed The algorithm exploits the symmetry of the input matrix #define SQUARE ( x ) (( x )*( x )) 36 static void tridiagonalize_symmetric_3x3 ( double matrix [ 3 ][ 3 ], double eigenvectors [ 3 ][ 3 ], double diagonal [ 3 ], double subdiagonal [ 2 ]) { const int size = 3 ; double householder_vector [ size ], temp_vector [ size ]; double omega , scale , sigma , tau ; // Initialize eigenvectors to the identity matrix for ( int i = 0 ; i < size ; i ++) { eigenvectors [ i ][ i ] = 1.0 ; for ( int j = 0 ; j < i ; j ++) eigenvectors [ i ][ j ] = eigenvectors [ j ][ i ] = 0.0 ; } // Compute the first Householder reflection scale = SQUARE ( matrix [ 0 ][ 1 ]) + SQUARE ( matrix [ 0 ][ 2 ]); sigma = ( matrix [ 0 ][ 1 ] > 0 ) ? - sqrt ( scale ) : sqrt ( scale ); subdiagonal [ 0 ] = sigma ; tau = sigma * matrix [ 0 ][ 1 ]; householder_vector [ 1 ] = matrix [ 0 ][ 1 ] - sigma ; householder_vector [ 2 ] = matrix [ 0 ][ 2 ]; omega = scale - tau ; if ( omega > 0.0 ) { omega = 1.0 / omega ; sigma = 0.0 ; for ( int i = 1 ; i < size ; i ++) { tau = matrix [ 1 ][ i ] * householder_vector [ 1 ] + matrix [ i ][ 2 ] * householder_vector [ 2 ]; temp_vector [ i ] = omega * tau ; sigma += householder_vector [ i ] * tau ; } sigma *= 0.5 * SQUARE ( omega ); for ( int i = 1 ; i < size ; i ++) temp_vector [ i ] -= sigma * householder_vector [ i ]; diagonal [ 0 ] = matrix [ 0 ][ 0 ]; diagonal [ 1 ] = matrix [ 1 ][ 1 ] - 2.0 * temp_vector [ 1 ] * householder_vector [ 1 ]; diagonal [ 2 ] = matrix [ 2 ][ 2 ] - 2.0 * temp_vector [ 2 ] * householder_vector [ 2 ]; for ( int j = 1 ; j < size ; j ++) { tau = omega * householder_vector [ j ]; for ( int i = 1 ; i < size ; i ++) eigenvectors [ i ][ j ] -= tau * householder_vector [ i ]; } subdiagonal [ 1 ] = matrix [ 1 ][ 2 ] - temp_vector [ 1 ] * householder_vector [ 2 ] - householder_vector [ 1 ] * temp_vector [ 2 ]; } else { for ( int i = 0 ; i < size ; i ++) diagonal [ i ] = matrix [ i ][ i ]; subdiagonal [ 1 ] = matrix [ 1 ][ 2 ]; } } ### Compute Eigenvalues and Eigenvectors of a 3x3 Symmetric Matrix Calculates the complete eigensystem (eigenvalues and eigenvectors) of a 3x3 symmetric matrix using the QL algorithm with implicit shifts, after first reducing the matrix to tridiagonal form.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Parameters: matrix[in]: Input...",
    "content": "Parameters: matrix[in]: Input 3x3 symmetric matrix whose eigensystem will be computed eigenvectors[out]: Matrix whose columns are the eigenvectors eigenvalues[out]: Array containing the eigenvalues Return Value: 0: Computation successful -1: Algorithm failed to converge within the maximum number of iterations Algorithm Details: First checks if the matrix is already diagonal If not, tridiagonalizes the matrix using Householder transformations Applies the QL algorithm with implicit shifts to compute eigenvalues Maximum of 30 iterations are allowed for convergence Numerical tolerance of 1e-15 is used for detecting diagonal matrices Usage Example: double matrix [ 3 ][ 3 ] = {{ 1.0 , 0.5 , 0.3 }, { 0.5 , 2.0 , 0.1 }, { 0.3 , 0.1 , 3.0 }}; double eigenvectors [ 3 ][ 3 ]; double eigenvalues [ 3 ]; int result = compute_eigensystem_symmetric_3x3 ( matrix , eigenvectors , eigenvalues ); if ( result == 0 ) { // Computation successful } static int compute_eigensystem_symmetric_3x3 ( double matrix [ 3 ][ 3 ], double eigenvectors [ 3 ][ 3 ], double eigenvalues [ 3 ]) { const int size = 3 ; const int max_iterations = 30 ; double subdiagonal [ 3 ]; double g , r , p , f , b , s , c , t ; int iteration_count ; int m ; // Check for diagonal matrix with unit entries if ( SQUARE ( matrix [ 0 ][ 1 ]) < 1e-15 && SQUARE ( matrix [ 0 ][ 2 ]) < 1e-15 && SQUARE ( matrix [ 1 ][ 2 ]) < 1e-15 ) { for ( int i = 0 ; i < size ; i ++) { for ( int j = 0 ; j < size ; j ++) { eigenvectors [ i ][ j ] = ( i == j ) ? 1.0 : 0.0 ; } eigenvalues [ i ] = matrix [ i ][ i ]; } return 0 ; } tridiagonalize_symmetric_3x3 ( matrix , eigenvectors , eigenvalues , subdiagonal ); for ( int l = 0 ; l < size - 1 ; l ++) { iteration_count = 0 ; while ( 1 ) { for ( m = l ; m <= size - 2 ; m ++) { g = fabs ( eigenvalues [ m ]) + fabs ( eigenvalues [ m + 1 ]); if ( fabs ( subdiagonal [ m ]) + g == g ) break ; } if ( m == l ) break ; if ( iteration_count ++ >= max_iterations ) return - 1 ; g = ( eigenvalues [ l + 1 ] - eigenvalues [ l ]) / ( 2.0 * subdiagonal [ l ]); r = sqrt ( SQUARE ( g ) + 1.0 ); g = eigenvalues [ m ] - eigenvalues [ l ] + subdiagonal [ l ] / ( g + ( g > 0 ? fabs ( r ) : - fabs ( r ))); s = c = 1.0 ; p = 0.0 ; for ( int i = m - 1 ; i >= l ; i --) { f = s * subdiagonal [ i ]; b = c * subdiagonal [ i ]; if ( fabs ( f ) > fabs ( g )) { c = g / f ; r = sqrt ( SQUARE ( c ) + 1.0 ); subdiagonal [ i + 1 ] = f * r ; c *= ( s = 1.0 / r ); } else { s = f / g ; r = sqrt ( SQUARE ( s ) + 1.0 ); subdiagonal [ i + 1 ] = g * r ; s *= ( c = 1.0 / r ); } g = eigenvalues [ i + 1 ] - p ; r = ( eigenvalues [ i ] - g ) * s + 2.0 * c * b ; p = s * r ; eigenvalues [ i + 1 ] = g + p ; g = c * r - b ; for ( int k = 0 ; k < size ; k ++) { t = eigenvectors [ k ][ i + 1 ]; eigenvectors [ k ][ i + 1 ] = s * eigenvectors [ k ][ i ] + c * t ; eigenvectors [ k ][ i ] = c * eigenvectors [ k ][ i ] - s * t ; } } eigenvalues [ l ] -= p ; subdiagonal [ l ] = g ; subdiagonal [ m ] = 0.0 ; } } return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "#define SQUARE(x)((x)*(x))36staticvoidtridiagonalize_symmetric_3x3(doublematrix[3][3],doubleeigenvectors[3][3],doublediagonal[3],doublesubdiagonal[2]){constintsize=3;doublehouseholder_vector[size],temp_vector[size];doubleomega,scale,sigma,tau;// Initialize eigenvectors to the identity matrixfor(inti=0;i<size;i++){eigenvectors[i][i]=1.0;for(intj=0;j<i;j++)eigenvectors[i][j]=eigenvectors[j][i]=0.0;}// Compute the first Householder reflectionscale=SQUARE(matrix[0][1])+SQUARE(matrix[0][2]);sigma=(matrix[0][1]>0)?-sqrt(scale):sqrt(scale);subdiagonal[0]=sigma;tau=sigma*matrix[0][1];householder_vector[1]=matrix[0][1]-sigma;householder_vector[2]=matrix[0][2];omega=scale-tau;if(omega>0.0){omega=1.0/omega;sigma=0.0;for(inti=1;i<size;i++){tau=matrix[1][i]*householder_vector[1]+matrix[i][2]*householder_vector[2];temp_vector[i]=omega*tau;sigma+=householder_vector[i]*tau;}sigma*=0.5*SQUARE(omega);for(inti=1;i<size;i++)temp_vector[i]-=sigma*householder_vector[i];diagonal[0]=matrix[0][0];diagonal[1]=matrix[1][1]-2.0*temp_vector[1]*householder_vector[1];diagonal[2]=matrix[2][2]-2.0*temp_vector[2]*householder_vector[2];for(intj=1;j<size;j++){tau=omega*householder_vector[j];for(inti=1;i<size;i++)eigenvectors[i][j]-=tau*householder_vector[i];}subdiagonal[1]=matrix[1][2]-temp_vector[1]*householder_vector[2]-householder_vector[1]*temp_vector[2];}else{for(inti=0;i<size;i++)diagonal[i]=matrix[i][i];subdiagonal[1]=matrix[1][2];}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doublematrix[3][3]={{1.0,0.5,0.3},{0.5,2.0,0.1},{0.3,0.1,3.0}};doubleeigenvectors[3][3];doubleeigenvalues[3];intresult=compute_eigensystem_symmetric_3x3(matrix,eigenvectors,eigenvalues);if(result==0){// Computation successful}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "staticintcompute_eigensystem_symmetric_3x3(doublematrix[3][3],doubleeigenvectors[3][3],doubleeigenvalues[3]){constintsize=3;constintmax_iterations=30;doublesubdiagonal[3];doubleg,r,p,f,b,s,c,t;intiteration_count;intm;// Check for diagonal matrix with unit entriesif(SQUARE(matrix[0][1])<1e-15&&SQUARE(matrix[0][2])<1e-15&&SQUARE(matrix[1][2])<1e-15){for(inti=0;i<size;i++){for(intj=0;j<size;j++){eigenvectors[i][j]=(i==j)?1.0:0.0;}eigenvalues[i]=matrix[i][i];}return0;}tridiagonalize_symmetric_3x3(matrix,eigenvectors,eigenvalues,subdiagonal);for(intl=0;l<size-1;l++){iteration_count=0;while(1){for(m=l;m<=size-2;m++){g=fabs(eigenvalues[m])+fabs(eigenvalues[m+1]);if(fabs(subdiagonal[m])+g==g)break;}if(m==l)break;if(iteration_count++>=max_iterations)return-1;g=(eigenvalues[l+1]-eigenvalues[l])/(2.0*subdiagonal[l]);r=sqrt(SQUARE(g)+1.0);g=eigenvalues[m]-eigenvalues[l]+subdiagonal[l]/(g+(g>0?fabs(r):-fabs(r)));s=c=1.0;p=0.0;for(inti=m-1;i>=l;i--){f=s*subdiagonal[i];b=c*subdiagonal[i];if(fabs(f)>fabs(g)){c=g/f;r=sqrt(SQUARE(c)+1.0);subdiagonal[i+1]=f*r;c*=(s=1.0/r);}else{s=f/g;r=sqrt(SQUARE(s)+1.0);subdiagonal[i+1]=g*r;s*=(c=1.0/r);}g=eigenvalues[i+1]-p;r=(eigenvalues[i]-g)*s+2.0*c*b;p=s*r;eigenvalues[i+1]=g+p;g=c*r-b;for(intk=0;k<size;k++){t=eigenvectors[k][i+1];eigenvectors[k][i+1]=s*eigenvectors[k][i]+c*t;eigenvectors[k][i]=c*eigenvectors[k][i]-s*t;}}eigenvalues[l]-=p;subdiagonal[l]=g;subdiagonal[m]=0.0;}}return0;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "src-local/two-phaseVE.h See raw file Modification by Vatsal Sanjay Version 2.0, Oct 17, 2024 Changelog Oct 17, 2024: added support for VE simulations. Brief history v1.0 is the vanilla Basilisk code for two-phase flows: http://basilisk.fr/src/two-phase.h + http://basilisk.fr/src/two-phase-generic.h v2.0 is the modification for viscoelastic fluids using the log-conformation method. Two-phase interfacial flows This is a modified version of two-phase.h . It contains the implementation of Viscoplastic Fluid (Bingham Fluid). This file helps setup simulations for flows of two fluids separated by an interface (i.e. immiscible fluids). It is typically used in combination with a Navier\u2013Stokes solver . The interface between the fluids is tracked with a Volume-Of-Fluid method. The volume fraction in fluid 1 is \\(f=1\\) and \\(f=0\\) in fluid 2.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: C/C++ Code",
    "content": "The densities and dynamic viscosities for fluid 1 and 2 are rho1 , mu1 , rho2 , mu2 , respectively. #include \"vof.h\" scalar f [], * interfaces = { f }; double rho1 = 1. , mu1 = 0. , rho2 = 1. , mu2 = 0. ; double G1 = 0. , G2 = 0. ; // elastic moduli double lambda1 = 0. , lambda2 = 0. ; // relaxation times double TOLelastic = 1e-2 ; // tolerance for elastic modulus #TOFIX: this must always be a very small number. Auxilliary fields are necessary to define the (variable) specific volume \\(\\alpha=1/\\rho\\) as well as the cell-centered density. face vector alphav []; scalar rhov []; scalar Gpd []; scalar lambdapd []; event defaults ( i = 0 ) { alpha = alphav ; rho = rhov ; Gp = Gpd ; lambda = lambdapd ; If the viscosity is non-zero, we need to allocate the face-centered viscosity field. mu = new face vector ; } The density and viscosity are defined using arithmetic averages by default.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Definitions - Python Function",
    "content": "The user can overload these definitions to use other types of averages (i.e. harmonic). #ifndef rho # define rho ( f ) ( clamp ( f , 0. , 1. )*( rho1 - rho2 ) + rho2 ) 62 #endif #ifndef mu // for Arithmetic mean, use this # define mu ( f ) ( clamp ( f , 0. , 1. )*( mu1 - mu2 ) + mu2 ) 66 #endif We have the option of using some \u201csmearing\u201d of the density/viscosity jump. #ifdef FILTERED scalar sf []; #else # define sf f 76 #endif event tracer_advection ( i ++) { When using smearing of the density jump, we initialise sf with the vertex-average of f . #ifndef sf #if dimension <= foreach () sf [] = ( 4. * f [] + 2. *( f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 1 , 0 ] + f [- 1 , 0 ]) + f [- 1 ,- 1 ] + f [ 1 ,- 1 ] + f [ 1 , 1 ] + f [- 1 , 1 ])/ 16. ; #else // dimension == foreach () sf [] = ( 8. * f [] + 4. *( f [- 1 ] + f [ 1 ] + f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 0 , 0 , 1 ] + f [ 0 , 0 ,- 1 ]) + 2. *( f [- 1 , 1 ] + f [- 1 , 0 , 1 ] + f [- 1 , 0 ,- 1 ] + f [- 1 ,- 1 ] + f [ 0 , 1 , 1 ] + f [ 0 , 1 ,- 1 ] + f [ 0 ,- 1 , 1 ] + f [ 0 ,- 1 ,- 1 ] + f [ 1 , 1 ] + f [ 1 , 0 , 1 ] + f [ 1 ,- 1 ] + f [ 1 , 0 ,- 1 ]) + f [ 1 ,- 1 , 1 ] + f [- 1 , 1 , 1 ] + f [- 1 , 1 ,- 1 ] + f [ 1 , 1 , 1 ] + f [ 1 , 1 ,- 1 ] + f [- 1 ,- 1 ,- 1 ] + f [ 1 ,- 1 ,- 1 ] + f [- 1 ,- 1 , 1 ])/ 64. ; #endif #endif #if TREE sf . prolongation = refine_bilinear ; sf . dirty = true ; // boundary conditions need to be updated #endif } event properties ( i ++) { foreach_face () { double ff = ( sf [] + sf [- 1 ])/ 2. ; alphav . x [] = fm . x []/ rho ( ff ); face vector muv = mu ; muv . x [] = fm . x []* mu ( ff ); } foreach (){ rhov [] = cm []* rho ( sf []); Gpd [] = 0. ; lambdapd [] = 0. ; if ( clamp ( sf [], 0. , 1. ) > TOLelastic ){ Gpd [] += G1 * clamp ( sf [], 0. , 1. ); lambdapd [] += lambda1 * clamp ( sf [], 0. , 1. ); } if ( clamp (( 1 - sf []), 0. , 1. ) > TOLelastic ){ Gpd [] += G2 * clamp (( 1 - sf []), 0. , 1. ); lambdapd [] += lambda2 * clamp (( 1 - sf []), 0. , 1. ); } } #if TREE sf . prolongation = fraction_refine ; sf . dirty = true ; // boundary conditions need to be updated #endif }",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "#include\"vof.h\"scalar f[],*interfaces={f};doublerho1=1.,mu1=0.,rho2=1.,mu2=0.;doubleG1=0.,G2=0.;// elastic modulidoublelambda1=0.,lambda2=0.;// relaxation timesdoubleTOLelastic=1e-2;// tolerance for elastic modulus #TOFIX: this must always be a very small number.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "face vector alphav[];scalar rhov[];scalar Gpd[];scalar lambdapd[];event defaults(i=0){alpha=alphav;rho=rhov;Gp=Gpd;lambda=lambdapd;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Function: rho",
    "content": "#ifndef rho# define rho(f)(clamp(f,0.,1.)*(rho1-rho2)+rho2)62#endif#ifndef mu// for Arithmetic mean, use this# define mu(f)(clamp(f,0.,1.)*(mu1-mu2)+mu2)66#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Function: FILTEREDscalar",
    "content": "#ifdef FILTEREDscalar sf[];#else# define sf f76#endifevent tracer_advection(i++){",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Function: sf",
    "content": "#ifndef sf#if dimension <=foreach()sf[]=(4.*f[]+2.*(f[0,1]+f[0,-1]+f[1,0]+f[-1,0])+f[-1,-1]+f[1,-1]+f[1,1]+f[-1,1])/16.;#else// dimension ==foreach()sf[]=(8.*f[]+4.*(f[-1]+f[1]+f[0,1]+f[0,-1]+f[0,0,1]+f[0,0,-1])+2.*(f[-1,1]+f[-1,0,1]+f[-1,0,-1]+f[-1,-1]+f[0,1,1]+f[0,1,-1]+f[0,-1,1]+f[0,-1,-1]+f[1,1]+f[1,0,1]+f[1,-1]+f[1,0,-1])+f[1,-1,1]+f[-1,1,1]+f[-1,1,-1]+f[1,1,1]+f[1,1,-1]+f[-1,-1,-1]+f[1,-1,-1]+f[-1,-1,1])/64.;#endif#endif#if TREEsf.prolongation=refine_bilinear;sf.dirty=true;// boundary conditions need to be updated#endif}event properties(i++){foreach_face(){doubleff=(sf[]+sf[-1])/2.;alphav.x[]=fm.x[]/rho(ff);face vector muv=mu;muv.x[]=fm.x[]*mu(ff);}foreach(){rhov[]=cm[]*rho(sf[]);Gpd[]=0.;lambdapd[]=0.;if(clamp(sf[],0.,1.)>TOLelastic){Gpd[]+=G1*clamp(sf[],0.,1.);lambdapd[]+=lambda1*clamp(sf[],0.,1.);}if(clamp((1-sf[]),0.,1.)>TOLelastic){Gpd[]+=G2*clamp((1-sf[]),0.,1.);lambdapd[]+=lambda2*clamp((1-sf[]),0.,1.);}}#if TREEsf.prolongation=fraction_refine;sf.dirty=true;// boundary conditions need to be updated#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Methods",
    "content": "src-local/log-conform-viscoelastic-scalar-3D.h See raw file Log-Conformation Method for 3D Viscoelastic Fluids Overview Title : log-conform-viscoelastic-3D.h Version : 2.6 Description : Implementation of the log-conformation method for viscoelastic fluids in 3D Key Features Conformation tensor A exists across the domain and relaxes according to \u03bb Stress acts according to elastic modulus G 3D implementation extending log-conform-viscoelastic-scalar-2D.h Eigenvalue clamping for numerical stability Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Mar 16, 2025 Dependencies bcg.h: Bell-Collela-Glaz scheme for advection eigen_decomposition.h: For 3D eigenvalue computation navier-stokes/centered.h: For base flow solver References Fattal & Kupferman (2004, 2005): Original log-conformation method Comminal et al. (2015): Constitutive model functions Hao & Pan (2007): Split scheme implementation Version History v1.0 (Oct 19, 2024) Initial 3D implementation Scalar implementation approach v1.1 (Oct 20, 2024) Added negative eigenvalue detection Added error reporting system v2.0 (Oct 29, 2024) Major matrix algebra corrections for 3D Optimized tensor calculations Improved code structure and documentation v2.1 (Oct 29, 2024) Added initialization functions for tensor structures v2.2 (Nov 3, 2024) Refactored tensor operations Improved code maintainability Enhanced tensor manipulation consistency v2.3 (Nov 14, 2024) Added infinite Deborah number support v2.5 (Nov 23, 2024) Documentation improvements Added mathematical explanations v2.6 (Mar 16, 2025) Implemented eigenvalue clamping system Added minimum eigenvalue threshold (EIGENVALUE_MIN = 1e-8) Improved numerical stability handling Added diagnostic capabilities Fixed 3D velocity gradient calculation Implementation Notes The code extends the standard Basilisk log-conformation implementation Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling with polymeric stress Includes both 2D and 3D implementations Uses atomic operations for thread-safe diagnostics Future Work Axisymmetric Compatibility Currently not implemented Use log-conform-viscoelastic-scalar-2D.h for axi cases Or use log-conform-viscoelastic.h for better efficiency Metric Terms Improvements Enforce tensor compatibility using foreach_dimension Complete metric terms (cm, fm) implementation #if AXI #error \"axi compatibility is not there.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Introduction",
    "content": "To keep the code easy to read, we will not implement axi compatibility just yet.\" #endif The log-conformation method for some viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function. The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: In the case...",
    "content": "In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models. Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This instability poses...",
    "content": "This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) . /* TODO : - Perhaps, instead of the Bell--Collela--Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to [http://basilisk.fr/src/navier-stokes/conserving.h](http://basilisk.fr/src/navier-stokes/conserving.h) */ #define EIGENVALUE_MIN 1e-8 220 #ifdef DEBUG_EIGENVALUES static int eigenvalue_corrections = 0 ; #endif #include \"bcg.h\" ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time /* conformation tensor */ // diagonal elements scalar A11 [], A22 [], A33 []; // off-diagonal elements scalar A12 [], A13 [], A23 []; /* stress tensor */ // diagonal elements scalar T11 [], T22 [], T33 []; // off-diagonal elements scalar T12 [], T13 [], T23 []; event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; /* initialize A and T */ for ( scalar s in { A11 , A22 , A33 }) { foreach () { s [] = 1. ; } } for ( scalar s in { T11 , T12 , T13 , T22 , T23 , T33 , A12 , A13 , A23 }) { foreach (){ s [] = 0. ; } } for ( scalar s in { A11 , A22 , A33 , T11 , T22 , T33 , A12 , A13 , A23 , T12 , T13 , T23 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } if ( s . boundary [ top ] != periodic_bc ) { s [ top ] = neumann ( 0 ); s [ bottom ] = neumann ( 0 ); } #if dimension == if ( s . boundary [ front ] != periodic_bc ) { s [ front ] = neumann ( 0 ); s [ back ] = neumann ( 0 ); } #endif } } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. #if dimension == typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } #endif /* Now this is the 3D implementation. */ #if dimension == #include \"eigen_decomposition.h\" typedef struct { double x , y , z ; } pseudo_v3d ; typedef struct { pseudo_v3d x , y , z ; } pseudo_t3d ; // Function to initialize pseudo_v3d static inline void init_pseudo_v3d ( pseudo_v3d * v , double value ) { v -> x = value ; v -> y = value ; v -> z = value ; } // Function to initialize pseudo_t3d static inline void init_pseudo_t3d ( pseudo_t3d * t , double value ) { init_pseudo_v3d (& t -> x , value ); init_pseudo_v3d (& t -> y , value ); init_pseudo_v3d (& t -> z , value ); } static void diagonalization_3D ( pseudo_v3d * Lambda , pseudo_t3d * R , pseudo_t3d * A ) { // Check if the matrix is already diagonal if ( sq ( A -> x . y ) + sq ( A -> x . z ) + sq ( A -> y . z ) < 1e-15 ) { R -> x . x = R -> y . y = R -> z . z = 1. ; R -> y . x = R -> x . y = R -> z . x = R -> x . z = R -> z . y = R -> y . z = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; Lambda -> z = A -> z . z ; return ; } // Compute eigenvalues using the eigen_decomposition function double matrix [ 3 ][ 3 ] = { { A -> x . x , A -> x . y , A -> x . z }, { A -> y . x , A -> y . y , A -> y . z }, { A -> z . x , A -> z . y , A -> z . z } }; double eigenvectors [ 3 ][ 3 ]; double eigenvalues [ 3 ]; compute_eigensystem_symmetric_3x3 ( matrix , eigenvectors , eigenvalues ); // Store eigenvalues and eigenvectors Lambda -> x = eigenvalues [ 0 ]; Lambda -> y = eigenvalues [ 1 ]; Lambda -> z = eigenvalues [ 2 ]; R -> x . x = eigenvectors [ 0 ][ 0 ]; R -> x . y = eigenvectors [ 0 ][ 1 ]; R -> x . z = eigenvectors [ 0 ][ 2 ]; R -> y . x = eigenvectors [ 1 ][ 0 ]; R -> y . y = eigenvectors [ 1 ][ 1 ]; R -> y . z = eigenvectors [ 1 ][ 2 ]; R -> z . x = eigenvectors [ 2 ][ 0 ]; R -> z . y = eigenvectors [ 2 ][ 1 ]; R -> z . z = eigenvectors [ 2 ][ 2 ]; } #endif The stress tensor depends on previous instants and has to be integrated in time.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: In the log-conformation...",
    "content": "In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) . We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ). In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] #if dimension == Advances the log-conformation tensor and updates the corresponding conformation and stress tensors.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "This event function performs three primary steps within the viscoelastic fluid simulation: - Diagonalizes the conformation tensor and computes its logarithm (\u03a8) while applying eigenvalue clamping to ensure numerical stability. - Advances \u03a8 in time by incorporating the upper convective term computed from the velocity gradient, which is used to update the log-conformation tensor. - Recovers the physical conformation tensor and stress tensor by exponentiating the diagonalized eigenvalues and integrating the relaxation term.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Note: Although the...",
    "content": "Note: Although the overall simulation targets 3D viscoelastic fluids, this implementation uses a 2D diagonalization routine. event tracer_advection ( i ++) { scalar Psi11 = A11 ; scalar Psi12 = A12 ; scalar Psi22 = A22 ; Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A = {{ A11 [], A12 []}, { A12 [], A22 []}}; The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); pseudo_t R ; init_pseudo_t (& R , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This prevents numerical...",
    "content": "This prevents numerical instabilities while maintaining physical meaning. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"WARNING: Negative eigenvalue detected at ( %g , %g ): [ %g , %g ] \\n \" , x , y , Lambda . x , Lambda . y ); #ifdef DEBUG_EIGENVALUES atomic_increment (& eigenvalue_corrections ); #endif Lambda . x = max ( Lambda . x , EIGENVALUE_MIN ); Lambda . y = max ( Lambda . y , EIGENVALUE_MIN ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) . Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); Psi22 [] = sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . x )* log ( Lambda . x ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The diagonalization will...",
    "content": "The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis. Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: R is the eigenvector matrix of the conformation tensor M is the velocity gradient tensor in the eigenvector basis The construction ensures B is symmetric and traceless pseudo_t B ; init_pseudo_t (& B , 0.0 ); double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; init_pseudo_t (& M , 0.0 ); foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi12 []; Psi12 [] += dt * ( 2. * B . x . y + OM * ( Psi22 [] - Psi11 [])); s *= - 1 ; Psi11 [] += dt * 2. * ( B . x . x + s * OM ); s *= - 1 ; Psi22 [] += dt * 2. * ( B . y . y + s * OM ); } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . advection ({ Psi11 , Psi12 , Psi22 }, uf , dt ); Convert back to Aij foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi11 [], Psi12 []}, { Psi12 [], Psi22 []}}, R ; init_pseudo_t (& R , 0.0 ); pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . A12 [] = A . x . y ; T12 [] = Gp []* A . x . y ; A11 [] = A . x . x ; T11 [] = Gp []*( A . x . x - 1. ); A22 [] = A . y . y ; T22 [] = Gp []*( A . y . y - 1. ); } } #elif dimension == Advances the log-conformation tensor and computes the corresponding conformation and stress tensors for 3D viscoelastic fluid simulations. This event function performs a two-step update for the viscoelastic fluid model using the log-conformation method.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: In the first...",
    "content": "In the first part, it computes the logarithm of the conformation tensor \\(\\Psi\\) from A by: - Diagonalizing A to obtain eigenvalues ( \\(\\Lambda\\) ) and eigenvectors (R). - Clamping any negative eigenvalues to prevent numerical instabilities (using EIGENVALUE_MIN). - Evaluating \\(\\Psi = \\log(A)\\) and incorporating the upper convective contribution via the symmetric tensor B and the skew-symmetric tensor \\(\\Omega\\) . \\(\\Psi\\) is then advanced in time using central difference approximations for the velocity gradients, where degenerate eigenvalue cases are handled with simplified calculations. In the second part, the function converts the updated log-conformation tensor back to the conformation tensor A by exponentiating the eigenvalues and applies the relaxation factor derived from the relaxation time. Finally, it computes the polymeric stress tensor T from A.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Warnings are printed...",
    "content": "Warnings are printed if negative eigenvalues are detected, and a debug counter is incremented when debugging is enabled. event tracer_advection ( i ++) { Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term // start by declaring the scalar variables that will store the components of $\\Psi$ scalar Psi11 = A11 , Psi12 = A12 , Psi13 = A13 , Psi22 = A22 , Psi23 = A23 , Psi33 = A33 ; foreach () { pseudo_t3d A , R ; init_pseudo_t3d (& R , 0.0 ); pseudo_v3d Lambda ; init_pseudo_v3d (& Lambda , 0.0 ); A . x . x = A11 []; A . x . y = A12 []; A . x . z = A13 []; A . y . x = A12 []; A . y . y = A22 []; A . y . z = A23 []; A . z . x = A13 []; A . z . y = A23 []; A . z . z = A33 []; // Diagonalize the conformation tensor A to obtain the eigenvalues Lambda and eigenvectors R diagonalization_3D (& Lambda , & R , & A ); /* Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This prevents numerical...",
    "content": "This prevents numerical instabilities while maintaining physical meaning. */ if ( Lambda . x <= 0. || Lambda . y <= 0. || Lambda . z <= 0. ) { fprintf ( ferr , \"WARNING: Negative eigenvalue detected at ( %g , %g , %g ): [ %g , %g , %g ] \\n \" , x , y , z , Lambda . x , Lambda . y , Lambda . z ); #ifdef DEBUG_EIGENVALUES atomic_increment (& eigenvalue_corrections ); #endif Lambda . x = max ( Lambda . x , EIGENVALUE_MIN ); Lambda . y = max ( Lambda . y , EIGENVALUE_MIN ); Lambda . z = max ( Lambda . z , EIGENVALUE_MIN ); } // Compute Psi = log(A) = R * log(Lambda) * R^T Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ) + sq ( R . x . z )* log ( Lambda . z ); Psi22 [] = sq ( R . y . x )* log ( Lambda . x ) + sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . z )* log ( Lambda . z ); Psi33 [] = sq ( R . z . x )* log ( Lambda . x ) + sq ( R . z . y )* log ( Lambda . y ) + sq ( R . z . z )* log ( Lambda . z ); Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . x . y * R . y . y * log ( Lambda . y ) + R . x . z * R . y . z * log ( Lambda . z ); Psi13 [] = R . x . x * R . z . x * log ( Lambda . x ) + R . x . y * R . z . y * log ( Lambda . y ) + R . x . z * R . z . z * log ( Lambda . z ); Psi23 [] = R . y . x * R . z . x * log ( Lambda . x ) + R . y . y * R . z . y * log ( Lambda . y ) + R . y . z * R . z . z * log ( Lambda . z ); // Compute B and Omega tensors (3D version) pseudo_t3d B , M , Omega ; init_pseudo_t3d (& B , 0.0 ); init_pseudo_t3d (& M , 0.0 ); init_pseudo_t3d (& Omega , 0.0 ); // Check if any pair of eigenvalues are numerically equal (within a small tolerance) if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 || fabs ( Lambda . y - Lambda . z ) <= 1e-20 || fabs ( Lambda . z - Lambda . x ) <= 1e-20 ) { // In case of equal eigenvalues, the calculations for B and Omega simplify significantly // B is grad U and Omega is zero. // Compute off-diagonal elements of B using central differences // These represent the symmetric part of the velocity gradient tensor B . x . y = ( u . y [ 1 , 0 , 0 ] - u . y [- 1 , 0 , 0 ] + u . x [ 0 , 1 , 0 ] - u . x [ 0 ,- 1 , 0 ])/( 4. * Delta ); // (dv/dx + du/dy)/2 B . x . z = ( u . z [ 1 , 0 , 0 ] - u . z [- 1 , 0 , 0 ] + u . x [ 0 , 0 , 1 ] - u . x [ 0 , 0 ,- 1 ])/( 4. * Delta ); // (dw/dx + du/dz)/2 B . y . z = ( u . z [ 0 , 1 , 0 ] - u . z [ 0 ,- 1 , 0 ] + u . y [ 0 , 0 , 1 ] - u . y [ 0 , 0 ,- 1 ])/( 4. * Delta ); // (dw/dy + dv/dz)/2 // Compute diagonal elements of B // These represent the normal strain rates B . x . x = ( u . x [ 1 , 0 , 0 ] - u . x [- 1 , 0 , 0 ])/( 2. * Delta ); // du/dx B . y . y = ( u . y [ 0 , 1 , 0 ] - u . y [ 0 ,- 1 , 0 ])/( 2. * Delta ); // dv/dy B . z . z = ( u . z [ 0 , 0 , 1 ] - u . z [ 0 , 0 ,- 1 ])/( 2. * Delta ); // dw/dz // Set all components of Omega to zero // This is because Omega represents the antisymmetric part of the velocity gradient tensor, // which vanishes when eigenvalues are equal Omega . x . y = Omega . x . z = Omega . y . z = Omega . y . x = Omega . z . x = Omega . z . y = 0. ; } else { /* ### Compute the velocity gradient tensor components using central differences - These represent the spatial derivatives of each velocity component - These gradients form the velocity gradient tensor (nablaU): [ dudx dudy dudz ] [ dvdx dvdy dvdz ] [ dwdx dwdy dwdz ] */ // Derivatives of u (x-component of velocity) double dudx = ( u . x [ 1 , 0 , 0 ] - u . x [- 1 , 0 , 0 ])/( 2.0 * Delta ); // du/dx double dudy = ( u . x [ 0 , 1 , 0 ] - u . x [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // du/dy double dudz = ( u . x [ 0 , 0 , 1 ] - u . x [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // du/dz // Derivatives of v (y-component of velocity) double dvdx = ( u . y [ 1 , 0 , 0 ] - u . y [- 1 , 0 , 0 ])/( 2.0 * Delta ); // dv/dx double dvdy = ( u . y [ 0 , 1 , 0 ] - u . y [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // dv/dy double dvdz = ( u . y [ 0 , 0 , 1 ] - u . y [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // dv/dz // Derivatives of w (z-component of velocity) double dwdx = ( u . z [ 1 , 0 , 0 ] - u . z [- 1 , 0 , 0 ])/( 2.0 * Delta ); // dw/dx double dwdy = ( u . z [ 0 , 1 , 0 ] - u . z [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // dw/dy double dwdz = ( u . z [ 0 , 0 , 1 ] - u . z [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // dw/dz /* Calculate the M tensor through matrix multiplication: M = R * (nablaU)^T R^T.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This represents the...",
    "content": "This represents the velocity gradient tensor transformed to the eigenvector basis of the conformation tensor. * Steps: 1. Compute intermediate products (R * nablaU^T): - Store row-wise products in Rx_gradU_*, Ry_gradU_*, Rz_gradU_* - Each variable represents one row of the intermediate matrix 2.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Multiply by R^T...",
    "content": "Multiply by R^T to obtain the final M tensor: - M.i.j represents the (i,j) component of the transformed velocity gradient - This transformation expresses the velocity gradient in the eigenvector basis - The resulting M tensor is used to compute Omega (\u03a9) and B tensors, such that */ // First, compute intermediate products of R and (nablaU)^T double Rx_gradU_x = R . x . x * dudx + R . x . y * dvdx + R . x . z * dwdx ; double Rx_gradU_y = R . x . x * dudy + R . x . y * dvdy + R . x . z * dwdy ; double Rx_gradU_z = R . x . x * dudz + R . x . y * dvdz + R . x . z * dwdz ; double Ry_gradU_x = R . y . x * dudx + R . y . y * dvdx + R . y . z * dwdx ; double Ry_gradU_y = R . y . x * dudy + R . y . y * dvdy + R . y . z * dwdy ; double Ry_gradU_z = R . y . x * dudz + R . y . y * dvdz + R . y . z * dwdz ; double Rz_gradU_x = R . z . x * dudx + R . z . y * dvdx + R . z . z * dwdx ; double Rz_gradU_y = R . z . x * dudy + R . z . y * dvdy + R . z . z * dwdy ; double Rz_gradU_z = R . z . x * dudz + R . z . y * dvdz + R . z . z * dwdz ; // Now compute M components by multiplying the intermediate products with R^T M . x . x = R . x . x * Rx_gradU_x + R . x . y * Rx_gradU_y + R . x . z * Rx_gradU_z ; M . x . y = R . x . x * Ry_gradU_x + R . x . y * Ry_gradU_y + R . x . z * Ry_gradU_z ; M . x . z = R . x . x * Rz_gradU_x + R . x . y * Rz_gradU_y + R . x . z * Rz_gradU_z ; M . y . x = R . y . x * Rx_gradU_x + R . y . y * Rx_gradU_y + R . y . z * Rx_gradU_z ; M . y . y = R . y . x * Ry_gradU_x + R . y . y * Ry_gradU_y + R . y . z * Ry_gradU_z ; M . y . z = R . y . x * Rz_gradU_x + R . y . y * Rz_gradU_y + R . y . z * Rz_gradU_z ; M . z . x = R . z . x * Rx_gradU_x + R . z . y * Rx_gradU_y + R . z . z * Rx_gradU_z ; M . z . y = R . z . x * Ry_gradU_x + R . z . y * Ry_gradU_y + R . z . z * Ry_gradU_z ; M . z . z = R . z . x * Rz_gradU_x + R . z . y * Rz_gradU_y + R . z . z * Rz_gradU_z ; // Compute the off-diagonal elements of the Omega tensor in the eigenvector basis double omega_xy = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); double omega_xz = ( Lambda . z * M . x . z + Lambda . x * M . z . x )/( Lambda . z - Lambda . x ); double omega_yz = ( Lambda . z * M . y . z + Lambda . y * M . z . y )/( Lambda . z - Lambda . y ); // Calculate intermediate rotation combinations for each direction // x-direction rotation combinations double rot_x_xy_yz = ( R . x . x * omega_xy - R . x . z * omega_yz ); // xy rotation minus yz rotation, x components double rot_x_xy_xz = ( R . x . y * omega_xy + R . x . z * omega_xz ); // xy rotation plus xz rotation, x components double rot_x_xz_yz = ( R . x . x * omega_xz + R . x . y * omega_yz ); // xz rotation plus yz rotation, x components // y-direction rotation combinations double rot_y_xy_yz = ( R . y . x * omega_xy - R . y . z * omega_yz ); // xy rotation minus yz rotation, y components double rot_y_xy_xz = ( R . y . y * omega_xy + R . y . z * omega_xz ); // xy rotation plus xz rotation, y components double rot_y_xz_yz = ( R . y . x * omega_xz + R . y . y * omega_yz ); // xz rotation plus yz rotation, y components // z-direction rotation combinations double rot_z_xy_yz = ( R . z . x * omega_xy - R . z . z * omega_yz ); // xy rotation minus yz rotation, z components double rot_z_xy_xz = ( R . z . y * omega_xy + R . z . z * omega_xz ); // xy rotation plus xz rotation, z components double rot_z_xz_yz = ( R . z . x * omega_xz + R . z . y * omega_yz ); // xz rotation plus yz rotation, z components Calculate the components of the Omega tensor in the physical coordinate system The Omega tensor represents the rotational part of the velocity gradient tensor and is computed through the following steps: We already have: R: eigenvector matrix of the conformation tensor rot_*_*_*: pre-computed rotation combinations for each direction Mathematical background: Omega = R * Omega_eigen * R^T where Omega_eigen is the rotation tensor in eigenvector space The components are calculated using the rotation combinations: rot_i_jk_lm represents combined rotations in the i-direction Each component Omega_ij is a linear combination of these rotations // Compute x-row components of Omega Omega . x . x = R . x . y * rot_x_xy_yz // xy-yz rotation contribution - R . x . x * rot_x_xy_xz // xy-xz rotation contribution + R . x . z * rot_x_xz_yz ; // xz-yz rotation contribution Omega . x . y = R . y . y * rot_x_xy_yz // xy-yz rotation mapped to y-direction - R . y . x * rot_x_xy_xz // xy-xz rotation mapped to y-direction + R . y . z * rot_x_xz_yz ; // xz-yz rotation mapped to y-direction Omega . x . z = R . z . y * rot_x_xy_yz // xy-yz rotation mapped to z-direction - R . z . x * rot_x_xy_xz // xy-xz rotation mapped to z-direction + R . z . z * rot_x_xz_yz ; // xz-yz rotation mapped to z-direction // Compute y-row components using similar pattern Omega . y . x = R . x . y * rot_y_xy_yz - R . x . x * rot_y_xy_xz + R . x . z * rot_y_xz_yz ; Omega . y . y = R . y . y * rot_y_xy_yz - R . y . x * rot_y_xy_xz + R . y . z * rot_y_xz_yz ; Omega . y . z = R . z . y * rot_y_xy_yz - R . z . x * rot_y_xy_xz + R . z . z * rot_y_xz_yz ; // Compute z-row components using similar pattern Omega . z . x = R . x . y * rot_z_xy_yz - R . x . x * rot_z_xy_xz + R . x . z * rot_z_xz_yz ; Omega . z . y = R . y . y * rot_z_xy_yz - R . y . x * rot_z_xy_xz + R . y . z * rot_z_xz_yz ; Omega . z . z = R . z . y * rot_z_xy_yz - R . z . x * rot_z_xy_xz + R . z . z * rot_z_xz_yz ; Note: The resulting Omega tensor is skew-symmetric, meaning: - Omega_ij = -Omega_ji This property is automatically satisfied by the construction above and is essential for preserving the physical meaning of rotation // Extract diagonal components of M (velocity gradient tensor in eigenvector basis) double M_diag_x = M . x . x , M_diag_y = M . y . y , M_diag_z = M . z . z ; Compute B tensor: B = R * diag(M) * R^T - This transforms the diagonal velocity gradient tensor back to the original coordinate system - B is symmetric, so we only need to compute the upper triangle // Compute diagonal elements of B B . x . x = M_diag_x * sq ( R . x . x ) + M_diag_y * sq ( R . x . y ) + M_diag_z * sq ( R . x . z ); B . y . y = M_diag_x * sq ( R . y . x ) + M_diag_y * sq ( R . y . y ) + M_diag_z * sq ( R . y . z ); B . z . z = M_diag_x * sq ( R . z . x ) + M_diag_y * sq ( R . z . y ) + M_diag_z * sq ( R . z . z ); // Compute off-diagonal elements of B (upper triangle) B . x . y = M_diag_x * R . x . x * R . y . x + M_diag_y * R . x . y * R . y . y + M_diag_z * R . x . z * R . y . z ; B . x . z = M_diag_x * R . x . x * R . z . x + M_diag_y * R . x . y * R . z . y + M_diag_z * R . x . z * R . z . z ; B . y . z = M_diag_x * R . y . x * R . z . x + M_diag_y * R . y . y * R . z . y + M_diag_z * R . y . z * R . z . z ; // Fill in lower triangle using symmetry of B B . y . x = B . x . y ; B . z . x = B . x . z ; B . z . y = B . y . z ; } We now advance \\(\\Psi\\) in time, adding the upper convective contribution.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This step 1:...",
    "content": "This step 1: _t = 2 + (-) // save old values of Psi components double old_Psi11 = Psi11 []; double old_Psi22 = Psi22 []; double old_Psi33 = Psi33 []; double old_Psi12 = Psi12 []; double old_Psi13 = Psi13 []; double old_Psi23 = Psi23 []; // Psi11 Psi11 [] += dt * ( 2.0 * B . x . x + Omega . x . y * old_Psi12 - Omega . y . x * old_Psi12 + Omega . x . z * old_Psi13 - Omega . z . x * old_Psi13 ); // Psi22 Psi22 [] += dt * ( 2.0 * B . y . y - Omega . x . y * old_Psi12 + Omega . y . x * old_Psi12 + Omega . y . z * old_Psi23 - Omega . z . y * old_Psi23 ); // Psi33 Psi33 [] += dt * ( 2.0 * B . z . z - Omega . x . z * old_Psi13 + Omega . z . x * old_Psi13 - Omega . y . z * old_Psi23 + Omega . z . y * old_Psi23 ); // Psi12 Psi12 [] += dt * ( 2.0 * B . x . y + Omega . x . x * old_Psi12 - Omega . x . y * old_Psi11 + Omega . x . y * old_Psi22 - Omega . y . y * old_Psi12 + Omega . x . z * old_Psi23 - Omega . z . y * old_Psi13 ); // Psi13 Psi13 [] += dt * ( 2.0 * B . x . z + Omega . x . x * old_Psi13 - Omega . x . z * old_Psi11 + Omega . x . y * old_Psi23 - Omega . y . z * old_Psi12 + Omega . x . z * old_Psi33 - Omega . z . z * old_Psi13 ); // Psi23 Psi23 [] += dt * ( 2.0 * B . y . z + Omega . y . x * old_Psi13 - Omega . x . z * old_Psi12 + Omega . y . y * old_Psi23 - Omega . y . z * old_Psi22 + Omega . y . z * old_Psi33 - Omega . z . z * old_Psi23 ); } // Advection of Psi, which is the log-conformation tensor advection ({ Psi11 , Psi12 , Psi13 , Psi22 , Psi23 , Psi33 }, uf , dt ); Convert back to A and T We now convert the log-conformation tensor Psi back to the conformation tensor A and compute the stress tensor T.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This process involves...",
    "content": "This process involves diagonalization, exponentiation of eigenvalues, and application of the relaxation factor. foreach () { pseudo_t3d A , R ; init_pseudo_t3d (& R , 0.0 ); pseudo_v3d Lambda ; init_pseudo_v3d (& Lambda , 0.0 ); // Reconstruct the log-conformation tensor from its components A . x . x = Psi11 []; A . x . y = Psi12 []; A . x . z = Psi13 []; A . y . x = Psi12 []; A . y . y = Psi22 []; A . y . z = Psi23 []; A . z . x = Psi13 []; A . z . y = Psi23 []; A . z . z = Psi33 []; // Diagonalize A to obtain eigenvalues and eigenvectors diagonalization_3D (& Lambda , & R , & A ); // Exponentiate eigenvalues Lambda . x = exp ( Lambda . x ); Lambda . y = exp ( Lambda . y ); Lambda . z = exp ( Lambda . z ); // Reconstruct A using A = R * diag(Lambda) * R^T A . x . x = Lambda . x * sq ( R . x . x ) + Lambda . y * sq ( R . x . y ) + Lambda . z * sq ( R . x . z ); A . x . y = Lambda . x * R . x . x * R . y . x + Lambda . y * R . x . y * R . y . y + Lambda . z * R . x . z * R . y . z ; A . y . x = A . x . y ; A . x . z = Lambda . x * R . x . x * R . z . x + Lambda . y * R . x . y * R . z . y + Lambda . z * R . x . z * R . z . z ; A . z . x = A . x . z ; A . y . y = Lambda . x * sq ( R . y . x ) + Lambda . y * sq ( R . y . y ) + Lambda . z * sq ( R . y . z ); A . y . z = Lambda . x * R . y . x * R . z . x + Lambda . y * R . y . y * R . z . y + Lambda . z * R . y . z * R . z . z ; A . z . y = A . y . z ; A . z . z = Lambda . x * sq ( R . z . x ) + Lambda . y * sq ( R . z . y ) + Lambda . z * sq ( R . z . z ); // Apply relaxation using the relaxation time lambda double intFactor = lambda [] != 0. ? exp (- dt / lambda []) : 0. ; A . x . y *= intFactor ; A . y . x = A . x . y ; A . x . z *= intFactor ; A . z . x = A . x . z ; A . y . z *= intFactor ; A . z . y = A . y . z ; foreach_dimension () A . x . x = 1. + ( A . x . x - 1. )* intFactor ; Get Aij from A.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: These commands might...",
    "content": "These commands might look repetitive. But, I do this so that in the future, generalization to tensor only form is easier. // diagonal terms: A11 [] = A . x . x ; A22 [] = A . y . y ; A33 [] = A . z . z ; // off-diagonal terms: A12 [] = A . x . y ; A13 [] = A . x . z ; A23 [] = A . y . z ; // Compute the stress tensor T using the polymer modulus Gp T11 [] = Gp []*( A . x . x - 1. ); T22 [] = Gp []*( A . y . y - 1. ); T33 [] = Gp []*( A . z . z - 1. ); T12 [] = Gp []* A . x . y ; T13 [] = Gp []* A . x . z ; T23 [] = Gp []* A . y . z ; } } #endif Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{T}\\) is defined at cell centers, while the corresponding force (acceleration) is defined at cell faces. For each component of the momentum equation, we need to compute the divergence of the corresponding row of the stress tensor.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Examples",
    "content": "For example, for the x-component in 3D: \\[ (\\nabla \\cdot \\mathbf{T})_x = \\partial_x T_{xx} + \\partial_y T_{xy} + \\partial_z T_{xz} \\] The normal stress gradient (e.g. \\(\\partial_x T_{xx}\\) ) is computed directly from cell-centered values.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The shear stress...",
    "content": "The shear stress gradients (e.g. \\(\\partial_y T_{xy}\\) ) are computed using vertex-averaged values to avoid checkerboard instabilities. event acceleration ( i ++) { face vector av = a ; #if dimension == // 2D implementation foreach_face ( x ) { if ( fm . x [] > 1e-20 ) { // y-gradient of T12 (shear stress) double shearX = ( T12 [ 0 , 1 ]* cm [ 0 , 1 ] + T12 [- 1 , 1 ]* cm [- 1 , 1 ] - T12 [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; // x-gradient of T11 (normal stress) double gradX_T11 = cm []* T11 [] - cm [- 1 ]* T11 [- 1 ]; av . x [] += ( shearX + gradX_T11 )* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ) { if ( fm . y [] > 1e-20 ) { // x-gradient of T12 (shear stress) double shearY = ( T12 [ 1 , 0 ]* cm [ 1 , 0 ] + T12 [ 1 ,- 1 ]* cm [ 1 ,- 1 ] - T12 [- 1 , 0 ]* cm [- 1 , 0 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; // y-gradient of T22 (normal stress) double gradY_T22 = cm []* T22 [] - cm [ 0 ,- 1 ]* T22 [ 0 ,- 1 ]; av . y [] += ( shearY + gradY_T22 )* alpha . y []/( sq ( fm . y [])* Delta ); } } #elif dimension == // 3D implementation foreach_face ( x ) { if ( fm . x [] > 1e-20 ) { // y-gradient of T12 double shearY = ( T12 [ 0 , 1 , 0 ]* cm [ 0 , 1 , 0 ] + T12 [- 1 , 1 , 0 ]* cm [- 1 , 1 , 0 ] - T12 [ 0 ,- 1 , 0 ]* cm [ 0 ,- 1 , 0 ] - T12 [- 1 ,- 1 , 0 ]* cm [- 1 ,- 1 , 0 ])/ 4. ; // z-gradient of T13 double shearZ = ( T13 [ 0 , 0 , 1 ]* cm [ 0 , 0 , 1 ] + T13 [- 1 , 0 , 1 ]* cm [- 1 , 0 , 1 ] - T13 [ 0 , 0 ,- 1 ]* cm [ 0 , 0 ,- 1 ] - T13 [- 1 , 0 ,- 1 ]* cm [- 1 , 0 ,- 1 ])/ 4. ; // x-gradient of T11 double gradX_T11 = cm []* T11 [] - cm [- 1 , 0 , 0 ]* T11 [- 1 , 0 , 0 ]; av . x [] += ( shearY + shearZ + gradX_T11 )* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ) { if ( fm . y [] > 1e-20 ) { // x-gradient of T12 double shearX = ( T12 [ 1 , 0 , 0 ]* cm [ 1 , 0 , 0 ] + T12 [ 1 ,- 1 , 0 ]* cm [ 1 ,- 1 , 0 ] - T12 [- 1 , 0 , 0 ]* cm [- 1 , 0 , 0 ] - T12 [- 1 ,- 1 , 0 ]* cm [- 1 ,- 1 , 0 ])/ 4. ; // z-gradient of T23 double shearZ = ( T23 [ 0 , 0 , 1 ]* cm [ 0 , 0 , 1 ] + T23 [ 0 ,- 1 , 1 ]* cm [ 0 ,- 1 , 1 ] - T23 [ 0 , 0 ,- 1 ]* cm [ 0 , 0 ,- 1 ] - T23 [ 0 ,- 1 ,- 1 ]* cm [ 0 ,- 1 ,- 1 ])/ 4. ; // y-gradient of T22 double gradY_T22 = cm []* T22 [] - cm [ 0 ,- 1 , 0 ]* T22 [ 0 ,- 1 , 0 ]; av . y [] += ( shearX + shearZ + gradY_T22 )* alpha . y []/( sq ( fm . y [])* Delta ); } } foreach_face ( z ) { if ( fm . z [] > 1e-20 ) { // x-gradient of T13 double shearX = ( T13 [ 1 , 0 , 0 ]* cm [ 1 , 0 , 0 ] + T13 [ 1 , 0 ,- 1 ]* cm [ 1 , 0 ,- 1 ] - T13 [- 1 , 0 , 0 ]* cm [- 1 , 0 , 0 ] - T13 [- 1 , 0 ,- 1 ]* cm [- 1 , 0 ,- 1 ])/ 4. ; // y-gradient of T23 double shearY = ( T23 [ 0 , 1 , 0 ]* cm [ 0 , 1 , 0 ] + T23 [ 0 , 1 ,- 1 ]* cm [ 0 , 1 ,- 1 ] - T23 [ 0 ,- 1 , 0 ]* cm [ 0 ,- 1 , 0 ] - T23 [ 0 ,- 1 ,- 1 ]* cm [ 0 ,- 1 ,- 1 ])/ 4. ; // z-gradient of T33 double gradZ_T33 = cm []* T33 [] - cm [ 0 , 0 ,- 1 ]* T33 [ 0 , 0 ,- 1 ]; av . z [] += ( shearX + shearY + gradZ_T33 )* alpha . z []/( sq ( fm . z [])* Delta ); } } #endif }",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#if AXI#error \"axi compatibility is not there. To keep the code easy to read, we will not implement axi compatibility just yet.\"#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: /*TODO:- Perhaps, instead...",
    "content": "/*TODO:- Perhaps, instead of the Bell--Collela--Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to [http://basilisk.fr/src/navier-stokes/conserving.h](http://basilisk.fr/src/navier-stokes/conserving.h)*/#define EIGENVALUE_MIN1e-8220#ifdef DEBUG_EIGENVALUESstaticinteigenvalue_corrections=0;#endif#include\"bcg.h\"(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation time/*conformation tensor */// diagonal elementsscalar A11[],A22[],A33[];// off-diagonal elementsscalar A12[],A13[],A23[];/*stress tensor */// diagonal elementsscalar T11[],T22[],T33[];// off-diagonal elementsscalar T12[],T13[],T23[];event defaults(i=0){if(is_constant(a.x))a=new face vector;/*initialize A and T*/for(scalar s in{A11,A22,A33}){foreach(){s[]=1.;}}for(scalar s in{T11,T12,T13,T22,T23,T33,A12,A13,A23}){foreach(){s[]=0.;}}for(scalar s in{A11,A22,A33,T11,T22,T33,A12,A13,A23,T12,T13,T23}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}if(s.boundary[top]!=periodic_bc){s[top]=neumann(0);s[bottom]=neumann(0);}#if dimension ==if(s.boundary[front]!=periodic_bc){s[front]=neumann(0);s[back]=neumann(0);}#endif}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#if dimension ==typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}#endif/*Now this is the 3D implementation.*/#if dimension ==#include\"eigen_decomposition.h\"typedefstruct{doublex,y,z;}pseudo_v3d;typedefstruct{pseudo_v3d x,y,z;}pseudo_t3d;// Function to initialize pseudo_v3dstaticinlinevoidinit_pseudo_v3d(pseudo_v3d*v,doublevalue){v->x=value;v->y=value;v->z=value;}// Function to initialize pseudo_t3dstaticinlinevoidinit_pseudo_t3d(pseudo_t3d*t,doublevalue){init_pseudo_v3d(&t->x,value);init_pseudo_v3d(&t->y,value);init_pseudo_v3d(&t->z,value);}staticvoiddiagonalization_3D(pseudo_v3d*Lambda,pseudo_t3d*R,pseudo_t3d*A){// Check if the matrix is already diagonalif(sq(A->x.y)+sq(A->x.z)+sq(A->y.z)<1e-15){R->x.x=R->y.y=R->z.z=1.;R->y.x=R->x.y=R->z.x=R->x.z=R->z.y=R->y.z=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;Lambda->z=A->z.z;return;}// Compute eigenvalues using the eigen_decomposition functiondoublematrix[3][3]={{A->x.x,A->x.y,A->x.z},{A->y.x,A->y.y,A->y.z},{A->z.x,A->z.y,A->z.z}};doubleeigenvectors[3][3];doubleeigenvalues[3];compute_eigensystem_symmetric_3x3(matrix,eigenvectors,eigenvalues);// Store eigenvalues and eigenvectorsLambda->x=eigenvalues[0];Lambda->y=eigenvalues[1];Lambda->z=eigenvalues[2];R->x.x=eigenvectors[0][0];R->x.y=eigenvectors[0][1];R->x.z=eigenvectors[0][2];R->y.x=eigenvectors[1][0];R->y.y=eigenvectors[1][1];R->y.z=eigenvectors[1][2];R->z.x=eigenvectors[2][0];R->z.y=eigenvectors[2][1];R->z.z=eigenvectors[2][2];}#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event tracer_advection(i++){scalar Psi11=A11;scalar Psi12=A12;scalar Psi22=A22;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);pseudo_t R;init_pseudo_t(&R,0.0);diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.This prevents numerical instabilities while maintaining physical meaning.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"WARNING: Negative eigenvalue detected at (%g,%g): [%g,%g]\\n\",x,y,Lambda.x,Lambda.y);#ifdef DEBUG_EIGENVALUESatomic_increment(&eigenvalue_corrections);#endifLambda.x=max(Lambda.x,EIGENVALUE_MIN);Lambda.y=max(Lambda.y,EIGENVALUE_MIN);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);Psi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);Psi22[]=sq(R.y.y)*log(Lambda.y)+sq(R.y.x)*log(Lambda.x);",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "pseudo_t B;init_pseudo_t(&B,0.0);doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;init_pseudo_t(&M,0.0);foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubles=-Psi12[];Psi12[]+=dt*(2.*B.x.y+OM*(Psi22[]-Psi11[]));s*=-1;Psi11[]+=dt*2.*(B.x.x+s*OM);s*=-1;Psi22[]+=dt*2.*(B.y.y+s*OM);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_t A={{Psi11[],Psi12[]},{Psi12[],Psi22[]}},R;init_pseudo_t(&R,0.0);pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);A.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A12[]=A.x.y;T12[]=Gp[]*A.x.y;A11[]=A.x.x;T11[]=Gp[]*(A.x.x-1.);A22[]=A.y.y;T22[]=Gp[]*(A.y.y-1.);}}#elif dimension ==",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: // start by...",
    "content": "// start by declaring the scalar variables that will store the components of $\\Psi$scalar Psi11=A11,Psi12=A12,Psi13=A13,Psi22=A22,Psi23=A23,Psi33=A33;foreach(){pseudo_t3d A,R;init_pseudo_t3d(&R,0.0);pseudo_v3d Lambda;init_pseudo_v3d(&Lambda,0.0);A.x.x=A11[];A.x.y=A12[];A.x.z=A13[];A.y.x=A12[];A.y.y=A22[];A.y.z=A23[];A.z.x=A13[];A.z.y=A23[];A.z.z=A33[];// Diagonalize the conformation tensor A to obtain the eigenvalues Lambda and eigenvectors Rdiagonalization_3D(&Lambda,&R,&A);/*Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.This prevents numerical instabilities while maintaining physical meaning.*/if(Lambda.x<=0.||Lambda.y<=0.||Lambda.z<=0.){fprintf(ferr,\"WARNING: Negative eigenvalue detected at (%g,%g,%g): [%g,%g,%g]\\n\",x,y,z,Lambda.x,Lambda.y,Lambda.z);#ifdef DEBUG_EIGENVALUESatomic_increment(&eigenvalue_corrections);#endifLambda.x=max(Lambda.x,EIGENVALUE_MIN);Lambda.y=max(Lambda.y,EIGENVALUE_MIN);Lambda.z=max(Lambda.z,EIGENVALUE_MIN);}// Compute Psi = log(A) = R * log(Lambda) * R^TPsi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y)+sq(R.x.z)*log(Lambda.z);Psi22[]=sq(R.y.x)*log(Lambda.x)+sq(R.y.y)*log(Lambda.y)+sq(R.y.z)*log(Lambda.z);Psi33[]=sq(R.z.x)*log(Lambda.x)+sq(R.z.y)*log(Lambda.y)+sq(R.z.z)*log(Lambda.z);Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.x.y*R.y.y*log(Lambda.y)+R.x.z*R.y.z*log(Lambda.z);Psi13[]=R.x.x*R.z.x*log(Lambda.x)+R.x.y*R.z.y*log(Lambda.y)+R.x.z*R.z.z*log(Lambda.z);Psi23[]=R.y.x*R.z.x*log(Lambda.x)+R.y.y*R.z.y*log(Lambda.y)+R.y.z*R.z.z*log(Lambda.z);// Compute B and Omega tensors (3D version)pseudo_t3d B,M,Omega;init_pseudo_t3d(&B,0.0);init_pseudo_t3d(&M,0.0);init_pseudo_t3d(&Omega,0.0);// Check if any pair of eigenvalues are numerically equal (within a small tolerance)if(fabs(Lambda.x-Lambda.y)<=1e-20||fabs(Lambda.y-Lambda.z)<=1e-20||fabs(Lambda.z-Lambda.x)<=1e-20){// In case of equal eigenvalues, the calculations for B and Omega simplify significantly// B is grad U and Omega is zero.// Compute off-diagonal elements of B using central differences// These represent the symmetric part of the velocity gradient tensorB.x.y=(u.y[1,0,0]-u.y[-1,0,0]+u.x[0,1,0]-u.x[0,-1,0])/(4.*Delta);// (dv/dx + du/dy)/2B.x.z=(u.z[1,0,0]-u.z[-1,0,0]+u.x[0,0,1]-u.x[0,0,-1])/(4.*Delta);// (dw/dx + du/dz)/2B.y.z=(u.z[0,1,0]-u.z[0,-1,0]+u.y[0,0,1]-u.y[0,0,-1])/(4.*Delta);// (dw/dy + dv/dz)/2// Compute diagonal elements of B// These represent the normal strain ratesB.x.x=(u.x[1,0,0]-u.x[-1,0,0])/(2.*Delta);// du/dxB.y.y=(u.y[0,1,0]-u.y[0,-1,0])/(2.*Delta);// dv/dyB.z.z=(u.z[0,0,1]-u.z[0,0,-1])/(2.*Delta);// dw/dz// Set all components of Omega to zero// This is because Omega represents the antisymmetric part of the velocity gradient tensor,// which vanishes when eigenvalues are equalOmega.x.y=Omega.x.z=Omega.y.z=Omega.y.x=Omega.z.x=Omega.z.y=0.;}else{/*###Compute the velocity gradient tensor components using central differences- These represent the spatial derivatives of each velocity component- These gradients form the velocity gradient tensor (nablaU):[ dudx  dudy  dudz ][ dvdx  dvdy  dvdz ][ dwdx  dwdy  dwdz ]*/// Derivatives of u (x-component of velocity)doubledudx=(u.x[1,0,0]-u.x[-1,0,0])/(2.0*Delta);// du/dxdoubledudy=(u.x[0,1,0]-u.x[0,-1,0])/(2.0*Delta);// du/dydoubledudz=(u.x[0,0,1]-u.x[0,0,-1])/(2.0*Delta);// du/dz// Derivatives of v (y-component of velocity)doubledvdx=(u.y[1,0,0]-u.y[-1,0,0])/(2.0*Delta);// dv/dxdoubledvdy=(u.y[0,1,0]-u.y[0,-1,0])/(2.0*Delta);// dv/dydoubledvdz=(u.y[0,0,1]-u.y[0,0,-1])/(2.0*Delta);// dv/dz// Derivatives of w (z-component of velocity)doubledwdx=(u.z[1,0,0]-u.z[-1,0,0])/(2.0*Delta);// dw/dxdoubledwdy=(u.z[0,1,0]-u.z[0,-1,0])/(2.0*Delta);// dw/dydoubledwdz=(u.z[0,0,1]-u.z[0,0,-1])/(2.0*Delta);// dw/dz/*Calculate the M tensor through matrix multiplication: M = R * (nablaU)^T R^T.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: This represents the...",
    "content": "This represents the velocity gradient tensor transformed to the eigenvector basis of the conformation tensor.* Steps:1. Compute intermediate products (R * nablaU^T):- Store row-wise products in Rx_gradU_*, Ry_gradU_*, Rz_gradU_*- Each variable represents one row of the intermediate matrix2.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Multiply by R^T...",
    "content": "Multiply by R^T to obtain the final M tensor:- M.i.j represents the (i,j) component of the transformed velocity gradient- This transformation expresses the velocity gradient in the eigenvector basis- The resulting M tensor is used to compute Omega (\u03a9) and B tensors, such that*/// First, compute intermediate products of R and (nablaU)^TdoubleRx_gradU_x=R.x.x*dudx+R.x.y*dvdx+R.x.z*dwdx;doubleRx_gradU_y=R.x.x*dudy+R.x.y*dvdy+R.x.z*dwdy;doubleRx_gradU_z=R.x.x*dudz+R.x.y*dvdz+R.x.z*dwdz;doubleRy_gradU_x=R.y.x*dudx+R.y.y*dvdx+R.y.z*dwdx;doubleRy_gradU_y=R.y.x*dudy+R.y.y*dvdy+R.y.z*dwdy;doubleRy_gradU_z=R.y.x*dudz+R.y.y*dvdz+R.y.z*dwdz;doubleRz_gradU_x=R.z.x*dudx+R.z.y*dvdx+R.z.z*dwdx;doubleRz_gradU_y=R.z.x*dudy+R.z.y*dvdy+R.z.z*dwdy;doubleRz_gradU_z=R.z.x*dudz+R.z.y*dvdz+R.z.z*dwdz;// Now compute M components by multiplying the intermediate products with R^TM.x.x=R.x.x*Rx_gradU_x+R.x.y*Rx_gradU_y+R.x.z*Rx_gradU_z;M.x.y=R.x.x*Ry_gradU_x+R.x.y*Ry_gradU_y+R.x.z*Ry_gradU_z;M.x.z=R.x.x*Rz_gradU_x+R.x.y*Rz_gradU_y+R.x.z*Rz_gradU_z;M.y.x=R.y.x*Rx_gradU_x+R.y.y*Rx_gradU_y+R.y.z*Rx_gradU_z;M.y.y=R.y.x*Ry_gradU_x+R.y.y*Ry_gradU_y+R.y.z*Ry_gradU_z;M.y.z=R.y.x*Rz_gradU_x+R.y.y*Rz_gradU_y+R.y.z*Rz_gradU_z;M.z.x=R.z.x*Rx_gradU_x+R.z.y*Rx_gradU_y+R.z.z*Rx_gradU_z;M.z.y=R.z.x*Ry_gradU_x+R.z.y*Ry_gradU_y+R.z.z*Ry_gradU_z;M.z.z=R.z.x*Rz_gradU_x+R.z.y*Rz_gradU_y+R.z.z*Rz_gradU_z;// Compute the off-diagonal elements of the Omega tensor in the eigenvector basisdoubleomega_xy=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);doubleomega_xz=(Lambda.z*M.x.z+Lambda.x*M.z.x)/(Lambda.z-Lambda.x);doubleomega_yz=(Lambda.z*M.y.z+Lambda.y*M.z.y)/(Lambda.z-Lambda.y);// Calculate intermediate rotation combinations for each direction// x-direction rotation combinationsdoublerot_x_xy_yz=(R.x.x*omega_xy-R.x.z*omega_yz);// xy rotation minus yz rotation, x componentsdoublerot_x_xy_xz=(R.x.y*omega_xy+R.x.z*omega_xz);// xy rotation plus xz rotation, x componentsdoublerot_x_xz_yz=(R.x.x*omega_xz+R.x.y*omega_yz);// xz rotation plus yz rotation, x components// y-direction rotation combinationsdoublerot_y_xy_yz=(R.y.x*omega_xy-R.y.z*omega_yz);// xy rotation minus yz rotation, y componentsdoublerot_y_xy_xz=(R.y.y*omega_xy+R.y.z*omega_xz);// xy rotation plus xz rotation, y componentsdoublerot_y_xz_yz=(R.y.x*omega_xz+R.y.y*omega_yz);// xz rotation plus yz rotation, y components// z-direction rotation combinationsdoublerot_z_xy_yz=(R.z.x*omega_xy-R.z.z*omega_yz);// xy rotation minus yz rotation, z componentsdoublerot_z_xy_xz=(R.z.y*omega_xy+R.z.z*omega_xz);// xy rotation plus xz rotation, z componentsdoublerot_z_xz_yz=(R.z.x*omega_xz+R.z.y*omega_yz);// xz rotation plus yz rotation, z components",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: // Compute x-row...",
    "content": "// Compute x-row components of OmegaOmega.x.x=R.x.y*rot_x_xy_yz// xy-yz rotation contribution-R.x.x*rot_x_xy_xz// xy-xz rotation contribution+R.x.z*rot_x_xz_yz;// xz-yz rotation contributionOmega.x.y=R.y.y*rot_x_xy_yz// xy-yz rotation mapped to y-direction-R.y.x*rot_x_xy_xz// xy-xz rotation mapped to y-direction+R.y.z*rot_x_xz_yz;// xz-yz rotation mapped to y-directionOmega.x.z=R.z.y*rot_x_xy_yz// xy-yz rotation mapped to z-direction-R.z.x*rot_x_xy_xz// xy-xz rotation mapped to z-direction+R.z.z*rot_x_xz_yz;// xz-yz rotation mapped to z-direction// Compute y-row components using similar patternOmega.y.x=R.x.y*rot_y_xy_yz-R.x.x*rot_y_xy_xz+R.x.z*rot_y_xz_yz;Omega.y.y=R.y.y*rot_y_xy_yz-R.y.x*rot_y_xy_xz+R.y.z*rot_y_xz_yz;Omega.y.z=R.z.y*rot_y_xy_yz-R.z.x*rot_y_xy_xz+R.z.z*rot_y_xz_yz;// Compute z-row components using similar patternOmega.z.x=R.x.y*rot_z_xy_yz-R.x.x*rot_z_xy_xz+R.x.z*rot_z_xz_yz;Omega.z.y=R.y.y*rot_z_xy_yz-R.y.x*rot_z_xy_xz+R.y.z*rot_z_xz_yz;Omega.z.z=R.z.y*rot_z_xy_yz-R.z.x*rot_z_xy_xz+R.z.z*rot_z_xz_yz;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "// Extract diagonal components of M (velocity gradient tensor in eigenvector basis)doubleM_diag_x=M.x.x,M_diag_y=M.y.y,M_diag_z=M.z.z;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: // Compute diagonal...",
    "content": "// Compute diagonal elements of BB.x.x=M_diag_x*sq(R.x.x)+M_diag_y*sq(R.x.y)+M_diag_z*sq(R.x.z);B.y.y=M_diag_x*sq(R.y.x)+M_diag_y*sq(R.y.y)+M_diag_z*sq(R.y.z);B.z.z=M_diag_x*sq(R.z.x)+M_diag_y*sq(R.z.y)+M_diag_z*sq(R.z.z);// Compute off-diagonal elements of B (upper triangle)B.x.y=M_diag_x*R.x.x*R.y.x+M_diag_y*R.x.y*R.y.y+M_diag_z*R.x.z*R.y.z;B.x.z=M_diag_x*R.x.x*R.z.x+M_diag_y*R.x.y*R.z.y+M_diag_z*R.x.z*R.z.z;B.y.z=M_diag_x*R.y.x*R.z.x+M_diag_y*R.y.y*R.z.y+M_diag_z*R.y.z*R.z.z;// Fill in lower triangle using symmetry of BB.y.x=B.x.y;B.z.x=B.x.z;B.z.y=B.y.z;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: // save old...",
    "content": "// save old values of Psi componentsdoubleold_Psi11=Psi11[];doubleold_Psi22=Psi22[];doubleold_Psi33=Psi33[];doubleold_Psi12=Psi12[];doubleold_Psi13=Psi13[];doubleold_Psi23=Psi23[];// Psi11Psi11[]+=dt*(2.0*B.x.x+Omega.x.y*old_Psi12-Omega.y.x*old_Psi12+Omega.x.z*old_Psi13-Omega.z.x*old_Psi13);// Psi22Psi22[]+=dt*(2.0*B.y.y-Omega.x.y*old_Psi12+Omega.y.x*old_Psi12+Omega.y.z*old_Psi23-Omega.z.y*old_Psi23);// Psi33Psi33[]+=dt*(2.0*B.z.z-Omega.x.z*old_Psi13+Omega.z.x*old_Psi13-Omega.y.z*old_Psi23+Omega.z.y*old_Psi23);// Psi12Psi12[]+=dt*(2.0*B.x.y+Omega.x.x*old_Psi12-Omega.x.y*old_Psi11+Omega.x.y*old_Psi22-Omega.y.y*old_Psi12+Omega.x.z*old_Psi23-Omega.z.y*old_Psi13);// Psi13Psi13[]+=dt*(2.0*B.x.z+Omega.x.x*old_Psi13-Omega.x.z*old_Psi11+Omega.x.y*old_Psi23-Omega.y.z*old_Psi12+Omega.x.z*old_Psi33-Omega.z.z*old_Psi13);// Psi23Psi23[]+=dt*(2.0*B.y.z+Omega.y.x*old_Psi13-Omega.x.z*old_Psi12+Omega.y.y*old_Psi23-Omega.y.z*old_Psi22+Omega.y.z*old_Psi33-Omega.z.z*old_Psi23);}// Advection of Psi, which is the log-conformation tensoradvection({Psi11,Psi12,Psi13,Psi22,Psi23,Psi33},uf,dt);",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "foreach(){pseudo_t3d A,R;init_pseudo_t3d(&R,0.0);pseudo_v3d Lambda;init_pseudo_v3d(&Lambda,0.0);// Reconstruct the log-conformation tensor from its componentsA.x.x=Psi11[];A.x.y=Psi12[];A.x.z=Psi13[];A.y.x=Psi12[];A.y.y=Psi22[];A.y.z=Psi23[];A.z.x=Psi13[];A.z.y=Psi23[];A.z.z=Psi33[];// Diagonalize A to obtain eigenvalues and eigenvectorsdiagonalization_3D(&Lambda,&R,&A);// Exponentiate eigenvaluesLambda.x=exp(Lambda.x);Lambda.y=exp(Lambda.y);Lambda.z=exp(Lambda.z);// Reconstruct A using A = R * diag(Lambda) * R^TA.x.x=Lambda.x*sq(R.x.x)+Lambda.y*sq(R.x.y)+Lambda.z*sq(R.x.z);A.x.y=Lambda.x*R.x.x*R.y.x+Lambda.y*R.x.y*R.y.y+Lambda.z*R.x.z*R.y.z;A.y.x=A.x.y;A.x.z=Lambda.x*R.x.x*R.z.x+Lambda.y*R.x.y*R.z.y+Lambda.z*R.x.z*R.z.z;A.z.x=A.x.z;A.y.y=Lambda.x*sq(R.y.x)+Lambda.y*sq(R.y.y)+Lambda.z*sq(R.y.z);A.y.z=Lambda.x*R.y.x*R.z.x+Lambda.y*R.y.y*R.z.y+Lambda.z*R.y.z*R.z.z;A.z.y=A.y.z;A.z.z=Lambda.x*sq(R.z.x)+Lambda.y*sq(R.z.y)+Lambda.z*sq(R.z.z);// Apply relaxation using the relaxation time lambdadoubleintFactor=lambda[]!=0.?exp(-dt/lambda[]):0.;A.x.y*=intFactor;A.y.x=A.x.y;A.x.z*=intFactor;A.z.x=A.x.z;A.y.z*=intFactor;A.z.y=A.y.z;foreach_dimension()A.x.x=1.+(A.x.x-1.)*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "// diagonal terms:A11[]=A.x.x;A22[]=A.y.y;A33[]=A.z.z;// off-diagonal terms:A12[]=A.x.y;A13[]=A.x.z;A23[]=A.y.z;// Compute the stress tensor T using the polymer modulus GpT11[]=Gp[]*(A.x.x-1.);T22[]=Gp[]*(A.y.y-1.);T33[]=Gp[]*(A.z.z-1.);T12[]=Gp[]*A.x.y;T13[]=Gp[]*A.x.z;T23[]=Gp[]*A.y.z;}}#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: event acceleration(i++){face vector...",
    "content": "event acceleration(i++){face vector av=a;#if dimension ==// 2D implementationforeach_face(x){if(fm.x[]>1e-20){// y-gradient of T12 (shear stress)doubleshearX=(T12[0,1]*cm[0,1]+T12[-1,1]*cm[-1,1]-T12[0,-1]*cm[0,-1]-T12[-1,-1]*cm[-1,-1])/4.;// x-gradient of T11 (normal stress)doublegradX_T11=cm[]*T11[]-cm[-1]*T11[-1];av.x[]+=(shearX+gradX_T11)*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){// x-gradient of T12 (shear stress)doubleshearY=(T12[1,0]*cm[1,0]+T12[1,-1]*cm[1,-1]-T12[-1,0]*cm[-1,0]-T12[-1,-1]*cm[-1,-1])/4.;// y-gradient of T22 (normal stress)doublegradY_T22=cm[]*T22[]-cm[0,-1]*T22[0,-1];av.y[]+=(shearY+gradY_T22)*alpha.y[]/(sq(fm.y[])*Delta);}}#elif dimension ==// 3D implementationforeach_face(x){if(fm.x[]>1e-20){// y-gradient of T12doubleshearY=(T12[0,1,0]*cm[0,1,0]+T12[-1,1,0]*cm[-1,1,0]-T12[0,-1,0]*cm[0,-1,0]-T12[-1,-1,0]*cm[-1,-1,0])/4.;// z-gradient of T13doubleshearZ=(T13[0,0,1]*cm[0,0,1]+T13[-1,0,1]*cm[-1,0,1]-T13[0,0,-1]*cm[0,0,-1]-T13[-1,0,-1]*cm[-1,0,-1])/4.;// x-gradient of T11doublegradX_T11=cm[]*T11[]-cm[-1,0,0]*T11[-1,0,0];av.x[]+=(shearY+shearZ+gradX_T11)*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){// x-gradient of T12doubleshearX=(T12[1,0,0]*cm[1,0,0]+T12[1,-1,0]*cm[1,-1,0]-T12[-1,0,0]*cm[-1,0,0]-T12[-1,-1,0]*cm[-1,-1,0])/4.;// z-gradient of T23doubleshearZ=(T23[0,0,1]*cm[0,0,1]+T23[0,-1,1]*cm[0,-1,1]-T23[0,0,-1]*cm[0,0,-1]-T23[0,-1,-1]*cm[0,-1,-1])/4.;// y-gradient of T22doublegradY_T22=cm[]*T22[]-cm[0,-1,0]*T22[0,-1,0];av.y[]+=(shearX+shearZ+gradY_T22)*alpha.y[]/(sq(fm.y[])*Delta);}}foreach_face(z){if(fm.z[]>1e-20){// x-gradient of T13doubleshearX=(T13[1,0,0]*cm[1,0,0]+T13[1,0,-1]*cm[1,0,-1]-T13[-1,0,0]*cm[-1,0,0]-T13[-1,0,-1]*cm[-1,0,-1])/4.;// y-gradient of T23doubleshearY=(T23[0,1,0]*cm[0,1,0]+T23[0,1,-1]*cm[0,1,-1]-T23[0,-1,0]*cm[0,-1,0]-T23[0,-1,-1]*cm[0,-1,-1])/4.;// z-gradient of T33doublegradZ_T33=cm[]*T33[]-cm[0,0,-1]*T33[0,0,-1];av.z[]+=(shearX+shearY+gradZ_T33)*alpha.z[]/(sq(fm.z[])*Delta);}}#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Methods",
    "content": "src-local/log-conform-viscoelastic-scalar-2D.h See raw file Log-Conformation Method for 2D Viscoelastic Fluids Overview Title : log-conform-viscoelastic-scalar-2D.h Version : 2.5 Description : 2D and axisymmetric scalar implementation of viscoelastic fluid dynamics using the log-conformation method Key Features Conformation tensor A exists across domain and relaxes according to \u03bb Stress acts according to elastic modulus G Supports both 2D and axisymmetric configurations Scalar implementation approach for better performance Compatible with log-conform-viscoelastic.h Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Nov 23, 2024 Implementation Notes Based on http://basilisk.fr/src/log-conform.h with key improvements: Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling bug where [\u03c3_p] = 0 & [\u03c3_s] = \u03b3\u03ba Ensures [\u03c3_s+\u03c3_p] = \u03b3\u03ba for correct interface behavior Version History v1.0 (Oct 18, 2024) Initial implementation with 2D+axi support Scalar-based implementation for efficiency v2.0 (Nov 3, 2024) Major documentation improvements Made code an axisymmetric mirror of log-conform-viscoelastic-scalar-3D.h Added negative eigenvalue detection with location reporting Added initialization functions for pseudo_v and pseudo_t v2.1 (Nov 14, 2024) Added support for infinite Deborah number cases v2.5 (Nov 23, 2024) Enhanced documentation clarity and completeness Future Work Tensor Formulation Convert to consistent tensor formulation for: Improved readability and maintainability Better computational efficiency Reduced potential for bugs Prerequisites for axi compatibility in 3D version Related issues: https://github.com/comphy-lab/Viscoelastic3D/issues/11 https://github.com/comphy-lab/Viscoelastic3D/issues/5 Code Improvements Enforce tensor usage throughout codebase Implement foreach_dimension compatibility The log-conformation method for viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Therefore these materials...",
    "content": "Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers. Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The conformation tensor...",
    "content": "The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time. In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Parameters The primary...",
    "content": "Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features. This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: TODO: - Perhaps,...",
    "content": "TODO: - Perhaps, instead of the Bell\u2013Collela\u2013Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to http://basilisk.fr/src/navier-stokes/conserving.h #include \"bcg.h\" ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time scalar A11 [], A12 [], A22 []; // conformation tensor scalar T11 [], T12 [], T22 []; // stress tensor #if AXI scalar AThTh [], T_ThTh []; #endif event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; /* initialize A and T */ for ( scalar s in { A11 , A22 }) { foreach () { s [] = 1. ; } } for ( scalar s in { T11 , T12 , T22 , A12 }) { foreach (){ s [] = 0. ; } } #if AXI foreach (){ T_ThTh [] = 0 ; AThTh [] = 1. ; } #endif for ( scalar s in { T11 , T12 , T22 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } for ( scalar s in { A11 , A12 , A22 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } #if AXI T12 [ bottom ] = dirichlet ( 0. ); A12 [ bottom ] = dirichlet ( 0. ); #endif } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } The stress tensor depends on previous instants and has to be integrated in time. In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: We use a...",
    "content": "We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ).",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: In an Oldroyd-B...",
    "content": "In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] event tracer_advection ( i ++) { scalar Psi11 = A11 ; scalar Psi12 = A12 ; scalar Psi22 = A22 ; #if AXI scalar Psiqq = AThTh ; #endif Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A ; A . x . x = A11 []; A . y . y = A22 []; A . x . y = A12 []; #if AXI double Aqq = AThTh []; Psiqq [] = log ( Aqq ); #endif The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); pseudo_t R ; init_pseudo_t (& R , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues -- this should never happen.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: If it does,...",
    "content": "If it does, print the location and value of the offending eigenvalue. Please report this bug by opening an issue on the GitHub repository. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"Negative eigenvalue detected: Lambda.x = %g , Lambda.y = %g\\n \" , Lambda . x , Lambda . y ); fprintf ( ferr , \"x = %g , y = %g\\n \" , x , y ); exit ( 1 ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) . Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); Psi22 [] = sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . x )* log ( Lambda . x ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The diagonalization will...",
    "content": "The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis. Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: R is the eigenvector matrix of the conformation tensor M is the velocity gradient tensor in the eigenvector basis The construction ensures B is symmetric and traceless pseudo_t B ; init_pseudo_t (& B , 0.0 ); double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; init_pseudo_t (& M , 0.0 ); foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi12 []; Psi12 [] += dt * ( 2. * B . x . y + OM * ( Psi22 [] - Psi11 [])); s *= - 1 ; Psi11 [] += dt * 2. * ( B . x . x + s * OM ); s *= - 1 ; Psi22 [] += dt * 2. * ( B . y . y + s * OM ); In the axisymmetric case, the governing equation for \\(\\Psi_{\\theta \\theta}\\) only involves that component, \\[ \\Psi_{\\theta \\theta}|_t - 2 L_{\\theta \\theta} = \\frac{\\mathbf{f}_r(e^{-\\Psi_{\\theta \\theta}})}{\\lambda} \\] with \\(L_{\\theta \\theta} = u_y/y\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Therefore step (a)...",
    "content": "Therefore step (a) for \\(\\Psi_{\\theta \\theta}\\) is #if AXI Psiqq [] += dt * 2. * u . y []/ max ( y , 1e-20 ); #endif } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . #if AXI advection ({ Psi11 , Psi12 , Psi22 , Psiqq }, uf , dt ); #else advection ({ Psi11 , Psi12 , Psi22 }, uf , dt ); #endif Convert back to Aij foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi11 [], Psi12 []}, { Psi12 [], Psi22 []}}, R ; init_pseudo_t (& R , 0.0 ); pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; #if AXI double Aqq = exp ( Psiqq []); #endif We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); #if AXI Aqq = ( 1. - intFactor ) + intFactor * exp ( Psiqq []); #endif A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . A12 [] = A . x . y ; T12 [] = Gp []* A . x . y ; #if AXI AThTh [] = Aqq ; T_ThTh [] = Gp []*( Aqq - 1. ); #endif A11 [] = A . x . x ; T11 [] = Gp []*( A . x . x - 1. ); A22 [] = A . y . y ; T22 [] = Gp []*( A . y . y - 1. ); } } Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{\\tau}_p\\) is defined at cell centers while the corresponding force (acceleration) will be defined at cell faces. Two terms contribute to each component of the momentum equation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Examples",
    "content": "For example the \\(x\\) -component in Cartesian coordinates has the following terms: \\(\\partial_x \\mathbf{\\tau}_{p_{xx}} + \\partial_y \\mathbf{\\tau}_{p_{xy}}\\) . The first term is easy to compute since it can be calculated directly from center values of cells sharing the face. The other one is harder. It will be computed from vertex values. The vertex values are obtained by averaging centered values.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Note that as a result of the vertex averaging cells [] and [-1,0] are not involved in the computation of shear. event acceleration ( i ++) { face vector av = a ; foreach_face ( x ){ if ( fm . x [] > 1e-20 ) { double shearX = ( T12 [ 0 , 1 ]* cm [ 0 , 1 ] + T12 [- 1 , 1 ]* cm [- 1 , 1 ] - T12 [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . x [] += ( shearX + cm []* T11 [] - cm [- 1 ]* T11 [- 1 ])* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ){ if ( fm . y [] > 1e-20 ) { double shearY = ( T12 [ 1 , 0 ]* cm [ 1 , 0 ] + T12 [ 1 ,- 1 ]* cm [ 1 ,- 1 ] - T12 [- 1 , 0 ]* cm [- 1 , 0 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . y [] += ( shearY + cm []* T22 [] - cm [ 0 ,- 1 ]* T22 [ 0 ,- 1 ])* alpha . y []/( sq ( fm . y [])* Delta ); } } #if AXI foreach_face ( y ) if ( y > 1e-20 ) av . y [] -= ( T_ThTh [] + T_ThTh [ 0 ,- 1 ])* alpha . y []/ sq ( y )/ 2. ; #endif }",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code: C/C++ Code",
    "content": "#include\"bcg.h\"(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation timescalar A11[],A12[],A22[];// conformation tensorscalar T11[],T12[],T22[];// stress tensor#if AXIscalar AThTh[],T_ThTh[];#endifevent defaults(i=0){if(is_constant(a.x))a=new face vector;/*initialize A and T*/for(scalar s in{A11,A22}){foreach(){s[]=1.;}}for(scalar s in{T11,T12,T22,A12}){foreach(){s[]=0.;}}#if AXIforeach(){T_ThTh[]=0;AThTh[]=1.;}#endiffor(scalar s in{T11,T12,T22}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}for(scalar s in{A11,A12,A22}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}#if AXIT12[bottom]=dirichlet(0.);A12[bottom]=dirichlet(0.);#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event tracer_advection(i++){scalar Psi11=A11;scalar Psi12=A12;scalar Psi22=A22;#if AXIscalar Psiqq=AThTh;#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_t A;A.x.x=A11[];A.y.y=A22[];A.x.y=A12[];#if AXIdoubleAqq=AThTh[];Psiqq[]=log(Aqq);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);pseudo_t R;init_pseudo_t(&R,0.0);diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue.Please report this bug by opening an issue on the GitHub repository.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"Negative eigenvalue detected: Lambda.x =%g, Lambda.y =%g\\n\",Lambda.x,Lambda.y);fprintf(ferr,\"x =%g, y =%g\\n\",x,y);exit(1);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);Psi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);Psi22[]=sq(R.y.y)*log(Lambda.y)+sq(R.y.x)*log(Lambda.x);",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "pseudo_t B;init_pseudo_t(&B,0.0);doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;init_pseudo_t(&M,0.0);foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubles=-Psi12[];Psi12[]+=dt*(2.*B.x.y+OM*(Psi22[]-Psi11[]));s*=-1;Psi11[]+=dt*2.*(B.x.x+s*OM);s*=-1;Psi22[]+=dt*2.*(B.y.y+s*OM);",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#if AXIadvection({Psi11,Psi12,Psi22,Psiqq},uf,dt);#elseadvection({Psi11,Psi12,Psi22},uf,dt);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_t A={{Psi11[],Psi12[]},{Psi12[],Psi22[]}},R;init_pseudo_t(&R,0.0);pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;#if AXIdoubleAqq=exp(Psiqq[]);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);#if AXIAqq=(1.-intFactor)+intFactor*exp(Psiqq[]);#endifA.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "A12[]=A.x.y;T12[]=Gp[]*A.x.y;#if AXIAThTh[]=Aqq;T_ThTh[]=Gp[]*(Aqq-1.);#endifA11[]=A.x.x;T11[]=Gp[]*(A.x.x-1.);A22[]=A.y.y;T22[]=Gp[]*(A.y.y-1.);}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: event acceleration(i++){face vector...",
    "content": "event acceleration(i++){face vector av=a;foreach_face(x){if(fm.x[]>1e-20){doubleshearX=(T12[0,1]*cm[0,1]+T12[-1,1]*cm[-1,1]-T12[0,-1]*cm[0,-1]-T12[-1,-1]*cm[-1,-1])/4.;av.x[]+=(shearX+cm[]*T11[]-cm[-1]*T11[-1])*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){doubleshearY=(T12[1,0]*cm[1,0]+T12[1,-1]*cm[1,-1]-T12[-1,0]*cm[-1,0]-T12[-1,-1]*cm[-1,-1])/4.;av.y[]+=(shearY+cm[]*T22[]-cm[0,-1]*T22[0,-1])*alpha.y[]/(sq(fm.y[])*Delta);}}#if AXIforeach_face(y)if(y>1e-20)av.y[]-=(T_ThTh[]+T_ThTh[0,-1])*alpha.y[]/sq(y)/2.;#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Methods",
    "content": "src-local/log-conform-viscoelastic.h See raw file Log-Conformation Method with Tensor Implementation Overview Title : log-conform-viscoelastic.h Version : 10.5 Description : Tensor-based implementation of the log-conformation method for viscoelastic fluids Key Features Conformation tensor A exists across domain and relaxes according to \u03bb Stress acts according to elastic modulus G Uses native tensor data structures for better code organization Supports both 2D and axisymmetric configurations Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Nov 23, 2024 Implementation Notes Based on http://basilisk.fr/src/log-conform.h with key improvements: Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling bug where [\u03c3_p] = 0 & [\u03c3_s] = \u03b3\u03ba Ensures [\u03c3_s+\u03c3_p] = \u03b3\u03ba for correct interface behavior Important Limitations 3D Compatibility Currently limited to 2D and axisymmetric cases only 3D support is blocked by Basilisk core limitations: Boundary conditions for symmetric tensors are not implemented in Basilisk core See basilisk/src/grid/cartesian-common.h lines 230-251 Comment in source: \u201cfixme: boundary conditions don\u2019t work!\u201d Alternative for 3D For 3D simulations, use log-conform-viscoelastic-scalar-3D.h Scalar version uses individual components instead of tensors Provides full 3D functionality without boundary condition limitations Technical Notes Variable Naming conform_p , conform_qq : Represent the Conformation tensor Tensor implementation provides more natural mathematical representation Axisymmetric components handled separately when needed Mathematical Framework The implementation follows the standard log-conformation approach: 1.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Uses tensor mathematics...",
    "content": "Uses tensor mathematics for clean formulation 2. Handles both planar and axisymmetric geometries 3. Provides natural extension to various constitutive models Note: In this code, conform_p, conform_qq are in fact the Conformation tensor. The log-conformation method for viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Function Definition",
    "content": "Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function. The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: In the case...",
    "content": "In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models. Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This instability poses...",
    "content": "This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) . TODO: - Perhaps, instead of the Bell\u2013Collela\u2013Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to http://basilisk.fr/src/navier-stokes/conserving.h #include \"bcg.h\" #if dimension == #error \"This implementation does not support 3D due to missing tensor boundary conditions in Basilisk (see cartesian-common.h line ~246).",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: JavaScript",
    "content": "Use log-conform-viscoelastic-scalar-3D.h for 3D simulations.\" #endif ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time symmetric tensor conform_p [], tau_p []; #if AXI scalar conform_qq [], tau_qq []; #endif event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; foreach () { foreach_dimension (){ tau_p . x . x [] = 0. ; conform_p . x . x [] = 1. ; } tau_p . x . y [] = 0. ; conform_p . x . y [] = 0. ; #if AXI tau_qq [] = 0 ; conform_qq [] = 1. ; #endif } for ( scalar s in { tau_p }) { s . v . x . i = - 1 ; // just a scalar, not the component of a vector foreach_dimension (){ if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } } for ( scalar s in { conform_p }) { s . v . x . i = - 1 ; // just a scalar, not the component of a vector foreach_dimension (){ if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } } #if AXI scalar s1 = tau_p . x . y ; s1 [ bottom ] = dirichlet ( 0. ); #endif #if AXI scalar s2 = conform_p . x . y ; s2 [ bottom ] = dirichlet ( 0. ); #endif } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } The stress tensor depends on previous instants and has to be integrated in time. In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: We use a...",
    "content": "We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ). In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] event tracer_advection ( i ++) { tensor Psi = conform_p ; #if AXI scalar Psiqq = conform_qq ; #endif Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A ; A . x . y = conform_p . x . y []; foreach_dimension () A . x . x = conform_p . x . x []; In the axisymmetric case, \\(\\Psi_{\\theta \\theta} = \\log A_{\\theta \\theta}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Therefore \\(\\Psi_{\\theta \\theta}...",
    "content": "Therefore \\(\\Psi_{\\theta \\theta} = \\log [ ( 1 + \\text{fa} \\tau_{p_{\\theta \\theta}})]\\) . #if AXI double Aqq = conform_qq []; Psiqq [] = log ( Aqq ); #endif The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; pseudo_t R ; diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue. Please report this bug by opening an issue on the GitHub repository. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"Negative eigenvalue detected: Lambda.x = %g , Lambda.y = %g\\n \" , Lambda . x , Lambda . y ); fprintf ( ferr , \"x = %g , y = %g\\n \" , x , y ); exit ( 1 ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "Psi . x . y [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); foreach_dimension () Psi . x . x [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) . The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Transform omega back...",
    "content": "Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: - R is the eigenvector matrix of the conformation tensor - M is the velocity gradient tensor in the eigenvector basis - The construction ensures B is symmetric and traceless pseudo_t B ; double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi . x . y []; Psi . x . y [] += dt *( 2. * B . x . y + OM *( Psi . y . y [] - Psi . x . x [])); foreach_dimension () { s *= - 1 ; Psi . x . x [] += dt * 2. *( B . x . x + s * OM ); } In the axisymmetric case, the governing equation for \\(\\Psi_{\\theta \\theta}\\) only involves that component, \\[ \\Psi_{\\theta \\theta}|_t - 2 L_{\\theta \\theta} = \\frac{\\mathbf{f}_r(e^{-\\Psi_{\\theta \\theta}})}{\\lambda} \\] with \\(L_{\\theta \\theta} = u_y/y\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Therefore step (a)...",
    "content": "Therefore step (a) for \\(\\Psi_{\\theta \\theta}\\) is #if AXI Psiqq [] += dt * 2. * u . y []/ max ( y , 1e-20 ); #endif } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . #if AXI advection ({ Psi . x . x , Psi . x . y , Psi . y . y , Psiqq }, uf , dt ); #else advection ({ Psi . x . x , Psi . x . y , Psi . y . y }, uf , dt ); #endif Convert back to _p foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi . x . x [], Psi . x . y []}, { Psi . y . x [], Psi . y . y []}}, R ; pseudo_v Lambda ; diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; #if AXI double Aqq = exp ( Psiqq []); #endif We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); #if AXI Aqq = ( 1. - intFactor ) + intFactor * exp ( Psiqq []); #endif A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . conform_p . x . y [] = A . x . y ; tau_p . x . y [] = Gp []* A . x . y ; #if AXI conform_qq [] = Aqq ; tau_qq [] = Gp []*( Aqq - 1. ); #endif foreach_dimension (){ conform_p . x . x [] = A . x . x ; tau_p . x . x [] = Gp []*( A . x . x - 1. ); } } } Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{\\tau}_p\\) is defined at cell centers while the corresponding force (acceleration) will be defined at cell faces. Two terms contribute to each component of the momentum equation.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Examples",
    "content": "For example the \\(x\\) -component in Cartesian coordinates has the following terms: \\(\\partial_x \\mathbf{\\tau}_{p_{xx}} + \\partial_y \\mathbf{\\tau}_{p_{xy}}\\) . The first term is easy to compute since it can be calculated directly from center values of cells sharing the face. The other one is harder. It will be computed from vertex values. The vertex values are obtained by averaging centered values.",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Results",
    "content": "Note that as a result of the vertex averaging cells [] and [-1,0] are not involved in the computation of shear. event acceleration ( i ++) { face vector av = a ; foreach_face () if ( fm . x [] > 1e-20 ) { double shear = ( tau_p . x . y [ 0 , 1 ]* cm [ 0 , 1 ] + tau_p . x . y [- 1 , 1 ]* cm [- 1 , 1 ] - tau_p . x . y [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - tau_p . x . y [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . x [] += ( shear + cm []* tau_p . x . x [] - cm [- 1 ]* tau_p . x . x [- 1 ])* alpha . x []/( sq ( fm . x [])* Delta ); } #if AXI foreach_face ( y ) if ( y > 0. ) av . y [] -= ( tau_qq [] + tau_qq [ 0 ,- 1 ])* alpha . y []/ sq ( y )/ 2. ; #endif }",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code: C/C++ Code",
    "content": "#include\"bcg.h\"#if dimension ==#error \"This implementation does not support 3D due to missing tensor boundary conditions in Basilisk (see cartesian-common.h line ~246).",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code: Context",
    "content": "Use log-conform-viscoelastic-scalar-3D.h for 3D simulations.\"#endif(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation timesymmetric tensor conform_p[],tau_p[];#if AXIscalar conform_qq[],tau_qq[];#endifevent defaults(i=0){if(is_constant(a.x))a=new face vector;foreach(){foreach_dimension(){tau_p.x.x[]=0.;conform_p.x.x[]=1.;}tau_p.x.y[]=0.;conform_p.x.y[]=0.;#if AXItau_qq[]=0;conform_qq[]=1.;#endif}for(scalar s in{tau_p}){s.v.x.i=-1;// just a scalar, not the component of a vectorforeach_dimension(){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}}for(scalar s in{conform_p}){s.v.x.i=-1;// just a scalar, not the component of a vectorforeach_dimension(){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}}#if AXIscalar s1=tau_p.x.y;s1[bottom]=dirichlet(0.);#endif#if AXIscalar s2=conform_p.x.y;s2[bottom]=dirichlet(0.);#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event tracer_advection(i++){tensor Psi=conform_p;#if AXIscalar Psiqq=conform_qq;#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_t A;A.x.y=conform_p.x.y[];foreach_dimension()A.x.x=conform_p.x.x[];",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#if AXIdoubleAqq=conform_qq[];Psiqq[]=log(Aqq);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_v Lambda;pseudo_t R;diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue.Please report this bug by opening an issue on the GitHub repository.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"Negative eigenvalue detected: Lambda.x =%g, Lambda.y =%g\\n\",Lambda.x,Lambda.y);fprintf(ferr,\"x =%g, y =%g\\n\",x,y);exit(1);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "Psi.x.y[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);foreach_dimension()Psi.x.x[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "pseudo_t B;doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubles=-Psi.x.y[];Psi.x.y[]+=dt*(2.*B.x.y+OM*(Psi.y.y[]-Psi.x.x[]));foreach_dimension(){s*=-1;Psi.x.x[]+=dt*2.*(B.x.x+s*OM);}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "#if AXIadvection({Psi.x.x,Psi.x.y,Psi.y.y,Psiqq},uf,dt);#elseadvection({Psi.x.x,Psi.x.y,Psi.y.y},uf,dt);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "pseudo_t A={{Psi.x.x[],Psi.x.y[]},{Psi.y.x[],Psi.y.y[]}},R;pseudo_v Lambda;diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;#if AXIdoubleAqq=exp(Psiqq[]);#endif",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);#if AXIAqq=(1.-intFactor)+intFactor*exp(Psiqq[]);#endifA.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "conform_p.x.y[]=A.x.y;tau_p.x.y[]=Gp[]*A.x.y;#if AXIconform_qq[]=Aqq;tau_qq[]=Gp[]*(Aqq-1.);#endifforeach_dimension(){conform_p.x.x[]=A.x.x;tau_p.x.x[]=Gp[]*(A.x.x-1.);}}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "event acceleration(i++){face vector av=a;foreach_face()if(fm.x[]>1e-20){doubleshear=(tau_p.x.y[0,1]*cm[0,1]+tau_p.x.y[-1,1]*cm[-1,1]-tau_p.x.y[0,-1]*cm[0,-1]-tau_p.x.y[-1,-1]*cm[-1,-1])/4.;av.x[]+=(shear+cm[]*tau_p.x.x[]-cm[-1]*tau_p.x.x[-1])*alpha.x[]/(sq(fm.x[])*Delta);}#if AXIforeach_face(y)if(y>0.)av.y[]-=(tau_qq[]+tau_qq[0,-1])*alpha.y[]/sq(y)/2.;#endif}",
    "url": "https://comphy-lab.org/Viscoelastic3D/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData-elastic-scalar2D.c This program extracts and processes data from fluid dynamics simulation snapshots, specifically designed for viscoela... getFacet2D.c A utility for extracting interface facets from fluid simulation data. VideoAxi.py Viscoelastic Visualization Tool =========================================== This script processes and visualizes flui...",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "postProcess/VideoAxi.py See raw file #!/usr/bin/env python3 # -*- coding: utf-8 -*- Viscoelastic Visualization Tool This script processes and visualizes fluid dynamics simulation data, particularly focused on droplet impact and deformable soft matter like liquid drops, sheets, and bubbles. It extracts interface positions and scalar field data from simulation files and creates visualizations showing physical quantities like strain rates and stresses. The script is designed to process multiple simulation snapshots in parallel, extracting data using external executables and generating visualizations with proper colormaps, scales, and mathematical labels.",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Features: - Extracts...",
    "content": "Features: - Extracts fluid interfaces and scalar fields from simulation files - Generates visualizations with proper colormaps and mathematical labels - Processes multiple timesteps in parallel using multiprocessing - Configurable via command-line arguments for different simulation cases - Creates publication-quality figures with LaTeX-rendered mathematical expressions Usage: python fluid_vis.py [options] Command-line Arguments: \u2013CPUs Number of CPUs to use for parallel processing (default: all available) \u2013nGFS Number of restart files to process (default: 550) \u2013ZMAX Maximum Z coordinate for visualization (default: 4.0) \u2013RMAX Maximum R coordinate for visualization (default: 2.0) \u2013ZMIN Minimum Z coordinate for visualization (default: -4.0) \u2013caseToProcess Path to simulation case directory (default: \u2018../simulationCases/dropImpact\u2019) \u2013folderToSave Directory to save visualization images (default: \u2018dropImpact\u2019) Dependencies: External executables: getFacet2D, getData-elastic-scalar2D Python libraries: numpy, matplotlib, subprocess, multiprocessing Author: Vatsal Sanjay Email: vatsalsanjay@gmail.com Affiliation: Physics of Fluids Last updated: Jul 24, 2024 import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import multiprocessing as mp from functools import partial import argparse import matplotlib.colors as mcolors custom_colors = [ \"white\" , \"#DA8A67\" , \"#A0522D\" , \"#400000\" ] custom_cmap = mcolors.LinearSegmentedColormap.from_list( \"custom_hot\" , custom_colors) # Configure matplotlib for publication-quality figures with LaTeX rendering matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' def gettingFacets(filename, includeCoat = 'true' ): Extract interface positions (facets) from simulation files.",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Args: filename (str):...",
    "content": "Args: filename (str): Path to simulation snapshot file includeCoat (str, optional): Whether to include coating layer. Defaults to \u2018true\u2019. Returns: list: List of line segments defining fluid interfaces exe = [ \"./getFacet2D\" , filename, includeCoat] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) skip = True return segs def gettingfield(filename, zmin, zmax, rmax, nr): Extract scalar field data from simulation files.",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Args: filename (str):...",
    "content": "Args: filename (str): Path to simulation snapshot file zmin (float): Minimum Z coordinate zmax (float): Maximum Z coordinate rmax (float): Maximum R coordinate nr (int): Number of grid points in R direction Returns: tuple: (R, Z, D2, vel, taup, nz) arrays of coordinates and field values exe = [ \"./getData-elastic-scalar2D\" , filename, str (zmin), str ( 0 ), str (zmax), str (rmax), str (nr)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, D2temp, veltemp, taupTemp = [],[],[],[],[] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) D2temp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) taupTemp.append( float (temp3[ 4 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) taup = np.asarray(taupTemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) taup.resize((nz, nr)) return R, Z, D2, vel, taup, nz # ---------------------------------------------------------------------------------------------------------------------- def process_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw, caseToProcess): Process a single timestep from simulation data and generate visualization.",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Args: ti (int):...",
    "content": "Args: ti (int): Timestep index folder (str): Directory to save output images nGFS (int): Total number of timesteps GridsPerR (int): Grid points per unit length in R direction rmin (float): Minimum R coordinate rmax (float): Maximum R coordinate zmin (float): Minimum Z coordinate zmax (float): Maximum Z coordinate lw (float): Line width for plot elements caseToProcess (str): Path to simulation case directory t = 0.01 * ti place = f\" { caseToProcess } /intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" if not os.path.exists(place): print ( f\" { place } File not found!\" ) return if os.path.exists(name): print ( f\" { name } Image present!\" ) return segs1 = gettingFacets(place) segs2 = gettingFacets(place, 'false' ) if not segs1 and not segs2: print ( f\"Problem in the available file { place } \" ) return nr = int (GridsPerR * rmax) R, Z, taus, vel, taup, nz = gettingfield(place, zmin, zmax, rmax, nr) zminp, zmaxp, rminp, rmaxp = Z. min (), Z. max (), R. min (), R. max () # Plotting AxesLabel, TickLabel = 50 , 20 fig, ax = plt.subplots() fig.set_size_inches( 19.20 , 10.80 ) # Draw domain boundaries ax.plot([ 0 , 0 ], [zmin, zmax], '-.' , color = 'grey' , linewidth = lw) ax.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Add fluid interfaces line_segments = LineCollection(segs2, linewidths = 4 , colors = 'green' , linestyle = 'solid' ) ax.add_collection(line_segments) line_segments = LineCollection(segs1, linewidths = 4 , colors = 'blue' , linestyle = 'solid' ) ax.add_collection(line_segments) # Plot scalar fields with colormaps cntrl1 = ax.imshow(taus, cmap = \"hot_r\" , interpolation = 'Bilinear' , origin = 'lower' , extent = [ - rminp, - rmaxp, zminp, zmaxp], vmax = 2.0 , vmin =- 3.0 ) # TODO : fixme the colorbar bounds for taup must be set manually based on the simulated case. cntrl2 = ax.imshow(taup, interpolation = 'Bilinear' , cmap = custom_cmap, origin = 'lower' , extent = [rminp, rmaxp, zminp, zmaxp], vmax = 2.0 , vmin =- 3.0 ) # Set plot properties ax.set_aspect( 'equal' ) ax.set_xlim(rmin, rmax) ax.set_ylim(zmin, zmax) ax.set_title( f'$t/ \\\\ tau_ \\\\ gamma$ = { t :4.3f} ' , fontsize = TickLabel) # Add colorbars l, b, w, h = ax.get_position().bounds # Left colorbar cb1 = fig.add_axes([l - 0.04 , b, 0.03 , h]) c1 = plt.colorbar(cntrl1, cax = cb1, orientation = 'vertical' ) c1.set_label( r' $ \\ log_ {10} \\ left ( \\| \\m athcal{D} \\|\\r ight ) $ ' , fontsize = TickLabel, labelpad = 5 ) c1.ax.tick_params(labelsize = TickLabel) c1.ax.yaxis.set_ticks_position( 'left' ) c1.ax.yaxis.set_label_position( 'left' ) c1.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.1f} ' )) # Right colorbar cb2 = fig.add_axes([l + w + 0.01 , b, 0.03 , h]) c2 = plt.colorbar(cntrl2, cax = cb2, orientation = 'vertical' ) c2.ax.tick_params(labelsize = TickLabel) c2.set_label( r' $ \\ log_ {10} \\ left ( \\t ext{tr} \\ left ( \\m athcal{A} \\r ight ) -1 \\r ight ) $ ' , fontsize = TickLabel) c2.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.2f} ' )) ax.axis( 'off' ) plt.savefig(name, bbox_inches = \"tight\" ) plt.close() def main(): Main function that parses command-line arguments and parallelizes processing of timesteps. # Set up command-line argument parsing parser = argparse.ArgumentParser(description = 'Process fluid dynamics simulation data and create visualizations' ) parser.add_argument( '--CPUs' , type = int , default = mp.cpu_count(), help = 'Number of CPUs to use (default: all available)' ) parser.add_argument( '--nGFS' , type = int , default = 550 , help = 'Number of restart files to process (default: 550)' ) parser.add_argument( '--ZMAX' , type = float , default = 4.0 , help = 'Maximum Z value (default: 4.0)' ) parser.add_argument( '--RMAX' , type = float , default = 2.0 , help = 'Maximum R value (default: 2.0)' ) parser.add_argument( '--ZMIN' , type = float , default =- 4.0 , help = 'Minimum Z value (default: -4.0)' ) parser.add_argument( '--caseToProcess' , type = str , default = '../simulationCases/dropImpact' , help = 'Case to process (default: ../simulationCases/dropImpact)' ) parser.add_argument( '--folderToSave' , type = str , default = 'dropImpact' , help = 'Folder to save output images (default: dropImpact)' ) args = parser.parse_args() # Extract arguments CPUStoUse = args.CPUs nGFS = args.nGFS ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN num_processes = CPUStoUse rmin, rmax, zmin, zmax = [ - RMAX, RMAX, ZMIN, ZMAX] GridsPerR = 128 # Grid resolution parameter lw = 2 # Line width for plot elements folder = args.folderToSave caseToProcess = args.caseToProcess # Create output directory if it doesn't exist if not os.path.isdir(folder): os.makedirs(folder) # Create a pool of worker processes for parallel processing with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments process_func = partial(process_timestep, folder = folder, nGFS = nGFS, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw, caseToProcess = caseToProcess) # Map the process_func to all timesteps pool. map (process_func, range (nGFS)) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Methods",
    "content": "importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportmultiprocessingasmpfromfunctoolsimportpartialimportargparseimportmatplotlib.colorsasmcolorscustom_colors=[\"white\",\"#DA8A67\",\"#A0522D\",\"#400000\"]custom_cmap=mcolors.LinearSegmentedColormap.from_list(\"custom_hot\", custom_colors)# Configure matplotlib for publication-quality figures with LaTeX renderingmatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'defgettingFacets(filename, includeCoat='true'):",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "exe=[\"./getFacet2D\", filename, includeCoat]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, zmax, rmax, nr):",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "exe=[\"./getData-elastic-scalar2D\", filename,str(zmin),str(0),str(zmax),str(rmax),str(nr)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, D2temp, veltemp, taupTemp=[],[],[],[],[]forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))D2temp.append(float(temp3[2]))veltemp.append(float(temp3[3]))taupTemp.append(float(temp3[4]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)taup=np.asarray(taupTemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))taup.resize((nz, nr))returnR, Z, D2, vel, taup, nz# ----------------------------------------------------------------------------------------------------------------------defprocess_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw, caseToProcess):",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "t=0.01*tiplace=f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"ifnotos.path.exists(place):print(f\"{place}File not found!\")returnifos.path.exists(name):print(f\"{name}Image present!\")returnsegs1=gettingFacets(place)segs2=gettingFacets(place,'false')ifnotsegs1andnotsegs2:print(f\"Problem in the available file{place}\")returnnr=int(GridsPerR*rmax)R, Z, taus, vel, taup, nz=gettingfield(place, zmin, zmax, rmax, nr)zminp, zmaxp, rminp, rmaxp=Z.min(), Z.max(), R.min(), R.max()# PlottingAxesLabel, TickLabel=50,20fig, ax=plt.subplots()fig.set_size_inches(19.20,10.80)# Draw domain boundariesax.plot([0,0], [zmin, zmax],'-.', color='grey', linewidth=lw)ax.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Add fluid interfacesline_segments=LineCollection(segs2, linewidths=4, colors='green', linestyle='solid')ax.add_collection(line_segments)line_segments=LineCollection(segs1, linewidths=4, colors='blue', linestyle='solid')ax.add_collection(line_segments)# Plot scalar fields with colormapscntrl1=ax.imshow(taus, cmap=\"hot_r\", interpolation='Bilinear', origin='lower',extent=[-rminp,-rmaxp, zminp, zmaxp], vmax=2.0, vmin=-3.0)#TODO: fixme the colorbar bounds for taup must be set manually based on the simulated case.cntrl2=ax.imshow(taup, interpolation='Bilinear', cmap=custom_cmap, origin='lower',extent=[rminp, rmaxp, zminp, zmaxp], vmax=2.0, vmin=-3.0)# Set plot propertiesax.set_aspect('equal')ax.set_xlim(rmin, rmax)ax.set_ylim(zmin, zmax)ax.set_title(f'$t/\\\\tau_\\\\gamma$ ={t:4.3f}', fontsize=TickLabel)# Add colorbarsl, b, w, h=ax.get_position().bounds# Left colorbarcb1=fig.add_axes([l-0.04, b,0.03, h])c1=plt.colorbar(cntrl1, cax=cb1, orientation='vertical')c1.set_label(r'$\\log_{10}\\left(\\|\\mathcal{D}\\|\\right)$', fontsize=TickLabel, labelpad=5)c1.ax.tick_params(labelsize=TickLabel)c1.ax.yaxis.set_ticks_position('left')c1.ax.yaxis.set_label_position('left')c1.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}'))# Right colorbarcb2=fig.add_axes([l+w+0.01, b,0.03, h])c2=plt.colorbar(cntrl2, cax=cb2, orientation='vertical')c2.ax.tick_params(labelsize=TickLabel)c2.set_label(r'$\\log_{10}\\left(\\text{tr}\\left(\\mathcal{A}\\right)-1\\right)$', fontsize=TickLabel)c2.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.2f}'))ax.axis('off')plt.savefig(name, bbox_inches=\"tight\")plt.close()defmain():",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: # Set up...",
    "content": "# Set up command-line argument parsingparser=argparse.ArgumentParser(description='Process fluid dynamics simulation data and create visualizations')parser.add_argument('--CPUs',type=int, default=mp.cpu_count(),help='Number of CPUs to use (default: all available)')parser.add_argument('--nGFS',type=int, default=550,help='Number of restart files to process (default: 550)')parser.add_argument('--ZMAX',type=float, default=4.0,help='Maximum Z value (default: 4.0)')parser.add_argument('--RMAX',type=float, default=2.0,help='Maximum R value (default: 2.0)')parser.add_argument('--ZMIN',type=float, default=-4.0,help='Minimum Z value (default: -4.0)')parser.add_argument('--caseToProcess',type=str,default='../simulationCases/dropImpact',help='Case to process (default: ../simulationCases/dropImpact)')parser.add_argument('--folderToSave',type=str, default='dropImpact',help='Folder to save output images (default: dropImpact)')args=parser.parse_args()# Extract argumentsCPUStoUse=args.CPUsnGFS=args.nGFSZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMINnum_processes=CPUStoUsermin, rmax, zmin, zmax=[-RMAX, RMAX, ZMIN, ZMAX]GridsPerR=128# Grid resolution parameterlw=2# Line width for plot elementsfolder=args.folderToSavecaseToProcess=args.caseToProcess# Create output directory if it doesn't existifnotos.path.isdir(folder):os.makedirs(folder)# Create a pool of worker processes for parallel processingwithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed argumentsprocess_func=partial(process_timestep,folder=folder, nGFS=nGFS,GridsPerR=GridsPerR, rmin=rmin, rmax=rmax,zmin=zmin, zmax=zmax, lw=lw, caseToProcess=caseToProcess)# Map the process_func to all timestepspool.map(process_func,range(nGFS))if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "postProcess/getData-elastic-scalar2D.c See raw file Simulation Data Extraction and Processing This program extracts and processes data from fluid dynamics simulation snapshots, specifically designed for viscoelastic fluid simulations with conformation tensor analysis. It computes important derived quantities including deformation rate tensor components, velocity magnitude, and conformation tensor trace. The program interpolates these quantities onto a regular grid and outputs the results for further analysis or visualization. Physics Background This code handles viscoelastic fluid simulation data where the fluid stress tensor includes both a viscous component (proportional to the deformation rate) and an elastic component (represented by the conformation tensor).",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: C/C++ Code",
    "content": "The trace of the conformation tensor provides a measure of polymer stretching in the fluid. #include \"utils.h\" #include \"output.h\" scalar f []; // Volume fraction field vector u []; // Velocity field scalar A11 [], A12 [], A22 []; // Conformation tensor components scalar conform_qq []; // Additional conformation tensor component char filename [ 80 ]; // Input file name int nx , ny , len ; // Grid dimensions and field count double xmin , ymin , xmax , ymax , Deltax , Deltay ; // Domain boundaries and grid spacing Derived Fields D2c: Log10 of squared deformation rate tensor weighted by volume fraction vel: Magnitude of velocity trA: Log10 of excess trace of conformation tensor scalar D2c [], vel [], trA []; scalar * list = NULL ; // List to store output fields Main Function Processes simulation data and computes derived quantities Arguments: arguments[1]: Input filename arguments[2-5]: Domain boundaries (xmin, ymin, xmax, ymax) arguments[6]: Number of grid points in y-direction (ny) Returns: 0 on successful execution int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); // Initialize list of fields to output list = list_add ( list , D2c ); list = list_add ( list , vel ); list = list_add ( list , trA ); Data Processing Workflow Restore simulation state from snapshot file Compute derived quantities at each grid point Interpolate fields onto regular grid Output data to file restore ( file = filename ); Field Computation For each cell, compute: - Components of the deformation rate tensor D - Squared magnitude of D weighted by volume fraction - Velocity magnitude - Excess trace of the conformation tensor foreach () { // Compute deformation rate tensor components double D11 = ( u . y [ 0 , 1 ] - u . y [ 0 , - 1 ]) / ( 2 * Delta ); double D22 = ( u . y [] / y ); double D33 = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ]) / ( 2 * Delta ); double D13 = 0.5 * (( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 , - 1 ]) / ( 2 * Delta )); double D2 = ( sq ( D11 ) + sq ( D22 ) + sq ( D33 ) + 2.0 * sq ( D13 )); D2c [] = f [] * D2 ; // Take log10 of D2c for better visualization if ( D2c [] > 0. ) { D2c [] = log ( D2c []) / log ( 10 ); } else { D2c [] = - 10 ; } // Compute velocity magnitude vel [] = sqrt ( sq ( u . x []) + sq ( u . y [])); // Compute excess trace of conformation tensor trA [] = ( A11 [] + A22 [] + conform_qq []) / 3.0 - 1.0 ; // Take log10 of trA for better visualization if ( trA [] > 0. ) { trA [] = log ( trA []) / log ( 10 ); } else { trA [] = - 10 ; } } Grid Interpolation and Output Calculate grid spacing based on domain size and ny Allocate memory for interpolated field values Interpolate field values onto regular grid Output grid coordinates and field values FILE * fp = ferr ; Deltay = ( double )(( ymax - ymin ) / ( ny )); nx = ( int )(( xmax - xmin ) / Deltay ); Deltax = ( double )(( xmax - xmin ) / ( nx )); len = list_len ( list ); // Allocate memory for field values double ** field = ( double **) matrix_new ( nx , ny + 1 , len * sizeof ( double )); // Interpolate field values onto regular grid for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; int k = 0 ; for ( scalar s in list ) { field [ i ][ len * j + k ++] = interpolate ( s , x , y ); } } } // Output grid coordinates and field values for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; fprintf ( fp , \" %g %g \" , x , y ); int k = 0 ; for ( scalar s in list ) { fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } // Clean up fflush ( fp ); fclose ( fp ); matrix_free ( field ); return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"scalar f[];// Volume fraction fieldvector u[];// Velocity fieldscalar A11[],A12[],A22[];// Conformation tensor componentsscalar conform_qq[];// Additional conformation tensor componentcharfilename[80];// Input file nameintnx,ny,len;// Grid dimensions and field countdoublexmin,ymin,xmax,ymax,Deltax,Deltay;// Domain boundaries and grid spacing",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "scalar D2c[],vel[],trA[];scalar*list=NULL;// List to store output fields",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);// Initialize list of fields to outputlist=list_add(list,D2c);list=list_add(list,vel);list=list_add(list,trA);",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: foreach(){// Compute deformation...",
    "content": "foreach(){// Compute deformation rate tensor componentsdoubleD11=(u.y[0,1]-u.y[0,-1])/(2*Delta);doubleD22=(u.y[]/y);doubleD33=(u.x[1,0]-u.x[-1,0])/(2*Delta);doubleD13=0.5*((u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(2*Delta));doubleD2=(sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13));D2c[]=f[]*D2;// Take log10 of D2c for better visualizationif(D2c[]>0.){D2c[]=log(D2c[])/log(10);}else{D2c[]=-10;}// Compute velocity magnitudevel[]=sqrt(sq(u.x[])+sq(u.y[]));// Compute excess trace of conformation tensortrA[]=(A11[]+A22[]+conform_qq[])/3.0-1.0;// Take log10 of trA for better visualizationif(trA[]>0.){trA[]=log(trA[])/log(10);}else{trA[]=-10;}}",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example: Context",
    "content": "FILE*fp=ferr;Deltay=(double)((ymax-ymin)/(ny));nx=(int)((xmax-xmin)/Deltay);Deltax=(double)((xmax-xmin)/(nx));len=list_len(list);// Allocate memory for field valuesdouble**field=(double**)matrix_new(nx,ny+1,len*sizeof(double));// Interpolate field values onto regular gridfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y);}}}// Output grid coordinates and field valuesfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;fprintf(fp,\"%g%g\",x,y);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}// Clean upfflush(fp);fclose(fp);matrix_free(field);return0;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: Context",
    "content": "postProcess/getFacet2D.c See raw file Getting Facets A utility for extracting interface facets from fluid simulation data. Description This program extracts and outputs the facets representing the interface between different phases in a multiphase flow simulation. The facets define the boundary between fluid phases, useful for geometric analysis and visualization of the interface morphology. Physics Background In multiphase fluid simulations, interfaces between different fluids are critical features that determine many physical phenomena like surface tension effects, droplet formation, and coalescence events. This utility identifies these interfaces by extracting facets from volume fraction data, allowing for quantitative analysis of interfacial dynamics.",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework: C/C++ Code",
    "content": "Usage ./getFacets input_file Author: Vatsal Sanjay vatsalsanjay@gmail.com Physics of Fluids Department University of Twente #include \"utils.h\" #include \"output.h\" #include \"fractions.h\" scalar f []; // Volume fraction field char filename [ 80 ]; Main Function Loads a simulation snapshot and extracts the interface facets. Input parameters: arguments[1] : Filename of the simulation snapshot to process Process: Restores the simulation state from the specified file Extracts interface facets from the volume fraction field Outputs facet data to standard error Return value: Returns 0 on successful completion Note: The facet extraction algorithm identifies where the volume fraction field crosses a threshold value (typically 0.5) between adjacent cells. int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); restore ( file = filename ); FILE * fp = ferr ; output_facets ( f , fp ); fflush ( fp ); fclose ( fp ); return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"fractions.h\"scalar f[];// Volume fraction fieldcharfilename[80];",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | ElastoFlow: 2D/3D Viscoelastic Fluid Simulation Framework - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);restore(file=filename);FILE*fp=ferr;output_facets(f,fp);fflush(fp);fclose(fp);return0;}",
    "url": "https://comphy-lab.org/Viscoelastic3D/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Viscoelastic Worthington Jets...",
    "content": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles This repository contains the simulation code and analysis for studying the dynamics of viscoelastic Worthington jets and droplets produced by bursting bubbles. The code uses the ElastoFlow framework to simulate bubble cavity collapse in viscoelastic media, examining how elastic modulus and relaxation time affect jet and droplet formation. The article can be found at: Overview The project investigates how viscoelasticity influences bubble bursting dynamics by exploring the three-dimensional phase space of solvent Ohnesorge number, elastocapillary number, and Deborah number using volume of fluid-based finite volume simulations. The results demonstrate that polymer addition significantly influences the overall dynamics through the interplay of viscous and elastic effects.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Repository Structure basilisk/src/...",
    "content": "Repository Structure basilisk/src/ - # Core Basilisk CFD library (reference only, do not modify) src-local/ - # Custom viscoelastic solvers and tensor utilities log-conform-viscoelastic-scalar-3D.h - # 3D log-conformation (scalar) log-conform-viscoelastic-scalar-2D.h - # 2D/axi log-conformation (scalar) log-conform-viscoelastic.h - # 2D/axi log-conformation (tensor) two-phaseVE.h - # Two-phase viscoelastic extension eigen_decomposition.h - # 3x3 symmetric eigenvalue solver simulationCases/ - # Example/test cases and post-processing scripts burstingBubbleVE.c - # Bursting bubble simulation postProcess/ - # Project-specific post-processing tools and utilities getData-elastic-scalar2D.c - # Data extraction utility getFacet2D.c - # Facet extraction utility VideoAxi.py - # Python visualization script Installation and Setup To ensure you have the necessary tools and a fresh Basilisk installation, use the provided script: ./reset_install_requirements.sh Function This script checks for Basilisk installation and compiles it if not present.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: OS Compatibility Designed...",
    "content": "OS Compatibility Designed for macOS. If you encounter issues on Linux, consider opening a GitHub issue. Dependencies Basilisk C is fetched and built automatically. Xcode Command Line Tools (macOS) or equivalent compiler toolchain (Linux) are required. Environment Setup After running the script, a .project_config file is created, setting BASILISK and PATH automatically.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "If you have previously installed Basilisk or changed dependencies, re-run the script with --hard : ./reset_install_requirements.sh --hard Running the Code Recommended Method: Using Makefile The easiest way to compile and run the code is using the Makefile approach: Navigate to the testCases directory: cd testCases Compile and run using make: CFLAGS = -DDISPLAY=-1 make burstingBubbleVE.tst Alternative Method: Direct Compilation You can compile the code directly using qcc in two ways: Using include paths (recommended): qcc -O2 -Wall -disable-dimensions -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm Without include paths: qcc -O2 -Wall -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm Note : If using method 2, you must first manually copy the src-local folder to your running directory.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Local Execution MacOS:...",
    "content": "Local Execution MacOS: # First source the configuration source .project_config # Compile using include paths (recommended) qcc -O2 -Wall -disable-dimensions -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm # Or compile without include paths (requires manually copying src-local folder) qcc -O2 -Wall -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm # Run the executable, only supports serial execution ./burstingBubbleVE Linux: # First source the configuration source .project_config # Compile using include paths (recommended) qcc -O2 -Wall -disable-dimensions -fopenmp -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm # Or compile without include paths (requires manually copying src-local folder) qcc -O2 -Wall -disable-dimensions -fopenmp burstingBubbleVE.c -o burstingBubbleVE -lm # Set the number of OpenMP threads export OMP_NUM_THREADS = 4 # Run the executable ./burstingBubbleVE HPC Cluster Execution (e.g., Snellius) For cluster environments, it is strongly recommended to manually copy the src-local folder to your working directory to ensure reliable compilation across different cluster configurations: First, copy the required files: cp -r /path/to/original/src-local .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Compile the code...",
    "content": "Compile the code for MPI: CC99 = 'mpicc -std=c99' qcc -Wall -O2 -D_MPI = 1 -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm Create a SLURM job script (e.g., run_simulation.sh ): #!/bin/bash #SBATCH --nodes=1 #SBATCH --ntasks=32 #SBATCH --time=1:00:00 #SBATCH --partition=genoa #SBATCH --mail-type=ALL #SBATCH --mail-user=v.sanjay@utwente.nl srun --mpi = pmi2 -n 32 --gres = cpu:32 --mem-per-cpu = 1750mb burstingBubbleVE Submit the job: sbatch run_simulation.sh Additional Running Scripts The z_extras/running directory contains supplementary materials and post-processing tools used in the analysis. This includes C-based data extraction utilities, Python visualization scripts, and analysis notebooks. These tools were used to process simulation outputs and generate figures for the study. For detailed documentation of these tools, see the README in the z_extras directory.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Reset Install Requirements...",
    "content": "Reset Install Requirements Script The reset_install_requirements.sh script is designed to reset the installation requirements for the project. This can be useful when you want to ensure that all dependencies are fresh and up-to-date. Purpose The script re-installs all required packages as specified in the requirements file, ensuring that the project\u2019s dependencies are up-to-date and consistent. Usage To run the script, use the following command in your terminal: bash reset_install_requirements.sh Make sure to have the necessary permissions to execute the script. Citation If you use this code in your research, please cite: Paper @article { Dixit_Oratis_Zinelis_Lohse_Sanjay_2025 , title ={Viscoelastic Worthington jets and droplets produced by bursting bubbles}, volume ={1010}, journal ={J. Fluid Mech.}, author ={Dixit, A.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "K. and Oratis, A. and Zinelis, K. and Lohse, D. and Sanjay, V.}, year ={2025}, pages ={A2}, DOI ={10.1017/jfm.2025.237}} Software @software{vatsal_sanjay_2024_14210635, author = {Vatsal Sanjay}, title = {{comphy-lab/Viscoelastic3D: \ud83c\udf0a v2.5: ElastoFlow - Complete 2D/3D Viscoelastic Framework}}, month = nov, year = 2024, publisher = {Zenodo}, version = {v2.5}, doi = {10.5281/zenodo.14210635}, url = {https://doi.org/10.5281/zenodo.14210635} } Features Simulation of bubble cavity collapse in viscoelastic media Analysis of Worthington jet formation and droplet ejection Investigation of polymer effects through: Elastic modulus (elastocapillary number) Relaxation time (Deborah number) Viscous effects (Ohnesorge number) Dependencies The code utilizes: - Basilisk C ( basilliskpopinet ) - Volume of Fluid (VoF) method for interface tracking - Adaptive Mesh Refinement (AMR) with quadtree grids Key Results The simulations reveal: 1.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: JavaScript",
    "content": "Three distinct flow regimes: - Jets forming droplets - Jets without droplet formation - Absence of jet formation 2. Impact of viscoelasticity on: - Capillary wave propagation - Jet elongation and retraction - Droplet formation and size Additional Resources The z_extras directory contains supplementary materials and post-processing tools used in the analysis. This includes C-based data extraction utilities, Python visualization scripts, and analysis notebooks. These tools were used to process simulation outputs and generate figures for the study. For detailed documentation of these tools, see the README in the z_extras directory. Authors Ayush K.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Dixit (University of...",
    "content": "Dixit (University of Twente), a.k.dixit@utwente.nl Alexandros Oratis (University of Twente, now TU Delft), a.t.oratis@tudelft.nl Konstantinos Zinelis (Imperial College London, now MIT), zinelis@mit.edu Detlef Lohse (University of Twente & Max Planck Institute), d.lohse@utwente.nl Vatsal Sanjay (University of Twente), vatsalsanjay@gmail.com License This project is licensed under standard academic terms. Please cite the paper and software if you use this code in your research. Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/VideoAxi.py postProcess/getData-elastic-scalar2D.c postProcess/getFacet2D.c simulationCases simulationCases/Makefile simulationCases/burstingBubbleVE.c simulationCases/runCodesInParallel.sh src-local src-local/eigen_decomposition.h src-local/log-conform-viscoelastic-scalar-2D.h src-local/log-conform-viscoelastic-scalar-3D.h src-local/log-conform-viscoelastic.h src-local/two-phaseVE.h",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "qcc-O2-Wall-disable-dimensions-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "qcc-O2-Wall-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# First source the configurationsource.project_config# Compile using include paths (recommended)qcc-O2-Wall-disable-dimensions-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm# Or compile without include paths (requires manually copying src-local folder)qcc-O2-Wall-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm# Run the executable, only supports serial execution./burstingBubbleVE",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# First source the configurationsource.project_config# Compile using include paths (recommended)qcc-O2-Wall-disable-dimensions-fopenmp-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm# Or compile without include paths (requires manually copying src-local folder)qcc-O2-Wall-disable-dimensions-fopenmpburstingBubbleVE.c-oburstingBubbleVE-lm# Set the number of OpenMP threadsexportOMP_NUM_THREADS=4# Run the executable./burstingBubbleVE",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "CC99='mpicc -std=c99'qcc-Wall-O2-D_MPI=1-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#!/bin/bash#SBATCH --nodes=1#SBATCH --ntasks=32#SBATCH --time=1:00:00#SBATCH --partition=genoa#SBATCH --mail-type=ALL#SBATCH --mail-user=v.sanjay@utwente.nlsrun--mpi=pmi2-n32--gres=cpu:32--mem-per-cpu=1750mb burstingBubbleVE",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "@article{Dixit_Oratis_Zinelis_Lohse_Sanjay_2025,title={Viscoelastic Worthington jets and droplets produced by bursting bubbles},volume={1010},journal={J. Fluid Mech.},author={Dixit, A. K. and Oratis, A. and Zinelis, K. and Lohse, D. and Sanjay, V.},year={2025},pages={A2},DOI={10.1017/jfm.2025.237}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "@software{vatsal_sanjay_2024_14210635,author       = {Vatsal Sanjay},title        = {{comphy-lab/Viscoelastic3D: \ud83c\udf0a v2.5: ElastoFlow -Complete 2D/3D Viscoelastic Framework}},month        = nov,year         = 2024,publisher    = {Zenodo},version      = {v2.5},doi          = {10.5281/zenodo.14210635},url          = {https://doi.org/10.5281/zenodo.14210635}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # tested on MacOS only.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue. # modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk # Check if --hard flag is passed HARD_RESET = \\f alse if [[ \" \\$ 1\" == \"--hard\" ]]; then HARD_RESET = \\t rue fi # Function to install basilisk install_basilisk() { darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make } # Remove project config always rm -rf .project_config # Check if basilisk needs to be installed if [[ \" \\$ HARD_RESET\" == true ]] || [[ ! -d \"basilisk\" ]]; then echo \"Installing basilisk...\" rm -rf basilisk install_basilisk else echo \"Using existing basilisk installation...\" cd basilisk/src fi # Setup environment variables echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config # Check if qcc is working properly echo \"\\nChecking qcc installation...\" if ! qcc --version > /dev/null 2 >& 1 ; then echo \"\\033[0;31mError: qcc is not working properly.\\033[0m\" echo \"Please ensure you have Xcode Command Line Tools installed.\" echo \"You can install them by running: xcode-select --install\" echo \"For more details, visit: http://basilisk.fr/src/INSTALL\" exit 1 else echo \"\\033[0;32mqcc is properly installed.\\033[0m\" qcc --version fi",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: #!/bin/zsh# tested on...",
    "content": "#!/bin/zsh# tested on MacOS only.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue.# modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basilisk# Check if --hard flag is passedHARD_RESET=\\falseif[[\"\\$1\"==\"--hard\"]];thenHARD_RESET=\\truefi# Function to install basiliskinstall_basilisk(){darcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake}# Remove project config alwaysrm-rf.project_config# Check if basilisk needs to be installedif[[\"\\$HARD_RESET\"==true]]||[[!-d\"basilisk\"]];thenecho\"Installing basilisk...\"rm-rfbasiliskinstall_basiliskelseecho\"Using existing basilisk installation...\"cdbasilisk/srcfi# Setup environment variablesecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config# Check if qcc is working properlyecho\"\\nChecking qcc installation...\"if!qcc--version>/dev/null2>&1;thenecho\"\\033[0;31mError: qcc is not working properly.\\033[0m\"echo\"Please ensure you have Xcode Command Line Tools installed.\"echo\"You can install them by running: xcode-select --install\"echo\"For more details, visit: http://basilisk.fr/src/INSTALL\"exit1elseecho\"\\033[0;32mqcc is properly installed.\\033[0m\"qcc--versionfi",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "simulationCases/burstingBubbleVE.c See raw file Bursting Bubbles in Viscoelastic Media Simulation This simulation models the dynamics of bursting bubbles in viscoelastic media using the Basilisk framework. It particularly focuses on the formation of Worthington jets and droplets that emerge during the bursting process. Physics Overview The simulation implements a two-phase flow model with viscoelastic properties, utilizing the log-conformation approach for numerical stability. This approach preserves the positive-definiteness of the conformation tensor, which is crucial for stable simulations of viscoelastic fluids at high Deborah numbers. For theoretical details, see: V.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Sanjay, Zenodo, DOI:...",
    "content": "Sanjay, Zenodo, DOI: 10.5281/zenodo.14210635 (2024) Usage ./program maxLevel De Ec Oh Bond tmax Where: - maxLevel : Maximum refinement level for adaptive mesh - De : Deborah number (ratio of relaxation time to flow time) - Ec : Elasto-capillary number (ratio of elastic to surface tension forces) - Oh : Ohnesorge number (ratio of viscous to inertial-capillary forces) - Bond : Bond number (ratio of gravitational to surface tension forces) - tmax : Maximum simulation time @file burstingBubbleVE.c @author Vatsal Sanjay and Ayush Dixit @version 1.0 @date Nov 23, 2024 - Work used in the paper: DOI: 10.1017/jfm.2025.237 #include \"axi.h\" #include \"navier-stokes/centered.h\" // Uncomment to use the scalar version of the viscoelastic code // #define _SCALAR #if !_SCALAR #include \"log-conform-viscoelastic.h\" #else #include \"log-conform-viscoelastic-scalar-2D.h\" #endif Simulation Parameters FILTERED : Enable density and viscosity jump smoothing tsnap : Time interval between snapshots (default: 1e-2) fErr : Error tolerance for volume fraction (1e-3) KErr : Error tolerance for curvature calculation (1e-6) VelErr : Error tolerance for velocity field (1e-3) AErr : Error tolerance for conformation tensor (1e-3) Ldomain : Domain size in characteristic lengths (8) #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #if !_MPI #include \"distance.h\" #endif #define tsnap ( 1e-2 ) // 0.001 only for some cases. // Error tolerances #define fErr ( 1e-3 ) // Error tolerance in f1 VOF #define KErr ( 1e-6 ) // Error tolerance in VoF curvature calculated using height function method #define VelErr ( 1e-3 ) // Error tolerances in velocity - Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define AErr ( 1e-3 ) // Error tolerances in conformation inside the liquid // Domain size #define Ldomain 8 79 // Boundary conditions - outflow on the right boundary u . n [ right ] = neumann ( 0. ); p [ right ] = dirichlet ( 0. ); int MAXlevel ; // Physical parameters: // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // De -> Deborah number // Ec -> Elasto-capillary number double Oh , Oha , De , Ec , Bond , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; Main Function Initializes the simulation parameters and sets up the domain.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Uses command line...",
    "content": "Uses command line arguments to set simulation parameters Sets up the physical domain with appropriate dimensions Configures fluid properties for both phases Creates necessary directories for output int main ( int argc , char const * argv []) { dtmax = 1e-5 ; // BEWARE of this for stability issues. L0 = Ldomain ; origin (- L0 / 2. , 0. ); // Values taken from the terminal. Here we use some representative values. // In production run, you can pass it from the command line. MAXlevel = 10 ; // atoi(argv[1]); De = 0.1 ; // atof(argv[2]); // Use 1e30 to simulate the De \u2192 \u221e limit Ec = 0.01 ; // atof(argv[3]); Oh = 1e-2 ; // atof(argv[4]); Bond = 1e-3 ; // atof(argv[5]); tmax = 1e0 ; // atof(argv[6]); // Ensure that all the variables were transferred properly from the terminal or job script. // if (argc < 7){ // fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Need %d more...",
    "content": "Need %d more arguments\\n\", 7-argc); // return 1; // } init_grid ( 1 << 5 ); // Create a folder named intermediate where all the simulation snapshots are stored. char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "See writingFiles event. sprintf ( dumpFile , \"restart\" ); Physical Properties Configuration Sets up the material properties for both phases: - rho1 , rho2 : Density of liquid and gas phases - mu1 , mu2 : Dynamic viscosity of liquid and gas phases - lambda1 , lambda2 : Relaxation times - G1 , G2 : Elastic moduli Dimensionless parameters: - Oh : Ohnesorge number for liquid phase - Oha : Ohnesorge number for gas phase (= 2e-2 * Oh) - De : Deborah number - Ec : Elasto-capillary number - Bond : Bond number rho1 = 1. , rho2 = 1e-3 ; Oha = 2e-2 * Oh ; mu1 = Oh , mu2 = Oha ; lambda1 = De ; lambda2 = 0. ; G1 = Ec ; G2 = 0. ; f . sigma = 1.0 ; TOLERANCE = 1e-4 ; CFL = 1e-1 ; run (); } Initialization Event Sets up the initial conditions for the simulation. The function attempts to restore from a dump file first.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: If that fails:...",
    "content": "If that fails: - For MPI runs: Ends with an error - For non-MPI runs: Tries to load an initial shape from a data file, creates a distance field, and initializes the volume fraction event init ( t = 0 ) { #if _MPI // This is for supercomputers without OpenMP support if (! restore ( file = dumpFile )) { fprintf ( ferr , \"Cannot restored from a dump file! \\n \" ); } #else // Note that distance.h is incompatible with OpenMPI.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: So, the below...",
    "content": "So, the below code should not be used with MPI if (! restore ( file = dumpFile )) { char filename [ 60 ]; sprintf ( filename , \"Bo %5.4f .dat\" , Bond ); FILE * fp = fopen ( filename , \"rb\" ); if ( fp == NULL ) { fprintf ( ferr , \"There is no file named %s\\n \" , filename ); // Try in folder one level up sprintf ( filename , \"../Bo %5.4f .dat\" , Bond ); fp = fopen ( filename , \"rb\" ); if ( fp == NULL ) { fprintf ( ferr , \"There is no file named %s\\n \" , filename ); return 1 ; } } coord * InitialShape ; InitialShape = input_xy ( fp ); fclose ( fp ); scalar d []; distance ( d , InitialShape ); while ( adapt_wavelet (( scalar *){ f , d }, ( double []){ 1e-8 , 1e-8 }, MAXlevel ). nf ); // The distance function is defined at the center of each cell, we have // to calculate the value of this function at each vertex. vertex scalar phi []; foreach_vertex () { phi [] = -( d [] + d [- 1 ] + d [ 0 ,- 1 ] + d [- 1 ,- 1 ])/ 4. ; } // We can now initialize the volume fraction of the domain. fractions ( phi , f ); } // return 1; #endif } Adaptive Mesh Refinement Refines the mesh based on gradients of key fields: - Volume fraction - Velocity components - Conformation tensor components - Curvature The refinement criteria are set by the error tolerance parameters defined at the beginning of the file.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This adaptive approach...",
    "content": "This adaptive approach allows for high resolution in regions of interest while maintaining computational efficiency. event adapt ( i ++) { scalar KAPPA []; curvature ( f , KAPPA ); #if !_SCALAR adapt_wavelet (( scalar *){ f , u . x , u . y , conform_p . x . x , conform_p . y . y , conform_p . y . x , conform_qq , KAPPA }, ( double []){ fErr , VelErr , VelErr , AErr , AErr , AErr , AErr , KErr }, MAXlevel , MAXlevel - 6 ); #else adapt_wavelet (( scalar *){ f , u . x , u . y , A11 , A22 , A12 , AThTh , KAPPA }, ( double []){ fErr , VelErr , VelErr , AErr , AErr , AErr , AErr , KErr }, MAXlevel , MAXlevel - 6 ); #endif } Output Management Creates periodic snapshots of the simulation state. - Dumps restart files for simulation recovery - Saves intermediate snapshots at regular intervals defined by tsnap event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Simulation Termination Writes a final summary of the simulation parameters when the simulation ends. event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , De %2.1e , Ec %2.1e , Oh %2.1e , Oha %2.1e , Bo %4.3f\\n \" , MAXlevel , De , Ec , Oh , Oha , Bond ); } Simulation Logging Records key simulation data at each timestep: - Iteration number - Timestep size - Current simulation time - Kinetic energy Also performs safety checks: - Monitors kinetic energy for stability - Terminates simulation if energy becomes too high or too low - Creates log files for post-processing analysis event logWriting ( i ++) { // Calculate kinetic energy double ke = 0. ; foreach ( reduction (+: ke )) { ke += ( 2 * pi * y )*( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y [])))* sq ( Delta ); } if ( pid () == 0 ) { static FILE * fp ; if ( i == 0 ) { fprintf ( ferr , \"Level %d , De %2.1e , Ec %2.1e , Oh %2.1e , Oha %2.1e , Bo %4.3f\\n \" , MAXlevel , De , Ec , Oh , Oha , Bond ); fprintf ( ferr , \"De Ec Oh i dt t ke \\n \" ); fp = fopen ( \"log\" , \"w\" ); fprintf ( fp , \"Level %d , De %2.1e , Ec %2.1e , Oh %2.1e , Oha %2.1e , Bo %4.3f\\n \" , MAXlevel , De , Ec , Oh , Oha , Bond ); fprintf ( fp , \"i dt t ke \\n \" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } else { fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); assert ( ke > - 1e-10 ); // Check for energy blowup (numerical instability) if ( ke > 1e2 && i > 1e1 ) { if ( pid () == 0 ) { fprintf ( ferr , \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \"The kinetic energy blew up. Stopping simulation \\n \" ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } assert ( ke < 1e2 ); // Check for energy dissipation below threshold if ( ke < 1e-6 && i > 1e1 ) { if ( pid () == 0 ) { fprintf ( ferr , \"kinetic energy too small now! Stopping! \\n \" ); dump ( file = dumpFile ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \"kinetic energy too small now! Stopping! \\n \" ); fclose ( fp ); return 1 ; } } } }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"axi.h\"#include\"navier-stokes/centered.h\"// Uncomment to use the scalar version of the viscoelastic code// #define _SCALAR#if !_SCALAR#include\"log-conform-viscoelastic.h\"#else#include\"log-conform-viscoelastic-scalar-2D.h\"#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code: C/C++ Code",
    "content": "#define FILTERED// Smear density and viscosity jumps#include\"two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#if !_MPI#include\"distance.h\"#endif#define tsnap(1e-2)// 0.001 only for some cases.// Error tolerances#define fErr(1e-3)// Error tolerance in f1 VOF#define KErr(1e-6)// Error tolerance in VoF curvature calculated using height function method#define VelErr(1e-3)// Error tolerances in velocity - Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J#define AErr(1e-3)// Error tolerances in conformation inside the liquid// Domain size#define Ldomain879// Boundary conditions - outflow on the right boundaryu.n[right]=neumann(0.);p[right]=dirichlet(0.);intMAXlevel;// Physical parameters:// Oh -> Solvent Ohnesorge number// Oha -> air Ohnesorge number// De -> Deborah number// Ec -> Elasto-capillary numberdoubleOh,Oha,De,Ec,Bond,tmax;charnameOut[80],dumpFile[80];",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: intmain(intargc,charconst*argv[]){dtmax=1e-5;// BEWARE of...",
    "content": "intmain(intargc,charconst*argv[]){dtmax=1e-5;// BEWARE of this for stability issues.L0=Ldomain;origin(-L0/2.,0.);// Values taken from the terminal.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Here we use...",
    "content": "Here we use some representative values.// In production run, you can pass it from the command line.MAXlevel=10;// atoi(argv[1]);De=0.1;// atof(argv[2]); // Use 1e30 to simulate the De \u2192 \u221e limitEc=0.01;// atof(argv[3]);Oh=1e-2;// atof(argv[4]);Bond=1e-3;// atof(argv[5]);tmax=1e0;// atof(argv[6]);// Ensure that all the variables were transferred properly from the terminal or job script.// if (argc < 7){//   fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Need %d more...",
    "content": "Need %d more arguments\\n\", 7-argc);//   return 1;// }init_grid(1<<5);// Create a folder named intermediate where all the simulation snapshots are stored.charcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file. See writingFiles event.sprintf(dumpFile,\"restart\");",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "rho1=1.,rho2=1e-3;Oha=2e-2*Oh;mu1=Oh,mu2=Oha;lambda1=De;lambda2=0.;G1=Ec;G2=0.;f.sigma=1.0;TOLERANCE=1e-4;CFL=1e-1;run();}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event init(t=0){#if _MPI//...",
    "content": "event init(t=0){#if _MPI// This is for supercomputers without OpenMP supportif(!restore(file=dumpFile)){fprintf(ferr,\"Cannot restored from a dump file!\\n\");}#else// Note that distance.h is incompatible with OpenMPI.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: So, the below...",
    "content": "So, the below code should not be used with MPIif(!restore(file=dumpFile)){charfilename[60];sprintf(filename,\"Bo%5.4f.dat\",Bond);FILE*fp=fopen(filename,\"rb\");if(fp==NULL){fprintf(ferr,\"There is no file named%s\\n\",filename);// Try in folder one level upsprintf(filename,\"../Bo%5.4f.dat\",Bond);fp=fopen(filename,\"rb\");if(fp==NULL){fprintf(ferr,\"There is no file named%s\\n\",filename);return1;}}coord*InitialShape;InitialShape=input_xy(fp);fclose(fp);scalar d[];distance(d,InitialShape);while(adapt_wavelet((scalar*){f,d},(double[]){1e-8,1e-8},MAXlevel).nf);// The distance function is defined at the center of each cell, we have// to calculate the value of this function at each vertex.vertex scalar phi[];foreach_vertex(){phi[]=-(d[]+d[-1]+d[0,-1]+d[-1,-1])/4.;}// We can now initialize the volume fraction of the domain.fractions(phi,f);}// return 1;#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);#if !_SCALARadapt_wavelet((scalar*){f,u.x,u.y,conform_p.x.x,conform_p.y.y,conform_p.y.x,conform_qq,KAPPA},(double[]){fErr,VelErr,VelErr,AErr,AErr,AErr,AErr,KErr},MAXlevel,MAXlevel-6);#elseadapt_wavelet((scalar*){f,u.x,u.y,A11,A22,A12,AThTh,KAPPA},(double[]){fErr,VelErr,VelErr,AErr,AErr,AErr,AErr,KErr},MAXlevel,MAXlevel-6);#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, De%2.1e, Ec%2.1e, Oh%2.1e, Oha%2.1e, Bo%4.3f\\n\",MAXlevel,De,Ec,Oh,Oha,Bond);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event logWriting(i++){// Calculate...",
    "content": "event logWriting(i++){// Calculate kinetic energydoubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])))*sq(Delta);}if(pid()==0){staticFILE*fp;if(i==0){fprintf(ferr,\"Level%d, De%2.1e, Ec%2.1e, Oh%2.1e, Oha%2.1e, Bo%4.3f\\n\",MAXlevel,De,Ec,Oh,Oha,Bond);fprintf(ferr,\"De Ec Oh i dt t ke\\n\");fp=fopen(\"log\",\"w\");fprintf(fp,\"Level%d, De%2.1e, Ec%2.1e, Oh%2.1e, Oha%2.1e, Bo%4.3f\\n\",MAXlevel,De,Ec,Oh,Oha,Bond);fprintf(fp,\"i dt t ke\\n\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}else{fp=fopen(\"log\",\"a\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);assert(ke>-1e-10);// Check for energy blowup (numerical instability)if(ke>1e2&&i>1e1){if(pid()==0){fprintf(ferr,\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleVE.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Stopping simulation\\n\");fp=fopen(\"log\",\"a\");fprintf(fp,\"The kinetic...",
    "content": "Stopping simulation\\n\");fp=fopen(\"log\",\"a\");fprintf(fp,\"The kinetic energy blew up. Stopping simulation\\n\");fclose(fp);dump(file=dumpFile);return1;}}assert(ke<1e2);// Check for energy dissipation below thresholdif(ke<1e-6&&i>1e1){if(pid()==0){fprintf(ferr,\"kinetic energy too small now! Stopping!\\n\");dump(file=dumpFile);fp=fopen(\"log\",\"a\");fprintf(fp,\"kinetic energy too small now! Stopping!\\n\");fclose(fp);return1;}}}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/burstingBubbleVE.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases burstingBubbleVE.c This simulation models the dynamics of bursting bubbles in viscoelastic media using the Basilisk framework. It partic... Makefile ifeq (\\$(wildcard ../.projectconfig),) \\$(error '../.projectconfig not found') endif BASILISK := \\$(shell . ../.proje... runCodesInParallel.sh if [ \\$ -lt 1 ]; then echo 'Usage: \\$0 [numberofprocesses]' exit 1 fi file=\\$1 NP=\\${2:-4} use 4 as default if not p...",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCodesInParallel.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles",
    "content": "simulationCases/runCodesInParallel.sh See raw file runCodesInParallel.sh #!/bin/bash # check that CLI inputs are there. 1 is compulsory. if 2 is not there, use 4 (default) if [ \\$ # -lt 1 ] ; then echo \"Usage: \\$ 0 <filename> [number_of_processes]\" exit 1 fi file = \\$ 1 NP = \\$ {2:-4} # use 4 as default if not provided mkdir -p \\$ file CC99 = 'mpicc -std=c99' qcc -Wall -O2 -D_MPI = 1 -I\\$PWD /src-local -I\\$PWD /../src-local -disable-dimensions \\$ file.c -o \\$ file/\\$file -lm chmod +x \\$ file/\\$file # Ensure executable has proper permissions cd \\$ file mpirun --allow-run-as-root -np \\$ NP ./\\$file",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/runCodesInParallel.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCodesInParallel.sh | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#!/bin/bash# check that CLI inputs are there. 1 is compulsory. if 2 is not there, use 4 (default)if[\\$#-lt1];thenecho\"Usage:\\$0 <filename> [number_of_processes]\"exit1fifile=\\$1NP=\\${2:-4}# use 4 as default if not providedmkdir-p\\$fileCC99='mpicc -std=c99'qcc-Wall-O2-D_MPI=1-I\\$PWD/src-local-I\\$PWD/../src-local-disable-dimensions\\$file.c-o\\$file/\\$file-lmchmod+x\\$file/\\$file# Ensure executable has proper permissionscd\\$filempirun--allow-run-as-root-np\\$NP ./\\$file",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/runCodesInParallel.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles",
    "content": "simulationCases/Makefile See raw file Makefile # Check if .project_config exists ifeq ( \\$ ( wildcard ../.project_config ) , ) \\$ ( error \"../.project_config not found\" ) endif BASILISK := \\$ ( shell . ../.project_config && echo \\$\\$ BASILISK ) CFLAGS += -O2 -disable-dimensions CFLAGS += -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local include \\$ ( BASILISK ) /Makefile.defs",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/Makefile.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# Check if .project_config existsifeq(\\$(wildcard../.project_config),)\\$(error\"../.project_config not found\")endifBASILISK:=\\$(shell. ../.project_config&&echo\\$\\$BASILISK)CFLAGS+=-O2-disable-dimensionsCFLAGS+=-I\\$(PWD)/src-local-I\\$(PWD)/../src-localinclude\\$(BASILISK)/Makefile.defs",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/simulationCases/Makefile.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files eigen_decomposition.h This module provides algorithms for computing eigenvalues and eigenvectors of 3x3 symmetric matrices, which are commo... log-conform-viscoelastic-scalar-2D.h Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materia... log-conform-viscoelastic-scalar-3D.h Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materia... log-conform-viscoelastic.h The implementation follows the standard log-conformation approach: 1. Uses tensor mathematics for clean formulation 2... two-phaseVE.h This is a modified version of [two-phase.h](http://basilisk.fr/src/two-phase.h). It contains the implementation of Vi...",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "src-local/eigen_decomposition.h See raw file Matrix Eigenvalue Solver This module provides algorithms for computing eigenvalues and eigenvectors of 3x3 symmetric matrices, which are commonly encountered in computational fluid dynamics, solid mechanics, and other physics-based simulations. Mathematical Background The implementation uses the Householder transformation to reduce a symmetric matrix to tridiagonal form, followed by the QL algorithm with implicit shifts to compute the eigenvalues and eigenvectors. For a 3x3 symmetric matrix, these methods are particularly efficient and numerically stable, providing accurate results even for matrices with closely spaced eigenvalues. Tridiagonalize a 3x3 Symmetric Matrix Reduces a 3x3 symmetric matrix to tridiagonal form using the Householder method, which applies a series of orthogonal transformations to eliminate elements below the subdiagonal.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Results",
    "content": "Parameters: matrix[in]: Input 3x3 symmetric matrix to be tridiagonalized eigenvectors[out]: Orthogonal matrix of Householder vectors diagonal[out]: Diagonal elements of the resulting tridiagonal matrix subdiagonal[out]: Subdiagonal elements of the tridiagonal matrix Implementation Notes: The original matrix is preserved The eigenvectors matrix is initialized to identity and then transformed The algorithm exploits the symmetry of the input matrix #define SQUARE ( x ) (( x )*( x )) 36 static void tridiagonalize_symmetric_3x3 ( double matrix [ 3 ][ 3 ], double eigenvectors [ 3 ][ 3 ], double diagonal [ 3 ], double subdiagonal [ 2 ]) { const int size = 3 ; double householder_vector [ size ], temp_vector [ size ]; double omega , scale , sigma , tau ; // Initialize eigenvectors to the identity matrix for ( int i = 0 ; i < size ; i ++) { eigenvectors [ i ][ i ] = 1.0 ; for ( int j = 0 ; j < i ; j ++) eigenvectors [ i ][ j ] = eigenvectors [ j ][ i ] = 0.0 ; } // Compute the first Householder reflection scale = SQUARE ( matrix [ 0 ][ 1 ]) + SQUARE ( matrix [ 0 ][ 2 ]); sigma = ( matrix [ 0 ][ 1 ] > 0 ) ? - sqrt ( scale ) : sqrt ( scale ); subdiagonal [ 0 ] = sigma ; tau = sigma * matrix [ 0 ][ 1 ]; householder_vector [ 1 ] = matrix [ 0 ][ 1 ] - sigma ; householder_vector [ 2 ] = matrix [ 0 ][ 2 ]; omega = scale - tau ; if ( omega > 0.0 ) { omega = 1.0 / omega ; sigma = 0.0 ; for ( int i = 1 ; i < size ; i ++) { tau = matrix [ 1 ][ i ] * householder_vector [ 1 ] + matrix [ i ][ 2 ] * householder_vector [ 2 ]; temp_vector [ i ] = omega * tau ; sigma += householder_vector [ i ] * tau ; } sigma *= 0.5 * SQUARE ( omega ); for ( int i = 1 ; i < size ; i ++) temp_vector [ i ] -= sigma * householder_vector [ i ]; diagonal [ 0 ] = matrix [ 0 ][ 0 ]; diagonal [ 1 ] = matrix [ 1 ][ 1 ] - 2.0 * temp_vector [ 1 ] * householder_vector [ 1 ]; diagonal [ 2 ] = matrix [ 2 ][ 2 ] - 2.0 * temp_vector [ 2 ] * householder_vector [ 2 ]; for ( int j = 1 ; j < size ; j ++) { tau = omega * householder_vector [ j ]; for ( int i = 1 ; i < size ; i ++) eigenvectors [ i ][ j ] -= tau * householder_vector [ i ]; } subdiagonal [ 1 ] = matrix [ 1 ][ 2 ] - temp_vector [ 1 ] * householder_vector [ 2 ] - householder_vector [ 1 ] * temp_vector [ 2 ]; } else { for ( int i = 0 ; i < size ; i ++) diagonal [ i ] = matrix [ i ][ i ]; subdiagonal [ 1 ] = matrix [ 1 ][ 2 ]; } } ### Compute Eigenvalues and Eigenvectors of a 3x3 Symmetric Matrix Calculates the complete eigensystem (eigenvalues and eigenvectors) of a 3x3 symmetric matrix using the QL algorithm with implicit shifts, after first reducing the matrix to tridiagonal form.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Parameters: matrix[in]: Input...",
    "content": "Parameters: matrix[in]: Input 3x3 symmetric matrix whose eigensystem will be computed eigenvectors[out]: Matrix whose columns are the eigenvectors eigenvalues[out]: Array containing the eigenvalues Return Value: 0: Computation successful -1: Algorithm failed to converge within the maximum number of iterations Algorithm Details: First checks if the matrix is already diagonal If not, tridiagonalizes the matrix using Householder transformations Applies the QL algorithm with implicit shifts to compute eigenvalues Maximum of 30 iterations are allowed for convergence Numerical tolerance of 1e-15 is used for detecting diagonal matrices Usage Example: double matrix [ 3 ][ 3 ] = {{ 1.0 , 0.5 , 0.3 }, { 0.5 , 2.0 , 0.1 }, { 0.3 , 0.1 , 3.0 }}; double eigenvectors [ 3 ][ 3 ]; double eigenvalues [ 3 ]; int result = compute_eigensystem_symmetric_3x3 ( matrix , eigenvectors , eigenvalues ); if ( result == 0 ) { // Computation successful } static int compute_eigensystem_symmetric_3x3 ( double matrix [ 3 ][ 3 ], double eigenvectors [ 3 ][ 3 ], double eigenvalues [ 3 ]) { const int size = 3 ; const int max_iterations = 30 ; double subdiagonal [ 3 ]; double g , r , p , f , b , s , c , t ; int iteration_count ; int m ; // Check for diagonal matrix with unit entries if ( SQUARE ( matrix [ 0 ][ 1 ]) < 1e-15 && SQUARE ( matrix [ 0 ][ 2 ]) < 1e-15 && SQUARE ( matrix [ 1 ][ 2 ]) < 1e-15 ) { for ( int i = 0 ; i < size ; i ++) { for ( int j = 0 ; j < size ; j ++) { eigenvectors [ i ][ j ] = ( i == j ) ? 1.0 : 0.0 ; } eigenvalues [ i ] = matrix [ i ][ i ]; } return 0 ; } tridiagonalize_symmetric_3x3 ( matrix , eigenvectors , eigenvalues , subdiagonal ); for ( int l = 0 ; l < size - 1 ; l ++) { iteration_count = 0 ; while ( 1 ) { for ( m = l ; m <= size - 2 ; m ++) { g = fabs ( eigenvalues [ m ]) + fabs ( eigenvalues [ m + 1 ]); if ( fabs ( subdiagonal [ m ]) + g == g ) break ; } if ( m == l ) break ; if ( iteration_count ++ >= max_iterations ) return - 1 ; g = ( eigenvalues [ l + 1 ] - eigenvalues [ l ]) / ( 2.0 * subdiagonal [ l ]); r = sqrt ( SQUARE ( g ) + 1.0 ); g = eigenvalues [ m ] - eigenvalues [ l ] + subdiagonal [ l ] / ( g + ( g > 0 ? fabs ( r ) : - fabs ( r ))); s = c = 1.0 ; p = 0.0 ; for ( int i = m - 1 ; i >= l ; i --) { f = s * subdiagonal [ i ]; b = c * subdiagonal [ i ]; if ( fabs ( f ) > fabs ( g )) { c = g / f ; r = sqrt ( SQUARE ( c ) + 1.0 ); subdiagonal [ i + 1 ] = f * r ; c *= ( s = 1.0 / r ); } else { s = f / g ; r = sqrt ( SQUARE ( s ) + 1.0 ); subdiagonal [ i + 1 ] = g * r ; s *= ( c = 1.0 / r ); } g = eigenvalues [ i + 1 ] - p ; r = ( eigenvalues [ i ] - g ) * s + 2.0 * c * b ; p = s * r ; eigenvalues [ i + 1 ] = g + p ; g = c * r - b ; for ( int k = 0 ; k < size ; k ++) { t = eigenvectors [ k ][ i + 1 ]; eigenvectors [ k ][ i + 1 ] = s * eigenvectors [ k ][ i ] + c * t ; eigenvectors [ k ][ i ] = c * eigenvectors [ k ][ i ] - s * t ; } } eigenvalues [ l ] -= p ; subdiagonal [ l ] = g ; subdiagonal [ m ] = 0.0 ; } } return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "#define SQUARE(x)((x)*(x))36staticvoidtridiagonalize_symmetric_3x3(doublematrix[3][3],doubleeigenvectors[3][3],doublediagonal[3],doublesubdiagonal[2]){constintsize=3;doublehouseholder_vector[size],temp_vector[size];doubleomega,scale,sigma,tau;// Initialize eigenvectors to the identity matrixfor(inti=0;i<size;i++){eigenvectors[i][i]=1.0;for(intj=0;j<i;j++)eigenvectors[i][j]=eigenvectors[j][i]=0.0;}// Compute the first Householder reflectionscale=SQUARE(matrix[0][1])+SQUARE(matrix[0][2]);sigma=(matrix[0][1]>0)?-sqrt(scale):sqrt(scale);subdiagonal[0]=sigma;tau=sigma*matrix[0][1];householder_vector[1]=matrix[0][1]-sigma;householder_vector[2]=matrix[0][2];omega=scale-tau;if(omega>0.0){omega=1.0/omega;sigma=0.0;for(inti=1;i<size;i++){tau=matrix[1][i]*householder_vector[1]+matrix[i][2]*householder_vector[2];temp_vector[i]=omega*tau;sigma+=householder_vector[i]*tau;}sigma*=0.5*SQUARE(omega);for(inti=1;i<size;i++)temp_vector[i]-=sigma*householder_vector[i];diagonal[0]=matrix[0][0];diagonal[1]=matrix[1][1]-2.0*temp_vector[1]*householder_vector[1];diagonal[2]=matrix[2][2]-2.0*temp_vector[2]*householder_vector[2];for(intj=1;j<size;j++){tau=omega*householder_vector[j];for(inti=1;i<size;i++)eigenvectors[i][j]-=tau*householder_vector[i];}subdiagonal[1]=matrix[1][2]-temp_vector[1]*householder_vector[2]-householder_vector[1]*temp_vector[2];}else{for(inti=0;i<size;i++)diagonal[i]=matrix[i][i];subdiagonal[1]=matrix[1][2];}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doublematrix[3][3]={{1.0,0.5,0.3},{0.5,2.0,0.1},{0.3,0.1,3.0}};doubleeigenvectors[3][3];doubleeigenvalues[3];intresult=compute_eigensystem_symmetric_3x3(matrix,eigenvectors,eigenvalues);if(result==0){// Computation successful}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/eigen_decomposition.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "staticintcompute_eigensystem_symmetric_3x3(doublematrix[3][3],doubleeigenvectors[3][3],doubleeigenvalues[3]){constintsize=3;constintmax_iterations=30;doublesubdiagonal[3];doubleg,r,p,f,b,s,c,t;intiteration_count;intm;// Check for diagonal matrix with unit entriesif(SQUARE(matrix[0][1])<1e-15&&SQUARE(matrix[0][2])<1e-15&&SQUARE(matrix[1][2])<1e-15){for(inti=0;i<size;i++){for(intj=0;j<size;j++){eigenvectors[i][j]=(i==j)?1.0:0.0;}eigenvalues[i]=matrix[i][i];}return0;}tridiagonalize_symmetric_3x3(matrix,eigenvectors,eigenvalues,subdiagonal);for(intl=0;l<size-1;l++){iteration_count=0;while(1){for(m=l;m<=size-2;m++){g=fabs(eigenvalues[m])+fabs(eigenvalues[m+1]);if(fabs(subdiagonal[m])+g==g)break;}if(m==l)break;if(iteration_count++>=max_iterations)return-1;g=(eigenvalues[l+1]-eigenvalues[l])/(2.0*subdiagonal[l]);r=sqrt(SQUARE(g)+1.0);g=eigenvalues[m]-eigenvalues[l]+subdiagonal[l]/(g+(g>0?fabs(r):-fabs(r)));s=c=1.0;p=0.0;for(inti=m-1;i>=l;i--){f=s*subdiagonal[i];b=c*subdiagonal[i];if(fabs(f)>fabs(g)){c=g/f;r=sqrt(SQUARE(c)+1.0);subdiagonal[i+1]=f*r;c*=(s=1.0/r);}else{s=f/g;r=sqrt(SQUARE(s)+1.0);subdiagonal[i+1]=g*r;s*=(c=1.0/r);}g=eigenvalues[i+1]-p;r=(eigenvalues[i]-g)*s+2.0*c*b;p=s*r;eigenvalues[i+1]=g+p;g=c*r-b;for(intk=0;k<size;k++){t=eigenvectors[k][i+1];eigenvectors[k][i+1]=s*eigenvectors[k][i]+c*t;eigenvectors[k][i]=c*eigenvectors[k][i]-s*t;}}eigenvalues[l]-=p;subdiagonal[l]=g;subdiagonal[m]=0.0;}}return0;}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/eigen_decomposition.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "src-local/two-phaseVE.h See raw file Modification by Vatsal Sanjay Version 2.0, Oct 17, 2024 Changelog Oct 17, 2024: added support for VE simulations. Brief history v1.0 is the vanilla Basilisk code for two-phase flows: http://basilisk.fr/src/two-phase.h + http://basilisk.fr/src/two-phase-generic.h v2.0 is the modification for viscoelastic fluids using the log-conformation method. Two-phase interfacial flows This is a modified version of two-phase.h . It contains the implementation of Viscoplastic Fluid (Bingham Fluid). This file helps setup simulations for flows of two fluids separated by an interface (i.e. immiscible fluids). It is typically used in combination with a Navier\u2013Stokes solver . The interface between the fluids is tracked with a Volume-Of-Fluid method. The volume fraction in fluid 1 is \\(f=1\\) and \\(f=0\\) in fluid 2.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Code",
    "content": "The densities and dynamic viscosities for fluid 1 and 2 are rho1 , mu1 , rho2 , mu2 , respectively. #include \"vof.h\" scalar f [], * interfaces = { f }; double rho1 = 1. , mu1 = 0. , rho2 = 1. , mu2 = 0. ; double G1 = 0. , G2 = 0. ; // elastic moduli double lambda1 = 0. , lambda2 = 0. ; // relaxation times double TOLelastic = 1e-2 ; // tolerance for elastic modulus #TOFIX: this must always be a very small number. Auxilliary fields are necessary to define the (variable) specific volume \\(\\alpha=1/\\rho\\) as well as the cell-centered density. face vector alphav []; scalar rhov []; scalar Gpd []; scalar lambdapd []; event defaults ( i = 0 ) { alpha = alphav ; rho = rhov ; Gp = Gpd ; lambda = lambdapd ; If the viscosity is non-zero, we need to allocate the face-centered viscosity field. mu = new face vector ; } The density and viscosity are defined using arithmetic averages by default.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Definitions - Python Function",
    "content": "The user can overload these definitions to use other types of averages (i.e. harmonic). #ifndef rho # define rho ( f ) ( clamp ( f , 0. , 1. )*( rho1 - rho2 ) + rho2 ) 62 #endif #ifndef mu // for Arithmetic mean, use this # define mu ( f ) ( clamp ( f , 0. , 1. )*( mu1 - mu2 ) + mu2 ) 66 #endif We have the option of using some \u201csmearing\u201d of the density/viscosity jump. #ifdef FILTERED scalar sf []; #else # define sf f 76 #endif event tracer_advection ( i ++) { When using smearing of the density jump, we initialise sf with the vertex-average of f . #ifndef sf #if dimension <= foreach () sf [] = ( 4. * f [] + 2. *( f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 1 , 0 ] + f [- 1 , 0 ]) + f [- 1 ,- 1 ] + f [ 1 ,- 1 ] + f [ 1 , 1 ] + f [- 1 , 1 ])/ 16. ; #else // dimension == foreach () sf [] = ( 8. * f [] + 4. *( f [- 1 ] + f [ 1 ] + f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 0 , 0 , 1 ] + f [ 0 , 0 ,- 1 ]) + 2. *( f [- 1 , 1 ] + f [- 1 , 0 , 1 ] + f [- 1 , 0 ,- 1 ] + f [- 1 ,- 1 ] + f [ 0 , 1 , 1 ] + f [ 0 , 1 ,- 1 ] + f [ 0 ,- 1 , 1 ] + f [ 0 ,- 1 ,- 1 ] + f [ 1 , 1 ] + f [ 1 , 0 , 1 ] + f [ 1 ,- 1 ] + f [ 1 , 0 ,- 1 ]) + f [ 1 ,- 1 , 1 ] + f [- 1 , 1 , 1 ] + f [- 1 , 1 ,- 1 ] + f [ 1 , 1 , 1 ] + f [ 1 , 1 ,- 1 ] + f [- 1 ,- 1 ,- 1 ] + f [ 1 ,- 1 ,- 1 ] + f [- 1 ,- 1 , 1 ])/ 64. ; #endif #endif #if TREE sf . prolongation = refine_bilinear ; sf . dirty = true ; // boundary conditions need to be updated #endif } event properties ( i ++) { foreach_face () { double ff = ( sf [] + sf [- 1 ])/ 2. ; alphav . x [] = fm . x []/ rho ( ff ); face vector muv = mu ; muv . x [] = fm . x []* mu ( ff ); } foreach (){ rhov [] = cm []* rho ( sf []); Gpd [] = 0. ; lambdapd [] = 0. ; if ( clamp ( sf [], 0. , 1. ) > TOLelastic ){ Gpd [] += G1 * clamp ( sf [], 0. , 1. ); lambdapd [] += lambda1 * clamp ( sf [], 0. , 1. ); } if ( clamp (( 1 - sf []), 0. , 1. ) > TOLelastic ){ Gpd [] += G2 * clamp (( 1 - sf []), 0. , 1. ); lambdapd [] += lambda2 * clamp (( 1 - sf []), 0. , 1. ); } } #if TREE sf . prolongation = fraction_refine ; sf . dirty = true ; // boundary conditions need to be updated #endif }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"vof.h\"scalar f[],*interfaces={f};doublerho1=1.,mu1=0.,rho2=1.,mu2=0.;doubleG1=0.,G2=0.;// elastic modulidoublelambda1=0.,lambda2=0.;// relaxation timesdoubleTOLelastic=1e-2;// tolerance for elastic modulus #TOFIX: this must always be a very small number.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "face vector alphav[];scalar rhov[];scalar Gpd[];scalar lambdapd[];event defaults(i=0){alpha=alphav;rho=rhov;Gp=Gpd;lambda=lambdapd;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Function: rho",
    "content": "#ifndef rho# define rho(f)(clamp(f,0.,1.)*(rho1-rho2)+rho2)62#endif#ifndef mu// for Arithmetic mean, use this# define mu(f)(clamp(f,0.,1.)*(mu1-mu2)+mu2)66#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Function: FILTEREDscalar",
    "content": "#ifdef FILTEREDscalar sf[];#else# define sf f76#endifevent tracer_advection(i++){",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Function: sf",
    "content": "#ifndef sf#if dimension <=foreach()sf[]=(4.*f[]+2.*(f[0,1]+f[0,-1]+f[1,0]+f[-1,0])+f[-1,-1]+f[1,-1]+f[1,1]+f[-1,1])/16.;#else// dimension ==foreach()sf[]=(8.*f[]+4.*(f[-1]+f[1]+f[0,1]+f[0,-1]+f[0,0,1]+f[0,0,-1])+2.*(f[-1,1]+f[-1,0,1]+f[-1,0,-1]+f[-1,-1]+f[0,1,1]+f[0,1,-1]+f[0,-1,1]+f[0,-1,-1]+f[1,1]+f[1,0,1]+f[1,-1]+f[1,0,-1])+f[1,-1,1]+f[-1,1,1]+f[-1,1,-1]+f[1,1,1]+f[1,1,-1]+f[-1,-1,-1]+f[1,-1,-1]+f[-1,-1,1])/64.;#endif#endif#if TREEsf.prolongation=refine_bilinear;sf.dirty=true;// boundary conditions need to be updated#endif}event properties(i++){foreach_face(){doubleff=(sf[]+sf[-1])/2.;alphav.x[]=fm.x[]/rho(ff);face vector muv=mu;muv.x[]=fm.x[]*mu(ff);}foreach(){rhov[]=cm[]*rho(sf[]);Gpd[]=0.;lambdapd[]=0.;if(clamp(sf[],0.,1.)>TOLelastic){Gpd[]+=G1*clamp(sf[],0.,1.);lambdapd[]+=lambda1*clamp(sf[],0.,1.);}if(clamp((1-sf[]),0.,1.)>TOLelastic){Gpd[]+=G2*clamp((1-sf[]),0.,1.);lambdapd[]+=lambda2*clamp((1-sf[]),0.,1.);}}#if TREEsf.prolongation=fraction_refine;sf.dirty=true;// boundary conditions need to be updated#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "src-local/log-conform-viscoelastic-scalar-3D.h See raw file Log-Conformation Method for 3D Viscoelastic Fluids Overview Title : log-conform-viscoelastic-3D.h Version : 2.6 Description : Implementation of the log-conformation method for viscoelastic fluids in 3D Key Features Conformation tensor A exists across the domain and relaxes according to \u03bb Stress acts according to elastic modulus G 3D implementation extending log-conform-viscoelastic-scalar-2D.h Eigenvalue clamping for numerical stability Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Mar 16, 2025 Dependencies bcg.h: Bell-Collela-Glaz scheme for advection eigen_decomposition.h: For 3D eigenvalue computation navier-stokes/centered.h: For base flow solver References Fattal & Kupferman (2004, 2005): Original log-conformation method Comminal et al. (2015): Constitutive model functions Hao & Pan (2007): Split scheme implementation Version History v1.0 (Oct 19, 2024) Initial 3D implementation Scalar implementation approach v1.1 (Oct 20, 2024) Added negative eigenvalue detection Added error reporting system v2.0 (Oct 29, 2024) Major matrix algebra corrections for 3D Optimized tensor calculations Improved code structure and documentation v2.1 (Oct 29, 2024) Added initialization functions for tensor structures v2.2 (Nov 3, 2024) Refactored tensor operations Improved code maintainability Enhanced tensor manipulation consistency v2.3 (Nov 14, 2024) Added infinite Deborah number support v2.5 (Nov 23, 2024) Documentation improvements Added mathematical explanations v2.6 (Mar 16, 2025) Implemented eigenvalue clamping system Added minimum eigenvalue threshold (EIGENVALUE_MIN = 1e-8) Improved numerical stability handling Added diagnostic capabilities Fixed 3D velocity gradient calculation Implementation Notes The code extends the standard Basilisk log-conformation implementation Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling with polymeric stress Includes both 2D and 3D implementations Uses atomic operations for thread-safe diagnostics Future Work Axisymmetric Compatibility Currently not implemented Use log-conform-viscoelastic-scalar-2D.h for axi cases Or use log-conform-viscoelastic.h for better efficiency Metric Terms Improvements Enforce tensor compatibility using foreach_dimension Complete metric terms (cm, fm) implementation #if AXI #error \"axi compatibility is not there.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Introduction",
    "content": "To keep the code easy to read, we will not implement axi compatibility just yet.\" #endif The log-conformation method for some viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Function Definition",
    "content": "Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function. The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: In the case...",
    "content": "In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models. Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This instability poses...",
    "content": "This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) . /* TODO : - Perhaps, instead of the Bell--Collela--Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to [http://basilisk.fr/src/navier-stokes/conserving.h](http://basilisk.fr/src/navier-stokes/conserving.h) */ #define EIGENVALUE_MIN 1e-8 220 #ifdef DEBUG_EIGENVALUES static int eigenvalue_corrections = 0 ; #endif #include \"bcg.h\" ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time /* conformation tensor */ // diagonal elements scalar A11 [], A22 [], A33 []; // off-diagonal elements scalar A12 [], A13 [], A23 []; /* stress tensor */ // diagonal elements scalar T11 [], T22 [], T33 []; // off-diagonal elements scalar T12 [], T13 [], T23 []; event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; /* initialize A and T */ for ( scalar s in { A11 , A22 , A33 }) { foreach () { s [] = 1. ; } } for ( scalar s in { T11 , T12 , T13 , T22 , T23 , T33 , A12 , A13 , A23 }) { foreach (){ s [] = 0. ; } } for ( scalar s in { A11 , A22 , A33 , T11 , T22 , T33 , A12 , A13 , A23 , T12 , T13 , T23 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } if ( s . boundary [ top ] != periodic_bc ) { s [ top ] = neumann ( 0 ); s [ bottom ] = neumann ( 0 ); } #if dimension == if ( s . boundary [ front ] != periodic_bc ) { s [ front ] = neumann ( 0 ); s [ back ] = neumann ( 0 ); } #endif } } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. #if dimension == typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } #endif /* Now this is the 3D implementation. */ #if dimension == #include \"eigen_decomposition.h\" typedef struct { double x , y , z ; } pseudo_v3d ; typedef struct { pseudo_v3d x , y , z ; } pseudo_t3d ; // Function to initialize pseudo_v3d static inline void init_pseudo_v3d ( pseudo_v3d * v , double value ) { v -> x = value ; v -> y = value ; v -> z = value ; } // Function to initialize pseudo_t3d static inline void init_pseudo_t3d ( pseudo_t3d * t , double value ) { init_pseudo_v3d (& t -> x , value ); init_pseudo_v3d (& t -> y , value ); init_pseudo_v3d (& t -> z , value ); } static void diagonalization_3D ( pseudo_v3d * Lambda , pseudo_t3d * R , pseudo_t3d * A ) { // Check if the matrix is already diagonal if ( sq ( A -> x . y ) + sq ( A -> x . z ) + sq ( A -> y . z ) < 1e-15 ) { R -> x . x = R -> y . y = R -> z . z = 1. ; R -> y . x = R -> x . y = R -> z . x = R -> x . z = R -> z . y = R -> y . z = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; Lambda -> z = A -> z . z ; return ; } // Compute eigenvalues using the eigen_decomposition function double matrix [ 3 ][ 3 ] = { { A -> x . x , A -> x . y , A -> x . z }, { A -> y . x , A -> y . y , A -> y . z }, { A -> z . x , A -> z . y , A -> z . z } }; double eigenvectors [ 3 ][ 3 ]; double eigenvalues [ 3 ]; compute_eigensystem_symmetric_3x3 ( matrix , eigenvectors , eigenvalues ); // Store eigenvalues and eigenvectors Lambda -> x = eigenvalues [ 0 ]; Lambda -> y = eigenvalues [ 1 ]; Lambda -> z = eigenvalues [ 2 ]; R -> x . x = eigenvectors [ 0 ][ 0 ]; R -> x . y = eigenvectors [ 0 ][ 1 ]; R -> x . z = eigenvectors [ 0 ][ 2 ]; R -> y . x = eigenvectors [ 1 ][ 0 ]; R -> y . y = eigenvectors [ 1 ][ 1 ]; R -> y . z = eigenvectors [ 1 ][ 2 ]; R -> z . x = eigenvectors [ 2 ][ 0 ]; R -> z . y = eigenvectors [ 2 ][ 1 ]; R -> z . z = eigenvectors [ 2 ][ 2 ]; } #endif The stress tensor depends on previous instants and has to be integrated in time.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: In the log-conformation...",
    "content": "In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) . We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ). In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] #if dimension == Advances the log-conformation tensor and updates the corresponding conformation and stress tensors.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Function Definition",
    "content": "This event function performs three primary steps within the viscoelastic fluid simulation: - Diagonalizes the conformation tensor and computes its logarithm (\u03a8) while applying eigenvalue clamping to ensure numerical stability. - Advances \u03a8 in time by incorporating the upper convective term computed from the velocity gradient, which is used to update the log-conformation tensor. - Recovers the physical conformation tensor and stress tensor by exponentiating the diagonalized eigenvalues and integrating the relaxation term.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Note: Although the...",
    "content": "Note: Although the overall simulation targets 3D viscoelastic fluids, this implementation uses a 2D diagonalization routine. event tracer_advection ( i ++) { scalar Psi11 = A11 ; scalar Psi12 = A12 ; scalar Psi22 = A22 ; Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A = {{ A11 [], A12 []}, { A12 [], A22 []}}; The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); pseudo_t R ; init_pseudo_t (& R , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This prevents numerical...",
    "content": "This prevents numerical instabilities while maintaining physical meaning. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"WARNING: Negative eigenvalue detected at ( %g , %g ): [ %g , %g ] \\n \" , x , y , Lambda . x , Lambda . y ); #ifdef DEBUG_EIGENVALUES atomic_increment (& eigenvalue_corrections ); #endif Lambda . x = max ( Lambda . x , EIGENVALUE_MIN ); Lambda . y = max ( Lambda . y , EIGENVALUE_MIN ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) . Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); Psi22 [] = sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . x )* log ( Lambda . x ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The diagonalization will...",
    "content": "The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis. Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: R is the eigenvector matrix of the conformation tensor M is the velocity gradient tensor in the eigenvector basis The construction ensures B is symmetric and traceless pseudo_t B ; init_pseudo_t (& B , 0.0 ); double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; init_pseudo_t (& M , 0.0 ); foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi12 []; Psi12 [] += dt * ( 2. * B . x . y + OM * ( Psi22 [] - Psi11 [])); s *= - 1 ; Psi11 [] += dt * 2. * ( B . x . x + s * OM ); s *= - 1 ; Psi22 [] += dt * 2. * ( B . y . y + s * OM ); } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . advection ({ Psi11 , Psi12 , Psi22 }, uf , dt ); Convert back to Aij foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi11 [], Psi12 []}, { Psi12 [], Psi22 []}}, R ; init_pseudo_t (& R , 0.0 ); pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . A12 [] = A . x . y ; T12 [] = Gp []* A . x . y ; A11 [] = A . x . x ; T11 [] = Gp []*( A . x . x - 1. ); A22 [] = A . y . y ; T22 [] = Gp []*( A . y . y - 1. ); } } #elif dimension == Advances the log-conformation tensor and computes the corresponding conformation and stress tensors for 3D viscoelastic fluid simulations. This event function performs a two-step update for the viscoelastic fluid model using the log-conformation method.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: In the first...",
    "content": "In the first part, it computes the logarithm of the conformation tensor \\(\\Psi\\) from A by: - Diagonalizing A to obtain eigenvalues ( \\(\\Lambda\\) ) and eigenvectors (R). - Clamping any negative eigenvalues to prevent numerical instabilities (using EIGENVALUE_MIN). - Evaluating \\(\\Psi = \\log(A)\\) and incorporating the upper convective contribution via the symmetric tensor B and the skew-symmetric tensor \\(\\Omega\\) . \\(\\Psi\\) is then advanced in time using central difference approximations for the velocity gradients, where degenerate eigenvalue cases are handled with simplified calculations. In the second part, the function converts the updated log-conformation tensor back to the conformation tensor A by exponentiating the eigenvalues and applies the relaxation factor derived from the relaxation time. Finally, it computes the polymeric stress tensor T from A.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Warnings are printed...",
    "content": "Warnings are printed if negative eigenvalues are detected, and a debug counter is incremented when debugging is enabled. event tracer_advection ( i ++) { Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term // start by declaring the scalar variables that will store the components of $\\Psi$ scalar Psi11 = A11 , Psi12 = A12 , Psi13 = A13 , Psi22 = A22 , Psi23 = A23 , Psi33 = A33 ; foreach () { pseudo_t3d A , R ; init_pseudo_t3d (& R , 0.0 ); pseudo_v3d Lambda ; init_pseudo_v3d (& Lambda , 0.0 ); A . x . x = A11 []; A . x . y = A12 []; A . x . z = A13 []; A . y . x = A12 []; A . y . y = A22 []; A . y . z = A23 []; A . z . x = A13 []; A . z . y = A23 []; A . z . z = A33 []; // Diagonalize the conformation tensor A to obtain the eigenvalues Lambda and eigenvectors R diagonalization_3D (& Lambda , & R , & A ); /* Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This prevents numerical...",
    "content": "This prevents numerical instabilities while maintaining physical meaning. */ if ( Lambda . x <= 0. || Lambda . y <= 0. || Lambda . z <= 0. ) { fprintf ( ferr , \"WARNING: Negative eigenvalue detected at ( %g , %g , %g ): [ %g , %g , %g ] \\n \" , x , y , z , Lambda . x , Lambda . y , Lambda . z ); #ifdef DEBUG_EIGENVALUES atomic_increment (& eigenvalue_corrections ); #endif Lambda . x = max ( Lambda . x , EIGENVALUE_MIN ); Lambda . y = max ( Lambda . y , EIGENVALUE_MIN ); Lambda . z = max ( Lambda . z , EIGENVALUE_MIN ); } // Compute Psi = log(A) = R * log(Lambda) * R^T Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ) + sq ( R . x . z )* log ( Lambda . z ); Psi22 [] = sq ( R . y . x )* log ( Lambda . x ) + sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . z )* log ( Lambda . z ); Psi33 [] = sq ( R . z . x )* log ( Lambda . x ) + sq ( R . z . y )* log ( Lambda . y ) + sq ( R . z . z )* log ( Lambda . z ); Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . x . y * R . y . y * log ( Lambda . y ) + R . x . z * R . y . z * log ( Lambda . z ); Psi13 [] = R . x . x * R . z . x * log ( Lambda . x ) + R . x . y * R . z . y * log ( Lambda . y ) + R . x . z * R . z . z * log ( Lambda . z ); Psi23 [] = R . y . x * R . z . x * log ( Lambda . x ) + R . y . y * R . z . y * log ( Lambda . y ) + R . y . z * R . z . z * log ( Lambda . z ); // Compute B and Omega tensors (3D version) pseudo_t3d B , M , Omega ; init_pseudo_t3d (& B , 0.0 ); init_pseudo_t3d (& M , 0.0 ); init_pseudo_t3d (& Omega , 0.0 ); // Check if any pair of eigenvalues are numerically equal (within a small tolerance) if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 || fabs ( Lambda . y - Lambda . z ) <= 1e-20 || fabs ( Lambda . z - Lambda . x ) <= 1e-20 ) { // In case of equal eigenvalues, the calculations for B and Omega simplify significantly // B is grad U and Omega is zero. // Compute off-diagonal elements of B using central differences // These represent the symmetric part of the velocity gradient tensor B . x . y = ( u . y [ 1 , 0 , 0 ] - u . y [- 1 , 0 , 0 ] + u . x [ 0 , 1 , 0 ] - u . x [ 0 ,- 1 , 0 ])/( 4. * Delta ); // (dv/dx + du/dy)/2 B . x . z = ( u . z [ 1 , 0 , 0 ] - u . z [- 1 , 0 , 0 ] + u . x [ 0 , 0 , 1 ] - u . x [ 0 , 0 ,- 1 ])/( 4. * Delta ); // (dw/dx + du/dz)/2 B . y . z = ( u . z [ 0 , 1 , 0 ] - u . z [ 0 ,- 1 , 0 ] + u . y [ 0 , 0 , 1 ] - u . y [ 0 , 0 ,- 1 ])/( 4. * Delta ); // (dw/dy + dv/dz)/2 // Compute diagonal elements of B // These represent the normal strain rates B . x . x = ( u . x [ 1 , 0 , 0 ] - u . x [- 1 , 0 , 0 ])/( 2. * Delta ); // du/dx B . y . y = ( u . y [ 0 , 1 , 0 ] - u . y [ 0 ,- 1 , 0 ])/( 2. * Delta ); // dv/dy B . z . z = ( u . z [ 0 , 0 , 1 ] - u . z [ 0 , 0 ,- 1 ])/( 2. * Delta ); // dw/dz // Set all components of Omega to zero // This is because Omega represents the antisymmetric part of the velocity gradient tensor, // which vanishes when eigenvalues are equal Omega . x . y = Omega . x . z = Omega . y . z = Omega . y . x = Omega . z . x = Omega . z . y = 0. ; } else { /* ### Compute the velocity gradient tensor components using central differences - These represent the spatial derivatives of each velocity component - These gradients form the velocity gradient tensor (nablaU): [ dudx dudy dudz ] [ dvdx dvdy dvdz ] [ dwdx dwdy dwdz ] */ // Derivatives of u (x-component of velocity) double dudx = ( u . x [ 1 , 0 , 0 ] - u . x [- 1 , 0 , 0 ])/( 2.0 * Delta ); // du/dx double dudy = ( u . x [ 0 , 1 , 0 ] - u . x [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // du/dy double dudz = ( u . x [ 0 , 0 , 1 ] - u . x [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // du/dz // Derivatives of v (y-component of velocity) double dvdx = ( u . y [ 1 , 0 , 0 ] - u . y [- 1 , 0 , 0 ])/( 2.0 * Delta ); // dv/dx double dvdy = ( u . y [ 0 , 1 , 0 ] - u . y [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // dv/dy double dvdz = ( u . y [ 0 , 0 , 1 ] - u . y [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // dv/dz // Derivatives of w (z-component of velocity) double dwdx = ( u . z [ 1 , 0 , 0 ] - u . z [- 1 , 0 , 0 ])/( 2.0 * Delta ); // dw/dx double dwdy = ( u . z [ 0 , 1 , 0 ] - u . z [ 0 ,- 1 , 0 ])/( 2.0 * Delta ); // dw/dy double dwdz = ( u . z [ 0 , 0 , 1 ] - u . z [ 0 , 0 ,- 1 ])/( 2.0 * Delta ); // dw/dz /* Calculate the M tensor through matrix multiplication: M = R * (nablaU)^T R^T.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This represents the...",
    "content": "This represents the velocity gradient tensor transformed to the eigenvector basis of the conformation tensor. * Steps: 1. Compute intermediate products (R * nablaU^T): - Store row-wise products in Rx_gradU_*, Ry_gradU_*, Rz_gradU_* - Each variable represents one row of the intermediate matrix 2.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Multiply by R^T...",
    "content": "Multiply by R^T to obtain the final M tensor: - M.i.j represents the (i,j) component of the transformed velocity gradient - This transformation expresses the velocity gradient in the eigenvector basis - The resulting M tensor is used to compute Omega (\u03a9) and B tensors, such that */ // First, compute intermediate products of R and (nablaU)^T double Rx_gradU_x = R . x . x * dudx + R . x . y * dvdx + R . x . z * dwdx ; double Rx_gradU_y = R . x . x * dudy + R . x . y * dvdy + R . x . z * dwdy ; double Rx_gradU_z = R . x . x * dudz + R . x . y * dvdz + R . x . z * dwdz ; double Ry_gradU_x = R . y . x * dudx + R . y . y * dvdx + R . y . z * dwdx ; double Ry_gradU_y = R . y . x * dudy + R . y . y * dvdy + R . y . z * dwdy ; double Ry_gradU_z = R . y . x * dudz + R . y . y * dvdz + R . y . z * dwdz ; double Rz_gradU_x = R . z . x * dudx + R . z . y * dvdx + R . z . z * dwdx ; double Rz_gradU_y = R . z . x * dudy + R . z . y * dvdy + R . z . z * dwdy ; double Rz_gradU_z = R . z . x * dudz + R . z . y * dvdz + R . z . z * dwdz ; // Now compute M components by multiplying the intermediate products with R^T M . x . x = R . x . x * Rx_gradU_x + R . x . y * Rx_gradU_y + R . x . z * Rx_gradU_z ; M . x . y = R . x . x * Ry_gradU_x + R . x . y * Ry_gradU_y + R . x . z * Ry_gradU_z ; M . x . z = R . x . x * Rz_gradU_x + R . x . y * Rz_gradU_y + R . x . z * Rz_gradU_z ; M . y . x = R . y . x * Rx_gradU_x + R . y . y * Rx_gradU_y + R . y . z * Rx_gradU_z ; M . y . y = R . y . x * Ry_gradU_x + R . y . y * Ry_gradU_y + R . y . z * Ry_gradU_z ; M . y . z = R . y . x * Rz_gradU_x + R . y . y * Rz_gradU_y + R . y . z * Rz_gradU_z ; M . z . x = R . z . x * Rx_gradU_x + R . z . y * Rx_gradU_y + R . z . z * Rx_gradU_z ; M . z . y = R . z . x * Ry_gradU_x + R . z . y * Ry_gradU_y + R . z . z * Ry_gradU_z ; M . z . z = R . z . x * Rz_gradU_x + R . z . y * Rz_gradU_y + R . z . z * Rz_gradU_z ; // Compute the off-diagonal elements of the Omega tensor in the eigenvector basis double omega_xy = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); double omega_xz = ( Lambda . z * M . x . z + Lambda . x * M . z . x )/( Lambda . z - Lambda . x ); double omega_yz = ( Lambda . z * M . y . z + Lambda . y * M . z . y )/( Lambda . z - Lambda . y ); // Calculate intermediate rotation combinations for each direction // x-direction rotation combinations double rot_x_xy_yz = ( R . x . x * omega_xy - R . x . z * omega_yz ); // xy rotation minus yz rotation, x components double rot_x_xy_xz = ( R . x . y * omega_xy + R . x . z * omega_xz ); // xy rotation plus xz rotation, x components double rot_x_xz_yz = ( R . x . x * omega_xz + R . x . y * omega_yz ); // xz rotation plus yz rotation, x components // y-direction rotation combinations double rot_y_xy_yz = ( R . y . x * omega_xy - R . y . z * omega_yz ); // xy rotation minus yz rotation, y components double rot_y_xy_xz = ( R . y . y * omega_xy + R . y . z * omega_xz ); // xy rotation plus xz rotation, y components double rot_y_xz_yz = ( R . y . x * omega_xz + R . y . y * omega_yz ); // xz rotation plus yz rotation, y components // z-direction rotation combinations double rot_z_xy_yz = ( R . z . x * omega_xy - R . z . z * omega_yz ); // xy rotation minus yz rotation, z components double rot_z_xy_xz = ( R . z . y * omega_xy + R . z . z * omega_xz ); // xy rotation plus xz rotation, z components double rot_z_xz_yz = ( R . z . x * omega_xz + R . z . y * omega_yz ); // xz rotation plus yz rotation, z components Calculate the components of the Omega tensor in the physical coordinate system The Omega tensor represents the rotational part of the velocity gradient tensor and is computed through the following steps: We already have: R: eigenvector matrix of the conformation tensor rot_*_*_*: pre-computed rotation combinations for each direction Mathematical background: Omega = R * Omega_eigen * R^T where Omega_eigen is the rotation tensor in eigenvector space The components are calculated using the rotation combinations: rot_i_jk_lm represents combined rotations in the i-direction Each component Omega_ij is a linear combination of these rotations // Compute x-row components of Omega Omega . x . x = R . x . y * rot_x_xy_yz // xy-yz rotation contribution - R . x . x * rot_x_xy_xz // xy-xz rotation contribution + R . x . z * rot_x_xz_yz ; // xz-yz rotation contribution Omega . x . y = R . y . y * rot_x_xy_yz // xy-yz rotation mapped to y-direction - R . y . x * rot_x_xy_xz // xy-xz rotation mapped to y-direction + R . y . z * rot_x_xz_yz ; // xz-yz rotation mapped to y-direction Omega . x . z = R . z . y * rot_x_xy_yz // xy-yz rotation mapped to z-direction - R . z . x * rot_x_xy_xz // xy-xz rotation mapped to z-direction + R . z . z * rot_x_xz_yz ; // xz-yz rotation mapped to z-direction // Compute y-row components using similar pattern Omega . y . x = R . x . y * rot_y_xy_yz - R . x . x * rot_y_xy_xz + R . x . z * rot_y_xz_yz ; Omega . y . y = R . y . y * rot_y_xy_yz - R . y . x * rot_y_xy_xz + R . y . z * rot_y_xz_yz ; Omega . y . z = R . z . y * rot_y_xy_yz - R . z . x * rot_y_xy_xz + R . z . z * rot_y_xz_yz ; // Compute z-row components using similar pattern Omega . z . x = R . x . y * rot_z_xy_yz - R . x . x * rot_z_xy_xz + R . x . z * rot_z_xz_yz ; Omega . z . y = R . y . y * rot_z_xy_yz - R . y . x * rot_z_xy_xz + R . y . z * rot_z_xz_yz ; Omega . z . z = R . z . y * rot_z_xy_yz - R . z . x * rot_z_xy_xz + R . z . z * rot_z_xz_yz ; Note: The resulting Omega tensor is skew-symmetric, meaning: - Omega_ij = -Omega_ji This property is automatically satisfied by the construction above and is essential for preserving the physical meaning of rotation // Extract diagonal components of M (velocity gradient tensor in eigenvector basis) double M_diag_x = M . x . x , M_diag_y = M . y . y , M_diag_z = M . z . z ; Compute B tensor: B = R * diag(M) * R^T - This transforms the diagonal velocity gradient tensor back to the original coordinate system - B is symmetric, so we only need to compute the upper triangle // Compute diagonal elements of B B . x . x = M_diag_x * sq ( R . x . x ) + M_diag_y * sq ( R . x . y ) + M_diag_z * sq ( R . x . z ); B . y . y = M_diag_x * sq ( R . y . x ) + M_diag_y * sq ( R . y . y ) + M_diag_z * sq ( R . y . z ); B . z . z = M_diag_x * sq ( R . z . x ) + M_diag_y * sq ( R . z . y ) + M_diag_z * sq ( R . z . z ); // Compute off-diagonal elements of B (upper triangle) B . x . y = M_diag_x * R . x . x * R . y . x + M_diag_y * R . x . y * R . y . y + M_diag_z * R . x . z * R . y . z ; B . x . z = M_diag_x * R . x . x * R . z . x + M_diag_y * R . x . y * R . z . y + M_diag_z * R . x . z * R . z . z ; B . y . z = M_diag_x * R . y . x * R . z . x + M_diag_y * R . y . y * R . z . y + M_diag_z * R . y . z * R . z . z ; // Fill in lower triangle using symmetry of B B . y . x = B . x . y ; B . z . x = B . x . z ; B . z . y = B . y . z ; } We now advance \\(\\Psi\\) in time, adding the upper convective contribution.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This step 1:...",
    "content": "This step 1: _t = 2 + (-) // save old values of Psi components double old_Psi11 = Psi11 []; double old_Psi22 = Psi22 []; double old_Psi33 = Psi33 []; double old_Psi12 = Psi12 []; double old_Psi13 = Psi13 []; double old_Psi23 = Psi23 []; // Psi11 Psi11 [] += dt * ( 2.0 * B . x . x + Omega . x . y * old_Psi12 - Omega . y . x * old_Psi12 + Omega . x . z * old_Psi13 - Omega . z . x * old_Psi13 ); // Psi22 Psi22 [] += dt * ( 2.0 * B . y . y - Omega . x . y * old_Psi12 + Omega . y . x * old_Psi12 + Omega . y . z * old_Psi23 - Omega . z . y * old_Psi23 ); // Psi33 Psi33 [] += dt * ( 2.0 * B . z . z - Omega . x . z * old_Psi13 + Omega . z . x * old_Psi13 - Omega . y . z * old_Psi23 + Omega . z . y * old_Psi23 ); // Psi12 Psi12 [] += dt * ( 2.0 * B . x . y + Omega . x . x * old_Psi12 - Omega . x . y * old_Psi11 + Omega . x . y * old_Psi22 - Omega . y . y * old_Psi12 + Omega . x . z * old_Psi23 - Omega . z . y * old_Psi13 ); // Psi13 Psi13 [] += dt * ( 2.0 * B . x . z + Omega . x . x * old_Psi13 - Omega . x . z * old_Psi11 + Omega . x . y * old_Psi23 - Omega . y . z * old_Psi12 + Omega . x . z * old_Psi33 - Omega . z . z * old_Psi13 ); // Psi23 Psi23 [] += dt * ( 2.0 * B . y . z + Omega . y . x * old_Psi13 - Omega . x . z * old_Psi12 + Omega . y . y * old_Psi23 - Omega . y . z * old_Psi22 + Omega . y . z * old_Psi33 - Omega . z . z * old_Psi23 ); } // Advection of Psi, which is the log-conformation tensor advection ({ Psi11 , Psi12 , Psi13 , Psi22 , Psi23 , Psi33 }, uf , dt ); Convert back to A and T We now convert the log-conformation tensor Psi back to the conformation tensor A and compute the stress tensor T.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This process involves...",
    "content": "This process involves diagonalization, exponentiation of eigenvalues, and application of the relaxation factor. foreach () { pseudo_t3d A , R ; init_pseudo_t3d (& R , 0.0 ); pseudo_v3d Lambda ; init_pseudo_v3d (& Lambda , 0.0 ); // Reconstruct the log-conformation tensor from its components A . x . x = Psi11 []; A . x . y = Psi12 []; A . x . z = Psi13 []; A . y . x = Psi12 []; A . y . y = Psi22 []; A . y . z = Psi23 []; A . z . x = Psi13 []; A . z . y = Psi23 []; A . z . z = Psi33 []; // Diagonalize A to obtain eigenvalues and eigenvectors diagonalization_3D (& Lambda , & R , & A ); // Exponentiate eigenvalues Lambda . x = exp ( Lambda . x ); Lambda . y = exp ( Lambda . y ); Lambda . z = exp ( Lambda . z ); // Reconstruct A using A = R * diag(Lambda) * R^T A . x . x = Lambda . x * sq ( R . x . x ) + Lambda . y * sq ( R . x . y ) + Lambda . z * sq ( R . x . z ); A . x . y = Lambda . x * R . x . x * R . y . x + Lambda . y * R . x . y * R . y . y + Lambda . z * R . x . z * R . y . z ; A . y . x = A . x . y ; A . x . z = Lambda . x * R . x . x * R . z . x + Lambda . y * R . x . y * R . z . y + Lambda . z * R . x . z * R . z . z ; A . z . x = A . x . z ; A . y . y = Lambda . x * sq ( R . y . x ) + Lambda . y * sq ( R . y . y ) + Lambda . z * sq ( R . y . z ); A . y . z = Lambda . x * R . y . x * R . z . x + Lambda . y * R . y . y * R . z . y + Lambda . z * R . y . z * R . z . z ; A . z . y = A . y . z ; A . z . z = Lambda . x * sq ( R . z . x ) + Lambda . y * sq ( R . z . y ) + Lambda . z * sq ( R . z . z ); // Apply relaxation using the relaxation time lambda double intFactor = lambda [] != 0. ? exp (- dt / lambda []) : 0. ; A . x . y *= intFactor ; A . y . x = A . x . y ; A . x . z *= intFactor ; A . z . x = A . x . z ; A . y . z *= intFactor ; A . z . y = A . y . z ; foreach_dimension () A . x . x = 1. + ( A . x . x - 1. )* intFactor ; Get Aij from A.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: These commands might...",
    "content": "These commands might look repetitive. But, I do this so that in the future, generalization to tensor only form is easier. // diagonal terms: A11 [] = A . x . x ; A22 [] = A . y . y ; A33 [] = A . z . z ; // off-diagonal terms: A12 [] = A . x . y ; A13 [] = A . x . z ; A23 [] = A . y . z ; // Compute the stress tensor T using the polymer modulus Gp T11 [] = Gp []*( A . x . x - 1. ); T22 [] = Gp []*( A . y . y - 1. ); T33 [] = Gp []*( A . z . z - 1. ); T12 [] = Gp []* A . x . y ; T13 [] = Gp []* A . x . z ; T23 [] = Gp []* A . y . z ; } } #endif Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{T}\\) is defined at cell centers, while the corresponding force (acceleration) is defined at cell faces. For each component of the momentum equation, we need to compute the divergence of the corresponding row of the stress tensor.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Examples",
    "content": "For example, for the x-component in 3D: \\[ (\\nabla \\cdot \\mathbf{T})_x = \\partial_x T_{xx} + \\partial_y T_{xy} + \\partial_z T_{xz} \\] The normal stress gradient (e.g. \\(\\partial_x T_{xx}\\) ) is computed directly from cell-centered values.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The shear stress...",
    "content": "The shear stress gradients (e.g. \\(\\partial_y T_{xy}\\) ) are computed using vertex-averaged values to avoid checkerboard instabilities. event acceleration ( i ++) { face vector av = a ; #if dimension == // 2D implementation foreach_face ( x ) { if ( fm . x [] > 1e-20 ) { // y-gradient of T12 (shear stress) double shearX = ( T12 [ 0 , 1 ]* cm [ 0 , 1 ] + T12 [- 1 , 1 ]* cm [- 1 , 1 ] - T12 [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; // x-gradient of T11 (normal stress) double gradX_T11 = cm []* T11 [] - cm [- 1 ]* T11 [- 1 ]; av . x [] += ( shearX + gradX_T11 )* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ) { if ( fm . y [] > 1e-20 ) { // x-gradient of T12 (shear stress) double shearY = ( T12 [ 1 , 0 ]* cm [ 1 , 0 ] + T12 [ 1 ,- 1 ]* cm [ 1 ,- 1 ] - T12 [- 1 , 0 ]* cm [- 1 , 0 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; // y-gradient of T22 (normal stress) double gradY_T22 = cm []* T22 [] - cm [ 0 ,- 1 ]* T22 [ 0 ,- 1 ]; av . y [] += ( shearY + gradY_T22 )* alpha . y []/( sq ( fm . y [])* Delta ); } } #elif dimension == // 3D implementation foreach_face ( x ) { if ( fm . x [] > 1e-20 ) { // y-gradient of T12 double shearY = ( T12 [ 0 , 1 , 0 ]* cm [ 0 , 1 , 0 ] + T12 [- 1 , 1 , 0 ]* cm [- 1 , 1 , 0 ] - T12 [ 0 ,- 1 , 0 ]* cm [ 0 ,- 1 , 0 ] - T12 [- 1 ,- 1 , 0 ]* cm [- 1 ,- 1 , 0 ])/ 4. ; // z-gradient of T13 double shearZ = ( T13 [ 0 , 0 , 1 ]* cm [ 0 , 0 , 1 ] + T13 [- 1 , 0 , 1 ]* cm [- 1 , 0 , 1 ] - T13 [ 0 , 0 ,- 1 ]* cm [ 0 , 0 ,- 1 ] - T13 [- 1 , 0 ,- 1 ]* cm [- 1 , 0 ,- 1 ])/ 4. ; // x-gradient of T11 double gradX_T11 = cm []* T11 [] - cm [- 1 , 0 , 0 ]* T11 [- 1 , 0 , 0 ]; av . x [] += ( shearY + shearZ + gradX_T11 )* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ) { if ( fm . y [] > 1e-20 ) { // x-gradient of T12 double shearX = ( T12 [ 1 , 0 , 0 ]* cm [ 1 , 0 , 0 ] + T12 [ 1 ,- 1 , 0 ]* cm [ 1 ,- 1 , 0 ] - T12 [- 1 , 0 , 0 ]* cm [- 1 , 0 , 0 ] - T12 [- 1 ,- 1 , 0 ]* cm [- 1 ,- 1 , 0 ])/ 4. ; // z-gradient of T23 double shearZ = ( T23 [ 0 , 0 , 1 ]* cm [ 0 , 0 , 1 ] + T23 [ 0 ,- 1 , 1 ]* cm [ 0 ,- 1 , 1 ] - T23 [ 0 , 0 ,- 1 ]* cm [ 0 , 0 ,- 1 ] - T23 [ 0 ,- 1 ,- 1 ]* cm [ 0 ,- 1 ,- 1 ])/ 4. ; // y-gradient of T22 double gradY_T22 = cm []* T22 [] - cm [ 0 ,- 1 , 0 ]* T22 [ 0 ,- 1 , 0 ]; av . y [] += ( shearX + shearZ + gradY_T22 )* alpha . y []/( sq ( fm . y [])* Delta ); } } foreach_face ( z ) { if ( fm . z [] > 1e-20 ) { // x-gradient of T13 double shearX = ( T13 [ 1 , 0 , 0 ]* cm [ 1 , 0 , 0 ] + T13 [ 1 , 0 ,- 1 ]* cm [ 1 , 0 ,- 1 ] - T13 [- 1 , 0 , 0 ]* cm [- 1 , 0 , 0 ] - T13 [- 1 , 0 ,- 1 ]* cm [- 1 , 0 ,- 1 ])/ 4. ; // y-gradient of T23 double shearY = ( T23 [ 0 , 1 , 0 ]* cm [ 0 , 1 , 0 ] + T23 [ 0 , 1 ,- 1 ]* cm [ 0 , 1 ,- 1 ] - T23 [ 0 ,- 1 , 0 ]* cm [ 0 ,- 1 , 0 ] - T23 [ 0 ,- 1 ,- 1 ]* cm [ 0 ,- 1 ,- 1 ])/ 4. ; // z-gradient of T33 double gradZ_T33 = cm []* T33 [] - cm [ 0 , 0 ,- 1 ]* T33 [ 0 , 0 ,- 1 ]; av . z [] += ( shearX + shearY + gradZ_T33 )* alpha . z []/( sq ( fm . z [])* Delta ); } } #endif }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#if AXI#error \"axi compatibility is not there. To keep the code easy to read, we will not implement axi compatibility just yet.\"#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: /*TODO:- Perhaps, instead...",
    "content": "/*TODO:- Perhaps, instead of the Bell--Collela--Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to [http://basilisk.fr/src/navier-stokes/conserving.h](http://basilisk.fr/src/navier-stokes/conserving.h)*/#define EIGENVALUE_MIN1e-8220#ifdef DEBUG_EIGENVALUESstaticinteigenvalue_corrections=0;#endif#include\"bcg.h\"(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation time/*conformation tensor */// diagonal elementsscalar A11[],A22[],A33[];// off-diagonal elementsscalar A12[],A13[],A23[];/*stress tensor */// diagonal elementsscalar T11[],T22[],T33[];// off-diagonal elementsscalar T12[],T13[],T23[];event defaults(i=0){if(is_constant(a.x))a=new face vector;/*initialize A and T*/for(scalar s in{A11,A22,A33}){foreach(){s[]=1.;}}for(scalar s in{T11,T12,T13,T22,T23,T33,A12,A13,A23}){foreach(){s[]=0.;}}for(scalar s in{A11,A22,A33,T11,T22,T33,A12,A13,A23,T12,T13,T23}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}if(s.boundary[top]!=periodic_bc){s[top]=neumann(0);s[bottom]=neumann(0);}#if dimension ==if(s.boundary[front]!=periodic_bc){s[front]=neumann(0);s[back]=neumann(0);}#endif}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#if dimension ==typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}#endif/*Now this is the 3D implementation.*/#if dimension ==#include\"eigen_decomposition.h\"typedefstruct{doublex,y,z;}pseudo_v3d;typedefstruct{pseudo_v3d x,y,z;}pseudo_t3d;// Function to initialize pseudo_v3dstaticinlinevoidinit_pseudo_v3d(pseudo_v3d*v,doublevalue){v->x=value;v->y=value;v->z=value;}// Function to initialize pseudo_t3dstaticinlinevoidinit_pseudo_t3d(pseudo_t3d*t,doublevalue){init_pseudo_v3d(&t->x,value);init_pseudo_v3d(&t->y,value);init_pseudo_v3d(&t->z,value);}staticvoiddiagonalization_3D(pseudo_v3d*Lambda,pseudo_t3d*R,pseudo_t3d*A){// Check if the matrix is already diagonalif(sq(A->x.y)+sq(A->x.z)+sq(A->y.z)<1e-15){R->x.x=R->y.y=R->z.z=1.;R->y.x=R->x.y=R->z.x=R->x.z=R->z.y=R->y.z=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;Lambda->z=A->z.z;return;}// Compute eigenvalues using the eigen_decomposition functiondoublematrix[3][3]={{A->x.x,A->x.y,A->x.z},{A->y.x,A->y.y,A->y.z},{A->z.x,A->z.y,A->z.z}};doubleeigenvectors[3][3];doubleeigenvalues[3];compute_eigensystem_symmetric_3x3(matrix,eigenvectors,eigenvalues);// Store eigenvalues and eigenvectorsLambda->x=eigenvalues[0];Lambda->y=eigenvalues[1];Lambda->z=eigenvalues[2];R->x.x=eigenvectors[0][0];R->x.y=eigenvectors[0][1];R->x.z=eigenvectors[0][2];R->y.x=eigenvectors[1][0];R->y.y=eigenvectors[1][1];R->y.z=eigenvectors[1][2];R->z.x=eigenvectors[2][0];R->z.y=eigenvectors[2][1];R->z.z=eigenvectors[2][2];}#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event tracer_advection(i++){scalar Psi11=A11;scalar Psi12=A12;scalar Psi22=A22;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);pseudo_t R;init_pseudo_t(&R,0.0);diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.This prevents numerical instabilities while maintaining physical meaning.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"WARNING: Negative eigenvalue detected at (%g,%g): [%g,%g]\\n\",x,y,Lambda.x,Lambda.y);#ifdef DEBUG_EIGENVALUESatomic_increment(&eigenvalue_corrections);#endifLambda.x=max(Lambda.x,EIGENVALUE_MIN);Lambda.y=max(Lambda.y,EIGENVALUE_MIN);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);Psi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);Psi22[]=sq(R.y.y)*log(Lambda.y)+sq(R.y.x)*log(Lambda.x);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "pseudo_t B;init_pseudo_t(&B,0.0);doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;init_pseudo_t(&M,0.0);foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubles=-Psi12[];Psi12[]+=dt*(2.*B.x.y+OM*(Psi22[]-Psi11[]));s*=-1;Psi11[]+=dt*2.*(B.x.x+s*OM);s*=-1;Psi22[]+=dt*2.*(B.y.y+s*OM);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_t A={{Psi11[],Psi12[]},{Psi12[],Psi22[]}},R;init_pseudo_t(&R,0.0);pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);A.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "A12[]=A.x.y;T12[]=Gp[]*A.x.y;A11[]=A.x.x;T11[]=Gp[]*(A.x.x-1.);A22[]=A.y.y;T22[]=Gp[]*(A.y.y-1.);}}#elif dimension ==",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: // start by...",
    "content": "// start by declaring the scalar variables that will store the components of $\\Psi$scalar Psi11=A11,Psi12=A12,Psi13=A13,Psi22=A22,Psi23=A23,Psi33=A33;foreach(){pseudo_t3d A,R;init_pseudo_t3d(&R,0.0);pseudo_v3d Lambda;init_pseudo_v3d(&Lambda,0.0);A.x.x=A11[];A.x.y=A12[];A.x.z=A13[];A.y.x=A12[];A.y.y=A22[];A.y.z=A23[];A.z.x=A13[];A.z.y=A23[];A.z.z=A33[];// Diagonalize the conformation tensor A to obtain the eigenvalues Lambda and eigenvectors Rdiagonalization_3D(&Lambda,&R,&A);/*Check for negative eigenvalues and clamp them to EIGENVALUE_MIN.This prevents numerical instabilities while maintaining physical meaning.*/if(Lambda.x<=0.||Lambda.y<=0.||Lambda.z<=0.){fprintf(ferr,\"WARNING: Negative eigenvalue detected at (%g,%g,%g): [%g,%g,%g]\\n\",x,y,z,Lambda.x,Lambda.y,Lambda.z);#ifdef DEBUG_EIGENVALUESatomic_increment(&eigenvalue_corrections);#endifLambda.x=max(Lambda.x,EIGENVALUE_MIN);Lambda.y=max(Lambda.y,EIGENVALUE_MIN);Lambda.z=max(Lambda.z,EIGENVALUE_MIN);}// Compute Psi = log(A) = R * log(Lambda) * R^TPsi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y)+sq(R.x.z)*log(Lambda.z);Psi22[]=sq(R.y.x)*log(Lambda.x)+sq(R.y.y)*log(Lambda.y)+sq(R.y.z)*log(Lambda.z);Psi33[]=sq(R.z.x)*log(Lambda.x)+sq(R.z.y)*log(Lambda.y)+sq(R.z.z)*log(Lambda.z);Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.x.y*R.y.y*log(Lambda.y)+R.x.z*R.y.z*log(Lambda.z);Psi13[]=R.x.x*R.z.x*log(Lambda.x)+R.x.y*R.z.y*log(Lambda.y)+R.x.z*R.z.z*log(Lambda.z);Psi23[]=R.y.x*R.z.x*log(Lambda.x)+R.y.y*R.z.y*log(Lambda.y)+R.y.z*R.z.z*log(Lambda.z);// Compute B and Omega tensors (3D version)pseudo_t3d B,M,Omega;init_pseudo_t3d(&B,0.0);init_pseudo_t3d(&M,0.0);init_pseudo_t3d(&Omega,0.0);// Check if any pair of eigenvalues are numerically equal (within a small tolerance)if(fabs(Lambda.x-Lambda.y)<=1e-20||fabs(Lambda.y-Lambda.z)<=1e-20||fabs(Lambda.z-Lambda.x)<=1e-20){// In case of equal eigenvalues, the calculations for B and Omega simplify significantly// B is grad U and Omega is zero.// Compute off-diagonal elements of B using central differences// These represent the symmetric part of the velocity gradient tensorB.x.y=(u.y[1,0,0]-u.y[-1,0,0]+u.x[0,1,0]-u.x[0,-1,0])/(4.*Delta);// (dv/dx + du/dy)/2B.x.z=(u.z[1,0,0]-u.z[-1,0,0]+u.x[0,0,1]-u.x[0,0,-1])/(4.*Delta);// (dw/dx + du/dz)/2B.y.z=(u.z[0,1,0]-u.z[0,-1,0]+u.y[0,0,1]-u.y[0,0,-1])/(4.*Delta);// (dw/dy + dv/dz)/2// Compute diagonal elements of B// These represent the normal strain ratesB.x.x=(u.x[1,0,0]-u.x[-1,0,0])/(2.*Delta);// du/dxB.y.y=(u.y[0,1,0]-u.y[0,-1,0])/(2.*Delta);// dv/dyB.z.z=(u.z[0,0,1]-u.z[0,0,-1])/(2.*Delta);// dw/dz// Set all components of Omega to zero// This is because Omega represents the antisymmetric part of the velocity gradient tensor,// which vanishes when eigenvalues are equalOmega.x.y=Omega.x.z=Omega.y.z=Omega.y.x=Omega.z.x=Omega.z.y=0.;}else{/*###Compute the velocity gradient tensor components using central differences- These represent the spatial derivatives of each velocity component- These gradients form the velocity gradient tensor (nablaU):[ dudx  dudy  dudz ][ dvdx  dvdy  dvdz ][ dwdx  dwdy  dwdz ]*/// Derivatives of u (x-component of velocity)doubledudx=(u.x[1,0,0]-u.x[-1,0,0])/(2.0*Delta);// du/dxdoubledudy=(u.x[0,1,0]-u.x[0,-1,0])/(2.0*Delta);// du/dydoubledudz=(u.x[0,0,1]-u.x[0,0,-1])/(2.0*Delta);// du/dz// Derivatives of v (y-component of velocity)doubledvdx=(u.y[1,0,0]-u.y[-1,0,0])/(2.0*Delta);// dv/dxdoubledvdy=(u.y[0,1,0]-u.y[0,-1,0])/(2.0*Delta);// dv/dydoubledvdz=(u.y[0,0,1]-u.y[0,0,-1])/(2.0*Delta);// dv/dz// Derivatives of w (z-component of velocity)doubledwdx=(u.z[1,0,0]-u.z[-1,0,0])/(2.0*Delta);// dw/dxdoubledwdy=(u.z[0,1,0]-u.z[0,-1,0])/(2.0*Delta);// dw/dydoubledwdz=(u.z[0,0,1]-u.z[0,0,-1])/(2.0*Delta);// dw/dz/*Calculate the M tensor through matrix multiplication: M = R * (nablaU)^T R^T.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: This represents the...",
    "content": "This represents the velocity gradient tensor transformed to the eigenvector basis of the conformation tensor.* Steps:1. Compute intermediate products (R * nablaU^T):- Store row-wise products in Rx_gradU_*, Ry_gradU_*, Rz_gradU_*- Each variable represents one row of the intermediate matrix2.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Multiply by R^T...",
    "content": "Multiply by R^T to obtain the final M tensor:- M.i.j represents the (i,j) component of the transformed velocity gradient- This transformation expresses the velocity gradient in the eigenvector basis- The resulting M tensor is used to compute Omega (\u03a9) and B tensors, such that*/// First, compute intermediate products of R and (nablaU)^TdoubleRx_gradU_x=R.x.x*dudx+R.x.y*dvdx+R.x.z*dwdx;doubleRx_gradU_y=R.x.x*dudy+R.x.y*dvdy+R.x.z*dwdy;doubleRx_gradU_z=R.x.x*dudz+R.x.y*dvdz+R.x.z*dwdz;doubleRy_gradU_x=R.y.x*dudx+R.y.y*dvdx+R.y.z*dwdx;doubleRy_gradU_y=R.y.x*dudy+R.y.y*dvdy+R.y.z*dwdy;doubleRy_gradU_z=R.y.x*dudz+R.y.y*dvdz+R.y.z*dwdz;doubleRz_gradU_x=R.z.x*dudx+R.z.y*dvdx+R.z.z*dwdx;doubleRz_gradU_y=R.z.x*dudy+R.z.y*dvdy+R.z.z*dwdy;doubleRz_gradU_z=R.z.x*dudz+R.z.y*dvdz+R.z.z*dwdz;// Now compute M components by multiplying the intermediate products with R^TM.x.x=R.x.x*Rx_gradU_x+R.x.y*Rx_gradU_y+R.x.z*Rx_gradU_z;M.x.y=R.x.x*Ry_gradU_x+R.x.y*Ry_gradU_y+R.x.z*Ry_gradU_z;M.x.z=R.x.x*Rz_gradU_x+R.x.y*Rz_gradU_y+R.x.z*Rz_gradU_z;M.y.x=R.y.x*Rx_gradU_x+R.y.y*Rx_gradU_y+R.y.z*Rx_gradU_z;M.y.y=R.y.x*Ry_gradU_x+R.y.y*Ry_gradU_y+R.y.z*Ry_gradU_z;M.y.z=R.y.x*Rz_gradU_x+R.y.y*Rz_gradU_y+R.y.z*Rz_gradU_z;M.z.x=R.z.x*Rx_gradU_x+R.z.y*Rx_gradU_y+R.z.z*Rx_gradU_z;M.z.y=R.z.x*Ry_gradU_x+R.z.y*Ry_gradU_y+R.z.z*Ry_gradU_z;M.z.z=R.z.x*Rz_gradU_x+R.z.y*Rz_gradU_y+R.z.z*Rz_gradU_z;// Compute the off-diagonal elements of the Omega tensor in the eigenvector basisdoubleomega_xy=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);doubleomega_xz=(Lambda.z*M.x.z+Lambda.x*M.z.x)/(Lambda.z-Lambda.x);doubleomega_yz=(Lambda.z*M.y.z+Lambda.y*M.z.y)/(Lambda.z-Lambda.y);// Calculate intermediate rotation combinations for each direction// x-direction rotation combinationsdoublerot_x_xy_yz=(R.x.x*omega_xy-R.x.z*omega_yz);// xy rotation minus yz rotation, x componentsdoublerot_x_xy_xz=(R.x.y*omega_xy+R.x.z*omega_xz);// xy rotation plus xz rotation, x componentsdoublerot_x_xz_yz=(R.x.x*omega_xz+R.x.y*omega_yz);// xz rotation plus yz rotation, x components// y-direction rotation combinationsdoublerot_y_xy_yz=(R.y.x*omega_xy-R.y.z*omega_yz);// xy rotation minus yz rotation, y componentsdoublerot_y_xy_xz=(R.y.y*omega_xy+R.y.z*omega_xz);// xy rotation plus xz rotation, y componentsdoublerot_y_xz_yz=(R.y.x*omega_xz+R.y.y*omega_yz);// xz rotation plus yz rotation, y components// z-direction rotation combinationsdoublerot_z_xy_yz=(R.z.x*omega_xy-R.z.z*omega_yz);// xy rotation minus yz rotation, z componentsdoublerot_z_xy_xz=(R.z.y*omega_xy+R.z.z*omega_xz);// xy rotation plus xz rotation, z componentsdoublerot_z_xz_yz=(R.z.x*omega_xz+R.z.y*omega_yz);// xz rotation plus yz rotation, z components",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: // Compute x-row...",
    "content": "// Compute x-row components of OmegaOmega.x.x=R.x.y*rot_x_xy_yz// xy-yz rotation contribution-R.x.x*rot_x_xy_xz// xy-xz rotation contribution+R.x.z*rot_x_xz_yz;// xz-yz rotation contributionOmega.x.y=R.y.y*rot_x_xy_yz// xy-yz rotation mapped to y-direction-R.y.x*rot_x_xy_xz// xy-xz rotation mapped to y-direction+R.y.z*rot_x_xz_yz;// xz-yz rotation mapped to y-directionOmega.x.z=R.z.y*rot_x_xy_yz// xy-yz rotation mapped to z-direction-R.z.x*rot_x_xy_xz// xy-xz rotation mapped to z-direction+R.z.z*rot_x_xz_yz;// xz-yz rotation mapped to z-direction// Compute y-row components using similar patternOmega.y.x=R.x.y*rot_y_xy_yz-R.x.x*rot_y_xy_xz+R.x.z*rot_y_xz_yz;Omega.y.y=R.y.y*rot_y_xy_yz-R.y.x*rot_y_xy_xz+R.y.z*rot_y_xz_yz;Omega.y.z=R.z.y*rot_y_xy_yz-R.z.x*rot_y_xy_xz+R.z.z*rot_y_xz_yz;// Compute z-row components using similar patternOmega.z.x=R.x.y*rot_z_xy_yz-R.x.x*rot_z_xy_xz+R.x.z*rot_z_xz_yz;Omega.z.y=R.y.y*rot_z_xy_yz-R.y.x*rot_z_xy_xz+R.y.z*rot_z_xz_yz;Omega.z.z=R.z.y*rot_z_xy_yz-R.z.x*rot_z_xy_xz+R.z.z*rot_z_xz_yz;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "// Extract diagonal components of M (velocity gradient tensor in eigenvector basis)doubleM_diag_x=M.x.x,M_diag_y=M.y.y,M_diag_z=M.z.z;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: // Compute diagonal...",
    "content": "// Compute diagonal elements of BB.x.x=M_diag_x*sq(R.x.x)+M_diag_y*sq(R.x.y)+M_diag_z*sq(R.x.z);B.y.y=M_diag_x*sq(R.y.x)+M_diag_y*sq(R.y.y)+M_diag_z*sq(R.y.z);B.z.z=M_diag_x*sq(R.z.x)+M_diag_y*sq(R.z.y)+M_diag_z*sq(R.z.z);// Compute off-diagonal elements of B (upper triangle)B.x.y=M_diag_x*R.x.x*R.y.x+M_diag_y*R.x.y*R.y.y+M_diag_z*R.x.z*R.y.z;B.x.z=M_diag_x*R.x.x*R.z.x+M_diag_y*R.x.y*R.z.y+M_diag_z*R.x.z*R.z.z;B.y.z=M_diag_x*R.y.x*R.z.x+M_diag_y*R.y.y*R.z.y+M_diag_z*R.y.z*R.z.z;// Fill in lower triangle using symmetry of BB.y.x=B.x.y;B.z.x=B.x.z;B.z.y=B.y.z;}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: // save old...",
    "content": "// save old values of Psi componentsdoubleold_Psi11=Psi11[];doubleold_Psi22=Psi22[];doubleold_Psi33=Psi33[];doubleold_Psi12=Psi12[];doubleold_Psi13=Psi13[];doubleold_Psi23=Psi23[];// Psi11Psi11[]+=dt*(2.0*B.x.x+Omega.x.y*old_Psi12-Omega.y.x*old_Psi12+Omega.x.z*old_Psi13-Omega.z.x*old_Psi13);// Psi22Psi22[]+=dt*(2.0*B.y.y-Omega.x.y*old_Psi12+Omega.y.x*old_Psi12+Omega.y.z*old_Psi23-Omega.z.y*old_Psi23);// Psi33Psi33[]+=dt*(2.0*B.z.z-Omega.x.z*old_Psi13+Omega.z.x*old_Psi13-Omega.y.z*old_Psi23+Omega.z.y*old_Psi23);// Psi12Psi12[]+=dt*(2.0*B.x.y+Omega.x.x*old_Psi12-Omega.x.y*old_Psi11+Omega.x.y*old_Psi22-Omega.y.y*old_Psi12+Omega.x.z*old_Psi23-Omega.z.y*old_Psi13);// Psi13Psi13[]+=dt*(2.0*B.x.z+Omega.x.x*old_Psi13-Omega.x.z*old_Psi11+Omega.x.y*old_Psi23-Omega.y.z*old_Psi12+Omega.x.z*old_Psi33-Omega.z.z*old_Psi13);// Psi23Psi23[]+=dt*(2.0*B.y.z+Omega.y.x*old_Psi13-Omega.x.z*old_Psi12+Omega.y.y*old_Psi23-Omega.y.z*old_Psi22+Omega.y.z*old_Psi33-Omega.z.z*old_Psi23);}// Advection of Psi, which is the log-conformation tensoradvection({Psi11,Psi12,Psi13,Psi22,Psi23,Psi33},uf,dt);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "foreach(){pseudo_t3d A,R;init_pseudo_t3d(&R,0.0);pseudo_v3d Lambda;init_pseudo_v3d(&Lambda,0.0);// Reconstruct the log-conformation tensor from its componentsA.x.x=Psi11[];A.x.y=Psi12[];A.x.z=Psi13[];A.y.x=Psi12[];A.y.y=Psi22[];A.y.z=Psi23[];A.z.x=Psi13[];A.z.y=Psi23[];A.z.z=Psi33[];// Diagonalize A to obtain eigenvalues and eigenvectorsdiagonalization_3D(&Lambda,&R,&A);// Exponentiate eigenvaluesLambda.x=exp(Lambda.x);Lambda.y=exp(Lambda.y);Lambda.z=exp(Lambda.z);// Reconstruct A using A = R * diag(Lambda) * R^TA.x.x=Lambda.x*sq(R.x.x)+Lambda.y*sq(R.x.y)+Lambda.z*sq(R.x.z);A.x.y=Lambda.x*R.x.x*R.y.x+Lambda.y*R.x.y*R.y.y+Lambda.z*R.x.z*R.y.z;A.y.x=A.x.y;A.x.z=Lambda.x*R.x.x*R.z.x+Lambda.y*R.x.y*R.z.y+Lambda.z*R.x.z*R.z.z;A.z.x=A.x.z;A.y.y=Lambda.x*sq(R.y.x)+Lambda.y*sq(R.y.y)+Lambda.z*sq(R.y.z);A.y.z=Lambda.x*R.y.x*R.z.x+Lambda.y*R.y.y*R.z.y+Lambda.z*R.y.z*R.z.z;A.z.y=A.y.z;A.z.z=Lambda.x*sq(R.z.x)+Lambda.y*sq(R.z.y)+Lambda.z*sq(R.z.z);// Apply relaxation using the relaxation time lambdadoubleintFactor=lambda[]!=0.?exp(-dt/lambda[]):0.;A.x.y*=intFactor;A.y.x=A.x.y;A.x.z*=intFactor;A.z.x=A.x.z;A.y.z*=intFactor;A.z.y=A.y.z;foreach_dimension()A.x.x=1.+(A.x.x-1.)*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "// diagonal terms:A11[]=A.x.x;A22[]=A.y.y;A33[]=A.z.z;// off-diagonal terms:A12[]=A.x.y;A13[]=A.x.z;A23[]=A.y.z;// Compute the stress tensor T using the polymer modulus GpT11[]=Gp[]*(A.x.x-1.);T22[]=Gp[]*(A.y.y-1.);T33[]=Gp[]*(A.z.z-1.);T12[]=Gp[]*A.x.y;T13[]=Gp[]*A.x.z;T23[]=Gp[]*A.y.z;}}#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-3D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event acceleration(i++){face vector...",
    "content": "event acceleration(i++){face vector av=a;#if dimension ==// 2D implementationforeach_face(x){if(fm.x[]>1e-20){// y-gradient of T12 (shear stress)doubleshearX=(T12[0,1]*cm[0,1]+T12[-1,1]*cm[-1,1]-T12[0,-1]*cm[0,-1]-T12[-1,-1]*cm[-1,-1])/4.;// x-gradient of T11 (normal stress)doublegradX_T11=cm[]*T11[]-cm[-1]*T11[-1];av.x[]+=(shearX+gradX_T11)*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){// x-gradient of T12 (shear stress)doubleshearY=(T12[1,0]*cm[1,0]+T12[1,-1]*cm[1,-1]-T12[-1,0]*cm[-1,0]-T12[-1,-1]*cm[-1,-1])/4.;// y-gradient of T22 (normal stress)doublegradY_T22=cm[]*T22[]-cm[0,-1]*T22[0,-1];av.y[]+=(shearY+gradY_T22)*alpha.y[]/(sq(fm.y[])*Delta);}}#elif dimension ==// 3D implementationforeach_face(x){if(fm.x[]>1e-20){// y-gradient of T12doubleshearY=(T12[0,1,0]*cm[0,1,0]+T12[-1,1,0]*cm[-1,1,0]-T12[0,-1,0]*cm[0,-1,0]-T12[-1,-1,0]*cm[-1,-1,0])/4.;// z-gradient of T13doubleshearZ=(T13[0,0,1]*cm[0,0,1]+T13[-1,0,1]*cm[-1,0,1]-T13[0,0,-1]*cm[0,0,-1]-T13[-1,0,-1]*cm[-1,0,-1])/4.;// x-gradient of T11doublegradX_T11=cm[]*T11[]-cm[-1,0,0]*T11[-1,0,0];av.x[]+=(shearY+shearZ+gradX_T11)*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){// x-gradient of T12doubleshearX=(T12[1,0,0]*cm[1,0,0]+T12[1,-1,0]*cm[1,-1,0]-T12[-1,0,0]*cm[-1,0,0]-T12[-1,-1,0]*cm[-1,-1,0])/4.;// z-gradient of T23doubleshearZ=(T23[0,0,1]*cm[0,0,1]+T23[0,-1,1]*cm[0,-1,1]-T23[0,0,-1]*cm[0,0,-1]-T23[0,-1,-1]*cm[0,-1,-1])/4.;// y-gradient of T22doublegradY_T22=cm[]*T22[]-cm[0,-1,0]*T22[0,-1,0];av.y[]+=(shearX+shearZ+gradY_T22)*alpha.y[]/(sq(fm.y[])*Delta);}}foreach_face(z){if(fm.z[]>1e-20){// x-gradient of T13doubleshearX=(T13[1,0,0]*cm[1,0,0]+T13[1,0,-1]*cm[1,0,-1]-T13[-1,0,0]*cm[-1,0,0]-T13[-1,0,-1]*cm[-1,0,-1])/4.;// y-gradient of T23doubleshearY=(T23[0,1,0]*cm[0,1,0]+T23[0,1,-1]*cm[0,1,-1]-T23[0,-1,0]*cm[0,-1,0]-T23[0,-1,-1]*cm[0,-1,-1])/4.;// z-gradient of T33doublegradZ_T33=cm[]*T33[]-cm[0,0,-1]*T33[0,0,-1];av.z[]+=(shearX+shearY+gradZ_T33)*alpha.z[]/(sq(fm.z[])*Delta);}}#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-3D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "src-local/log-conform-viscoelastic-scalar-2D.h See raw file Log-Conformation Method for 2D Viscoelastic Fluids Overview Title : log-conform-viscoelastic-scalar-2D.h Version : 2.5 Description : 2D and axisymmetric scalar implementation of viscoelastic fluid dynamics using the log-conformation method Key Features Conformation tensor A exists across domain and relaxes according to \u03bb Stress acts according to elastic modulus G Supports both 2D and axisymmetric configurations Scalar implementation approach for better performance Compatible with log-conform-viscoelastic.h Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Nov 23, 2024 Implementation Notes Based on http://basilisk.fr/src/log-conform.h with key improvements: Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling bug where [\u03c3_p] = 0 & [\u03c3_s] = \u03b3\u03ba Ensures [\u03c3_s+\u03c3_p] = \u03b3\u03ba for correct interface behavior Version History v1.0 (Oct 18, 2024) Initial implementation with 2D+axi support Scalar-based implementation for efficiency v2.0 (Nov 3, 2024) Major documentation improvements Made code an axisymmetric mirror of log-conform-viscoelastic-scalar-3D.h Added negative eigenvalue detection with location reporting Added initialization functions for pseudo_v and pseudo_t v2.1 (Nov 14, 2024) Added support for infinite Deborah number cases v2.5 (Nov 23, 2024) Enhanced documentation clarity and completeness Future Work Tensor Formulation Convert to consistent tensor formulation for: Improved readability and maintainability Better computational efficiency Reduced potential for bugs Prerequisites for axi compatibility in 3D version Related issues: https://github.com/comphy-lab/Viscoelastic3D/issues/11 https://github.com/comphy-lab/Viscoelastic3D/issues/5 Code Improvements Enforce tensor usage throughout codebase Implement foreach_dimension compatibility The log-conformation method for viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Therefore these materials...",
    "content": "Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers. Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The conformation tensor...",
    "content": "The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time. In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Parameters The primary...",
    "content": "Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features. This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: TODO: - Perhaps,...",
    "content": "TODO: - Perhaps, instead of the Bell\u2013Collela\u2013Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to http://basilisk.fr/src/navier-stokes/conserving.h #include \"bcg.h\" ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time scalar A11 [], A12 [], A22 []; // conformation tensor scalar T11 [], T12 [], T22 []; // stress tensor #if AXI scalar AThTh [], T_ThTh []; #endif event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; /* initialize A and T */ for ( scalar s in { A11 , A22 }) { foreach () { s [] = 1. ; } } for ( scalar s in { T11 , T12 , T22 , A12 }) { foreach (){ s [] = 0. ; } } #if AXI foreach (){ T_ThTh [] = 0 ; AThTh [] = 1. ; } #endif for ( scalar s in { T11 , T12 , T22 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } for ( scalar s in { A11 , A12 , A22 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } #if AXI T12 [ bottom ] = dirichlet ( 0. ); A12 [ bottom ] = dirichlet ( 0. ); #endif } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } The stress tensor depends on previous instants and has to be integrated in time. In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: We use a...",
    "content": "We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ).",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: In an Oldroyd-B...",
    "content": "In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] event tracer_advection ( i ++) { scalar Psi11 = A11 ; scalar Psi12 = A12 ; scalar Psi22 = A22 ; #if AXI scalar Psiqq = AThTh ; #endif Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A ; A . x . x = A11 []; A . y . y = A22 []; A . x . y = A12 []; #if AXI double Aqq = AThTh []; Psiqq [] = log ( Aqq ); #endif The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); pseudo_t R ; init_pseudo_t (& R , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues -- this should never happen.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: If it does,...",
    "content": "If it does, print the location and value of the offending eigenvalue. Please report this bug by opening an issue on the GitHub repository. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"Negative eigenvalue detected: Lambda.x = %g , Lambda.y = %g\\n \" , Lambda . x , Lambda . y ); fprintf ( ferr , \"x = %g , y = %g\\n \" , x , y ); exit ( 1 ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) . Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); Psi22 [] = sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . x )* log ( Lambda . x ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The diagonalization will...",
    "content": "The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis. Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: R is the eigenvector matrix of the conformation tensor M is the velocity gradient tensor in the eigenvector basis The construction ensures B is symmetric and traceless pseudo_t B ; init_pseudo_t (& B , 0.0 ); double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; init_pseudo_t (& M , 0.0 ); foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi12 []; Psi12 [] += dt * ( 2. * B . x . y + OM * ( Psi22 [] - Psi11 [])); s *= - 1 ; Psi11 [] += dt * 2. * ( B . x . x + s * OM ); s *= - 1 ; Psi22 [] += dt * 2. * ( B . y . y + s * OM ); In the axisymmetric case, the governing equation for \\(\\Psi_{\\theta \\theta}\\) only involves that component, \\[ \\Psi_{\\theta \\theta}|_t - 2 L_{\\theta \\theta} = \\frac{\\mathbf{f}_r(e^{-\\Psi_{\\theta \\theta}})}{\\lambda} \\] with \\(L_{\\theta \\theta} = u_y/y\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Therefore step (a)...",
    "content": "Therefore step (a) for \\(\\Psi_{\\theta \\theta}\\) is #if AXI Psiqq [] += dt * 2. * u . y []/ max ( y , 1e-20 ); #endif } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . #if AXI advection ({ Psi11 , Psi12 , Psi22 , Psiqq }, uf , dt ); #else advection ({ Psi11 , Psi12 , Psi22 }, uf , dt ); #endif Convert back to Aij foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi11 [], Psi12 []}, { Psi12 [], Psi22 []}}, R ; init_pseudo_t (& R , 0.0 ); pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; #if AXI double Aqq = exp ( Psiqq []); #endif We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); #if AXI Aqq = ( 1. - intFactor ) + intFactor * exp ( Psiqq []); #endif A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . A12 [] = A . x . y ; T12 [] = Gp []* A . x . y ; #if AXI AThTh [] = Aqq ; T_ThTh [] = Gp []*( Aqq - 1. ); #endif A11 [] = A . x . x ; T11 [] = Gp []*( A . x . x - 1. ); A22 [] = A . y . y ; T22 [] = Gp []*( A . y . y - 1. ); } } Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{\\tau}_p\\) is defined at cell centers while the corresponding force (acceleration) will be defined at cell faces. Two terms contribute to each component of the momentum equation.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Examples",
    "content": "For example the \\(x\\) -component in Cartesian coordinates has the following terms: \\(\\partial_x \\mathbf{\\tau}_{p_{xx}} + \\partial_y \\mathbf{\\tau}_{p_{xy}}\\) . The first term is easy to compute since it can be calculated directly from center values of cells sharing the face. The other one is harder. It will be computed from vertex values. The vertex values are obtained by averaging centered values.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Results",
    "content": "Note that as a result of the vertex averaging cells [] and [-1,0] are not involved in the computation of shear. event acceleration ( i ++) { face vector av = a ; foreach_face ( x ){ if ( fm . x [] > 1e-20 ) { double shearX = ( T12 [ 0 , 1 ]* cm [ 0 , 1 ] + T12 [- 1 , 1 ]* cm [- 1 , 1 ] - T12 [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . x [] += ( shearX + cm []* T11 [] - cm [- 1 ]* T11 [- 1 ])* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ){ if ( fm . y [] > 1e-20 ) { double shearY = ( T12 [ 1 , 0 ]* cm [ 1 , 0 ] + T12 [ 1 ,- 1 ]* cm [ 1 ,- 1 ] - T12 [- 1 , 0 ]* cm [- 1 , 0 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . y [] += ( shearY + cm []* T22 [] - cm [ 0 ,- 1 ]* T22 [ 0 ,- 1 ])* alpha . y []/( sq ( fm . y [])* Delta ); } } #if AXI foreach_face ( y ) if ( y > 1e-20 ) av . y [] -= ( T_ThTh [] + T_ThTh [ 0 ,- 1 ])* alpha . y []/ sq ( y )/ 2. ; #endif }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code: C/C++ Code",
    "content": "#include\"bcg.h\"(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation timescalar A11[],A12[],A22[];// conformation tensorscalar T11[],T12[],T22[];// stress tensor#if AXIscalar AThTh[],T_ThTh[];#endifevent defaults(i=0){if(is_constant(a.x))a=new face vector;/*initialize A and T*/for(scalar s in{A11,A22}){foreach(){s[]=1.;}}for(scalar s in{T11,T12,T22,A12}){foreach(){s[]=0.;}}#if AXIforeach(){T_ThTh[]=0;AThTh[]=1.;}#endiffor(scalar s in{T11,T12,T22}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}for(scalar s in{A11,A12,A22}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}#if AXIT12[bottom]=dirichlet(0.);A12[bottom]=dirichlet(0.);#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event tracer_advection(i++){scalar Psi11=A11;scalar Psi12=A12;scalar Psi22=A22;#if AXIscalar Psiqq=AThTh;#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_t A;A.x.x=A11[];A.y.y=A22[];A.x.y=A12[];#if AXIdoubleAqq=AThTh[];Psiqq[]=log(Aqq);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);pseudo_t R;init_pseudo_t(&R,0.0);diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue.Please report this bug by opening an issue on the GitHub repository.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"Negative eigenvalue detected: Lambda.x =%g, Lambda.y =%g\\n\",Lambda.x,Lambda.y);fprintf(ferr,\"x =%g, y =%g\\n\",x,y);exit(1);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);Psi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);Psi22[]=sq(R.y.y)*log(Lambda.y)+sq(R.y.x)*log(Lambda.x);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "pseudo_t B;init_pseudo_t(&B,0.0);doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;init_pseudo_t(&M,0.0);foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubles=-Psi12[];Psi12[]+=dt*(2.*B.x.y+OM*(Psi22[]-Psi11[]));s*=-1;Psi11[]+=dt*2.*(B.x.x+s*OM);s*=-1;Psi22[]+=dt*2.*(B.y.y+s*OM);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#if AXIadvection({Psi11,Psi12,Psi22,Psiqq},uf,dt);#elseadvection({Psi11,Psi12,Psi22},uf,dt);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_t A={{Psi11[],Psi12[]},{Psi12[],Psi22[]}},R;init_pseudo_t(&R,0.0);pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;#if AXIdoubleAqq=exp(Psiqq[]);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);#if AXIAqq=(1.-intFactor)+intFactor*exp(Psiqq[]);#endifA.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "A12[]=A.x.y;T12[]=Gp[]*A.x.y;#if AXIAThTh[]=Aqq;T_ThTh[]=Gp[]*(Aqq-1.);#endifA11[]=A.x.x;T11[]=Gp[]*(A.x.x-1.);A22[]=A.y.y;T22[]=Gp[]*(A.y.y-1.);}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event acceleration(i++){face vector...",
    "content": "event acceleration(i++){face vector av=a;foreach_face(x){if(fm.x[]>1e-20){doubleshearX=(T12[0,1]*cm[0,1]+T12[-1,1]*cm[-1,1]-T12[0,-1]*cm[0,-1]-T12[-1,-1]*cm[-1,-1])/4.;av.x[]+=(shearX+cm[]*T11[]-cm[-1]*T11[-1])*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){doubleshearY=(T12[1,0]*cm[1,0]+T12[1,-1]*cm[1,-1]-T12[-1,0]*cm[-1,0]-T12[-1,-1]*cm[-1,-1])/4.;av.y[]+=(shearY+cm[]*T22[]-cm[0,-1]*T22[0,-1])*alpha.y[]/(sq(fm.y[])*Delta);}}#if AXIforeach_face(y)if(y>1e-20)av.y[]-=(T_ThTh[]+T_ThTh[0,-1])*alpha.y[]/sq(y)/2.;#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "src-local/log-conform-viscoelastic.h See raw file Log-Conformation Method with Tensor Implementation Overview Title : log-conform-viscoelastic.h Version : 10.5 Description : Tensor-based implementation of the log-conformation method for viscoelastic fluids Key Features Conformation tensor A exists across domain and relaxes according to \u03bb Stress acts according to elastic modulus G Uses native tensor data structures for better code organization Supports both 2D and axisymmetric configurations Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Nov 23, 2024 Implementation Notes Based on http://basilisk.fr/src/log-conform.h with key improvements: Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling bug where [\u03c3_p] = 0 & [\u03c3_s] = \u03b3\u03ba Ensures [\u03c3_s+\u03c3_p] = \u03b3\u03ba for correct interface behavior Important Limitations 3D Compatibility Currently limited to 2D and axisymmetric cases only 3D support is blocked by Basilisk core limitations: Boundary conditions for symmetric tensors are not implemented in Basilisk core See basilisk/src/grid/cartesian-common.h lines 230-251 Comment in source: \u201cfixme: boundary conditions don\u2019t work!\u201d Alternative for 3D For 3D simulations, use log-conform-viscoelastic-scalar-3D.h Scalar version uses individual components instead of tensors Provides full 3D functionality without boundary condition limitations Technical Notes Variable Naming conform_p , conform_qq : Represent the Conformation tensor Tensor implementation provides more natural mathematical representation Axisymmetric components handled separately when needed Mathematical Framework The implementation follows the standard log-conformation approach: 1.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Uses tensor mathematics...",
    "content": "Uses tensor mathematics for clean formulation 2. Handles both planar and axisymmetric geometries 3. Provides natural extension to various constitutive models Note: In this code, conform_p, conform_qq are in fact the Conformation tensor. The log-conformation method for viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Function Definition",
    "content": "Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function. The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: In the case...",
    "content": "In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models. Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This instability poses...",
    "content": "This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) . TODO: - Perhaps, instead of the Bell\u2013Collela\u2013Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to http://basilisk.fr/src/navier-stokes/conserving.h #include \"bcg.h\" #if dimension == #error \"This implementation does not support 3D due to missing tensor boundary conditions in Basilisk (see cartesian-common.h line ~246).",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: JavaScript",
    "content": "Use log-conform-viscoelastic-scalar-3D.h for 3D simulations.\" #endif ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time symmetric tensor conform_p [], tau_p []; #if AXI scalar conform_qq [], tau_qq []; #endif event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; foreach () { foreach_dimension (){ tau_p . x . x [] = 0. ; conform_p . x . x [] = 1. ; } tau_p . x . y [] = 0. ; conform_p . x . y [] = 0. ; #if AXI tau_qq [] = 0 ; conform_qq [] = 1. ; #endif } for ( scalar s in { tau_p }) { s . v . x . i = - 1 ; // just a scalar, not the component of a vector foreach_dimension (){ if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } } for ( scalar s in { conform_p }) { s . v . x . i = - 1 ; // just a scalar, not the component of a vector foreach_dimension (){ if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } } #if AXI scalar s1 = tau_p . x . y ; s1 [ bottom ] = dirichlet ( 0. ); #endif #if AXI scalar s2 = conform_p . x . y ; s2 [ bottom ] = dirichlet ( 0. ); #endif } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } The stress tensor depends on previous instants and has to be integrated in time. In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: We use a...",
    "content": "We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ). In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] event tracer_advection ( i ++) { tensor Psi = conform_p ; #if AXI scalar Psiqq = conform_qq ; #endif Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A ; A . x . y = conform_p . x . y []; foreach_dimension () A . x . x = conform_p . x . x []; In the axisymmetric case, \\(\\Psi_{\\theta \\theta} = \\log A_{\\theta \\theta}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Therefore \\(\\Psi_{\\theta \\theta}...",
    "content": "Therefore \\(\\Psi_{\\theta \\theta} = \\log [ ( 1 + \\text{fa} \\tau_{p_{\\theta \\theta}})]\\) . #if AXI double Aqq = conform_qq []; Psiqq [] = log ( Aqq ); #endif The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; pseudo_t R ; diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue. Please report this bug by opening an issue on the GitHub repository. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"Negative eigenvalue detected: Lambda.x = %g , Lambda.y = %g\\n \" , Lambda . x , Lambda . y ); fprintf ( ferr , \"x = %g , y = %g\\n \" , x , y ); exit ( 1 ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "Psi . x . y [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); foreach_dimension () Psi . x . x [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) . The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Transform omega back...",
    "content": "Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: - R is the eigenvector matrix of the conformation tensor - M is the velocity gradient tensor in the eigenvector basis - The construction ensures B is symmetric and traceless pseudo_t B ; double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi . x . y []; Psi . x . y [] += dt *( 2. * B . x . y + OM *( Psi . y . y [] - Psi . x . x [])); foreach_dimension () { s *= - 1 ; Psi . x . x [] += dt * 2. *( B . x . x + s * OM ); } In the axisymmetric case, the governing equation for \\(\\Psi_{\\theta \\theta}\\) only involves that component, \\[ \\Psi_{\\theta \\theta}|_t - 2 L_{\\theta \\theta} = \\frac{\\mathbf{f}_r(e^{-\\Psi_{\\theta \\theta}})}{\\lambda} \\] with \\(L_{\\theta \\theta} = u_y/y\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Therefore step (a)...",
    "content": "Therefore step (a) for \\(\\Psi_{\\theta \\theta}\\) is #if AXI Psiqq [] += dt * 2. * u . y []/ max ( y , 1e-20 ); #endif } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . #if AXI advection ({ Psi . x . x , Psi . x . y , Psi . y . y , Psiqq }, uf , dt ); #else advection ({ Psi . x . x , Psi . x . y , Psi . y . y }, uf , dt ); #endif Convert back to _p foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi . x . x [], Psi . x . y []}, { Psi . y . x [], Psi . y . y []}}, R ; pseudo_v Lambda ; diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; #if AXI double Aqq = exp ( Psiqq []); #endif We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); #if AXI Aqq = ( 1. - intFactor ) + intFactor * exp ( Psiqq []); #endif A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . conform_p . x . y [] = A . x . y ; tau_p . x . y [] = Gp []* A . x . y ; #if AXI conform_qq [] = Aqq ; tau_qq [] = Gp []*( Aqq - 1. ); #endif foreach_dimension (){ conform_p . x . x [] = A . x . x ; tau_p . x . x [] = Gp []*( A . x . x - 1. ); } } } Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{\\tau}_p\\) is defined at cell centers while the corresponding force (acceleration) will be defined at cell faces. Two terms contribute to each component of the momentum equation.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Examples",
    "content": "For example the \\(x\\) -component in Cartesian coordinates has the following terms: \\(\\partial_x \\mathbf{\\tau}_{p_{xx}} + \\partial_y \\mathbf{\\tau}_{p_{xy}}\\) . The first term is easy to compute since it can be calculated directly from center values of cells sharing the face. The other one is harder. It will be computed from vertex values. The vertex values are obtained by averaging centered values.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Results",
    "content": "Note that as a result of the vertex averaging cells [] and [-1,0] are not involved in the computation of shear. event acceleration ( i ++) { face vector av = a ; foreach_face () if ( fm . x [] > 1e-20 ) { double shear = ( tau_p . x . y [ 0 , 1 ]* cm [ 0 , 1 ] + tau_p . x . y [- 1 , 1 ]* cm [- 1 , 1 ] - tau_p . x . y [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - tau_p . x . y [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . x [] += ( shear + cm []* tau_p . x . x [] - cm [- 1 ]* tau_p . x . x [- 1 ])* alpha . x []/( sq ( fm . x [])* Delta ); } #if AXI foreach_face ( y ) if ( y > 0. ) av . y [] -= ( tau_qq [] + tau_qq [ 0 ,- 1 ])* alpha . y []/ sq ( y )/ 2. ; #endif }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code: C/C++ Code",
    "content": "#include\"bcg.h\"#if dimension ==#error \"This implementation does not support 3D due to missing tensor boundary conditions in Basilisk (see cartesian-common.h line ~246).",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code: Context",
    "content": "Use log-conform-viscoelastic-scalar-3D.h for 3D simulations.\"#endif(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation timesymmetric tensor conform_p[],tau_p[];#if AXIscalar conform_qq[],tau_qq[];#endifevent defaults(i=0){if(is_constant(a.x))a=new face vector;foreach(){foreach_dimension(){tau_p.x.x[]=0.;conform_p.x.x[]=1.;}tau_p.x.y[]=0.;conform_p.x.y[]=0.;#if AXItau_qq[]=0;conform_qq[]=1.;#endif}for(scalar s in{tau_p}){s.v.x.i=-1;// just a scalar, not the component of a vectorforeach_dimension(){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}}for(scalar s in{conform_p}){s.v.x.i=-1;// just a scalar, not the component of a vectorforeach_dimension(){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}}#if AXIscalar s1=tau_p.x.y;s1[bottom]=dirichlet(0.);#endif#if AXIscalar s2=conform_p.x.y;s2[bottom]=dirichlet(0.);#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event tracer_advection(i++){tensor Psi=conform_p;#if AXIscalar Psiqq=conform_qq;#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_t A;A.x.y=conform_p.x.y[];foreach_dimension()A.x.x=conform_p.x.x[];",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#if AXIdoubleAqq=conform_qq[];Psiqq[]=log(Aqq);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_v Lambda;pseudo_t R;diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue.Please report this bug by opening an issue on the GitHub repository.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"Negative eigenvalue detected: Lambda.x =%g, Lambda.y =%g\\n\",Lambda.x,Lambda.y);fprintf(ferr,\"x =%g, y =%g\\n\",x,y);exit(1);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "Psi.x.y[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);foreach_dimension()Psi.x.x[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "pseudo_t B;doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubles=-Psi.x.y[];Psi.x.y[]+=dt*(2.*B.x.y+OM*(Psi.y.y[]-Psi.x.x[]));foreach_dimension(){s*=-1;Psi.x.x[]+=dt*2.*(B.x.x+s*OM);}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#if AXIadvection({Psi.x.x,Psi.x.y,Psi.y.y,Psiqq},uf,dt);#elseadvection({Psi.x.x,Psi.x.y,Psi.y.y},uf,dt);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "pseudo_t A={{Psi.x.x[],Psi.x.y[]},{Psi.y.x[],Psi.y.y[]}},R;pseudo_v Lambda;diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;#if AXIdoubleAqq=exp(Psiqq[]);#endif",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);#if AXIAqq=(1.-intFactor)+intFactor*exp(Psiqq[]);#endifA.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "conform_p.x.y[]=A.x.y;tau_p.x.y[]=Gp[]*A.x.y;#if AXIconform_qq[]=Aqq;tau_qq[]=Gp[]*(Aqq-1.);#endifforeach_dimension(){conform_p.x.x[]=A.x.x;tau_p.x.x[]=Gp[]*(A.x.x-1.);}}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic.h | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event acceleration(i++){face vector av=a;foreach_face()if(fm.x[]>1e-20){doubleshear=(tau_p.x.y[0,1]*cm[0,1]+tau_p.x.y[-1,1]*cm[-1,1]-tau_p.x.y[0,-1]*cm[0,-1]-tau_p.x.y[-1,-1]*cm[-1,-1])/4.;av.x[]+=(shear+cm[]*tau_p.x.x[]-cm[-1]*tau_p.x.x[-1])*alpha.x[]/(sq(fm.x[])*Delta);}#if AXIforeach_face(y)if(y>0.)av.y[]-=(tau_qq[]+tau_qq[0,-1])*alpha.y[]/sq(y)/2.;#endif}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/src-local/log-conform-viscoelastic.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData-elastic-scalar2D.c This program extracts and processes data from fluid dynamics simulation snapshots, specifically designed for viscoela... getFacet2D.c A utility for extracting interface facets from fluid simulation data. VideoAxi.py Viscoelastic Visualization Tool =========================================== This script processes and visualizes flui...",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "postProcess/VideoAxi.py See raw file #!/usr/bin/env python3 # -*- coding: utf-8 -*- Viscoelastic Visualization Tool This script processes and visualizes fluid dynamics simulation data, particularly focused on droplet impact and deformable soft matter like liquid drops, sheets, and bubbles. It extracts interface positions and scalar field data from simulation files and creates visualizations showing physical quantities like strain rates and stresses. The script is designed to process multiple simulation snapshots in parallel, extracting data using external executables and generating visualizations with proper colormaps, scales, and mathematical labels.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Features: - Extracts...",
    "content": "Features: - Extracts fluid interfaces and scalar fields from simulation files - Generates visualizations with proper colormaps and mathematical labels - Processes multiple timesteps in parallel using multiprocessing - Configurable via command-line arguments for different simulation cases - Creates publication-quality figures with LaTeX-rendered mathematical expressions Usage: python fluid_vis.py [options] Command-line Arguments: \u2013CPUs Number of CPUs to use for parallel processing (default: all available) \u2013nGFS Number of restart files to process (default: 550) \u2013ZMAX Maximum Z coordinate for visualization (default: 4.0) \u2013RMAX Maximum R coordinate for visualization (default: 2.0) \u2013ZMIN Minimum Z coordinate for visualization (default: -4.0) \u2013caseToProcess Path to simulation case directory (default: \u2018../simulationCases/dropImpact\u2019) \u2013folderToSave Directory to save visualization images (default: \u2018dropImpact\u2019) Dependencies: External executables: getFacet2D, getData-elastic-scalar2D Python libraries: numpy, matplotlib, subprocess, multiprocessing Author: Vatsal Sanjay Email: vatsalsanjay@gmail.com Affiliation: Physics of Fluids Last updated: Jul 24, 2024 import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import multiprocessing as mp from functools import partial import argparse import matplotlib.colors as mcolors custom_colors = [ \"white\" , \"#DA8A67\" , \"#A0522D\" , \"#400000\" ] custom_cmap = mcolors.LinearSegmentedColormap.from_list( \"custom_hot\" , custom_colors) # Configure matplotlib for publication-quality figures with LaTeX rendering matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' def gettingFacets(filename, includeCoat = 'true' ): Extract interface positions (facets) from simulation files.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Args: filename (str):...",
    "content": "Args: filename (str): Path to simulation snapshot file includeCoat (str, optional): Whether to include coating layer. Defaults to \u2018true\u2019. Returns: list: List of line segments defining fluid interfaces exe = [ \"./getFacet2D\" , filename, includeCoat] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) skip = True return segs def gettingfield(filename, zmin, zmax, rmax, nr): Extract scalar field data from simulation files.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Args: filename (str):...",
    "content": "Args: filename (str): Path to simulation snapshot file zmin (float): Minimum Z coordinate zmax (float): Maximum Z coordinate rmax (float): Maximum R coordinate nr (int): Number of grid points in R direction Returns: tuple: (R, Z, D2, vel, taup, nz) arrays of coordinates and field values exe = [ \"./getData-elastic-scalar2D\" , filename, str (zmin), str ( 0 ), str (zmax), str (rmax), str (nr)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, D2temp, veltemp, taupTemp = [],[],[],[],[] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) D2temp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) taupTemp.append( float (temp3[ 4 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) taup = np.asarray(taupTemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) taup.resize((nz, nr)) return R, Z, D2, vel, taup, nz # ---------------------------------------------------------------------------------------------------------------------- def process_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw, caseToProcess): Process a single timestep from simulation data and generate visualization.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Args: ti (int):...",
    "content": "Args: ti (int): Timestep index folder (str): Directory to save output images nGFS (int): Total number of timesteps GridsPerR (int): Grid points per unit length in R direction rmin (float): Minimum R coordinate rmax (float): Maximum R coordinate zmin (float): Minimum Z coordinate zmax (float): Maximum Z coordinate lw (float): Line width for plot elements caseToProcess (str): Path to simulation case directory t = 0.01 * ti place = f\" { caseToProcess } /intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" if not os.path.exists(place): print ( f\" { place } File not found!\" ) return if os.path.exists(name): print ( f\" { name } Image present!\" ) return segs1 = gettingFacets(place) segs2 = gettingFacets(place, 'false' ) if not segs1 and not segs2: print ( f\"Problem in the available file { place } \" ) return nr = int (GridsPerR * rmax) R, Z, taus, vel, taup, nz = gettingfield(place, zmin, zmax, rmax, nr) zminp, zmaxp, rminp, rmaxp = Z. min (), Z. max (), R. min (), R. max () # Plotting AxesLabel, TickLabel = 50 , 20 fig, ax = plt.subplots() fig.set_size_inches( 19.20 , 10.80 ) # Draw domain boundaries ax.plot([ 0 , 0 ], [zmin, zmax], '-.' , color = 'grey' , linewidth = lw) ax.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Add fluid interfaces line_segments = LineCollection(segs2, linewidths = 4 , colors = 'green' , linestyle = 'solid' ) ax.add_collection(line_segments) line_segments = LineCollection(segs1, linewidths = 4 , colors = 'blue' , linestyle = 'solid' ) ax.add_collection(line_segments) # Plot scalar fields with colormaps cntrl1 = ax.imshow(taus, cmap = \"hot_r\" , interpolation = 'Bilinear' , origin = 'lower' , extent = [ - rminp, - rmaxp, zminp, zmaxp], vmax = 2.0 , vmin =- 3.0 ) # TODO : fixme the colorbar bounds for taup must be set manually based on the simulated case. cntrl2 = ax.imshow(taup, interpolation = 'Bilinear' , cmap = custom_cmap, origin = 'lower' , extent = [rminp, rmaxp, zminp, zmaxp], vmax = 2.0 , vmin =- 3.0 ) # Set plot properties ax.set_aspect( 'equal' ) ax.set_xlim(rmin, rmax) ax.set_ylim(zmin, zmax) ax.set_title( f'$t/ \\\\ tau_ \\\\ gamma$ = { t :4.3f} ' , fontsize = TickLabel) # Add colorbars l, b, w, h = ax.get_position().bounds # Left colorbar cb1 = fig.add_axes([l - 0.04 , b, 0.03 , h]) c1 = plt.colorbar(cntrl1, cax = cb1, orientation = 'vertical' ) c1.set_label( r' $ \\ log_ {10} \\ left ( \\| \\m athcal{D} \\|\\r ight ) $ ' , fontsize = TickLabel, labelpad = 5 ) c1.ax.tick_params(labelsize = TickLabel) c1.ax.yaxis.set_ticks_position( 'left' ) c1.ax.yaxis.set_label_position( 'left' ) c1.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.1f} ' )) # Right colorbar cb2 = fig.add_axes([l + w + 0.01 , b, 0.03 , h]) c2 = plt.colorbar(cntrl2, cax = cb2, orientation = 'vertical' ) c2.ax.tick_params(labelsize = TickLabel) c2.set_label( r' $ \\ log_ {10} \\ left ( \\t ext{tr} \\ left ( \\m athcal{A} \\r ight ) -1 \\r ight ) $ ' , fontsize = TickLabel) c2.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.2f} ' )) ax.axis( 'off' ) plt.savefig(name, bbox_inches = \"tight\" ) plt.close() def main(): Main function that parses command-line arguments and parallelizes processing of timesteps. # Set up command-line argument parsing parser = argparse.ArgumentParser(description = 'Process fluid dynamics simulation data and create visualizations' ) parser.add_argument( '--CPUs' , type = int , default = mp.cpu_count(), help = 'Number of CPUs to use (default: all available)' ) parser.add_argument( '--nGFS' , type = int , default = 550 , help = 'Number of restart files to process (default: 550)' ) parser.add_argument( '--ZMAX' , type = float , default = 4.0 , help = 'Maximum Z value (default: 4.0)' ) parser.add_argument( '--RMAX' , type = float , default = 2.0 , help = 'Maximum R value (default: 2.0)' ) parser.add_argument( '--ZMIN' , type = float , default =- 4.0 , help = 'Minimum Z value (default: -4.0)' ) parser.add_argument( '--caseToProcess' , type = str , default = '../simulationCases/dropImpact' , help = 'Case to process (default: ../simulationCases/dropImpact)' ) parser.add_argument( '--folderToSave' , type = str , default = 'dropImpact' , help = 'Folder to save output images (default: dropImpact)' ) args = parser.parse_args() # Extract arguments CPUStoUse = args.CPUs nGFS = args.nGFS ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN num_processes = CPUStoUse rmin, rmax, zmin, zmax = [ - RMAX, RMAX, ZMIN, ZMAX] GridsPerR = 128 # Grid resolution parameter lw = 2 # Line width for plot elements folder = args.folderToSave caseToProcess = args.caseToProcess # Create output directory if it doesn't exist if not os.path.isdir(folder): os.makedirs(folder) # Create a pool of worker processes for parallel processing with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments process_func = partial(process_timestep, folder = folder, nGFS = nGFS, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw, caseToProcess = caseToProcess) # Map the process_func to all timesteps pool. map (process_func, range (nGFS)) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Methods",
    "content": "importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportmultiprocessingasmpfromfunctoolsimportpartialimportargparseimportmatplotlib.colorsasmcolorscustom_colors=[\"white\",\"#DA8A67\",\"#A0522D\",\"#400000\"]custom_cmap=mcolors.LinearSegmentedColormap.from_list(\"custom_hot\", custom_colors)# Configure matplotlib for publication-quality figures with LaTeX renderingmatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'defgettingFacets(filename, includeCoat='true'):",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "exe=[\"./getFacet2D\", filename, includeCoat]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, zmax, rmax, nr):",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "exe=[\"./getData-elastic-scalar2D\", filename,str(zmin),str(0),str(zmax),str(rmax),str(nr)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, D2temp, veltemp, taupTemp=[],[],[],[],[]forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))D2temp.append(float(temp3[2]))veltemp.append(float(temp3[3]))taupTemp.append(float(temp3[4]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)taup=np.asarray(taupTemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))taup.resize((nz, nr))returnR, Z, D2, vel, taup, nz# ----------------------------------------------------------------------------------------------------------------------defprocess_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw, caseToProcess):",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "t=0.01*tiplace=f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"ifnotos.path.exists(place):print(f\"{place}File not found!\")returnifos.path.exists(name):print(f\"{name}Image present!\")returnsegs1=gettingFacets(place)segs2=gettingFacets(place,'false')ifnotsegs1andnotsegs2:print(f\"Problem in the available file{place}\")returnnr=int(GridsPerR*rmax)R, Z, taus, vel, taup, nz=gettingfield(place, zmin, zmax, rmax, nr)zminp, zmaxp, rminp, rmaxp=Z.min(), Z.max(), R.min(), R.max()# PlottingAxesLabel, TickLabel=50,20fig, ax=plt.subplots()fig.set_size_inches(19.20,10.80)# Draw domain boundariesax.plot([0,0], [zmin, zmax],'-.', color='grey', linewidth=lw)ax.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Add fluid interfacesline_segments=LineCollection(segs2, linewidths=4, colors='green', linestyle='solid')ax.add_collection(line_segments)line_segments=LineCollection(segs1, linewidths=4, colors='blue', linestyle='solid')ax.add_collection(line_segments)# Plot scalar fields with colormapscntrl1=ax.imshow(taus, cmap=\"hot_r\", interpolation='Bilinear', origin='lower',extent=[-rminp,-rmaxp, zminp, zmaxp], vmax=2.0, vmin=-3.0)#TODO: fixme the colorbar bounds for taup must be set manually based on the simulated case.cntrl2=ax.imshow(taup, interpolation='Bilinear', cmap=custom_cmap, origin='lower',extent=[rminp, rmaxp, zminp, zmaxp], vmax=2.0, vmin=-3.0)# Set plot propertiesax.set_aspect('equal')ax.set_xlim(rmin, rmax)ax.set_ylim(zmin, zmax)ax.set_title(f'$t/\\\\tau_\\\\gamma$ ={t:4.3f}', fontsize=TickLabel)# Add colorbarsl, b, w, h=ax.get_position().bounds# Left colorbarcb1=fig.add_axes([l-0.04, b,0.03, h])c1=plt.colorbar(cntrl1, cax=cb1, orientation='vertical')c1.set_label(r'$\\log_{10}\\left(\\|\\mathcal{D}\\|\\right)$', fontsize=TickLabel, labelpad=5)c1.ax.tick_params(labelsize=TickLabel)c1.ax.yaxis.set_ticks_position('left')c1.ax.yaxis.set_label_position('left')c1.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}'))# Right colorbarcb2=fig.add_axes([l+w+0.01, b,0.03, h])c2=plt.colorbar(cntrl2, cax=cb2, orientation='vertical')c2.ax.tick_params(labelsize=TickLabel)c2.set_label(r'$\\log_{10}\\left(\\text{tr}\\left(\\mathcal{A}\\right)-1\\right)$', fontsize=TickLabel)c2.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.2f}'))ax.axis('off')plt.savefig(name, bbox_inches=\"tight\")plt.close()defmain():",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: # Set up...",
    "content": "# Set up command-line argument parsingparser=argparse.ArgumentParser(description='Process fluid dynamics simulation data and create visualizations')parser.add_argument('--CPUs',type=int, default=mp.cpu_count(),help='Number of CPUs to use (default: all available)')parser.add_argument('--nGFS',type=int, default=550,help='Number of restart files to process (default: 550)')parser.add_argument('--ZMAX',type=float, default=4.0,help='Maximum Z value (default: 4.0)')parser.add_argument('--RMAX',type=float, default=2.0,help='Maximum R value (default: 2.0)')parser.add_argument('--ZMIN',type=float, default=-4.0,help='Minimum Z value (default: -4.0)')parser.add_argument('--caseToProcess',type=str,default='../simulationCases/dropImpact',help='Case to process (default: ../simulationCases/dropImpact)')parser.add_argument('--folderToSave',type=str, default='dropImpact',help='Folder to save output images (default: dropImpact)')args=parser.parse_args()# Extract argumentsCPUStoUse=args.CPUsnGFS=args.nGFSZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMINnum_processes=CPUStoUsermin, rmax, zmin, zmax=[-RMAX, RMAX, ZMIN, ZMAX]GridsPerR=128# Grid resolution parameterlw=2# Line width for plot elementsfolder=args.folderToSavecaseToProcess=args.caseToProcess# Create output directory if it doesn't existifnotos.path.isdir(folder):os.makedirs(folder)# Create a pool of worker processes for parallel processingwithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed argumentsprocess_func=partial(process_timestep,folder=folder, nGFS=nGFS,GridsPerR=GridsPerR, rmin=rmin, rmax=rmax,zmin=zmin, zmax=zmax, lw=lw, caseToProcess=caseToProcess)# Map the process_func to all timestepspool.map(process_func,range(nGFS))if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "postProcess/getData-elastic-scalar2D.c See raw file Simulation Data Extraction and Processing This program extracts and processes data from fluid dynamics simulation snapshots, specifically designed for viscoelastic fluid simulations with conformation tensor analysis. It computes important derived quantities including deformation rate tensor components, velocity magnitude, and conformation tensor trace. The program interpolates these quantities onto a regular grid and outputs the results for further analysis or visualization. Physics Background This code handles viscoelastic fluid simulation data where the fluid stress tensor includes both a viscous component (proportional to the deformation rate) and an elastic component (represented by the conformation tensor).",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Code",
    "content": "The trace of the conformation tensor provides a measure of polymer stretching in the fluid. #include \"utils.h\" #include \"output.h\" scalar f []; // Volume fraction field vector u []; // Velocity field scalar A11 [], A12 [], A22 []; // Conformation tensor components scalar conform_qq []; // Additional conformation tensor component char filename [ 80 ]; // Input file name int nx , ny , len ; // Grid dimensions and field count double xmin , ymin , xmax , ymax , Deltax , Deltay ; // Domain boundaries and grid spacing Derived Fields D2c: Log10 of squared deformation rate tensor weighted by volume fraction vel: Magnitude of velocity trA: Log10 of excess trace of conformation tensor scalar D2c [], vel [], trA []; scalar * list = NULL ; // List to store output fields Main Function Processes simulation data and computes derived quantities Arguments: arguments[1]: Input filename arguments[2-5]: Domain boundaries (xmin, ymin, xmax, ymax) arguments[6]: Number of grid points in y-direction (ny) Returns: 0 on successful execution int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); // Initialize list of fields to output list = list_add ( list , D2c ); list = list_add ( list , vel ); list = list_add ( list , trA ); Data Processing Workflow Restore simulation state from snapshot file Compute derived quantities at each grid point Interpolate fields onto regular grid Output data to file restore ( file = filename ); Field Computation For each cell, compute: - Components of the deformation rate tensor D - Squared magnitude of D weighted by volume fraction - Velocity magnitude - Excess trace of the conformation tensor foreach () { // Compute deformation rate tensor components double D11 = ( u . y [ 0 , 1 ] - u . y [ 0 , - 1 ]) / ( 2 * Delta ); double D22 = ( u . y [] / y ); double D33 = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ]) / ( 2 * Delta ); double D13 = 0.5 * (( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 , - 1 ]) / ( 2 * Delta )); double D2 = ( sq ( D11 ) + sq ( D22 ) + sq ( D33 ) + 2.0 * sq ( D13 )); D2c [] = f [] * D2 ; // Take log10 of D2c for better visualization if ( D2c [] > 0. ) { D2c [] = log ( D2c []) / log ( 10 ); } else { D2c [] = - 10 ; } // Compute velocity magnitude vel [] = sqrt ( sq ( u . x []) + sq ( u . y [])); // Compute excess trace of conformation tensor trA [] = ( A11 [] + A22 [] + conform_qq []) / 3.0 - 1.0 ; // Take log10 of trA for better visualization if ( trA [] > 0. ) { trA [] = log ( trA []) / log ( 10 ); } else { trA [] = - 10 ; } } Grid Interpolation and Output Calculate grid spacing based on domain size and ny Allocate memory for interpolated field values Interpolate field values onto regular grid Output grid coordinates and field values FILE * fp = ferr ; Deltay = ( double )(( ymax - ymin ) / ( ny )); nx = ( int )(( xmax - xmin ) / Deltay ); Deltax = ( double )(( xmax - xmin ) / ( nx )); len = list_len ( list ); // Allocate memory for field values double ** field = ( double **) matrix_new ( nx , ny + 1 , len * sizeof ( double )); // Interpolate field values onto regular grid for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; int k = 0 ; for ( scalar s in list ) { field [ i ][ len * j + k ++] = interpolate ( s , x , y ); } } } // Output grid coordinates and field values for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; fprintf ( fp , \" %g %g \" , x , y ); int k = 0 ; for ( scalar s in list ) { fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } // Clean up fflush ( fp ); fclose ( fp ); matrix_free ( field ); return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"scalar f[];// Volume fraction fieldvector u[];// Velocity fieldscalar A11[],A12[],A22[];// Conformation tensor componentsscalar conform_qq[];// Additional conformation tensor componentcharfilename[80];// Input file nameintnx,ny,len;// Grid dimensions and field countdoublexmin,ymin,xmax,ymax,Deltax,Deltay;// Domain boundaries and grid spacing",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "scalar D2c[],vel[],trA[];scalar*list=NULL;// List to store output fields",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);// Initialize list of fields to outputlist=list_add(list,D2c);list=list_add(list,vel);list=list_add(list,trA);",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: foreach(){// Compute deformation...",
    "content": "foreach(){// Compute deformation rate tensor componentsdoubleD11=(u.y[0,1]-u.y[0,-1])/(2*Delta);doubleD22=(u.y[]/y);doubleD33=(u.x[1,0]-u.x[-1,0])/(2*Delta);doubleD13=0.5*((u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(2*Delta));doubleD2=(sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13));D2c[]=f[]*D2;// Take log10 of D2c for better visualizationif(D2c[]>0.){D2c[]=log(D2c[])/log(10);}else{D2c[]=-10;}// Compute velocity magnitudevel[]=sqrt(sq(u.x[])+sq(u.y[]));// Compute excess trace of conformation tensortrA[]=(A11[]+A22[]+conform_qq[])/3.0-1.0;// Take log10 of trA for better visualizationif(trA[]>0.){trA[]=log(trA[])/log(10);}else{trA[]=-10;}}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "FILE*fp=ferr;Deltay=(double)((ymax-ymin)/(ny));nx=(int)((xmax-xmin)/Deltay);Deltax=(double)((xmax-xmin)/(nx));len=list_len(list);// Allocate memory for field valuesdouble**field=(double**)matrix_new(nx,ny+1,len*sizeof(double));// Interpolate field values onto regular gridfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y);}}}// Output grid coordinates and field valuesfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;fprintf(fp,\"%g%g\",x,y);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}// Clean upfflush(fp);fclose(fp);matrix_free(field);return0;}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "postProcess/getFacet2D.c See raw file Getting Facets A utility for extracting interface facets from fluid simulation data. Description This program extracts and outputs the facets representing the interface between different phases in a multiphase flow simulation. The facets define the boundary between fluid phases, useful for geometric analysis and visualization of the interface morphology. Physics Background In multiphase fluid simulations, interfaces between different fluids are critical features that determine many physical phenomena like surface tension effects, droplet formation, and coalescence events. This utility identifies these interfaces by extracting facets from volume fraction data, allowing for quantitative analysis of interfacial dynamics.",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Code",
    "content": "Usage ./getFacets input_file Author: Vatsal Sanjay vatsalsanjay@gmail.com Physics of Fluids Department University of Twente #include \"utils.h\" #include \"output.h\" #include \"fractions.h\" scalar f []; // Volume fraction field char filename [ 80 ]; Main Function Loads a simulation snapshot and extracts the interface facets. Input parameters: arguments[1] : Filename of the simulation snapshot to process Process: Restores the simulation state from the specified file Extracts interface facets from the volume fraction field Outputs facet data to standard error Return value: Returns 0 on successful completion Note: The facet extraction algorithm identifies where the volume fraction field crosses a threshold value (typically 0.5) between adjacent cells. int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); restore ( file = filename ); FILE * fp = ferr ; output_facets ( f , fp ); fflush ( fp ); fclose ( fp ); return 0 ; }",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"fractions.h\"scalar f[];// Volume fraction fieldcharfilename[80];",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | Viscoelastic Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);restore(file=filename);FILE*fp=ferr;output_facets(f,fp);fflush(fp);fclose(fp);return0;}",
    "url": "https://comphy-lab.org/Viscoelastic-Worthington-jets-and-droplets-produced-by-bursting-bubbles/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Herschel-Bulkley Worthington Jets...",
    "content": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles This repository contains the simulation code and analysis for studying the dynamics of Herschel-Bulkley Worthington jets and droplets produced by bursting bubbles.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: JavaScript",
    "content": "The code uses the Basilisk framework to simulate bubble cavity collapse in non-Newtonian media, examining how power-law index, yield stress, and viscosity affect jet and droplet formation. basilisk/src/ - Core Basilisk CFD library (reference only, do not modify) simulationCases/ - Simulation cases and input/output data burstingBubbleHB.c - Main Herschel-Bulkley bursting bubble simulation initial-condition-test.ipynb - Jupyter notebook for initial condition tests Makefile - Makefile for compiling/running cases runMake.sh - Helper script for running make src-local/ - Custom header files extending Basilisk functionality two-phaseVP-HB.h - Herschel-Bulkley two-phase flow model postProcess/ - Project-specific post-processing tools getData.c - Data extraction utility getFacets.c - Facet extraction utility video.py - Python script for video/visualization reset_install_requirements.sh - Script to set up Basilisk and dependencies Overview The project investigates how non-Newtonian behavior influences bubble bursting dynamics by exploring the phase space of effective Ohnesorge number, power-law index, and plasto-capillary number using volume of fluid-based finite volume simulations.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Results",
    "content": "The results demonstrate how shear-thinning/thickening behavior and yield stress significantly influence the overall dynamics through the interplay of viscous and plastic effects. Installation and Setup To ensure you have the necessary tools and a fresh Basilisk installation, use the provided script: ./reset_install_requirements.sh Function This script checks for Basilisk installation and compiles it if not present. OS Compatibility Designed for macOS. If you encounter issues on Linux, please open a GitHub issue. Dependencies Basilisk C is fetched and built automatically. Xcode Command Line Tools (macOS) or equivalent compiler toolchain (Linux) are required. Environment Setup After running the script, a .project_config file is created, setting BASILISK and PATH automatically.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "If you have previously installed Basilisk or changed dependencies, re-run the script with --hard : ./reset_install_requirements.sh --hard Running the Code Recommended Method: Using Makefile The easiest way to compile and run the code is using the Makefile approach: Navigate to the testCases directory: cd testCases Compile and run using make (this runs the code interactively using the browser): CFLAGS = -DDISPLAY=-1 make burstingBubbleVE.tst To run the code non-interactively, use the following command: make burstingBubbleVE.tst Alternative Method: Direct Compilation You can compile the code directly using qcc in two ways: Using include paths (recommended): qcc -O2 -Wall -disable-dimensions -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm Without include paths: qcc -O2 -Wall -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm Note : If using method 2, you must first manually copy the src-local folder to your running directory.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Local Execution MacOS:...",
    "content": "Local Execution MacOS: # First source the configuration source .project_config # Compile using include paths (recommended) qcc -O2 -Wall -disable-dimensions -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm # Or compile without include paths (requires manually copying src-local folder) qcc -O2 -Wall -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm # Run the executable, only supports serial execution ./burstingBubbleVE Linux: # First source the configuration source .project_config # Compile using include paths (recommended) qcc -O2 -Wall -disable-dimensions -fopenmp -I $( PWD ) /src-local -I $( PWD ) /../src-local burstingBubbleVE.c -o burstingBubbleVE -lm # Or compile without include paths (requires manually copying src-local folder) qcc -O2 -Wall -disable-dimensions -fopenmp burstingBubbleVE.c -o burstingBubbleVE -lm # Set the number of OpenMP threads export OMP_NUM_THREADS = 4 # Run the executable ./burstingBubbleVE HPC Cluster Execution (e.g., Snellius) For cluster environments, it is strongly recommended to manually copy the src-local folder to your working directory to ensure reliable compilation across different cluster configurations: First, copy the required files: cp -r /path/to/original/src-local .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Compile the code...",
    "content": "Compile the code for MPI: CC99 = 'mpicc -std=c99' qcc -Wall -O2 -D_MPI = 1 -disable-dimensions burstingBubbleVE.c -o burstingBubbleVE -lm Create a SLURM job script (e.g., run_simulation.sh ): #!/bin/bash #SBATCH --nodes=1 #SBATCH --ntasks=32 #SBATCH --time=1:00:00 #SBATCH --partition=genoa #SBATCH --mail-type=ALL #SBATCH --mail-user=v.sanjay@utwente.nl srun --mpi = pmi2 -n 32 --gres = cpu:32 --mem-per-cpu = 1750mb burstingBubbleVE Submit the job: sbatch run_simulation.sh Additional Running Scripts The z_extras/running directory contains supplementary materials and post-processing tools used in the analysis. This includes C-based data extraction utilities, Python visualization scripts, and analysis notebooks. These tools were used to process simulation outputs and generate figures for the study. For detailed documentation of these tools, see the README in the z_extras directory. Contributing Issues & Contributions : Please file bug reports, feature requests, or pull requests on GitHub .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: When creating an...",
    "content": "When creating an issue, please: For bug reports: Include the error message, OS version, and steps to reproduce the issue For feature requests: Clearly describe the proposed feature and its use case For questions: Check existing issues and documentation first We welcome contributions! Please feel free to submit a Pull Request. Reset Install Requirements Script The reset_install_requirements.sh script is designed to reset the installation requirements for the project. This can be useful when you want to ensure that all dependencies are fresh and up-to-date. Purpose The script re-installs all required packages as specified in the requirements file, ensuring that the project\u2019s dependencies are up-to-date and consistent. Usage To run the script, use the following command in your terminal: bash reset_install_requirements.sh Make sure to have the necessary permissions to execute the script.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Citation If you...",
    "content": "Citation If you use this code in your research, please cite: Software Authors Vatsal Sanjay (University of Twente), vatsalsanjay@gmail.com License This project is licensed under standard academic terms. Please cite the paper and software if you use this code in your research. Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/getData.c postProcess/getFacets.c postProcess/video.py simulationCases simulationCases/Makefile simulationCases/burstingBubbleHB.c simulationCases/initial-condition-test.ipynb simulationCases/runMake.sh src-local src-local/two-phaseVP-HB.h",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "qcc-O2-Wall-disable-dimensions-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "qcc-O2-Wall-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# First source the configurationsource.project_config# Compile using include paths (recommended)qcc-O2-Wall-disable-dimensions-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm# Or compile without include paths (requires manually copying src-local folder)qcc-O2-Wall-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm# Run the executable, only supports serial execution./burstingBubbleVE",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# First source the configurationsource.project_config# Compile using include paths (recommended)qcc-O2-Wall-disable-dimensions-fopenmp-I$(PWD)/src-local-I$(PWD)/../src-local burstingBubbleVE.c-oburstingBubbleVE-lm# Or compile without include paths (requires manually copying src-local folder)qcc-O2-Wall-disable-dimensions-fopenmpburstingBubbleVE.c-oburstingBubbleVE-lm# Set the number of OpenMP threadsexportOMP_NUM_THREADS=4# Run the executable./burstingBubbleVE",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "CC99='mpicc -std=c99'qcc-Wall-O2-D_MPI=1-disable-dimensionsburstingBubbleVE.c-oburstingBubbleVE-lm",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#!/bin/bash#SBATCH --nodes=1#SBATCH --ntasks=32#SBATCH --time=1:00:00#SBATCH --partition=genoa#SBATCH --mail-type=ALL#SBATCH --mail-user=v.sanjay@utwente.nlsrun--mpi=pmi2-n32--gres=cpu:32--mem-per-cpu=1750mb burstingBubbleVE",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # tested on MacOS only.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue. # modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk # Check if --hard flag is passed HARD_RESET = \\f alse if [[ \" \\$ 1\" == \"--hard\" ]]; then HARD_RESET = \\t rue fi # Function to install basilisk install_basilisk() { darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make -k make } # Remove project config always rm -rf .project_config # Check if basilisk needs to be installed if [[ \" \\$ HARD_RESET\" == true ]] || [[ ! -d \"basilisk\" ]]; then echo \"Installing basilisk...\" rm -rf basilisk install_basilisk else echo \"Using existing basilisk installation...\" cd basilisk/src fi # Setup environment variables echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config # Check if qcc is working properly echo \"\\nChecking qcc installation...\" if ! qcc --version > /dev/null 2 >& 1 ; then echo \"\\033[0;31mError: qcc is not working properly.\\033[0m\" echo \"Please ensure you have Xcode Command Line Tools installed.\" echo \"You can install them by running: xcode-select --install\" echo \"For more details, visit: http://basilisk.fr/src/INSTALL\" exit 1 else echo \"\\033[0;32mqcc is properly installed.\\033[0m\" qcc --version fi",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: #!/bin/zsh# tested on...",
    "content": "#!/bin/zsh# tested on MacOS only.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue.# modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basilisk# Check if --hard flag is passedHARD_RESET=\\falseif[[\"\\$1\"==\"--hard\"]];thenHARD_RESET=\\truefi# Function to install basiliskinstall_basilisk(){darcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake-kmake}# Remove project config alwaysrm-rf.project_config# Check if basilisk needs to be installedif[[\"\\$HARD_RESET\"==true]]||[[!-d\"basilisk\"]];thenecho\"Installing basilisk...\"rm-rfbasiliskinstall_basiliskelseecho\"Using existing basilisk installation...\"cdbasilisk/srcfi# Setup environment variablesecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config# Check if qcc is working properlyecho\"\\nChecking qcc installation...\"if!qcc--version>/dev/null2>&1;thenecho\"\\033[0;31mError: qcc is not working properly.\\033[0m\"echo\"Please ensure you have Xcode Command Line Tools installed.\"echo\"You can install them by running: xcode-select --install\"echo\"For more details, visit: http://basilisk.fr/src/INSTALL\"exit1elseecho\"\\033[0;32mqcc is properly installed.\\033[0m\"qcc--versionfi",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases burstingBubbleHB.c This simulation models the dynamics of bursting bubbles in Herschel-Bulkley media, with particular focus on Worthingt... initial-condition-test.ipynb The basilisk script needs the points to be sorted such that the first point is the south pole of the bubble cavity th... Makefile ifeq (\\$(wildcard ../.projectconfig),) \\$(error '../.projectconfig not found') endif BASILISK := \\$(shell . ../.proje... runMake.sh source ../.projectconfig echo \\$BASILISK mkdir -p \\$1 qcc -O2 -Wall -disable-dimensions -I\\$(PWD)/src-local -I\\$(PWD)...",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/initial-condition-test.ipynb | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "simulationCases/initial-condition-test.ipynb See raw file Reverse engineer to fix bug Jupyter Notebook: Reverse engineer to fix bug Download Notebook View in nbviewer Open in Colab About this notebook The basilisk script needs the points to be sorted such that the first point is the south pole of the bubble cavity then you walk along the liquid-gas interface towards the bubble cap and then join to the far field liquid-gas interface (which is a straight line). Key Features: Visualization of data and results Analysis of simulation outputs Interactive exploration of parameters Tip: For the best interactive experience, download the notebook or open it in Google Colab. Notebook Preview Notebook Preview Unavailable The notebook preview could not be loaded.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/initial-condition-test.ipynb.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/initial-condition-test.ipynb | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: This may be...",
    "content": "This may be because: The notebook file is not yet available in the repository The nbviewer service is temporarily unavailable The repository is private or has access restrictions You can still download the notebook using the button above or view it directly through one of the external services.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/initial-condition-test.ipynb.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles",
    "content": "simulationCases/Makefile See raw file Makefile # Check if .project_config exists ifeq ( \\$ ( wildcard ../.project_config ) , ) \\$ ( error \"../.project_config not found\" ) endif BASILISK := \\$ ( shell . ../.project_config && echo \\$\\$ BASILISK ) CFLAGS += -O2 -disable-dimensions CFLAGS += -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local # Fix permissions for runtest script fix-permissions: @chmod +x \\$ ( BASILISK ) /src/runtest # Make all test targets depend on fix-permissions %.tst: fix-permissions include \\$ ( BASILISK ) /Makefile.defs",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/Makefile.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "# Check if .project_config existsifeq(\\$(wildcard../.project_config),)\\$(error\"../.project_config not found\")endifBASILISK:=\\$(shell. ../.project_config&&echo\\$\\$BASILISK)CFLAGS+=-O2-disable-dimensionsCFLAGS+=-I\\$(PWD)/src-local-I\\$(PWD)/../src-local# Fix permissions for runtest scriptfix-permissions:@chmod+x\\$(BASILISK)/src/runtest# Make all test targets depend on fix-permissions%.tst:fix-permissionsinclude\\$(BASILISK)/Makefile.defs",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/Makefile.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "simulationCases/burstingBubbleHB.c See raw file Bursting Bubbles in Herschel-Bulkley Media Simulation This simulation models the dynamics of bursting bubbles in Herschel-Bulkley media, with particular focus on Worthington jet formation and droplet ejection. The code implements a two-phase flow model with non-Newtonian rheology using an epsilon-regularisation approach.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: File Information File:...",
    "content": "File Information File: burstingBubbleHB.c Author: Vatsal Sanjay Version: 1.0 Date: Dec 31, 2024 Usage ./program maxLevel n OhK J Bond tmax Parameters maxLevel : Maximum refinement level for adaptive mesh n : Power-law index OhK : k-effective Ohnesorge number for the liquid phase: \\(Oh_k = \\frac{k}{\\sqrt{\\rho^nR_0^{3n-1}\\gamma^{2-n}}}\\) J : Plasto-capillary number: \\(\\mathcal{J} = \\frac{\\tau_yR_0}{\\gamma}\\) Bond : Bond number (ratio of gravitational to surface tension forces): \\(Bo = \\frac{\\rho g R_0^2}{\\gamma}\\) tmax : Maximum simulation time #include \"axi.h\" #include \"navier-stokes/centered.h\" Simulation Configuration Global Parameters FILTERED : Enable density and viscosity jump smoothing tsnap : Time interval between snapshots (default: 1e-2) fErr : Error tolerance for volume fraction (1e-3) KErr : Error tolerance for curvature calculation (1e-6) VelErr : Error tolerance for velocity field (1e-3) D2Err : Error tolerance for conformation inside the liquid (1e-2) Ldomain : Domain size in characteristic lengths (8) #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVP-HB.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #include \"reduced.h\" #if !_MPI #include \"distance.h\" #endif #define tsnap ( 1e-2 ) // 0.001 only for some cases. // Error tolerances #define fErr ( 1e-3 ) // Error tolerance in f1 VOF #define KErr ( 1e-6 ) // Error tolerance in VoF curvature calculated using // height function method (see adapt event) #define VelErr ( 1e-3 ) // Error tolerances in velocity -- Use 1e-2 for low Oh // and 1e-3 to 5e-3 for high Oh/moderate to high J #define D2Err ( 1e-2 ) // Error tolerances in conformation inside the liquid // Domain size #define Ldomain 8 66 // Boundary conditions - outflow on the right boundary u . n [ right ] = neumann ( 0. ); p [ right ] = dirichlet ( 0. ); int MAXlevel ; double OhK , Oha , J , Bond , tmax ; char nameOut [ 80 ], dumpFile [ 80 ], logFile [ 80 ]; Main Function The entry point of the simulation that initializes parameters and starts the simulation run.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Main",
    "content": "Parameters argc : Number of command line arguments argv : Array of command line argument strings Returns Integer status code (0 on successful completion) int main ( int argc , char const * argv []) { L0 = Ldomain ; origin (- L0 / 2. , 0. ); Parameter Initialization Setting default values for simulation parameters. In production runs, these values can be passed from the command line. MAXlevel = 10 ; n = 0.4 ; OhK = 0.001 ; J = 2e-1 ; Bond = 1.1 ; G . x = - Bond ; tmax = 2.5e0 ; epsilon = 1e-2 ; Command Line Argument Parsing To get parameters from the terminal, uncomment the following block. // First ensure that all the variables were transferred properly from the // terminal or job script. if ( argc < 7 ) { fprintf ( ferr , \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Need %d more...",
    "content": "Need %d more \" \"arguments \\n \" , 7 - argc ); return 1 ; } MAXlevel = atoi ( argv [ 1 ]); n = atof ( argv [ 2 ]); OhK = atof ( argv [ 3 ]); J = atof ( argv [ 4 ]); Bond = atof ( argv [ 5 ]); tmax = atof ( argv [ 6 ]); epsilon = 1e-2 ; init_grid ( 1 << 5 ); // Create a folder named intermediate where all the simulation snapshots are stored char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file. See writingFiles event sprintf ( dumpFile , \"restart\" ); // Name of the log file.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: See logWriting event...",
    "content": "See logWriting event sprintf ( logFile , \"logData.dat\" ); Physical Properties Configuration Phase Properties rho1 , rho2 : Density of liquid and gas phases mu1 , mu2 : Dynamic viscosity of liquid and gas phases Dimensionless Numbers Oh : Ohnesorge number for liquid phase Oha : Ohnesorge number for gas phase (= 2e-2 * Oh) J : Plasto-capillary number Bond : Bond number rho1 = 1. , rho2 = 1e-3 ; Oha = 2e-2 * OhK ; mu1 = OhK , mu2 = Oha ; tauy = J ; f . sigma = 1.0 ; TOLERANCE = 1e-4 ; CFL = 1e-1 ; run (); } Initialization Event Sets up the initial conditions for the simulation at t=0.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Function Definition",
    "content": "Process Attempts to restore from a dump file If not available, loads initial shape from data file Sets up distance function and volume fraction event init ( t = 0 ) { #if _MPI // This is for supercomputers without OpenMP support if (! restore ( file = dumpFile )) { fprintf ( ferr , \"Cannot restored from a dump file! \\n \" ); } #else if (! restore ( file = dumpFile )) { char filename [ 60 ]; // sprintf(filename,\"Bo%5.4f-buggy.dat\",Bond); // sprintf(filename,\"Bo%5.4f.dat\",Bond); sprintf ( filename , \"Bo %5.4f -buggy_fixed.dat\" , Bond ); FILE * fp = fopen ( filename , \"rb\" ); if ( fp == NULL ) { fprintf ( ferr , \"There is no file named %s\\n \" , filename ); // Try in folder one level up // sprintf(filename,\"../Bo%5.4f-buggy.dat\",Bond); // sprintf(filename,\"../Bo%5.4f.dat\",Bond); sprintf ( filename , \"../Bo %5.4f -buggy_fixed.dat\" , Bond ); fp = fopen ( filename , \"rb\" ); if ( fp == NULL ) { fprintf ( ferr , \"There is no file named %s\\n \" , filename ); return 1 ; } } coord * InitialShape ; InitialShape = input_xy ( fp ); fclose ( fp ); scalar d []; distance ( d , InitialShape ); while ( adapt_wavelet (( scalar *){ f , d }, ( double []){ 1e-8 , 1e-8 }, MAXlevel ). nf ); // The distance function is defined at the center of each cell, we have // to calculate the value of this function at each vertex. vertex scalar phi []; foreach_vertex () { phi [] = -( d [] + d [- 1 ] + d [ 0 ,- 1 ] + d [- 1 ,- 1 ])/ 4. ; } // We can now initialize the volume fraction of the domain. fractions ( phi , f ); } // return 1; #endif } Adaptive Mesh Refinement Implements wavelet-based adaptive mesh refinement to focus computational resources on areas of interest.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: JavaScript",
    "content": "Refinement Criteria Volume fraction gradient Velocity field changes Conformation tensor variations Curvature details event adapt ( i ++) { scalar KAPPA []; curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , u . x , u . y , D2 , KAPPA }, ( double []){ fErr , VelErr , VelErr , D2Err , KErr }, MAXlevel , MAXlevel - 6 ); } Output Generation Periodically saves simulation state for post-processing and creates snapshots at regular intervals.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Output Files Restart...",
    "content": "Output Files Restart file for continuing simulations Snapshot files for visualization and analysis event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Simulation Termination Executes when the simulation reaches its end time, displaying a summary of key simulation parameters. event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , n %2.1e , OhK %2.1e , Oha %2.1e , J %4.3f , \" \"Bo %4.3f\\n \" , MAXlevel , n , OhK , Oha , J , Bond ); } Simulation Monitoring Tracks key metrics like kinetic energy during simulation and logs to file.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Features Calculates total...",
    "content": "Features Calculates total kinetic energy Logs simulation progress Implements safety checks to stop simulation if instabilities occur event logWriting ( i ++) { // if (i > 5){ // FILE * ftest = fopen(\"test.txt\", \"w\"); // output_facets(f, ftest); // return 1;} double ke = 0. ; foreach ( reduction (+: ke )) { ke += ( 2 * pi * y )*( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y [])))* sq ( Delta ); } if ( pid () == 0 ) { static FILE * fp ; if ( i == 0 ) { fprintf ( ferr , \"Level %d , n %2.1e , OhK %2.1e , Oha %2.1e , J %4.3f , \" \"Bo %4.3f\\n \" , MAXlevel , n , OhK , Oha , J , Bond ); fprintf ( ferr , \"i dt t ke \\n \" ); fp = fopen ( logFile , \"w\" ); fprintf ( fp , \"Level %d , n %2.1e , OhK %2.1e , Oha %2.1e , J %4.3f , \" \"Bo %4.3f\\n \" , MAXlevel , n , OhK , Oha , J , Bond ); fprintf ( fp , \"i dt t ke \\n \" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } else { fp = fopen ( logFile , \"a\" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); assert ( ke > - 1e-10 ); if ( ke > 1e2 && i > 1e1 ) { if ( pid () == 0 ) { fprintf ( ferr , \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" ); fp = fopen ( logFile , \"a\" ); fprintf ( fp , \"The kinetic energy blew up. Stopping simulation \\n \" ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } assert ( ke < 1e2 ); if ( ke < 1e-6 && i > 1e1 ) { if ( pid () == 0 ) { fprintf ( ferr , \"Kinetic energy too small now! Stopping! \\n \" ); dump ( file = dumpFile ); fp = fopen ( logFile , \"a\" ); fprintf ( fp , \"Kinetic energy too small now! Stopping! \\n \" ); fclose ( fp ); return 1 ; } } } }",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code: C/C++ Code",
    "content": "#define FILTERED// Smear density and viscosity jumps#include\"two-phaseVP-HB.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#include\"reduced.h\"#if !_MPI#include\"distance.h\"#endif#define tsnap(1e-2)// 0.001 only for some cases.// Error tolerances#define fErr(1e-3)// Error tolerance in f1 VOF#define KErr(1e-6)// Error tolerance in VoF curvature calculated using// height function method (see adapt event)#define VelErr(1e-3)// Error tolerances in velocity -- Use 1e-2 for low Oh// and 1e-3 to 5e-3 for high Oh/moderate to high J#define D2Err(1e-2)// Error tolerances in conformation inside the liquid// Domain size#define Ldomain866// Boundary conditions - outflow on the right boundaryu.n[right]=neumann(0.);p[right]=dirichlet(0.);intMAXlevel;doubleOhK,Oha,J,Bond,tmax;charnameOut[80],dumpFile[80],logFile[80];",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "intmain(intargc,charconst*argv[]){L0=Ldomain;origin(-L0/2.,0.);",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "MAXlevel=10;n=0.4;OhK=0.001;J=2e-1;Bond=1.1;G.x=-Bond;tmax=2.5e0;epsilon=1e-2;",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "// First ensure that all the variables were transferred properly from the// terminal or job script.if(argc<7){fprintf(ferr,\"Lack of command line arguments. Check! Need%dmore \"\"arguments\\n\",7-argc);return1;}MAXlevel=atoi(argv[1]);n=atof(argv[2]);OhK=atof(argv[3]);J=atof(argv[4]);Bond=atof(argv[5]);tmax=atof(argv[6]);epsilon=1e-2;",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "init_grid(1<<5);// Create a folder named intermediate where all the simulation snapshots are storedcharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file. See writingFiles eventsprintf(dumpFile,\"restart\");// Name of the log file. See logWriting eventsprintf(logFile,\"logData.dat\");",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "rho1=1.,rho2=1e-3;Oha=2e-2*OhK;mu1=OhK,mu2=Oha;tauy=J;f.sigma=1.0;TOLERANCE=1e-4;CFL=1e-1;run();}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event init(t=0){#if _MPI//...",
    "content": "event init(t=0){#if _MPI// This is for supercomputers without OpenMP supportif(!restore(file=dumpFile)){fprintf(ferr,\"Cannot restored from a dump file!\\n\");}#elseif(!restore(file=dumpFile)){charfilename[60];// sprintf(filename,\"Bo%5.4f-buggy.dat\",Bond);// sprintf(filename,\"Bo%5.4f.dat\",Bond);sprintf(filename,\"Bo%5.4f-buggy_fixed.dat\",Bond);FILE*fp=fopen(filename,\"rb\");if(fp==NULL){fprintf(ferr,\"There is no file named%s\\n\",filename);// Try in folder one level up// sprintf(filename,\"../Bo%5.4f-buggy.dat\",Bond);// sprintf(filename,\"../Bo%5.4f.dat\",Bond);sprintf(filename,\"../Bo%5.4f-buggy_fixed.dat\",Bond);fp=fopen(filename,\"rb\");if(fp==NULL){fprintf(ferr,\"There is no file named%s\\n\",filename);return1;}}coord*InitialShape;InitialShape=input_xy(fp);fclose(fp);scalar d[];distance(d,InitialShape);while(adapt_wavelet((scalar*){f,d},(double[]){1e-8,1e-8},MAXlevel).nf);// The distance function is defined at the center of each cell, we have// to calculate the value of this function at each vertex.vertex scalar phi[];foreach_vertex(){phi[]=-(d[]+d[-1]+d[0,-1]+d[-1,-1])/4.;}// We can now initialize the volume fraction of the domain.fractions(phi,f);}// return 1;#endif}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);adapt_wavelet((scalar*){f,u.x,u.y,D2,KAPPA},(double[]){fErr,VelErr,VelErr,D2Err,KErr},MAXlevel,MAXlevel-6);}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, n%2.1e, OhK%2.1e, Oha%2.1e, J%4.3f, \"\"Bo%4.3f\\n\",MAXlevel,n,OhK,Oha,J,Bond);}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: event logWriting(i++){// if...",
    "content": "event logWriting(i++){// if (i > 5){// FILE * ftest = fopen(\"test.txt\", \"w\");// output_facets(f, ftest);// return 1;}doubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])))*sq(Delta);}if(pid()==0){staticFILE*fp;if(i==0){fprintf(ferr,\"Level%d, n%2.1e, OhK%2.1e, Oha%2.1e, J%4.3f, \"\"Bo%4.3f\\n\",MAXlevel,n,OhK,Oha,J,Bond);fprintf(ferr,\"i dt t ke\\n\");fp=fopen(logFile,\"w\");fprintf(fp,\"Level%d, n%2.1e, OhK%2.1e, Oha%2.1e, J%4.3f, \"\"Bo%4.3f\\n\",MAXlevel,n,OhK,Oha,J,Bond);fprintf(fp,\"i dt t ke\\n\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}else{fp=fopen(logFile,\"a\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);assert(ke>-1e-10);if(ke>1e2&&i>1e1){if(pid()==0){fprintf(ferr,\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/burstingBubbleHB.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Stopping simulation\\n\");fp=fopen(logFile,\"a\");fprintf(fp,\"The kinetic...",
    "content": "Stopping simulation\\n\");fp=fopen(logFile,\"a\");fprintf(fp,\"The kinetic energy blew up. Stopping simulation\\n\");fclose(fp);dump(file=dumpFile);return1;}}assert(ke<1e2);if(ke<1e-6&&i>1e1){if(pid()==0){fprintf(ferr,\"Kinetic energy too small now! Stopping!\\n\");dump(file=dumpFile);fp=fopen(logFile,\"a\");fprintf(fp,\"Kinetic energy too small now! Stopping!\\n\");fclose(fp);return1;}}}}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/burstingBubbleHB.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/runMake.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles",
    "content": "simulationCases/runMake.sh See raw file runMake.sh #!/bin/bash source ../.project_config echo \\$ BASILISK mkdir -p \\$ 1 qcc -O2 -Wall -disable-dimensions -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local \\$ 1.c -o \\$ 1/\\$1 -lm cd \\$ 1 ./\\$1",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/runMake.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runMake.sh | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "#!/bin/bashsource../.project_configecho\\$BASILISKmkdir-p\\$1qcc-O2-Wall-disable-dimensions-I\\$(PWD)/src-local-I\\$(PWD)/../src-local\\$1.c-o\\$1/\\$1-lmcd\\$1./\\$1",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/simulationCases/runMake.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files two-phaseVP-HB.h This is a modified version of [two-phase.h](http://basilisk.fr/src/two-phase.h). It contains the implementation of Vi...",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "src-local/two-phaseVP-HB.h See raw file Modification by Vatsal Sanjay Version 4.0, Jan 1, 2025 Changelog Jan 1, 2025 (v4.0) There was a bug in calculation of D2 which would trigger while using parallel computing only. This has been fixed. Dec 31, 2024 (v3.5) Added the Herschel-Bulkley formulation. n = 1 recovers the Bingham formulation. n = 1, tau_y = 0 recovers the Newtonian formulation. Oct 11, 2024 (v2.0) Using the epsilon formulation for the viscoplastic fluid. Unified the code to handle both planar and axi-symmetric cases seamlessly. This eliminates the need for a separate codebase when switching to axi-symmetric formulations. Only fluid 1 can be viscoplastic, fluid 2 is always Newtonian.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "Brief history: v0.0 is of course the original code on http://basilisk.fr/src/two-phase.h valid for Newtonian fluids. v1.0 is the modification for viscoplastic fluids using the min(temp, mumax) formulation where one needed to use a separate codebase for axi-symmetric cases (see: git@github.com:VatsalSy/Bursting-Bubble-In-a-Viscoplastic-Medium.git). v2.0 is the modification for viscoplastic fluids using the epsilon formulation (this code) where I also unified the code to handle both planar and axi-symmetric cases seamlessly. Two-phase interfacial flows This is a modified version of two-phase.h . It contains the implementation of Viscoplastic Fluid (Bingham Fluid). This file helps setup simulations for flows of two fluids separated by an interface (i.e. immiscible fluids). It is typically used in combination with a Navier\u2013Stokes solver . The interface between the fluids is tracked with a Volume-Of-Fluid method. The volume fraction in fluid 1 is \\(f=1\\) and \\(f=0\\) in fluid 2.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Code",
    "content": "The densities and dynamic viscosities for fluid 1 and 2 are rho1 , mu1 , rho2 , mu2 , respectively. #include \"vof.h\" scalar f [], * interfaces = { f }; scalar D2 []; face vector D2f []; double rho1 = 1. , mu1 = 0. , rho2 = 1. , mu2 = 0. ; double epsilon = 1e-6 , tauy = 0. , n = 1. ; Auxilliary fields are necessary to define the (variable) specific volume \\(\\alpha=1/\\rho\\) as well as the cell-centered density. face vector alphav []; scalar rhov []; event defaults ( i = 0 ) { alpha = alphav ; rho = rhov ; If the viscosity is non-zero, we need to allocate the face-centered viscosity field. mu = new face vector ; } The density and viscosity are defined using arithmetic averages by default.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Definitions - Python Function",
    "content": "The user can overload these definitions to use other types of averages (i.e. harmonic). #ifndef rho # define rho ( f ) ( clamp ( f , 0. , 1. )*( rho1 - rho2 ) + rho2 ) 66 #endif #ifndef mu // for Arithmetic mean, use this // # define mu(muTemp, mu2, f) (clamp(f,0.,1.)*(muTemp - mu2) + mu2) // for Harmonic mean, use this # define mu ( muTemp , mu2 , f ) ( 1.0 / (( clamp ( f , 0. , 1. ) / muTemp ) + (( 1.0 - clamp ( f , 0. , 1. )) / mu2 ))) 72 #endif We have the option of using some \u201csmearing\u201d of the density/viscosity jump. #ifdef FILTERED scalar sf []; #else # define sf f 82 #endif event tracer_advection ( i ++) { When using smearing of the density jump, we initialise sf with the vertex-average of f . #ifndef sf #if dimension <= foreach () sf [] = ( 4. * f [] + 2. *( f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 1 , 0 ] + f [- 1 , 0 ]) + f [- 1 ,- 1 ] + f [ 1 ,- 1 ] + f [ 1 , 1 ] + f [- 1 , 1 ])/ 16. ; #else // dimension == foreach () sf [] = ( 8. * f [] + 4. *( f [- 1 ] + f [ 1 ] + f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 0 , 0 , 1 ] + f [ 0 , 0 ,- 1 ]) + 2. *( f [- 1 , 1 ] + f [- 1 , 0 , 1 ] + f [- 1 , 0 ,- 1 ] + f [- 1 ,- 1 ] + f [ 0 , 1 , 1 ] + f [ 0 , 1 ,- 1 ] + f [ 0 ,- 1 , 1 ] + f [ 0 ,- 1 ,- 1 ] + f [ 1 , 1 ] + f [ 1 , 0 , 1 ] + f [ 1 ,- 1 ] + f [ 1 , 0 ,- 1 ]) + f [ 1 ,- 1 , 1 ] + f [- 1 , 1 , 1 ] + f [- 1 , 1 ,- 1 ] + f [ 1 , 1 , 1 ] + f [ 1 , 1 ,- 1 ] + f [- 1 ,- 1 ,- 1 ] + f [ 1 ,- 1 ,- 1 ] + f [- 1 ,- 1 , 1 ])/ 64. ; #endif #endif #if TREE sf . prolongation = refine_bilinear ; sf . dirty = true ; // boundary conditions need to be updated #endif } event properties ( i ++) { This is the part where we have made changes. # Herschel\u2013Bulkley formulation for non-Newtonian flows ## Features: * Yield stress \\(\\tau_y\\) * Power law dependance on the strain rate * Shear thinning for \\(n < 1\\) . * Shear thickening for \\(n > 1\\) . * Bingham model for \\(n = 1\\) . * Newtonian fluid for \\(n = 1\\) and \\(\\tau_y = 0\\) . \\(\\varepsilon\\) -formulation \\[ \\boldsymbol{\\tau} = \\tau_{y}\\,\\boldsymbol{\\mathcal{I}} \\;+\\; K\\left(2\\boldsymbol{\\mathcal{D}}\\right)^{n} = 2\\biggl[\\frac{\\tau_{y}}{2\\|\\boldsymbol{\\mathcal{D}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + K\\,\\bigl(2\\|\\boldsymbol{\\mathcal{D}}\\|+\\epsilon\\bigr)^{n-1} \\biggr]\\boldsymbol{\\mathcal{D}}. \\] Normalizing stresses with \\(\\gamma/R_0\\) , length with \\(R_0\\) , and velocity with \\(\\sqrt{\\gamma/\\rho_lR_0}\\) \u2026 \\[ \\boldsymbol{\\tilde{\\tau}} = 2\\biggl[\\frac{\\mathcal{J}}{2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + Oh_K\\,\\bigl(2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\epsilon\\bigr)^{n-1} \\biggr]\\boldsymbol{\\tilde{\\mathcal{D}}}. \\] Here, the effective Ohnesorge is \\[ Oh_K = \\frac{K}{\\sqrt{\\rho_l^n\\gamma^{2-n}R_0^{3n-2}}} \\] One can easily see that putting \\(n = 1\\) recovers the Bingham model with \\(Oh = \\eta_l/\\sqrt{\\rho_l\\gamma R_0}\\) .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Additionally, with \\(n...",
    "content": "Additionally, with \\(n = 1\\) & \\(\\mathcal{J}\\) = 0, the model will give a Newtonian response.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: More details on...",
    "content": "More details on the implementation Calculate the norm of the deformation tensor \\(\\boldsymbol{\\mathcal{D}}\\) : \\[\\mathcal{D}_{11} = \\frac{\\partial u_r}{\\partial r}\\] \\[\\mathcal{D}_{22} = \\frac{u_r}{r}\\] \\[\\mathcal{D}_{13} = \\frac{1}{2}\\left( \\frac{\\partial u_r}{\\partial z}+ \\frac{\\partial u_z}{\\partial r}\\right)\\] \\[\\mathcal{D}_{31} = \\frac{1}{2}\\left( \\frac{\\partial u_z}{\\partial r}+ \\frac{\\partial u_r}{\\partial z}\\right)\\] \\[\\mathcal{D}_{33} = \\frac{\\partial u_z}{\\partial z}\\] \\[\\mathcal{D}_{12} = \\mathcal{D}_{23} = 0.\\] The second invariant is \\(\\mathcal{D}_2=\\sqrt{\\mathcal{D}_{ij}\\mathcal{D}_{ij}}\\) (this is the Frobenius norm) \\[\\mathcal{D}_2^2= \\mathcal{D}_{ij}\\mathcal{D}_{ij}= \\mathcal{D}_{11}\\mathcal{D}_{11} + \\mathcal{D}_{22}\\mathcal{D}_{22} + \\mathcal{D}_{13}\\mathcal{D}_{31} + \\mathcal{D}_{31}\\mathcal{D}_{13} + \\mathcal{D}_{33}\\mathcal{D}_{33}\\] Note: \\(\\|\\mathcal{D}\\| = D_2/\\sqrt{2}\\) .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: We use the...",
    "content": "We use the formulation as given in Balmforth et al. (2013) [@balmforthYieldingStressRecent2014] , who use the strain rate tensor \\(\\boldsymbol{\\dot{\\mathcal{S}}}\\) which and its norm \\(\\sqrt{\\frac{1}{2}\\dot{\\mathcal{S}_{ij}}\\dot{\\mathcal{S}_{ij}}}\\) . Of course, given \\(\\dot{\\mathcal{S}}_{ij}=2 D_{ij}\\) . Calculate the equivalent viscosity Factorizing with \\(2 \\mathcal{D}_{ij}\\) to obtain an equivalent viscosity \\[\\eta_{\\text{eff}} = \\frac{\\mathcal{J}}{2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\varepsilon}\\,\\boldsymbol{\\mathcal{I}} + Oh_K\\,\\bigl(2\\|\\boldsymbol{\\tilde{\\mathcal{D}}}\\|+\\epsilon\\bigr)^{n-1} \\] In this formulation, \\(\\varepsilon\\) is a small number to ensure numerical stability. The term \\[\\frac{\\tau_y}{\\varepsilon} + ...\\] is equivalent to the \\(\\mu_{max}\\) of the previous (v1.0, see: GitHub ) formulation [@sanjayBurstingBubbleViscoplastic2021] . Note: The fluid flows always, it is not a solid, but a very viscous fluid. Reproduced from: P.-Y. Lagr\u00e9e\u2019s Sandbox .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Methods",
    "content": "Here, we use a face implementation of the regularisation method, described here . foreach_face ( x ) { double ff = ( sf [] + sf [- 1 ])/ 2. ; alphav . x [] = fm . x []/ rho ( ff ); double muTemp = mu1 ; face vector muv = mu ; double D2temp = 0. ; D2temp += sq ( 0.5 *( ( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ] + u . y [- 1 , 1 ] - u . y [- 1 ,- 1 ])/( 2. * Delta ) )); // D11 #if AXI D2temp += sq (( u . y [ 0 , 0 ] + u . y [- 1 , 0 ])/( 2 * max ( y , 1e-20 ))); // D22 #endif D2temp += sq (( u . x [] - u . x [- 1 , 0 ])/ Delta ); // D33 D2temp += 2.0 * sq ( 0.5 *( ( u . y [] - u . y [- 1 , 0 ])/ Delta + 0.5 *( ( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . x [- 1 , 1 ] - u . x [- 1 ,- 1 ])/( 2. * Delta ) ) )); // D13 D2temp = sqrt ( D2temp / 2.0 ); if ( tauy > 0. ){ muTemp = tauy /( 2.0 * D2temp + epsilon ) + mu1 * pow (( 2.0 * D2temp + epsilon ), n - 1 ); } muv . x [] = fm . x []* mu ( muTemp , mu2 , ff ); D2f . x [] = D2temp ; } foreach_face ( y ) { double ff = ( sf [ 0 , 0 ] + sf [ 0 ,- 1 ])/ 2. ; alphav . y [] = fm . y []/ rho ( ff ); double muTemp = mu1 ; face vector muv = mu ; double D2temp = 0. ; D2temp += sq (( u . y [ 0 , 0 ] - u . y [ 0 ,- 1 ])/ Delta ); // D11 #if AXI D2temp += sq (( u . y [ 0 , 0 ] + u . y [ 0 ,- 1 ])/( 2 * max ( y , 1e-20 ))); // D22 #endif D2temp += sq ( 0.5 *( ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ] + u . x [ 1 ,- 1 ] - u . x [- 1 ,- 1 ])/( 2. * Delta ) )); // D33 D2temp += 2.0 * sq ( 0.5 *( ( u . x [ 0 , 0 ] - u . x [ 0 ,- 1 ])/ Delta + 0.5 *( ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . y [ 1 ,- 1 ] - u . y [- 1 ,- 1 ])/( 2. * Delta ) ) )); // D13 D2temp = sqrt ( D2temp / 2.0 ); if ( tauy > 0. ){ muTemp = tauy /( 2.0 * D2temp + epsilon ) + mu1 * pow (( 2.0 * D2temp + epsilon ), n - 1 ); } muv . y [] = fm . y []* mu ( muTemp , mu2 , ff ); D2f . y [] = D2temp ; } #if dimension == error ( \"3D not implemented yet\" ); #endif I also calculate a cell-centered scalar D2, where I store \\(\\|\\mathbf{\\mathcal{D}}\\|\\) .",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: This can also...",
    "content": "This can also be used for refimnement to accurately refine the fake-yield surfaces. foreach (){ rhov [] = cm []* rho ( sf []); D2 [] = f []*( D2f . x []+ D2f . y []+ D2f . x [ 1 , 0 ]+ D2f . y [ 0 , 1 ])/ 4. ; } #if TREE sf . prolongation = fraction_refine ; sf . dirty = true ; // boundary conditions need to be updated #endif }",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"vof.h\"scalar f[],*interfaces={f};scalar D2[];face vector D2f[];doublerho1=1.,mu1=0.,rho2=1.,mu2=0.;doubleepsilon=1e-6,tauy=0.,n=1.;",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "face vector alphav[];scalar rhov[];event defaults(i=0){alpha=alphav;rho=rhov;",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Function: rho",
    "content": "#ifndef rho# define rho(f)(clamp(f,0.,1.)*(rho1-rho2)+rho2)66#endif#ifndef mu// for Arithmetic mean, use this// # define mu(muTemp, mu2, f)  (clamp(f,0.,1.)*(muTemp - mu2) + mu2)// for Harmonic mean, use this# define mu(muTemp,mu2,f)(1.0/((clamp(f,0.,1.)/muTemp)+((1.0-clamp(f,0.,1.))/mu2)))72#endif",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Function: FILTEREDscalar",
    "content": "#ifdef FILTEREDscalar sf[];#else# define sf f82#endifevent tracer_advection(i++){",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Function: sf",
    "content": "#ifndef sf#if dimension <=foreach()sf[]=(4.*f[]+2.*(f[0,1]+f[0,-1]+f[1,0]+f[-1,0])+f[-1,-1]+f[1,-1]+f[1,1]+f[-1,1])/16.;#else// dimension ==foreach()sf[]=(8.*f[]+4.*(f[-1]+f[1]+f[0,1]+f[0,-1]+f[0,0,1]+f[0,0,-1])+2.*(f[-1,1]+f[-1,0,1]+f[-1,0,-1]+f[-1,-1]+f[0,1,1]+f[0,1,-1]+f[0,-1,1]+f[0,-1,-1]+f[1,1]+f[1,0,1]+f[1,-1]+f[1,0,-1])+f[1,-1,1]+f[-1,1,1]+f[-1,1,-1]+f[1,1,1]+f[1,1,-1]+f[-1,-1,-1]+f[1,-1,-1]+f[-1,-1,1])/64.;#endif#endif#if TREEsf.prolongation=refine_bilinear;sf.dirty=true;// boundary conditions need to be updated#endif}event properties(i++){",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: Context",
    "content": "foreach_face(x){doubleff=(sf[]+sf[-1])/2.;alphav.x[]=fm.x[]/rho(ff);doublemuTemp=mu1;face vector muv=mu;doubleD2temp=0.;D2temp+=sq(0.5*((u.y[0,1]-u.y[0,-1]+u.y[-1,1]-u.y[-1,-1])/(2.*Delta)));// D11#if AXID2temp+=sq((u.y[0,0]+u.y[-1,0])/(2*max(y,1e-20)));// D22#endifD2temp+=sq((u.x[]-u.x[-1,0])/Delta);// D33D2temp+=2.0*sq(0.5*((u.y[]-u.y[-1,0])/Delta+0.5*((u.x[0,1]-u.x[0,-1]+u.x[-1,1]-u.x[-1,-1])/(2.*Delta))));// D13D2temp=sqrt(D2temp/2.0);if(tauy>0.){muTemp=tauy/(2.0*D2temp+epsilon)+mu1*pow((2.0*D2temp+epsilon),n-1);}muv.x[]=fm.x[]*mu(muTemp,mu2,ff);D2f.x[]=D2temp;}foreach_face(y){doubleff=(sf[0,0]+sf[0,-1])/2.;alphav.y[]=fm.y[]/rho(ff);doublemuTemp=mu1;face vector muv=mu;doubleD2temp=0.;D2temp+=sq((u.y[0,0]-u.y[0,-1])/Delta);// D11#if AXID2temp+=sq((u.y[0,0]+u.y[0,-1])/(2*max(y,1e-20)));// D22#endifD2temp+=sq(0.5*((u.x[1,0]-u.x[-1,0]+u.x[1,-1]-u.x[-1,-1])/(2.*Delta)));// D33D2temp+=2.0*sq(0.5*((u.x[0,0]-u.x[0,-1])/Delta+0.5*((u.y[1,0]-u.y[-1,0]+u.y[1,-1]-u.y[-1,-1])/(2.*Delta))));// D13D2temp=sqrt(D2temp/2.0);if(tauy>0.){muTemp=tauy/(2.0*D2temp+epsilon)+mu1*pow((2.0*D2temp+epsilon),n-1);}muv.y[]=fm.y[]*mu(muTemp,mu2,ff);D2f.y[]=D2temp;}#if dimension ==error(\"3D not implemented yet\");#endif",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVP-HB.h | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "foreach(){rhov[]=cm[]*rho(sf[]);D2[]=f[]*(D2f.x[]+D2f.y[]+D2f.x[1,0]+D2f.y[0,1])/4.;}#if TREEsf.prolongation=fraction_refine;sf.dirty=true;// boundary conditions need to be updated#endif}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/src-local/two-phaseVP-HB.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "postProcess/getData.c See raw file Fluid Simulation Data Extraction This program extracts and processes data from fluid dynamics simulation snapshots. It calculates key fluid mechanics quantities like strain rate tensor invariants and velocity magnitudes from simulation output files. Physical Background The code analyzes the spatial derivatives of velocity fields to compute the second invariant of the strain rate tensor, which is an important quantity for identifying vortical structures in fluid flows. Additionally, it calculates velocity magnitudes throughout the flow field. The strain rate tensor is a fundamental quantity in fluid mechanics that describes the rate of deformation of fluid elements. Its second invariant is particularly useful for identifying regions of strong vorticity and shear, making it valuable for visualizing coherent structures in turbulent flows.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "Usage ./program filename xmin ymin xmax ymax ny filename: Path to simulation snapshot file xmin, ymin: Minimum coordinates of the region of interest xmax, ymax: Maximum coordinates of the region of interest ny: Number of grid points in y-direction (resolution) @author Vatsal Sanjay @affiliation Physics of Fluids Group, University of Twente @email vatsalsanjay@gmail.com #include \"utils.h\" #include \"output.h\" scalar f []; // Volume fraction field vector u []; // Velocity field char filename [ 80 ]; int nx , ny , len ; double xmin , ymin , xmax , ymax , Deltax , Deltay ; scalar D2c [], vel []; // Derived fields scalar * list = NULL ; // List of fields to output Main Function Processes command line arguments, restores simulation data, computes derived quantities, and outputs results to a formatted file. a: Number of command line arguments arguments: Array of command line argument strings Returns exit status code int main ( int a , char const * arguments []) { // Parse command line arguments sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); // Initialize list of fields to output list = list_add ( list , D2c ); list = list_add ( list , vel ); Data Processing Restores simulation data and calculates derived quantities at each point: D2c: Log10 of the second invariant of the strain rate tensor vel: Velocity magnitude field The strain rate tensor components are computed using finite difference approximations of the velocity gradients. restore ( file = filename ); foreach () { // Calculate components of the strain rate tensor double D11 = ( u . y [ 0 , 1 ] - u . y [ 0 , - 1 ])/( 2 * Delta ); double D22 = ( u . y []/ y ); double D33 = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2 * Delta ); double D13 = 0.5 * (( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 , - 1 ])/( 2 * Delta )); // Calculate the second invariant double D2 = ( sq ( D11 ) + sq ( D22 ) + sq ( D33 ) + 2.0 * sq ( D13 )); D2c [] = f [] * sqrt ( D2 / 2.0 ); // Convert to log scale for better visualization if ( D2c [] > 0. ) { D2c [] = log ( D2c [])/ log ( 10 ); } else { D2c [] = - 10 ; // Floor value for zero or negative values } // Calculate velocity magnitude vel [] = f [] * sqrt ( sq ( u . x []) + sq ( u . y [])); } Data Output This section handles the output of processed data: Calculates the mesh dimensions based on user-specified bounds Interpolates field values onto a regular grid Writes output data to a formatted text file The output format is a space-separated values file with columns: x-coordinate, y-coordinate, followed by values of each field in \u2018list\u2019.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: FILE * fp...",
    "content": "FILE * fp = ferr ; // Calculate grid spacing and dimensions Deltay = ( double )(( ymax - ymin )/( ny )); nx = ( int )(( xmax - xmin )/ Deltay ); Deltax = ( double )(( xmax - xmin )/( nx )); len = list_len ( list ); // Allocate memory for interpolated field values double ** field = ( double **) matrix_new ( nx , ny + 1 , len * sizeof ( double )); // Interpolate field values onto regular grid for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; int k = 0 ; for ( scalar s in list ) { field [ i ][ len * j + k ++] = interpolate ( s , x , y ); } } } // Write interpolated data to output file for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; fprintf ( fp , \" %g %g \" , x , y ); int k = 0 ; for ( scalar s in list ) { fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } // Clean up resources fflush ( fp ); fclose ( fp ); matrix_free ( field ); }",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"scalar f[];// Volume fraction fieldvector u[];// Velocity fieldcharfilename[80];intnx,ny,len;doublexmin,ymin,xmax,ymax,Deltax,Deltay;scalar D2c[],vel[];// Derived fieldsscalar*list=NULL;// List of fields to output",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "intmain(inta,charconst*arguments[]){// Parse command line argumentssprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);// Initialize list of fields to outputlist=list_add(list,D2c);list=list_add(list,vel);",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: restore(file=filename);foreach(){// Calculate components...",
    "content": "restore(file=filename);foreach(){// Calculate components of the strain rate tensordoubleD11=(u.y[0,1]-u.y[0,-1])/(2*Delta);doubleD22=(u.y[]/y);doubleD33=(u.x[1,0]-u.x[-1,0])/(2*Delta);doubleD13=0.5*((u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(2*Delta));// Calculate the second invariantdoubleD2=(sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13));D2c[]=f[]*sqrt(D2/2.0);// Convert to log scale for better visualizationif(D2c[]>0.){D2c[]=log(D2c[])/log(10);}else{D2c[]=-10;// Floor value for zero or negative values}// Calculate velocity magnitudevel[]=f[]*sqrt(sq(u.x[])+sq(u.y[]));}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: FILE*fp=ferr;// Calculate grid...",
    "content": "FILE*fp=ferr;// Calculate grid spacing and dimensionsDeltay=(double)((ymax-ymin)/(ny));nx=(int)((xmax-xmin)/Deltay);Deltax=(double)((xmax-xmin)/(nx));len=list_len(list);// Allocate memory for interpolated field valuesdouble**field=(double**)matrix_new(nx,ny+1,len*sizeof(double));// Interpolate field values onto regular gridfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y);}}}// Write interpolated data to output filefor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;fprintf(fp,\"%g%g\",x,y);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}// Clean up resourcesfflush(fp);fclose(fp);matrix_free(field);}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/video.py | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Import Statements",
    "content": "postProcess/video.py See raw file # Author: Vatsal Sanjay # vatsalsanjay@gmail.com # Physics of Fluids # Last updated: Dec 24, 2024 import numpy as np import os import subprocess as sp import matplotlib matplotlib.use( 'Agg' ) # Use non-interactive backend import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import multiprocessing as mp from functools import partial import argparse import matplotlib.colors as mcolors custom_colors = [ \"white\" , \"#DA8A67\" , \"#A0522D\" , \"#400000\" ] custom_cmap = mcolors.LinearSegmentedColormap.from_list( \"custom_hot\" , custom_colors) # Set up matplotlib configuration plt.rcParams[ 'text.usetex' ] = True plt.rcParams[ 'font.family' ] = 'serif' plt.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath} \\ usepackage{amssymb}' plt.rcParams[ 'mathtext.fontset' ] = 'cm' plt.rcParams[ 'font.serif' ] = [ 'Computer Modern Roman' ] + plt.rcParams[ 'font.serif' ] def gettingFacets(filename): exe = [ \"./getFacets\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) skip = True return segs def gettingfield(filename, zmin, rmin, zmax, rmax, nr): exe = [ \"./getData\" , filename, str (zmin), str (rmin), str (zmax), str (rmax), str (nr)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, D2temp, veltemp = [],[],[],[] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) D2temp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) return R, Z, D2, vel, nz # ---------------------------------------------------------------------------------------------------------------------- def process_timestep(ti, caseToProcess, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw): t = 0.01 * ti place = f\" { caseToProcess } /intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" if not os.path.exists(place): print ( f\" { place } File not found!\" ) return if os.path.exists(name): print ( f\" { name } Image present!\" ) return # --- Gather interface segments and field data as before --- segs = gettingFacets(place) nr = int (GridsPerR * rmax) R, Z, D2, vel, nz = gettingfield(place, zmin, rmin, zmax, rmax, nr) [xminp, xmaxp, yminp, ymaxp] = R. min (), R. max (), Z. min (), Z. max () extent_vel = [ - xminp, - xmaxp, yminp, ymaxp] extent_D2 = [xminp, xmaxp, yminp, ymaxp] AxesLabel, TickLabel = 30 , 20 fig, ax = plt.subplots( 1 , 1 , figsize = ( 19.20 , 10.80 )) ax.plot([ - rmax, rmax], [ 0 , 0 ], '--' , color = 'grey' , linewidth = lw) # \"horizontal\" axis is z ax.plot([ 0 , 0 ], [zmin, zmax], '-.' , color = 'grey' , linewidth = lw) # \"vertical\" axis is r # Domain box: ax.plot([ - rmax, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax.plot([ - rmax, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([ - rmax, - rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) line_segments = LineCollection(segs, linewidths = 4 , colors = 'green' ) ax.add_collection(line_segments) # ---------------------------------------------------------- # Now show imshow with the rotated arrays and extents: # ---------------------------------------------------------- cntrl1 = ax.imshow( vel, cmap = \"Blues\" , interpolation = 'bilinear' , origin = 'lower' , extent = extent_vel, vmin = 0.0 , vmax = 4e0 ) cntrl2 = ax.imshow( D2, cmap = \"hot_r\" , interpolation = 'bilinear' , origin = 'lower' , extent = extent_D2, vmin =- 3e0 , vmax = 2e0 ) # Equal aspect ensures squares in the new orientation ax.set_aspect( 'equal' ) ax.set_xlim( - rmax, rmax) # x range ax.set_ylim(zmin, zmax) # y range # Titles and labels that match the new orientation ax.set_title( fr' $ t/ \\t au_ {{ \\ gamma }} = { t :.4f} $ ' , fontsize = TickLabel) # Colorbars: place them closer to the plot edges fig.subplots_adjust(left = 0.1 , right = 0.9 ) # adjust spacing for vertical colorbars # Left colorbar cbar_ax1 = fig.add_axes([ 0.07 , 0.15 , 0.02 , 0.7 ]) # x,y,width,height in figure coords c1 = plt.colorbar(cntrl1, cax = cbar_ax1, orientation = 'vertical' ) c1.ax.tick_params(labelsize = TickLabel) c1.set_label( r' $ \\| u_i \\| /V_{ \\ gamma} $ ' , fontsize = AxesLabel, labelpad = 10 , rotation = 90 , position = ( 0 , 0.5 )) c1.ax.yaxis.set_label_position( 'left' ) c1.ax.yaxis.set_ticks_position( 'left' ) # Move ticks to left side c1.ax.tick_params(axis = 'y' , labelright = False , labelleft = True ) # Move tick labels to left side # Right colorbar cbar_ax2 = fig.add_axes([ 0.92 , 0.15 , 0.02 , 0.7 ]) c2 = plt.colorbar(cntrl2, cax = cbar_ax2, orientation = 'vertical' ) c2.ax.tick_params(labelsize = TickLabel) c2.set_label( r' $ \\| \\m athcal{D}_{ij} \\|\\t au_{ \\ gamma} $ ' , fontsize = AxesLabel, labelpad = 10 ) ax.axis( 'off' ) # Save with higher DPI and specific backend plt.savefig(name, bbox_inches = \"tight\" , dpi = 150 , backend = 'agg' ) plt.close() def main(): # Get number of CPUs from command line argument, or use all available import argparse parser = argparse.ArgumentParser() parser.add_argument( '--CPUs' , type = int , default = mp.cpu_count(), help = 'Number of CPUs to use' ) parser.add_argument( '--nGFS' , type = int , default = 256 , help = 'Number of restart files to process' ) parser.add_argument( '--ZMAX' , type = float , default = 1.0 , help = 'Maximum Z value' ) parser.add_argument( '--RMAX' , type = float , default = 4.0 , help = 'Maximum R value' ) parser.add_argument( '--ZMIN' , type = float , default =- 3.0 , help = 'Minimum Z value' ) parser.add_argument( '--RMIN' , type = float , default = 0.0 , help = 'Minimum R value' ) parser.add_argument( '--caseToProcess' , type = str , default = '../testCases/burstingBubbleHB' , help = 'Case to process' ) args = parser.parse_args() CPUStoUse = args.CPUs nGFS = args.nGFS ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN RMIN = args.RMIN caseToProcess = args.caseToProcess num_processes = CPUStoUse rmin, rmax, zmin, zmax = [RMIN, RMAX, ZMIN, ZMAX] GridsPerR = 128 lw = 2 folder = 'Video' if not os.path.isdir(folder): os.makedirs(folder) # Create a pool of worker processes with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments process_func = partial(process_timestep, caseToProcess = caseToProcess, folder = folder, nGFS = nGFS, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw) # Map the process_func to all timesteps pool. map (process_func, range (nGFS)) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/video.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/video.py | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example: # Author: Vatsal...",
    "content": "# Author: Vatsal Sanjay# vatsalsanjay@gmail.com# Physics of Fluids# Last updated: Dec 24, 2024importnumpyasnpimportosimportsubprocessasspimportmatplotlibmatplotlib.use('Agg')# Use non-interactive backendimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportmultiprocessingasmpfromfunctoolsimportpartialimportargparseimportmatplotlib.colorsasmcolorscustom_colors=[\"white\",\"#DA8A67\",\"#A0522D\",\"#400000\"]custom_cmap=mcolors.LinearSegmentedColormap.from_list(\"custom_hot\", custom_colors)# Set up matplotlib configurationplt.rcParams['text.usetex']=Trueplt.rcParams['font.family']='serif'plt.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}\\usepackage{amssymb}'plt.rcParams['mathtext.fontset']='cm'plt.rcParams['font.serif']=['Computer Modern Roman']+plt.rcParams['font.serif']defgettingFacets(filename):exe=[\"./getFacets\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, rmin, zmax, rmax, nr):exe=[\"./getData\", filename,str(zmin),str(rmin),str(zmax),str(rmax),str(nr)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, D2temp, veltemp=[],[],[],[]forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))D2temp.append(float(temp3[2]))veltemp.append(float(temp3[3]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))returnR, Z, D2, vel, nz# ----------------------------------------------------------------------------------------------------------------------defprocess_timestep(ti, caseToProcess, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw):t=0.01*tiplace=f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"ifnotos.path.exists(place):print(f\"{place}File not found!\")returnifos.path.exists(name):print(f\"{name}Image present!\")return# --- Gather interface segments and field data as before ---segs=gettingFacets(place)nr=int(GridsPerR*rmax)R, Z, D2, vel, nz=gettingfield(place, zmin, rmin, zmax, rmax, nr)[xminp, xmaxp, yminp, ymaxp]=R.min(), R.max(), Z.min(), Z.max()extent_vel=[-xminp,-xmaxp, yminp, ymaxp]extent_D2=[xminp, xmaxp, yminp, ymaxp]AxesLabel, TickLabel=30,20fig, ax=plt.subplots(1,1, figsize=(19.20,10.80))ax.plot([-rmax, rmax], [0,0],'--', color='grey', linewidth=lw)# \"horizontal\" axis is zax.plot([0,0], [zmin, zmax],'-.', color='grey', linewidth=lw)# \"vertical\" axis is r# Domain box:ax.plot([-rmax, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax.plot([-rmax, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax.plot([-rmax,-rmax], [zmin, zmax],'-', color='black', linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)line_segments=LineCollection(segs, linewidths=4, colors='green')ax.add_collection(line_segments)# ----------------------------------------------------------# Now show imshow with the rotated arrays and extents:# ----------------------------------------------------------cntrl1=ax.imshow(vel,cmap=\"Blues\",interpolation='bilinear',origin='lower',extent=extent_vel,vmin=0.0,vmax=4e0)cntrl2=ax.imshow(D2,cmap=\"hot_r\",interpolation='bilinear',origin='lower',extent=extent_D2,vmin=-3e0,vmax=2e0)# Equal aspect ensures squares in the new orientationax.set_aspect('equal')ax.set_xlim(-rmax, rmax)# x rangeax.set_ylim(zmin, zmax)# y range# Titles and labels that match the new orientationax.set_title(fr'$t/\\tau_{{\\gamma}}={t:.4f}$', fontsize=TickLabel)# Colorbars: place them closer to the plot edgesfig.subplots_adjust(left=0.1, right=0.9)# adjust spacing for vertical colorbars# Left colorbarcbar_ax1=fig.add_axes([0.07,0.15,0.02,0.7])# x,y,width,height in figure coordsc1=plt.colorbar(cntrl1, cax=cbar_ax1, orientation='vertical')c1.ax.tick_params(labelsize=TickLabel)c1.set_label(r'$\\|u_i\\|/V_{\\gamma}$', fontsize=AxesLabel, labelpad=10, rotation=90, position=(0,0.5))c1.ax.yaxis.set_label_position('left')c1.ax.yaxis.set_ticks_position('left')# Move ticks to left sidec1.ax.tick_params(axis='y', labelright=False, labelleft=True)# Move tick labels to left side# Right colorbarcbar_ax2=fig.add_axes([0.92,0.15,0.02,0.7])c2=plt.colorbar(cntrl2, cax=cbar_ax2, orientation='vertical')c2.ax.tick_params(labelsize=TickLabel)c2.set_label(r'$\\|\\mathcal{D}_{ij}\\|\\tau_{\\gamma}$', fontsize=AxesLabel, labelpad=10)ax.axis('off')# Save with higher DPI and specific backendplt.savefig(name, bbox_inches=\"tight\", dpi=150, backend='agg')plt.close()defmain():# Get number of CPUs from command line argument, or use all availableimportargparseparser=argparse.ArgumentParser()parser.add_argument('--CPUs',type=int, default=mp.cpu_count(),help='Number of CPUs to use')parser.add_argument('--nGFS',type=int, default=256,help='Number of restart files to process')parser.add_argument('--ZMAX',type=float, default=1.0,help='Maximum Z value')parser.add_argument('--RMAX',type=float, default=4.0,help='Maximum R value')parser.add_argument('--ZMIN',type=float, default=-3.0,help='Minimum Z value')parser.add_argument('--RMIN',type=float, default=0.0,help='Minimum R value')parser.add_argument('--caseToProcess',type=str, default='../testCases/burstingBubbleHB',help='Case to process')args=parser.parse_args()CPUStoUse=args.CPUsnGFS=args.nGFSZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMINRMIN=args.RMINcaseToProcess=args.caseToProcessnum_processes=CPUStoUsermin, rmax, zmin, zmax=[RMIN, RMAX, ZMIN, ZMAX]GridsPerR=128lw=2folder='Video'ifnotos.path.isdir(folder):os.makedirs(folder)# Create a pool of worker processeswithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed argumentsprocess_func=partial(process_timestep, caseToProcess=caseToProcess,folder=folder, nGFS=nGFS,GridsPerR=GridsPerR, rmin=rmin, rmax=rmax,zmin=zmin, zmax=zmax, lw=lw)# Map the process_func to all timestepspool.map(process_func,range(nGFS))if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/video.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData.c This program extracts and processes data from fluid dynamics simulation snapshots. It calculates key fluid mechanics ... getFacets.c A utility for extracting interface facets from fluid simulation data. video.py import numpy as np import os import subprocess as sp import matplotlib matplotlib.use('Agg') Use non-interactive back...",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: Context",
    "content": "postProcess/getFacets.c See raw file Getting Facets A utility for extracting interface facets from fluid simulation data. Description This program extracts and outputs the facets representing the interface between different phases in a multiphase flow simulation. The facets define the boundary between fluid phases, useful for geometric analysis and visualization of the interface morphology. Physics Background In multiphase fluid simulations, interfaces between different fluids are critical features that determine many physical phenomena like surface tension effects, droplet formation, and coalescence events. This utility identifies these interfaces by extracting facets from volume fraction data, allowing for quantitative analysis of interfacial dynamics.",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getFacets.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles: C/C++ Code",
    "content": "Usage ./getFacets input_file Author: Vatsal Sanjay vatsalsanjay@gmail.com Physics of Fluids Department University of Twente #include \"utils.h\" #include \"output.h\" #include \"fractions.h\" scalar f []; // Volume fraction field char filename [ 80 ]; Main Function Loads a simulation snapshot and extracts the interface facets. Input parameters: arguments[1] : Filename of the simulation snapshot to process Process: Restores the simulation state from the specified file Extracts interface facets from the volume fraction field Outputs facet data to standard error Return value: Returns 0 on successful completion Note: The facet extraction algorithm identifies where the volume fraction field crosses a threshold value (typically 0.5) between adjacent cells. int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); restore ( file = filename ); FILE * fp = ferr ; output_facets ( f , fp ); fflush ( fp ); fclose ( fp ); return 0 ; }",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getFacets.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"fractions.h\"scalar f[];// Volume fraction fieldcharfilename[80];",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getFacets.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets.c | Herschel-Bulkley Worthington Jets & Droplets Produced by Bursting Bubbles - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);restore(file=filename);FILE*fp=ferr;output_facets(f,fp);fflush(fp);fclose(fp);return0;}",
    "url": "https://comphy-lab.org/BurstingBubble_Herschel-Bulkley/postProcess/getFacets.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: SOAPY - Simulation...",
    "content": "SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films S imulation O f A xisymmetric P henomena in bubbl Y films High-fidelity simulations of soap bubble dynamics and wrinkling instabilities using Basilisk C. Research Overview This repository contains computational tools for studying the dynamics of thin liquid films forming bubbles, with a focus on wrinkling instabilities driven by surface tension and viscous effects.",
    "url": "https://comphy-lab.org/soapy/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: The simulations solve...",
    "content": "The simulations solve the two-phase Navier-Stokes equations in axisymmetric configurations, capturing the complex interplay between: Surface tension-driven dynamics at the liquid-gas interface Viscous dissipation within the thin film Gravitational effects characterized by the Bond number Film thickness variations leading to instability formation Physical System The code models a soap bubble consisting of: - A thin liquid film (water with surfactants) - Surrounding gas phase (air) - Interface dynamics tracked using Volume-of-Fluid (VOF) method - Smoke tracer diffusion for flow visualization Key Dimensionless Parameters Ohnesorge number (Oh) : Ratio of viscous to inertio-capillary forces \\[\\text{Oh} = \\frac{\\mu}{\\sqrt{\\rho\\sigma R}}\\] Bond number (Bo) : Ratio of gravitational to surface tension forces \\[\\text{Bo} = \\frac{\\rho g R^2}{\\sigma}\\] P\u00e9clet number (Pe) : Ratio of advective to diffusive transport \\[\\text{Pe} = \\frac{V_\\gamma R}{D}\\] where \\(V_\\gamma\\) is the inertio-capillary velocity Curvature parameter (k) : Ratio of bubble radius to film thickness \\[k = \\frac{R}{h}\\] Repository Structure basilisk/src/ - Core Basilisk CFD library (reference only, do not modify) simulationCases/ - Test cases for simulation soapBubble-full.c - Full bubble simulation (spherical cap + rim) soapBubble-half.c - Half-bubble simulation variant postProcess/ - Project-specific post-processing tools getData.c - Data extraction utility getFacet.c - Interface facet extraction Video-generic.py - Python script for post-processing Simulation Configurations Full Bubble Simulation ( soapBubble-full.c ) Models a complete bubble with: - Lower hemisphere: Circular cap geometry - Upper region: Spherical rim structure - Initial film thickness: \\(h = 1/k\\) - Adaptive mesh refinement near interfaces Half Bubble Simulation ( soapBubble-half.c ) Variant configuration for studying partial bubble dynamics with modified boundary conditions.",
    "url": "https://comphy-lab.org/soapy/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Physical Parameters Used...",
    "content": "Physical Parameters Used Parameter Symbol Typical Value Description Ohnesorge number \\(\\text{Oh}\\) \\(10^{-3}\\) Viscous effects Density ratio \\(\\rho_2/\\rho_1\\) \\(10^{-3}\\) Gas/liquid density Viscosity ratio \\(\\mu_2/\\mu_1\\) \\(10^{-3}\\) Gas/liquid viscosity Curvature parameter \\(k\\) 25 \\(R/h\\) ratio P\u00e9clet number (gas) \\(\\text{Pe}_{\\text{gas}}\\) \\(10^{-1}\\) Smoke diffusion Domain size \\(L\\) 5.0 Computational domain Installation and Usage Prerequisites C99-compliant compiler (gcc or clang) GNU make Python 3+ with matplotlib, numpy for post-processing Quick Setup # Clone repository git clone git@github.com:comphy-lab/soapy.git cd soapy # Install Basilisk locally ./reset_install_requirements.sh source .project_config # Compile simulations cd simulationCases make soapBubble-full.tst Running Simulations # Run full bubble simulation ./soapBubble-full.tst # Run with custom parameters (edit source file for parameter changes) # Key parameters: Oh1, k, tmax, MAXlevel # Output files are saved in intermediate/ directory Post-Processing cd postProcess # Compile data extraction tools qcc -autolink getData.c -o getData -lm qcc -autolink getFacet.c -o getFacet -lm # Generate animations python Video-generic.py --case ../simulationCases --folder output_frames Output Data The simulations generate: - Snapshot files : Binary dumps at regular intervals ( \\(\\Delta t = 0.01\\) ) - Interface data : VOF field and curvature information - Velocity fields : Full velocity components in axisymmetric coordinates - Tracer concentration : Smoke diffusion patterns - Pressure fields : Dynamic pressure evolution Scientific Background The simulations investigate the Taylor-Culick instability in soap bubbles, where: Thin film dynamics : The bubble consists of a liquid film of thickness \\(h \\ll R\\) (bubble radius) Wrinkling mechanism : Instabilities arise from the competition between surface tension and viscous forces Rim formation : The bubble edge develops a toroidal rim structure that influences stability Drainage patterns : Gravity and capillary forces create complex flow patterns within the film Relevant Physics Taylor-Culick velocity : Characteristic retraction speed \\[V_{\\text{TC}} = \\sqrt{\\frac{2\\sigma}{\\rho h}}\\] Rayleigh-Plateau instability : Drives rim breakup and droplet formation Marangoni effects : Surface tension gradients due to surfactant concentration Film thinning : Coupled drainage and evaporation processes Numerical Methods The code employs: Volume-of-Fluid (VOF) method for interface tracking Adaptive mesh refinement (AMR) for resolving thin films Implicit viscous solver for stability at low Oh numbers Conservative momentum advection for accurate interface dynamics Height-function curvature computation for surface tension Contributing This code is part of ongoing research.",
    "url": "https://comphy-lab.org/soapy/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: For collaborations or...",
    "content": "For collaborations or questions: Open an issue for bug reports or feature requests Contact the authors for research collaborations See CLAUDE.md for code style guidelines Authors Saumili Jana - Primary developer ( jsaumili@gmail.com ) Vatsal Sanjay - vatsalsy@comphy-lab.org License This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details. Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/Video-generic.py postProcess/getData.c postProcess/getFacet.c simulationCases simulationCases/Makefile simulationCases/cleanup.sh simulationCases/runCases.sh simulationCases/soapBubble-full.c simulationCases/soapBubble-half.c",
    "url": "https://comphy-lab.org/soapy/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "# Clone repositorygitclone git@github.com:comphy-lab/soapy.gitcdsoapy# Install Basilisk locally./reset_install_requirements.shsource.project_config# Compile simulationscdsimulationCasesmakesoapBubble-full.tst",
    "url": "https://comphy-lab.org/soapy/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "# Run full bubble simulation./soapBubble-full.tst# Run with custom parameters (edit source file for parameter changes)# Key parameters: Oh1, k, tmax, MAXlevel# Output files are saved in intermediate/ directory",
    "url": "https://comphy-lab.org/soapy/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "cdpostProcess# Compile data extraction toolsqcc-autolinkgetData.c-ogetData-lmqcc-autolinkgetFacet.c-ogetFacet-lm# Generate animationspythonVideo-generic.py--case../simulationCases--folderoutput_frames",
    "url": "https://comphy-lab.org/soapy/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Context",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # tested on MacOS only.",
    "url": "https://comphy-lab.org/soapy/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue. # modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk # Check if --hard flag is passed HARD_RESET = \\f alse if [[ \" \\$ 1\" == \"--hard\" ]]; then HARD_RESET = \\t rue fi # Function to install basilisk install_basilisk() { darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make -k make } # Remove project config always rm -rf .project_config # Check if basilisk needs to be installed if [[ \" \\$ HARD_RESET\" == true ]] || [[ ! -d \"basilisk\" ]]; then echo \"Installing basilisk...\" rm -rf basilisk install_basilisk else echo \"Using existing basilisk installation...\" cd basilisk/src fi # Setup environment variables echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config # Check if qcc is working properly echo \"\\nChecking qcc installation...\" if ! qcc --version > /dev/null 2 >& 1 ; then echo \"\\033[0;31mError: qcc is not working properly.\\033[0m\" echo \"Please ensure you have Xcode Command Line Tools installed.\" echo \"You can install them by running: xcode-select --install\" echo \"For more details, visit: http://basilisk.fr/src/INSTALL\" exit 1 else echo \"\\033[0;32mqcc is properly installed.\\033[0m\" qcc --version fi",
    "url": "https://comphy-lab.org/soapy/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: #!/bin/zsh# tested on...",
    "content": "#!/bin/zsh# tested on MacOS only.",
    "url": "https://comphy-lab.org/soapy/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue.# modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basilisk# Check if --hard flag is passedHARD_RESET=\\falseif[[\"\\$1\"==\"--hard\"]];thenHARD_RESET=\\truefi# Function to install basiliskinstall_basilisk(){darcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake-kmake}# Remove project config alwaysrm-rf.project_config# Check if basilisk needs to be installedif[[\"\\$HARD_RESET\"==true]]||[[!-d\"basilisk\"]];thenecho\"Installing basilisk...\"rm-rfbasiliskinstall_basiliskelseecho\"Using existing basilisk installation...\"cdbasilisk/srcfi# Setup environment variablesecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config# Check if qcc is working properlyecho\"\\nChecking qcc installation...\"if!qcc--version>/dev/null2>&1;thenecho\"\\033[0;31mError: qcc is not working properly.\\033[0m\"echo\"Please ensure you have Xcode Command Line Tools installed.\"echo\"You can install them by running: xcode-select --install\"echo\"For more details, visit: http://basilisk.fr/src/INSTALL\"exit1elseecho\"\\033[0;32mqcc is properly installed.\\033[0m\"qcc--versionfi",
    "url": "https://comphy-lab.org/soapy/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases cleanup.sh rm -rf \\$1 Makefile ifeq (\\$(wildcard ../.projectconfig),) \\$(error '../.projectconfig not found') endif BASILISK := \\$(shell . ../.proje... runCases.sh ORIGDIR=\\$(pwd) mkdir -p \\$1 cp \\$1.c \\$1/ cd \\$1 CC99='mpicc -std=c99' qcc -Wall -O2 -DMPI=1 -disable-dimensions -I\\... soapBubble-full.c This simulation models the dynamics of a thin liquid film forming a bubble with wrinkling instabilities. The code sol... soapBubble-half.c This simulation models the dynamics of a thin liquid film forming a bubble with wrinkling instabilities. The code sol...",
    "url": "https://comphy-lab.org/soapy/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/cleanup.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Context",
    "content": "simulationCases/cleanup.sh See raw file cleanup.sh \u26a0\ufe0f DANGER: Destructive Script Warning This script permanently deletes directories and ALL their contents! Files deleted with rm -rf CANNOT be recovered No recycle bin or trash - deletion is immediate and permanent Can delete entire directory trees including subdirectories Always double-check the directory path before running Purpose This script is designed to clean up simulation output directories in the SOAPY project. It's commonly used to remove the intermediate/ directories that contain large binary dump files from completed simulations.",
    "url": "https://comphy-lab.org/soapy/simulationCases/cleanup.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/cleanup.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Examples",
    "content": "Usage ./cleanup.sh < directory_name > Example: # Remove intermediate simulation data ./cleanup.sh intermediate # Remove a specific output directory ./cleanup.sh output_test_run Safety Features The enhanced script now includes several safety checks: Argument verification - Ensures a directory name is provided Existence check - Verifies the directory exists before attempting deletion Path display - Shows the full absolute path of the directory to be deleted Size information - Displays directory size and file count Confirmation prompt - Requires explicit \"yes\" confirmation before deletion Graceful cancellation - Any response other than \"yes\" cancels the operation Script Source #!/bin/bash # cleanup.sh - Safely remove directories with confirmation # WARNING: This script permanently deletes directories and all contents! # Usage: ./cleanup.sh <directory_name> # Check if argument is provided if [ \\$ # -eq 0 ] ; then echo \"Error: No directory specified\" echo \"Usage: \\$0 <directory_name>\" exit 1 fi # Check if directory exists if [ ! -d \"\\$1\" ] ; then echo \"Error: Directory '\\$1' does not exist\" exit 1 fi # Get absolute path for clarity FULLPATH = \\$ ( cd \"\\$1\" 2 > /dev/null && pwd ) if [ -z \"\\$FULLPATH\" ] ; then echo \"Error: Cannot access directory '\\$1'\" exit 1 fi # Show directory size and confirm deletion echo \"WARNING: This will permanently delete the following directory and ALL its contents:\" echo \" \\$FULLPATH\" echo \"\" echo \"Directory information:\" du -sh \"\\$1\" 2 > /dev/null || echo \" Size: Unable to determine\" echo \" Number of files: \\$(find \" \\$ 1\" -type f 2>/dev/null | wc -l)\" echo \"\" read -p \"Are you sure you want to delete this directory?",
    "url": "https://comphy-lab.org/soapy/simulationCases/cleanup.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/cleanup.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Type 'yes' to...",
    "content": "Type 'yes' to confirm: \" CONFIRM if [ \"\\$CONFIRM\" = \"yes\" ] ; then echo \"Deleting directory...\" rm -rf \"\\$1\" if [ \\$ ? -eq 0 ] ; then echo \"Directory successfully deleted.\" else echo \"Error: Failed to delete directory.\" exit 1 fi else echo \"Deletion cancelled.\" exit 0 fi",
    "url": "https://comphy-lab.org/soapy/simulationCases/cleanup.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/cleanup.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "# Remove intermediate simulation data./cleanup.shintermediate# Remove a specific output directory./cleanup.shoutput_test_run",
    "url": "https://comphy-lab.org/soapy/simulationCases/cleanup.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/cleanup.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: Context",
    "content": "#!/bin/bash# cleanup.sh - Safely remove directories with confirmation# WARNING: This script permanently deletes directories and all contents!# Usage: ./cleanup.sh <directory_name># Check if argument is providedif[\\$#-eq0];thenecho\"Error: No directory specified\"echo\"Usage: \\$0 <directory_name>\"exit1fi# Check if directory existsif[!-d\"\\$1\"];thenecho\"Error: Directory '\\$1' does not exist\"exit1fi# Get absolute path for clarityFULLPATH=\\$(cd\"\\$1\"2>/dev/null&&pwd)if[-z\"\\$FULLPATH\"];thenecho\"Error: Cannot access directory '\\$1'\"exit1fi# Show directory size and confirm deletionecho\"WARNING: This will permanently delete the following directory and ALL its contents:\"echo\"  \\$FULLPATH\"echo\"\"echo\"Directory information:\"du-sh\"\\$1\"2>/dev/null||echo\"  Size: Unable to determine\"echo\"  Number of files: \\$(find \"\\$1\" -type f 2>/dev/null | wc -l)\"echo\"\"read-p\"Are you sure you want to delete this directory?",
    "url": "https://comphy-lab.org/soapy/simulationCases/cleanup.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/cleanup.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: Type 'yes' to...",
    "content": "Type 'yes' to confirm: \"CONFIRMif[\"\\$CONFIRM\"=\"yes\"];thenecho\"Deleting directory...\"rm-rf\"\\$1\"if[\\$?-eq0];thenecho\"Directory successfully deleted.\"elseecho\"Error: Failed to delete directory.\"exit1fielseecho\"Deletion cancelled.\"exit0fi",
    "url": "https://comphy-lab.org/soapy/simulationCases/cleanup.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/runCases.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films",
    "content": "simulationCases/runCases.sh See raw file runCases.sh #!/bin/bash # Save the original directory ORIG_DIR = \\$ ( pwd ) mkdir -p \\$ 1 cp \\$ 1.c \\$ 1/ cd \\$ 1 CC99 = 'mpicc -std=c99' qcc -Wall -O2 -D_MPI = 1 -disable-dimensions -I\\${ORIG_DIR} /src-local -I\\${ORIG_DIR} /../src-local \\$ 1.c -o \\$ 1 -lm mpirun -np \\$ 2 ./\\$1",
    "url": "https://comphy-lab.org/soapy/simulationCases/runCases.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCases.sh | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "#!/bin/bash# Save the original directoryORIG_DIR=\\$(pwd)mkdir-p\\$1cp\\$1.c\\$1/cd\\$1CC99='mpicc -std=c99'qcc-Wall-O2-D_MPI=1-disable-dimensions-I\\${ORIG_DIR}/src-local-I\\${ORIG_DIR}/../src-local\\$1.c-o\\$1-lmmpirun-np\\$2 ./\\$1",
    "url": "https://comphy-lab.org/soapy/simulationCases/runCases.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films",
    "content": "simulationCases/Makefile See raw file Makefile # Check if .project_config exists ifeq ( \\$ ( wildcard ../.project_config ) , ) \\$ ( error \"../.project_config not found\" ) endif BASILISK := \\$ ( shell . ../.project_config && echo \\$\\$ BASILISK ) CFLAGS += -O2 -disable-dimensions CFLAGS += -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local # Fix permissions for runtest script fix-permissions: @chmod +x \\$ ( BASILISK ) /src/runtest # Make all test targets depend on fix-permissions %.tst: fix-permissions include \\$ ( BASILISK ) /Makefile.defs",
    "url": "https://comphy-lab.org/soapy/simulationCases/Makefile.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "# Check if .project_config existsifeq(\\$(wildcard../.project_config),)\\$(error\"../.project_config not found\")endifBASILISK:=\\$(shell. ../.project_config&&echo\\$\\$BASILISK)CFLAGS+=-O2-disable-dimensionsCFLAGS+=-I\\$(PWD)/src-local-I\\$(PWD)/../src-local# Fix permissions for runtest scriptfix-permissions:@chmod+x\\$(BASILISK)/src/runtest# Make all test targets depend on fix-permissions%.tst:fix-permissionsinclude\\$(BASILISK)/Makefile.defs",
    "url": "https://comphy-lab.org/soapy/simulationCases/Makefile.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Context",
    "content": "simulationCases/soapBubble-half.c See raw file Axisymmetric Bubble Wrinkling Simulation Overview This simulation models the dynamics of a thin liquid film forming a bubble with wrinkling instabilities. The code solves the two-phase Navier-Stokes equations in an axisymmetric configuration, capturing the interface dynamics between a liquid film and surrounding gas phase.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Physics Description The...",
    "content": "Physics Description The simulation captures: - Two-phase flow dynamics with surface tension effects - Gravitational forcing characterized by Bond number (Bo) - Viscous effects characterized by Ohnesorge number (Oh) - Interface tracking using Volume-of-Fluid (VOF) method - Adaptive mesh refinement for efficient computation Authors and Changelog Author : Saumili Jana (jsaumili@gmail.com) Created : October 18, 2024 Version History Oct 28, 2024 (Vatsal): Fixed initial condition implementation Mar 6, 2025 (Saumili): Corrected boundary condition formulation Mar 15, 2025 (Saumili): Updated pressure boundary conditions Mar 31, 2025 (Saumili): Increased iterations for convergence Apr 4, 2025 (Saumili): Corrected pressure initial condition Phase Convention f = 1: Liquid phase (thin film) f = 0: Gas phase (surrounding medium) #include \"axi.h\" #include \"navier-stokes/centered.h\" #include \"two-phase.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #include \"henry.h\" scalar T [], * stracers = { T }; Simulation Parameters Adaptive Mesh Refinement Tolerances These control the error thresholds for grid adaptation: - Volume fraction error tolerance - Velocity component error tolerance - Curvature error tolerance - Acceleration error tolerance #define fErr ( 1e-3 ) 52 #define VelErr ( 1e-3 ) 53 #define KErr ( 1e-3 ) 54 #define AErr ( 1e-3 ) 55 #define MINlevel 2 56 57 Time Control Parameters tsnap : Interval for saving simulation snapshots #define tsnap ( 0.01 ) 62 63 Physical Properties Rho21 : Density ratio between gas and liquid phases ( \\(\\rho_g/\\rho_l\\) ) Mu21 : Viscosity ratio between gas and liquid phases ( \\(\\mu_g/\\mu_l\\) ) Xcent , Ycent : Center coordinates of the bubble R2circle : Macro for computing squared radial distance #define Rho21 ( 1e-3 ) 71 #define Mu21 ( 1e-3 ) 72 #define Xcent ( 0.0 ) 74 #define Ycent ( 0.0 ) 75 #define R2circle ( x , y ) ( sq ( x - Xcent ) + sq ( y - Ycent )) 76 77 Boundary Conditions Left Boundary (Axis of Symmetry) No-slip wall condition for velocity Contact angle set to 90 degrees via Dirichlet condition on f u . t [ left ] = dirichlet ( 0.0 ); u . n [ left ] = dirichlet ( 0.0 ); f [ left ] = dirichlet ( 0.0 ); Right Boundary (Outflow) Neumann conditions for velocity components Dirichlet condition for pressure (atmospheric) u . t [ right ] = neumann ( 0.0 ); u . n [ right ] = neumann ( 0.0 ); p [ right ] = dirichlet ( 0.0 ); Top Boundary (Outflow) Neumann conditions for velocity components Dirichlet condition for pressure (atmospheric) u . t [ top ] = neumann ( 0.0 ); u . n [ top ] = neumann ( 0.0 ); p [ top ] = dirichlet ( 0.0 ); Global Variables MAXlevel : Maximum refinement level for adaptive mesh tmax : Maximum simulation time Oh1 : Ohnesorge number for liquid film Bo : Bond number (gravity/surface tension ratio) Ldomain : Domain size k : Curvature parameter (R/h ratio) h : Film thickness int MAXlevel ; double tmax , Oh1 , Pe_gas , Ldomain , k , h ; Main Function Purpose Initializes simulation parameters and launches the computation.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Key Parameters Set...",
    "content": "Key Parameters Set Maximum grid refinement level: 8 Simulation duration: 1.0 time units Domain size: 2.4 units Ohnesorge number: 0.01 (moderate viscous effects) Curvature parameter: 10 (thin film approximation) int main ( int argc , char const * argv []) { // Parameter assignments MAXlevel = 11 ; tmax = 1.0 ; Ldomain = 5.0 ; Oh1 = 1e-3 ; k = 2.5e1 ; Note on the Peclet number: Peclet number based on diffusion coefficient of smoke in air. \\[ Pe = \\frac{V_\\gamma R_0}{D} \\] The inertio-capillary velocity is usuallly 0.1-1 m/s. Typical bubble radius is 1 mm. The diffusion coefficient of smoke in air is 1e-4 to 1e-5 m^2/s.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Pe_gas = 1e-1...",
    "content": "Pe_gas = 1e-1 ; fprintf ( ferr , \"Level %d , tmax %g , Oh1 %3.2e , Lo %g\\n \" , MAXlevel , tmax , Oh1 , Ldomain ); // Domain configuration L0 = Ldomain ; init_grid ( 1 << 6 ); // Create output directory char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Physical properties assignment rho1 = 1.0 ; rho2 = Rho21 ; mu1 = Oh1 ; mu2 = Mu21 * Oh1 ; f . sigma = 1.0 ; // Surface tension coefficient // for smoke concentration T T . D1 = 1e-3 / Pe_gas ; // inverse Peclet number based on diffusion coefficient of smoke in water, $Pe_\\text{water} \\to \\infty$. T . D2 = 1e0 / Pe_gas ; // inverse Peclet number based on diffusion coefficient of smoke in air. T . alpha = 1e-3 ; // proportion of smoke in water right at the interface (this should be close to 0.). run (); } Initial Condition Event Purpose Sets up the initial bubble geometry with a half-circle lower part and spherical rim upper part.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: This creates a...",
    "content": "This creates a bubble with controlled wrinkling potential based on the curvature parameter k.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Geometry Construction Lower...",
    "content": "Geometry Construction Lower region: Half-circular cap Upper region: Spherical shell rim Film thickness: h = 1/k Initial refinement focused near the interface event init ( t = 0 ) { if (! restore ( file = \"dump\" )) { float y_p , x_p , x1 , x2 ; h = 1 / k ; y_p = 0.1 ; x1 = sqrt ( sq ( 1.0 - h ) - sq ( y_p )); x2 = sqrt ( 1 - sq ( y_p )); x_p = ( x1 + x2 ) / 2 ; // Adaptive refinement near interface refine (( R2circle ( x , y ) < 1.05 ) && ( R2circle ( x , y ) > sq ( 0.025 *( 1.0 - h ))) && ( level < MAXlevel )); // Initialize level-set function for interface vertex scalar phi []; foreach_vertex () { if ( y < y_p && x > 0.0 ) { // Lower part - half circle geometry phi [] = ( sq ( h / 2 ) - ( sq ( x - x_p ) + sq ( y - y_p ))); } else { // Upper part - spherical rim double r = sqrt ( sq ( x ) + sq ( y )); double shell = min ( 1. - r , ( r - ( 1. - h ))); phi [] = shell ; } } fractions ( phi , f ); fraction ( T , ( sq (( 1.0 - h )* 0.5 ) - R2circle ( x , y ))); // Initialize pressure field based on region foreach () { T [] *= 1e1 ; if ( R2circle ( x , y ) < sq ( 1.0 - h )) { p [] = 2. + 2. /( 1. - h ); // Inner bubble pressure } else if (( R2circle ( x , y ) <= 1 ) && ( R2circle ( x , y ) >= sq ( 1.0 - h ))) { p [] = 2 * f []; // Film pressure } else { p [] = 0 ; // Atmospheric pressure } u . x [] = 0 ; u . y [] = 0 ; } } } Adaptive Mesh Refinement Event Purpose Dynamically refines the computational mesh based on solution gradients.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: This ensures high...",
    "content": "This ensures high resolution near the interface and regions of high curvature while maintaining efficiency in smooth regions. Refinement Criteria Volume fraction gradients (interface tracking) Velocity component gradients (flow features) Curvature gradients (wrinkling detection) scalar KAPPA []; event adapt ( i ++) { curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , u . x , u . y , KAPPA }, ( double []){ fErr , VelErr , VelErr , KErr }, MAXlevel , MAXlevel - 4 ); } Data Output Event Purpose Saves simulation state at regular intervals for post-processing and restart capability.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Output Schedule Initial...",
    "content": "Output Schedule Initial condition saved at t = 0 Snapshots saved every tsnap time units Full field data including pressure dumped event writingFiles ( t = 0 , t += tsnap ; t <= tmax ) { p . nodump = false ; // Enable pressure output dump ( file = \"dump\" ); char nameOut [ 80 ]; sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Logging Event Purpose Maintains a detailed log of simulation progress including timestep information and key parameters.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Log Contents Iteration...",
    "content": "Log Contents Iteration number Current timestep size Simulation time Initial header with all simulation parameters event logWriting ( i ++) { static FILE * fp ; if ( pid () == 0 ) { if ( i == 0 ) { fprintf ( ferr , \"i dt t \\n \" ); fp = fopen ( \"log\" , \"w\" ); fprintf ( fp , \"Level %d , tmax %g , Oh %3.2e , Lo %g\\n \" , MAXlevel , tmax , Oh1 , Ldomain ); fprintf ( fp , \"i dt t \\n \" ); fprintf ( fp , \" %d %g %g \\n \" , i , dt , t ); fclose ( fp ); } else { fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %d %g %g\\n \" , i , dt , t ); fclose ( fp ); } fprintf ( ferr , \" %d %g %g\\n \" , i , dt , t ); } }",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - C/C++ Code",
    "content": "#include\"axi.h\"#include\"navier-stokes/centered.h\"#include\"two-phase.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#include\"henry.h\"scalar T[],*stracers={T};",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "#define fErr(1e-3)52#define VelErr(1e-3)53#define KErr(1e-3)54#define AErr(1e-3)55#define MINlevel25657",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "#define Rho21(1e-3)71#define Mu21(1e-3)72#define Xcent(0.0)74#define Ycent(0.0)75#define R2circle(x,y)(sq(x-Xcent)+sq(y-Ycent))7677",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "u.t[left]=dirichlet(0.0);u.n[left]=dirichlet(0.0);f[left]=dirichlet(0.0);",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "u.t[right]=neumann(0.0);u.n[right]=neumann(0.0);p[right]=dirichlet(0.0);",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "u.t[top]=neumann(0.0);u.n[top]=neumann(0.0);p[top]=dirichlet(0.0);",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "intmain(intargc,charconst*argv[]){// Parameter assignmentsMAXlevel=11;tmax=1.0;Ldomain=5.0;Oh1=1e-3;k=2.5e1;",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: Context",
    "content": "Pe_gas=1e-1;fprintf(ferr,\"Level%d, tmax%g, Oh1%3.2e, Lo%g\\n\",MAXlevel,tmax,Oh1,Ldomain);// Domain configurationL0=Ldomain;init_grid(1<<6);// Create output directorycharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Physical properties assignmentrho1=1.0;rho2=Rho21;mu1=Oh1;mu2=Mu21*Oh1;f.sigma=1.0;// Surface tension coefficient// for smoke concentration TT.D1=1e-3/Pe_gas;// inverse Peclet number based on diffusion coefficient of smoke in water, $Pe_\\text{water} \\to \\infty$.T.D2=1e0/Pe_gas;// inverse Peclet number based on diffusion coefficient of smoke in air.T.alpha=1e-3;// proportion of smoke in water right at the interface (this should be close to 0.).run();}",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: Context",
    "content": "event init(t=0){if(!restore(file=\"dump\")){floaty_p,x_p,x1,x2;h=1/k;y_p=0.1;x1=sqrt(sq(1.0-h)-sq(y_p));x2=sqrt(1-sq(y_p));x_p=(x1+x2)/2;// Adaptive refinement near interfacerefine((R2circle(x,y)<1.05)&&(R2circle(x,y)>sq(0.025*(1.0-h)))&&(level<MAXlevel));// Initialize level-set function for interfacevertex scalar phi[];foreach_vertex(){if(y<y_p&&x>0.0){// Lower part - half circle geometryphi[]=(sq(h/2)-(sq(x-x_p)+sq(y-y_p)));}else{// Upper part - spherical rimdoubler=sqrt(sq(x)+sq(y));doubleshell=min(1.-r,(r-(1.-h)));phi[]=shell;}}fractions(phi,f);fraction(T,(sq((1.0-h)*0.5)-R2circle(x,y)));// Initialize pressure field based on regionforeach(){T[]*=1e1;if(R2circle(x,y)<sq(1.0-h)){p[]=2.+2./(1.-h);// Inner bubble pressure}elseif((R2circle(x,y)<=1)&&(R2circle(x,y)>=sq(1.0-h))){p[]=2*f[];// Film pressure}else{p[]=0;// Atmospheric pressure}u.x[]=0;u.y[]=0;}}}",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "scalar KAPPA[];event adapt(i++){curvature(f,KAPPA);adapt_wavelet((scalar*){f,u.x,u.y,KAPPA},(double[]){fErr,VelErr,VelErr,KErr},MAXlevel,MAXlevel-4);}",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "event writingFiles(t=0,t+=tsnap;t<=tmax){p.nodump=false;// Enable pressure outputdump(file=\"dump\");charnameOut[80];sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-half.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "event logWriting(i++){staticFILE*fp;if(pid()==0){if(i==0){fprintf(ferr,\"i dt t\\n\");fp=fopen(\"log\",\"w\");fprintf(fp,\"Level%d, tmax%g, Oh%3.2e, Lo%g\\n\",MAXlevel,tmax,Oh1,Ldomain);fprintf(fp,\"i dt t\\n\");fprintf(fp,\"%d%g%g\\n\",i,dt,t);fclose(fp);}else{fp=fopen(\"log\",\"a\");fprintf(fp,\"%d%g%g\\n\",i,dt,t);fclose(fp);}fprintf(ferr,\"%d%g%g\\n\",i,dt,t);}}",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-half.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Context",
    "content": "simulationCases/soapBubble-full.c See raw file Axisymmetric Bubble Wrinkling Simulation Overview This simulation models the dynamics of a thin liquid film forming a bubble with wrinkling instabilities. The code solves the two-phase Navier-Stokes equations in an axisymmetric configuration, capturing the interface dynamics between a liquid film and surrounding gas phase.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Physics Description The...",
    "content": "Physics Description The simulation captures: - Two-phase flow dynamics with surface tension effects - Gravitational forcing characterized by Bond number (Bo) - Viscous effects characterized by Ohnesorge number (Oh) - Interface tracking using Volume-of-Fluid (VOF) method - Adaptive mesh refinement for efficient computation Authors and Changelog Author : Saumili Jana (jsaumili@gmail.com) Created : October 18, 2024 Version History Oct 28, 2024 (Vatsal): Fixed initial condition implementation Mar 6, 2025 (Saumili): Corrected boundary condition formulation Mar 15, 2025 (Saumili): Updated pressure boundary conditions Mar 31, 2025 (Saumili): Increased iterations for convergence Apr 4, 2025 (Saumili): Corrected pressure initial condition Phase Convention f = 1: Liquid phase (thin film) f = 0: Gas phase (surrounding medium) #include \"axi.h\" #include \"navier-stokes/centered.h\" #include \"two-phase.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #include \"henry.h\" scalar T [], * stracers = { T }; Simulation Parameters Adaptive Mesh Refinement Tolerances These control the error thresholds for grid adaptation: - Volume fraction error tolerance - Velocity component error tolerance - Curvature error tolerance - Acceleration error tolerance #define fErr ( 1e-3 ) 52 #define VelErr ( 1e-3 ) 53 #define KErr ( 1e-3 ) 54 #define AErr ( 1e-3 ) 55 #define MINlevel 2 56 57 Time Control Parameters tsnap : Interval for saving simulation snapshots #define tsnap ( 0.01 ) 62 63 Physical Properties Rho21 : Density ratio between gas and liquid phases ( \\(\\rho_g/\\rho_l\\) ) Mu21 : Viscosity ratio between gas and liquid phases ( \\(\\mu_g/\\mu_l\\) ) Xcent , Ycent : Center coordinates of the bubble R2circle : Macro for computing squared radial distance #define Rho21 ( 1e-3 ) 71 #define Mu21 ( 1e-3 ) 72 #define Xcent ( 0.0 ) 74 #define Ycent ( 0.0 ) 75 #define R2circle ( x , y ) ( sq ( x - Xcent ) + sq ( y - Ycent )) 76 77 Boundary Conditions Left Boundary (Axis of Symmetry) No-slip wall condition for velocity Contact angle set to 90 degrees via Dirichlet condition on f u . t [ left ] = dirichlet ( 0.0 ); u . n [ left ] = dirichlet ( 0.0 ); f [ left ] = dirichlet ( 0.0 ); Right Boundary (Outflow) Neumann conditions for velocity components Dirichlet condition for pressure (atmospheric) u . t [ right ] = neumann ( 0.0 ); u . n [ right ] = neumann ( 0.0 ); p [ right ] = dirichlet ( 0.0 ); Top Boundary (Outflow) Neumann conditions for velocity components Dirichlet condition for pressure (atmospheric) u . t [ top ] = neumann ( 0.0 ); u . n [ top ] = neumann ( 0.0 ); p [ top ] = dirichlet ( 0.0 ); Global Variables MAXlevel : Maximum refinement level for adaptive mesh tmax : Maximum simulation time Oh1 : Ohnesorge number for liquid film Bo : Bond number (gravity/surface tension ratio) Ldomain : Domain size k : Curvature parameter (R/h ratio) h : Film thickness int MAXlevel ; double tmax , Oh1 , Pe_gas , Ldomain , k , h ; Main Function Purpose Initializes simulation parameters and launches the computation.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Key Parameters Set...",
    "content": "Key Parameters Set Maximum grid refinement level: 8 Simulation duration: 1.0 time units Domain size: 2.4 units Ohnesorge number: 0.01 (moderate viscous effects) Curvature parameter: 10 (thin film approximation) int main ( int argc , char const * argv []) { // Parameter assignments MAXlevel = 11 ; tmax = 1.0 ; Ldomain = 5.0 ; X0 = - 1.005 ; Oh1 = 1e-3 ; k = 2.5e1 ; Note on the Peclet number: Peclet number based on diffusion coefficient of smoke in air. \\[ Pe = \\frac{V_\\gamma R_0}{D} \\] The inertio-capillary velocity is usuallly 0.1-1 m/s. Typical bubble radius is 1 mm. The diffusion coefficient of smoke in air is 1e-4 to 1e-5 m^2/s.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Pe_gas = 1e-1...",
    "content": "Pe_gas = 1e-1 ; fprintf ( ferr , \"Level %d , tmax %g , Oh1 %3.2e , Lo %g\\n \" , MAXlevel , tmax , Oh1 , Ldomain ); // Domain configuration L0 = Ldomain ; init_grid ( 1 << 6 ); // Create output directory char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Physical properties assignment rho1 = 1.0 ; rho2 = Rho21 ; mu1 = Oh1 ; mu2 = Mu21 * Oh1 ; f . sigma = 1.0 ; // Surface tension coefficient // for smoke concentration T T . D1 = 1e-3 / Pe_gas ; // inverse Peclet number based on diffusion coefficient of smoke in water, $Pe_\\text{water} \\to \\infty$. T . D2 = 1e0 / Pe_gas ; // inverse Peclet number based on diffusion coefficient of smoke in air. T . alpha = 1e-3 ; // proportion of smoke in water right at the interface (this should be close to 0.). run (); } Initial Condition Event Purpose Sets up the initial bubble geometry with a half-circle lower part and spherical rim upper part.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: This creates a...",
    "content": "This creates a bubble with controlled wrinkling potential based on the curvature parameter k.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Geometry Construction Lower...",
    "content": "Geometry Construction Lower region: Half-circular cap Upper region: Spherical shell rim Film thickness: h = 1/k Initial refinement focused near the interface event init ( t = 0 ) { if (! restore ( file = \"dump\" )) { float y_p , x_p , x1 , x2 ; h = 1 / k ; y_p = 0.1 ; x1 = sqrt ( sq ( 1.0 - h ) - sq ( y_p )); x2 = sqrt ( 1 - sq ( y_p )); x_p = ( x1 + x2 ) / 2 ; // Adaptive refinement near interface refine (( R2circle ( x , y ) < 1.05 ) && ( R2circle ( x , y ) > sq ( 0.025 *( 1.0 - h ))) && ( level < MAXlevel )); // Initialize level-set function for interface vertex scalar phi []; foreach_vertex () { if ( y < y_p && x > 0.0 ) { // Lower part - half circle geometry phi [] = ( sq ( h / 2 ) - ( sq ( x - x_p ) + sq ( y - y_p ))); } else { // Upper part - spherical rim double r = sqrt ( sq ( x ) + sq ( y )); double shell = min ( 1. - r , ( r - ( 1. - h ))); phi [] = shell ; } } fractions ( phi , f ); fraction ( T , ( sq (( 1.0 - h )* 0.5 ) - R2circle ( x , y ))); // Initialize pressure field based on region foreach () { T [] *= 1e1 ; if ( R2circle ( x , y ) < sq ( 1.0 - h )) { p [] = 2. + 2. /( 1. - h ); // Inner bubble pressure } else if (( R2circle ( x , y ) <= 1 ) && ( R2circle ( x , y ) >= sq ( 1.0 - h ))) { p [] = 2 * f []; // Film pressure } else { p [] = 0 ; // Atmospheric pressure } u . x [] = 0 ; u . y [] = 0 ; } } } Adaptive Mesh Refinement Event Purpose Dynamically refines the computational mesh based on solution gradients.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: This ensures high...",
    "content": "This ensures high resolution near the interface and regions of high curvature while maintaining efficiency in smooth regions. Refinement Criteria Volume fraction gradients (interface tracking) Velocity component gradients (flow features) Curvature gradients (wrinkling detection) scalar KAPPA []; event adapt ( i ++) { curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , u . x , u . y , KAPPA }, ( double []){ fErr , VelErr , VelErr , KErr }, MAXlevel , MAXlevel - 4 ); } Data Output Event Purpose Saves simulation state at regular intervals for post-processing and restart capability.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Output Schedule Initial...",
    "content": "Output Schedule Initial condition saved at t = 0 Snapshots saved every tsnap time units Full field data including pressure dumped event writingFiles ( t = 0 , t += tsnap ; t <= tmax ) { p . nodump = false ; // Enable pressure output dump ( file = \"dump\" ); char nameOut [ 80 ]; sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Logging Event Purpose Maintains a detailed log of simulation progress including timestep information and key parameters.",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Log Contents Iteration...",
    "content": "Log Contents Iteration number Current timestep size Simulation time Initial header with all simulation parameters event logWriting ( i ++) { static FILE * fp ; if ( pid () == 0 ) { if ( i == 0 ) { fprintf ( ferr , \"i dt t \\n \" ); fp = fopen ( \"log\" , \"w\" ); fprintf ( fp , \"Level %d , tmax %g , Oh %3.2e , Lo %g\\n \" , MAXlevel , tmax , Oh1 , Ldomain ); fprintf ( fp , \"i dt t \\n \" ); fprintf ( fp , \" %d %g %g \\n \" , i , dt , t ); fclose ( fp ); } else { fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %d %g %g\\n \" , i , dt , t ); fclose ( fp ); } fprintf ( ferr , \" %d %g %g\\n \" , i , dt , t ); } }",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - C/C++ Code",
    "content": "#include\"axi.h\"#include\"navier-stokes/centered.h\"#include\"two-phase.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#include\"henry.h\"scalar T[],*stracers={T};",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "#define fErr(1e-3)52#define VelErr(1e-3)53#define KErr(1e-3)54#define AErr(1e-3)55#define MINlevel25657",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "#define Rho21(1e-3)71#define Mu21(1e-3)72#define Xcent(0.0)74#define Ycent(0.0)75#define R2circle(x,y)(sq(x-Xcent)+sq(y-Ycent))7677",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "u.t[left]=dirichlet(0.0);u.n[left]=dirichlet(0.0);f[left]=dirichlet(0.0);",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "u.t[right]=neumann(0.0);u.n[right]=neumann(0.0);p[right]=dirichlet(0.0);",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "u.t[top]=neumann(0.0);u.n[top]=neumann(0.0);p[top]=dirichlet(0.0);",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "intmain(intargc,charconst*argv[]){// Parameter assignmentsMAXlevel=11;tmax=1.0;Ldomain=5.0;X0=-1.005;Oh1=1e-3;k=2.5e1;",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: Context",
    "content": "Pe_gas=1e-1;fprintf(ferr,\"Level%d, tmax%g, Oh1%3.2e, Lo%g\\n\",MAXlevel,tmax,Oh1,Ldomain);// Domain configurationL0=Ldomain;init_grid(1<<6);// Create output directorycharcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Physical properties assignmentrho1=1.0;rho2=Rho21;mu1=Oh1;mu2=Mu21*Oh1;f.sigma=1.0;// Surface tension coefficient// for smoke concentration TT.D1=1e-3/Pe_gas;// inverse Peclet number based on diffusion coefficient of smoke in water, $Pe_\\text{water} \\to \\infty$.T.D2=1e0/Pe_gas;// inverse Peclet number based on diffusion coefficient of smoke in air.T.alpha=1e-3;// proportion of smoke in water right at the interface (this should be close to 0.).run();}",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: Context",
    "content": "event init(t=0){if(!restore(file=\"dump\")){floaty_p,x_p,x1,x2;h=1/k;y_p=0.1;x1=sqrt(sq(1.0-h)-sq(y_p));x2=sqrt(1-sq(y_p));x_p=(x1+x2)/2;// Adaptive refinement near interfacerefine((R2circle(x,y)<1.05)&&(R2circle(x,y)>sq(0.025*(1.0-h)))&&(level<MAXlevel));// Initialize level-set function for interfacevertex scalar phi[];foreach_vertex(){if(y<y_p&&x>0.0){// Lower part - half circle geometryphi[]=(sq(h/2)-(sq(x-x_p)+sq(y-y_p)));}else{// Upper part - spherical rimdoubler=sqrt(sq(x)+sq(y));doubleshell=min(1.-r,(r-(1.-h)));phi[]=shell;}}fractions(phi,f);fraction(T,(sq((1.0-h)*0.5)-R2circle(x,y)));// Initialize pressure field based on regionforeach(){T[]*=1e1;if(R2circle(x,y)<sq(1.0-h)){p[]=2.+2./(1.-h);// Inner bubble pressure}elseif((R2circle(x,y)<=1)&&(R2circle(x,y)>=sq(1.0-h))){p[]=2*f[];// Film pressure}else{p[]=0;// Atmospheric pressure}u.x[]=0;u.y[]=0;}}}",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "scalar KAPPA[];event adapt(i++){curvature(f,KAPPA);adapt_wavelet((scalar*){f,u.x,u.y,KAPPA},(double[]){fErr,VelErr,VelErr,KErr},MAXlevel,MAXlevel-4);}",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "event writingFiles(t=0,t+=tsnap;t<=tmax){p.nodump=false;// Enable pressure outputdump(file=\"dump\");charnameOut[80];sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/soapBubble-full.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "event logWriting(i++){staticFILE*fp;if(pid()==0){if(i==0){fprintf(ferr,\"i dt t\\n\");fp=fopen(\"log\",\"w\");fprintf(fp,\"Level%d, tmax%g, Oh%3.2e, Lo%g\\n\",MAXlevel,tmax,Oh1,Ldomain);fprintf(fp,\"i dt t\\n\");fprintf(fp,\"%d%g%g\\n\",i,dt,t);fclose(fp);}else{fp=fopen(\"log\",\"a\");fprintf(fp,\"%d%g%g\\n\",i,dt,t);fclose(fp);}fprintf(ferr,\"%d%g%g\\n\",i,dt,t);}}",
    "url": "https://comphy-lab.org/soapy/simulationCases/soapBubble-full.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Context",
    "content": "postProcess/getData.c See raw file Simulation Data Extraction Extract and interpolate field data from Basilisk snapshots onto a regular grid. Author : Vatsal Sanjay (vatsalsy@comphy-lab.org) Lab : CoMPhy Lab, Physics of Fluids Department Updated : March 8, 2025 Usage ./getData < filename > < xmin > < ymin > < xmax > < ymax > < ny > Output: Grid data (x, y, field_values) to stderr #include \"utils.h\" #include \"output.h\" VOF and velocity fields scalar f []; vector u []; Command-line parameters char filename [ 80 ]; int nx , ny , len ; double xmin , ymin , xmax , ymax , Deltax , Deltay ; Temperature field and scalar list scalar T []; scalar * list = NULL ; Main Function Extract simulation data and interpolate onto a regular grid.",
    "url": "https://comphy-lab.org/soapy/postProcess/getData.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Parameters filename :...",
    "content": "Parameters filename : Simulation snapshot file xmin , ymin : Lower bounds of extraction region xmax , ymax : Upper bounds of extraction region ny : Number of grid points in y-direction Process Parse arguments and validate input Load simulation and normalize T field Create uniform grid with spacing Deltay Interpolate fields onto grid points Output grid data to stderr int main ( int a , char const * arguments []) { if ( a != 7 ) { fprintf ( stderr , \"Error: Expected 6 arguments \\n \" ); fprintf ( stderr , \"Usage: %s <filename> <xmin> <ymin> <xmax> <ymax> <ny> \\n \" , arguments [ 0 ]); return 1 ; } sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); list = list_add ( list , T ); /* Load simulation */ restore ( file = filename ); /* Normalize T by maximum value */",
    "url": "https://comphy-lab.org/soapy/postProcess/getData.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "charfilename[80];intnx,ny,len;doublexmin,ymin,xmax,ymax,Deltax,Deltay;",
    "url": "https://comphy-lab.org/soapy/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "intmain(inta,charconst*arguments[]){if(a!=7){fprintf(stderr,\"Error: Expected 6 arguments\\n\");fprintf(stderr,\"Usage:%s<filename> <xmin> <ymin> <xmax> <ymax> <ny>\\n\",arguments[0]);return1;}sprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);list=list_add(list,T);/* Load simulation */restore(file=filename);/* Normalize T by maximum value */",
    "url": "https://comphy-lab.org/soapy/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films",
    "content": "postProcess/getFacet.c See raw file Facet Extraction Utility Extract interface facets from Basilisk simulation files. Author : Vatsal Sanjay (vatsalsy@comphy-lab.org) Lab : CoMPhy Lab, Physics of Fluids Department Updated : March 8, 2025 Usage ./getFacet < simulation_file > Output: Facet data to stderr #include \"utils.h\" #include \"output.h\" #include \"fractions.h\" VOF fraction field scalar f []; Input filename buffer char filename [ 80 ]; Main Function Extract facets from a saved simulation state. Parameters a : Argument count arguments : Command-line arguments arguments[1] : Simulation file path Process Load simulation file Extract facets from VOF field Output to stderr int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); restore ( file = filename ); FILE * fp = ferr ; output_facets ( f , fp ); fflush ( fp ); fclose ( fp ); }",
    "url": "https://comphy-lab.org/soapy/postProcess/getFacet.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"fractions.h\"",
    "url": "https://comphy-lab.org/soapy/postProcess/getFacet.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet.c | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);restore(file=filename);FILE*fp=ferr;output_facets(f,fp);fflush(fp);fclose(fp);}",
    "url": "https://comphy-lab.org/soapy/postProcess/getFacet.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData.c Extract and interpolate field data from Basilisk snapshots onto a regular grid. - Author: Vatsal Sanjay (vatsalsy@com... getFacet.c Extract interface facets from Basilisk simulation files. - Author: Vatsal Sanjay (vatsalsy@comphy-lab.org) - Lab: CoM... Video-generic.py Basilisk Fluid Dynamics Visualization Script This script processes Basilisk simulation snapshots to create high-quali...",
    "url": "https://comphy-lab.org/soapy/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Context",
    "content": "postProcess/Video-generic.py See raw file #!/usr/bin/env python3 # -*- coding: utf-8 -*- Basilisk Fluid Dynamics Visualization Script This script processes Basilisk simulation snapshots to create high-quality visualizations of fluid dynamics simulations, particularly for soap bubble and multiphase flow problems. It reads simulation data from intermediate snapshot files, extracts facet information (interfaces), and temperature/scalar fields, then generates publication-quality plots. The script supports parallel processing for efficient generation of animation frames from large simulation datasets.",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Context",
    "content": "Usage: python Video-generic.py [options] Basic usage: python Video-generic.py -CPUs 8 -nGFS 1000 Custom simulation: python Video-generic.py -caseToProcess ../mySimulation -RMAX 5.0 Dependencies: - numpy: For numerical operations - matplotlib: For visualization - multiprocessing: For parallel processing - subprocess: For calling external Basilisk utilities - argparse: For command-line argument parsing External Requirements: - ./getFacet: Basilisk utility to extract interface facets - ./getData: Basilisk utility to extract field data - LaTeX: For rendering mathematical expressions in plots Author: Vatsal Sanjay Email: vatsalsy@comphy-lab.org Affiliation: CoMPhy Lab, Physics of Fluids Department Last updated: Mar 8, 2025 import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import multiprocessing as mp from functools import partial import argparse import sys # =============================== # Matplotlib Configuration # =============================== matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' # =============================== # Data Extraction Functions # =============================== def gettingFacets(filename, includeCoat = 'true' ): Extract interface facets from a Basilisk snapshot file.",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Function Definition",
    "content": "This function calls the external getFacet utility to extract the coordinates of interface segments (facets) from a Basilisk simulation snapshot. The facets represent the boundaries between different phases or the free surface. The function automatically mirrors facets across the r=0 axis for axisymmetric simulations, creating a full 2D representation. Args: filename (str): Path to the Basilisk snapshot file includeCoat (str, optional): Whether to include coating interfaces. Defaults to \u2018true\u2019. Returns: list: List of line segments, where each segment is a tuple of two points ((r1, z1), (r2, z2)). Returns empty list if file has insufficient data.",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Examples",
    "content": "Raises: subprocess.CalledProcessError: If getFacet utility fails Example: >>> facets = gettingFacets(\u201csnapshot-0.1000\u201d) >>> print(f\u201dFound {len(facets)} facet segments\u201d) # Execute the getFacet utility exe = [ \"./getFacet\" , filename, includeCoat] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() # Parse the output from stderr (Basilisk utilities output to stderr) temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False # Only process if we have substantial output (>100 lines indicates valid data) if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: # Parse the next line for the second point of the segment temp4 = temp2[n1 + 1 ].split( \" \" ) # Note: getFacet outputs in (z, r) format, we convert to (r, z) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) # Add the original segment segs.append(((r1, z1), (r2, z2))) # Mirror across r=0 for axisymmetric visualization segs.append((( - r1, z1), ( - r2, z2))) skip = True return segs def gettingfield(filename, zmin, zmax, rmax, nr): Extract field data from a Basilisk snapshot within specified bounds.",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Function Definition",
    "content": "This function calls the getData utility to extract scalar field data (e.g., temperature, concentration) from a Basilisk simulation on a regular grid. The data is extracted in a rectangular region for efficient visualization.",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Args: filename (str):...",
    "content": "Args: filename (str): Path to the Basilisk snapshot file zmin (float): Minimum z-coordinate for data extraction zmax (float): Maximum z-coordinate for data extraction rmax (float): Maximum radial coordinate for data extraction nr (int): Number of grid points in the radial direction Returns: tuple: Contains: - R (numpy.ndarray): 2D array of radial coordinates (nz x nr) - Z (numpy.ndarray): 2D array of axial coordinates (nz x nr) - T (numpy.ndarray): 2D array of field values (nz x nr) - nz (int): Number of grid points in the axial direction Raises: subprocess.CalledProcessError: If getData utility fails ValueError: If data reshaping fails due to inconsistent dimensions Example: >>> R, Z, T, nz = gettingfield(\u201csnapshot-0.1000\u201d, 0, 4, 2, 256) >>> print(f\u201dGrid size: {nz} x {nr}\u201c) # Execute the getData utility with specified bounds exe = [ \"./getData\" , filename, str (zmin), str ( 0 ), str (zmax), str (rmax), str (nr)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() # Parse the output temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) Rtemp, Ztemp, Ttemp = [], [], [] # Extract data points from output for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : # getData outputs in (z, r, field) format Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) Ttemp.append( float (temp3[ 2 ])) # Convert to numpy arrays R = np.asarray(Rtemp) Z = np.asarray(Ztemp) T = np.asarray(Ttemp) # Calculate grid dimensions nz = int ( len (Z) / nr) print ( \"nz is %d \" % nz) # Reshape into 2D grids for visualization R.resize((nz, nr)) Z.resize((nz, nr)) T.resize((nz, nr)) return R, Z, T, nz # =============================== # Visualization Functions # =============================== def process_timestep(ti, caseToProcess, folder, tsnap, GridsPerR, rmin, rmax, zmin, zmax, lw): Process and visualize a single timestep from the simulation.",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Function Definition",
    "content": "This function handles the complete visualization pipeline for one timestep: reading data, creating the plot with field visualization and interface contours, and saving the image. It\u2019s designed to be called in parallel for multiple timesteps.",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: The visualization includes:...",
    "content": "The visualization includes: - Temperature/scalar field as a colored heatmap - Interface facets as blue lines - Domain boundaries - Axis of symmetry (for axisymmetric cases) Args: ti (int): Timestep index caseToProcess (str): Path to the simulation case directory folder (str): Output directory for saving images tsnap (float): Time interval between snapshots GridsPerR (int): Number of grid points per unit radius rmin (float): Minimum radial coordinate for plotting rmax (float): Maximum radial coordinate for plotting zmin (float): Minimum axial coordinate for plotting zmax (float): Maximum axial coordinate for plotting lw (float): Line width for plotting boundaries Returns: None: Saves image to disk Note: - Skips processing if output image already exists - Prints error messages if snapshot file is missing or corrupted - Images are saved with 8-digit zero-padded filenames for proper sorting Example: >>> process_timestep(100, \u201c../simCase\u201d, \u201coutput\u201d, 0.01, 128, -2, 2, 0, 4, 2) # Creates output/00001000.png for t=1.0 # Calculate physical time for this timestep t = tsnap * ti place = f\" { caseToProcess } /intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" # Check if snapshot file exists if not os.path.exists(place): print ( f\" { place } File not found!\" ) return # Skip if output already exists (useful for resuming interrupted runs) if os.path.exists(name): print ( f\" { name } Image present!\" ) return # Extract interface facets segs = gettingFacets(place) if not segs: print ( f\"Problem in the available file { place } \" ) return # Calculate grid resolution based on domain size nr = int (GridsPerR * rmax) # Extract field data R, Z, T, nz = gettingfield(place, zmin, zmax, rmax, nr) zminp, zmaxp, rminp, rmaxp = Z. min (), Z. max (), R. min (), R. max () # =============================== # Plotting Configuration # =============================== AxesLabel, TickLabel = 50 , 20 fig, ax = plt.subplots() fig.set_size_inches( 19.20 , 10.80 ) # Full HD resolution # Plot domain boundaries and axis of symmetry ax.plot([ 0 , 0 ], [zmin, zmax], '-.' , color = 'grey' , linewidth = lw) # Symmetry axis ax.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Left boundary ax.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) # Bottom boundary ax.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) # Top boundary ax.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Right boundary # Add interface facets as a collection for efficiency line_segments = LineCollection(segs, linewidths = 4 , colors = 'blue' , linestyle = 'solid' ) ax.add_collection(line_segments) # Create temperature/scalar field visualization cntrl2 = ax.imshow(T, interpolation = 'Bilinear' , cmap = 'hot_r' , origin = 'lower' , extent = [rminp, rmaxp, zminp, zmaxp], vmax = 1.0 , vmin = 0.0 ) # Configure plot appearance ax.set_aspect( 'equal' ) ax.set_xlim(rmin, rmax) ax.set_ylim(zmin, zmax) ax.set_title( f'$t/ \\\\ tau_ \\\\ gamma$ = { t :4.3f} ' , fontsize = TickLabel) ax.axis( 'off' ) # Remove axes for cleaner visualization # Save figure with tight layout plt.savefig(name, bbox_inches = \"tight\" ) plt.close() # =============================== # Main Execution # =============================== def main(): Main function that orchestrates the parallel visualization process.",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Context",
    "content": "This function: 1. Parses command-line arguments for configuration 2. Sets up the output directory 3. Creates a multiprocessing pool 4.",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Distributes timestep processing...",
    "content": "Distributes timestep processing across available CPUs The parallel processing significantly speeds up visualization of large simulation datasets by processing multiple timesteps simultaneously. parser = argparse.ArgumentParser( description = 'Generate visualizations from Basilisk simulation snapshots' , formatter_class = argparse.RawDescriptionHelpFormatter) parser.add_argument( '--CPUs' , type = int , default = 8 , help = 'Number of CPUs to use for parallel processing' ) parser.add_argument( '--nGFS' , type = int , default = 4000 , help = 'Number of snapshot files to process' ) parser.add_argument( '--GridsPerR' , type = int , default = 128 , help = 'Grid resolution per unit radius (affects image quality)' ) parser.add_argument( '--ZMAX' , type = float , default = 4.0 , help = 'Maximum Z coordinate for visualization domain' ) parser.add_argument( '--RMAX' , type = float , default = 4.0 , help = 'Maximum R coordinate for visualization domain' ) parser.add_argument( '--ZMIN' , type = float , default = 0.0 , help = 'Minimum Z coordinate for visualization domain' ) parser.add_argument( '--tsnap' , type = float , default = 0.01 , help = 'Time interval between snapshots' ) parser.add_argument( '--caseToProcess' , type = str , default = '../simulationCases/soapBubble-full' , help = 'Path to simulation case directory' ) parser.add_argument( '--folderToSave' , type = str , default = 'Video' , help = 'Output directory for images' ) args = parser.parse_args() # Extract arguments num_processes = args.CPUs nGFS = args.nGFS tsnap = args.tsnap ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN # Set up visualization domain (full domain for axisymmetric cases) rmin, rmax, zmin, zmax = [ - RMAX, RMAX, ZMIN, ZMAX] GridsPerR = args.GridsPerR # Visualization parameters lw = 2 # Line width for boundaries folder = args.folderToSave caseToProcess = args.caseToProcess # Create output directory if it doesn't exist if not os.path.isdir(folder): os.makedirs(folder) print ( f\"Created output directory: { folder } \" ) # =============================== # Parallel Processing # =============================== print ( f\"Starting parallel processing with { num_processes } CPUs...\" ) print ( f\"Processing { nGFS } timesteps from { caseToProcess } \" ) # Create a pool of worker processes with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments # This allows us to pass only the timestep index to each worker process_func = partial(process_timestep, caseToProcess = caseToProcess, folder = folder, tsnap = tsnap, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw) # Map the process function to all timesteps # This distributes the work across available CPUs pool. map (process_func, range (nGFS)) print ( f\"Processing complete!",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films: Images saved to...",
    "content": "Images saved to { folder } /\" ) print ( \"To create a video from images, use:\" ) print ( f\" ffmpeg -framerate 30 -pattern_type glob -i ' { folder } /*.png' -c:v libx264 output.mp4\" ) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: Methods",
    "content": "importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportmultiprocessingasmpfromfunctoolsimportpartialimportargparseimportsys# ===============================# Matplotlib Configuration# ===============================matplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'# ===============================# Data Extraction Functions# ===============================defgettingFacets(filename, includeCoat='true'):",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: # Execute the...",
    "content": "# Execute the getFacet utilityexe=[\"./getFacet\", filename, includeCoat]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()# Parse the output from stderr (Basilisk utilities output to stderr)temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=False# Only process if we have substantial output (>100 lines indicates valid data)if(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:# Parse the next line for the second point of the segmenttemp4=temp2[n1+1].split(\" \")# Note: getFacet outputs in (z, r) format, we convert to (r, z)r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])# Add the original segmentsegs.append(((r1, z1), (r2, z2)))# Mirror across r=0 for axisymmetric visualizationsegs.append(((-r1, z1), (-r2, z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, zmax, rmax, nr):",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: # Execute the...",
    "content": "# Execute the getData utility with specified boundsexe=[\"./getData\", filename,str(zmin),str(0),str(zmax),str(rmax),str(nr)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()# Parse the outputtemp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")Rtemp, Ztemp, Ttemp=[], [], []# Extract data points from outputforn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:# getData outputs in (z, r, field) formatZtemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))Ttemp.append(float(temp3[2]))# Convert to numpy arraysR=np.asarray(Rtemp)Z=np.asarray(Ztemp)T=np.asarray(Ttemp)# Calculate grid dimensionsnz=int(len(Z)/nr)print(\"nz is%d\"%nz)# Reshape into 2D grids for visualizationR.resize((nz, nr))Z.resize((nz, nr))T.resize((nz, nr))returnR, Z, T, nz# ===============================# Visualization Functions# ===============================defprocess_timestep(ti, caseToProcess, folder, tsnap, GridsPerR, rmin, rmax, zmin, zmax, lw):",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: # Calculate physical...",
    "content": "# Calculate physical time for this timestept=tsnap*tiplace=f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"# Check if snapshot file existsifnotos.path.exists(place):print(f\"{place}File not found!\")return# Skip if output already exists (useful for resuming interrupted runs)ifos.path.exists(name):print(f\"{name}Image present!\")return# Extract interface facetssegs=gettingFacets(place)ifnotsegs:print(f\"Problem in the available file{place}\")return# Calculate grid resolution based on domain sizenr=int(GridsPerR*rmax)# Extract field dataR, Z, T, nz=gettingfield(place, zmin, zmax, rmax, nr)zminp, zmaxp, rminp, rmaxp=Z.min(), Z.max(), R.min(), R.max()# ===============================# Plotting Configuration# ===============================AxesLabel, TickLabel=50,20fig, ax=plt.subplots()fig.set_size_inches(19.20,10.80)# Full HD resolution# Plot domain boundaries and axis of symmetryax.plot([0,0], [zmin, zmax],'-.', color='grey', linewidth=lw)# Symmetry axisax.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)# Left boundaryax.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)# Bottom boundaryax.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)# Top boundaryax.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Right boundary# Add interface facets as a collection for efficiencyline_segments=LineCollection(segs, linewidths=4, colors='blue', linestyle='solid')ax.add_collection(line_segments)# Create temperature/scalar field visualizationcntrl2=ax.imshow(T, interpolation='Bilinear', cmap='hot_r', origin='lower',extent=[rminp, rmaxp, zminp, zmaxp], vmax=1.0, vmin=0.0)# Configure plot appearanceax.set_aspect('equal')ax.set_xlim(rmin, rmax)ax.set_ylim(zmin, zmax)ax.set_title(f'$t/\\\\tau_\\\\gamma$ ={t:4.3f}', fontsize=TickLabel)ax.axis('off')# Remove axes for cleaner visualization# Save figure with tight layoutplt.savefig(name, bbox_inches=\"tight\")plt.close()# ===============================# Main Execution# ===============================defmain():",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: Context",
    "content": "parser=argparse.ArgumentParser(description='Generate visualizations from Basilisk simulation snapshots',formatter_class=argparse.RawDescriptionHelpFormatter)parser.add_argument('--CPUs',type=int, default=8,help='Number of CPUs to use for parallel processing')parser.add_argument('--nGFS',type=int, default=4000,help='Number of snapshot files to process')parser.add_argument('--GridsPerR',type=int, default=128,help='Grid resolution per unit radius (affects image quality)')parser.add_argument('--ZMAX',type=float, default=4.0,help='Maximum Z coordinate for visualization domain')parser.add_argument('--RMAX',type=float, default=4.0,help='Maximum R coordinate for visualization domain')parser.add_argument('--ZMIN',type=float, default=0.0,help='Minimum Z coordinate for visualization domain')parser.add_argument('--tsnap',type=float, default=0.01,help='Time interval between snapshots')parser.add_argument('--caseToProcess',type=str,default='../simulationCases/soapBubble-full',help='Path to simulation case directory')parser.add_argument('--folderToSave',type=str, default='Video',help='Output directory for images')args=parser.parse_args()# Extract argumentsnum_processes=args.CPUsnGFS=args.nGFStsnap=args.tsnapZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMIN# Set up visualization domain (full domain for axisymmetric cases)rmin, rmax, zmin, zmax=[-RMAX, RMAX, ZMIN, ZMAX]GridsPerR=args.GridsPerR# Visualization parameterslw=2# Line width for boundariesfolder=args.folderToSavecaseToProcess=args.caseToProcess# Create output directory if it doesn't existifnotos.path.isdir(folder):os.makedirs(folder)print(f\"Created output directory:{folder}\")# ===============================# Parallel Processing# ===============================print(f\"Starting parallel processing with{num_processes}CPUs...\")print(f\"Processing{nGFS}timesteps from{caseToProcess}\")# Create a pool of worker processeswithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed arguments# This allows us to pass only the timestep index to each workerprocess_func=partial(process_timestep,caseToProcess=caseToProcess,folder=folder,tsnap=tsnap,GridsPerR=GridsPerR,rmin=rmin,rmax=rmax,zmin=zmin,zmax=zmax,lw=lw)# Map the process function to all timesteps# This distributes the work across available CPUspool.map(process_func,range(nGFS))print(f\"Processing complete!",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video-generic.py | SOAPY - Simulation Of Axisymmetric Phenomena in bubblY films - Code Example: Images saved to{folder}/\")print(\"To...",
    "content": "Images saved to{folder}/\")print(\"To create a video from images, use:\")print(f\"  ffmpeg -framerate 30 -pattern_type glob -i '{folder}/*.png' -c:v libx264 output.mp4\")if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/soapy/postProcess/Video-generic.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Documentation | Documentation: Work in progress...",
    "content": "Work in progress Together with St\u00e9phane Zaleski, Chunheng Zhao, and Detlef Lohse For postprocessing: Run the command as follows sh python3 VideoBubbleinSheet.py --asy --Oh 0.01 Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/VideoBubbleinSheet.py postProcess/VideoBubbleinSheet_02.1_tp.py postProcess/VideoBubbleinSheet_02_tp.py postProcess/VideoBubbleinSheet_03.py postProcess/VideoBubbleinSheet_03_all.py postProcess/VideoBubbleinSheet_04.py postProcess/getData.c postProcess/getData_02.c postProcess/getFacet.c postProcess/getFacet1.c postProcess/getFacet2.c postProcess/getFacet_02.c postProcess/getab.c postProcess/geth.c postProcess/out_ab_time.py postProcess/out_h_time.py postProcess/out_theta_time_01.py postProcess/runpostProcess.sh simulationCases simulationCases/asyBubbleinSheet_01.c simulationCases/asyBubbleinSheet_03.c simulationCases/bubbleinSheet_01.1.c simulationCases/bubbleinSheet_01.c simulationCases/bubbleinSheet_02.c simulationCases/bubbleinSheet_03.1.c simulationCases/bubbleinSheet_03.2.c simulationCases/bubbleinSheet_03.3.c simulationCases/bubbleinSheet_03.c simulationCases/bubbleinSheet_04.c simulationCases/bubbleinSheet_05.c simulationCases/makeDirs.sh simulationCases/outEqshape_01.ipynb simulationCases/runCodes_snellius_singleNode.sh src-local src-local/three-phase.h",
    "url": "https://comphy-lab.org/HoleySheet/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Documentation | Documentation - Code Example",
    "content": "sh   python3 VideoBubbleinSheet.py --asy --Oh 0.01",
    "url": "https://comphy-lab.org/HoleySheet/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Documentation: Context",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # tested on MacOS only.",
    "url": "https://comphy-lab.org/HoleySheet/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Documentation: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue. # modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk # Check if --hard flag is passed HARD_RESET = \\f alse if [[ \" \\$ 1\" == \"--hard\" ]]; then HARD_RESET = \\t rue fi # Function to install basilisk install_basilisk() { darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make -k make } # Remove project config always rm -rf .project_config # Check if basilisk needs to be installed if [[ \" \\$ HARD_RESET\" == true ]] || [[ ! -d \"basilisk\" ]]; then echo \"Installing basilisk...\" rm -rf basilisk install_basilisk else echo \"Using existing basilisk installation...\" cd basilisk/src fi # Setup environment variables echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config # Check if qcc is working properly echo \"\\nChecking qcc installation...\" if ! qcc --version > /dev/null 2 >& 1 ; then echo \"\\033[0;31mError: qcc is not working properly.\\033[0m\" echo \"Please ensure you have Xcode Command Line Tools installed.\" echo \"You can install them by running: xcode-select --install\" echo \"For more details, visit: http://basilisk.fr/src/INSTALL\" exit 1 else echo \"\\033[0;32mqcc is properly installed.\\033[0m\" qcc --version fi",
    "url": "https://comphy-lab.org/HoleySheet/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Documentation - Code Example: #!/bin/zsh# tested on...",
    "content": "#!/bin/zsh# tested on MacOS only.",
    "url": "https://comphy-lab.org/HoleySheet/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Documentation - Code Example: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue.# modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basilisk# Check if --hard flag is passedHARD_RESET=\\falseif[[\"\\$1\"==\"--hard\"]];thenHARD_RESET=\\truefi# Function to install basiliskinstall_basilisk(){darcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake-kmake}# Remove project config alwaysrm-rf.project_config# Check if basilisk needs to be installedif[[\"\\$HARD_RESET\"==true]]||[[!-d\"basilisk\"]];thenecho\"Installing basilisk...\"rm-rfbasiliskinstall_basiliskelseecho\"Using existing basilisk installation...\"cdbasilisk/srcfi# Setup environment variablesecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config# Check if qcc is working properlyecho\"\\nChecking qcc installation...\"if!qcc--version>/dev/null2>&1;thenecho\"\\033[0;31mError: qcc is not working properly.\\033[0m\"echo\"Please ensure you have Xcode Command Line Tools installed.\"echo\"You can install them by running: xcode-select --install\"echo\"For more details, visit: http://basilisk.fr/src/INSTALL\"exit1elseecho\"\\033[0;32mqcc is properly installed.\\033[0m\"qcc--versionfi",
    "url": "https://comphy-lab.org/HoleySheet/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.c | Documentation: C/C++ Code",
    "content": "simulationCases/bubbleinSheet_03.c See raw file // Bubbles inside a draining sheet. || Uses CLSVOF // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps #include \u201ctwo-phase-clsvof.h\u201d #include \u201cintegral.h\u201d scalar sigmaf[]; #include \u201cdistance.h\u201d // #include \u201ctwo-phase.h\u201d // #include \u201cnavier-stokes/conserving.h\u201d // #include \u201ctension.h\u201d #define tsnap (1e-1) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define Ldomain 4 int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, tmax; char nameOut[80], dumpFile[80]; // Boundary conditions u.n[right] = dirichlet(-2 * pow(Bo,0.5) * x); u.t[right] = dirichlet(pow(Bo,0.5) * y); p[right] = dirichlet(0.); pf[right] = dirichlet(0.); u.n[top] = dirichlet(pow(Bo,0.5) * y); u.t[top] = dirichlet(-2 * pow(Bo,0.5) * x); p[top] = dirichlet(0.); pf[top] = dirichlet(0.); int main(int argc, char const *argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); tmax = atof(argv[4]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 5) { fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.c | Documentation: Need %d more...",
    "content": "Need %d more arguments\\n\", 5 - argc); return 1; } fprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo); init_grid(1 << 7); // Create intermediate for all snapshots. char comm[80]; sprintf(comm, \"mkdir -p intermediate\"); system(comm); // Name of the restart file, used in writingFiles event. sprintf(dumpFile, \"dump\"); rho1 = 1., rho2 = 1e-3; // Oha = 2e-2 * Oh; Oha = 2e-5; mu1 = Oh, mu2 = Oha; // f.sigma = 1.0; d.sigmaf = sigmaf; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { // fraction(f, difference(1.5625 - x * x, 1 - x * x - y * y)); foreach () { d[] = -(1 - x x - y y); d[] = fabs(x) > 1.25 ? -d[] : d[]; sigmaf[] = 1.; u.x[] = -2 * pow(Bo,0.5) * x; u.y[] = pow(Bo,0.5) * y; } boundary({f, u}); } // return 1; } event adapt(i++) { // scalar KAPPA[]; // curvature(f, KAPPA); adapt_wavelet((scalar *){f, u.x, u.y}, (double[]){fErr, VelErr, VelErr}, MAXlevel, MAXlevel - 3); } // Dumping snapshots event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } // Ending Simulation event end(t = end) { } // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %4.3f\u201d, MAXlevel, Oh, Bo); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e3); if ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e3 ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.c | Documentation: Stopping simulation\\n\" :...",
    "content": "Stopping simulation\\n\" : \"kinetic energy too small now! Stopping!\\n\"; fprintf(ferr, \"%s\", message); fp = fopen(\"log\", \"a\"); fprintf(fp, \"%s\", message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.c | Documentation - Code Example: // Values taken...",
    "content": "// Values taken from the terminal\nMAXlevel = atoi(argv[1]);\nOh = atof(argv[2]);\nBo = atof(argv[3]);\ntmax = atof(argv[4]);",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.c | Documentation - Code Example: // Ensure that...",
    "content": "// Ensure that all the variables were transferred properly from the terminal or job script.\nif (argc < 5)\n{\n    fprintf(ferr, \"Lack of command line arguments. Check! Need %d more arguments\\n\", 5 - argc);\n    return 1;\n}\nfprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo);\ninit_grid(1 << 7);\n// Create intermediate for all snapshots.\nchar comm[80];\nsprintf(comm, \"mkdir -p intermediate\");\nsystem(comm);\n// Name of the restart file, used in writingFiles event.\nsprintf(dumpFile, \"dump\");",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.c | Documentation - Code Example: Context",
    "content": "rho1 = 1., rho2 = 1e-3;\n// Oha = 2e-2 * Oh;\nOha = 2e-5;\nmu1 = Oh, mu2 = Oha; // f.sigma = 1.0;\nd.sigmaf = sigmaf; run();",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.c | Documentation - Code Example",
    "content": "assert(ke > -1e-10);\nassert(ke < 1e3);\n\nif ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0)\n{\n    const char *message = ke > 1e3 ? \"The kinetic energy blew up. Stopping simulation\\n\"\n                                   : \"kinetic energy too small now! Stopping!\\n\";\n    fprintf(ferr, \"%s\", message);\n    fp = fopen(\"log\", \"a\");\n    fprintf(fp, \"%s\", message);\n    fclose(fp);\n    dump(file = dumpFile);\n    return 1;\n}",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation: Context",
    "content": "Simulation Cases asyBubbleinSheet_01.c int MAXlevel; // Oh -> liquid Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR^3w^2/gamma ... asyBubbleinSheet_03.c scalar sigmaf[]; bubbleinSheet_01.1.c int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR^3w^2/gamma... bubbleinSheet_01.c int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR^3w^2/gamma... bubbleinSheet_02.c int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR^3w^2/gamma... bubbleinSheet_03.1.c scalar sigmaf[]; bubbleinSheet_03.2.c scalar sigmaf[]; bubbleinSheet_03.3.c scalar sigmaf[]; bubbleinSheet_03.c scalar sigmaf[]; bubbleinSheet_04.c scalar sigmaf[]; bubbleinSheet_05.c int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR^3w^2/gamma... makeDirs.sh start='1031' end='1039' for i in seq \\$start \\$end; do echo \\$i mkdir -p \\$i cp bubbleinSheets03 \\$i done outEqshape_01.ipynb This notebook provides visualization and analysis related to outEqshape 01. runCodes_snellius_singleNode.sh source ~/.bashshell MAXlevel='9' Oh=('1.00E-03' '3.00E-03' '6.00E-03' '1.00E-02' '3.00E-02' '6.00E-02' '1.00E-01') Bo...",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.c | Documentation: C/C++ Code",
    "content": "simulationCases/bubbleinSheet_01.c See raw file // Bubbles inside a draining sheet. // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps #include \u201ctwo-phase.h\u201d #include \u201cnavier-stokes/conserving.h\u201d #include \u201ctension.h\u201d #define tsnap (1e-1) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define Ldomain 4 int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, tmax; char nameOut[80], dumpFile[80]; // Boundary conditions u.n[right] = dirichlet(-2 * pow(Bo,0.5) * x); u.t[right] = dirichlet(pow(Bo,0.5) * y); p[right] = dirichlet(0.); pf[right] = dirichlet(0.); u.n[top] = dirichlet(pow(Bo,0.5) * y); u.t[top] = dirichlet(-2 * pow(Bo,0.5) * x); p[top] = dirichlet(0.); pf[top] = dirichlet(0.); int main(int argc, char const *argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); tmax = atof(argv[4]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 5) { fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.c | Documentation: Need %d more...",
    "content": "Need %d more arguments\\n\", 5 - argc); return 1; } fprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo); init_grid(1 << 7); // Create intermediate for all snapshots. char comm[80]; sprintf(comm, \"mkdir -p intermediate\"); system(comm); // Name of the restart file, used in writingFiles event. sprintf(dumpFile, \"dump\"); rho1 = 1., rho2 = 1e-3; // Oha = 2e-2 * Oh; Oha = 2e-5; mu1 = Oh, mu2 = Oha; f.sigma = 1.0; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { fraction(f, difference(1.5625 - x * x, 1 - x * x - y * y)); foreach () { u.x[] = -2 * pow(Bo,0.5) * x; u.y[] = pow(Bo,0.5) * y; } boundary({f, u}); } // return 1; } event adapt(i++) { scalar KAPPA[]; curvature(f, KAPPA); adapt_wavelet((scalar *){f, u.x, u.y, KAPPA}, (double[]){fErr, VelErr, VelErr, KErr}, MAXlevel, MAXlevel - 3); } // Dumping snapshots event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } // Ending Simulation event end(t = end) { } // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %4.3f\u201d, MAXlevel, Oh, Bo); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e2); if ((ke > 1e2 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e2 ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.c | Documentation: Stopping simulation\\n\" :...",
    "content": "Stopping simulation\\n\" : \"kinetic energy too small now! Stopping!\\n\"; fprintf(ferr, \"%s\", message); fp = fopen(\"log\", \"a\"); fprintf(fp, \"%s\", message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.c | Documentation - Code Example: // Values taken...",
    "content": "// Values taken from the terminal\nMAXlevel = atoi(argv[1]);\nOh = atof(argv[2]);\nBo = atof(argv[3]);\ntmax = atof(argv[4]);",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.c | Documentation - Code Example: // Ensure that...",
    "content": "// Ensure that all the variables were transferred properly from the terminal or job script.\nif (argc < 5)\n{\n    fprintf(ferr, \"Lack of command line arguments. Check! Need %d more arguments\\n\", 5 - argc);\n    return 1;\n}\nfprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo);\ninit_grid(1 << 7);\n// Create intermediate for all snapshots.\nchar comm[80];\nsprintf(comm, \"mkdir -p intermediate\");\nsystem(comm);\n// Name of the restart file, used in writingFiles event.\nsprintf(dumpFile, \"dump\");",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.c | Documentation - Code Example: Context",
    "content": "rho1 = 1., rho2 = 1e-3;\n// Oha = 2e-2 * Oh;\nOha = 2e-5;\nmu1 = Oh, mu2 = Oha; f.sigma = 1.0; run();",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.c | Documentation - Code Example",
    "content": "assert(ke > -1e-10);\nassert(ke < 1e2);\n\nif ((ke > 1e2 || ke < 1e-6) && i > 1e1 && pid() == 0)\n{\n    const char *message = ke > 1e2 ? \"The kinetic energy blew up. Stopping simulation\\n\"\n                                   : \"kinetic energy too small now! Stopping!\\n\";\n    fprintf(ferr, \"%s\", message);\n    fp = fopen(\"log\", \"a\");\n    fprintf(fp, \"%s\", message);\n    fclose(fp);\n    dump(file = dumpFile);\n    return 1;\n}",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_05.c | Documentation: Context",
    "content": "simulationCases/bubbleinSheet_05.c See raw file // Bubbles inside a draining sheet.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_05.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_05.c | Documentation: C/C++ Code",
    "content": "Initialize with eq. shape // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps #include \u201ctwo-phase.h\u201d #include \u201cnavier-stokes/conserving.h\u201d #include \u201ctension.h\u201d #include \u201cdistance.h\u201d #define tsnap (1e-1) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define Ldomain 4 int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, rh, tmax; char nameOut[80], dumpFile[80]; // Boundary conditions u.n[top] = dirichlet(0.); p[top] = dirichlet(0.); pf[top] = dirichlet(0.); int main(int argc, char const *argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_05.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_05.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); rh = atof(argv[4]); tmax = atof(argv[5]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 6) { fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_05.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_05.c | Documentation: Need %d more...",
    "content": "Need %d more arguments\\n\", 6 - argc); return 1; } fprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo); init_grid(1 << 10); // Create intermediate for all snapshots. char comm[80]; sprintf(comm, \"mkdir -p intermediate\"); system(comm); // Name of the restart file, used in writingFiles event. sprintf(dumpFile, \"dump\"); rho1 = 1., rho2 = 1e-3; // Oha = 2e-2 * Oh; Oha = 2e-5; mu1 = Oh, mu2 = Oha; f.sigma = 1.0; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { fraction(f, y < 2 rh + 1 ? 1 - x x - (y - 2 rh - 1) (y - 2 rh - 1) : 1 - x ); foreach () { u.x[] = -2 pow(Bo,0.5) * x; u.y[] = pow(Bo,0.5) * y; } boundary({f, u}); } // return 1; } event adapt(i++) { scalar KAPPA[]; curvature(f, KAPPA); adapt_wavelet((scalar *){f, u.x, u.y, KAPPA}, (double[]){fErr, VelErr, VelErr, KErr}, MAXlevel, MAXlevel - 3); } // Dumping snapshots event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } // Ending Simulation event end(t = end) { } // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %4.3f\u201d, MAXlevel, Oh, Bo); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e2); if ((ke > 1e2 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e2 ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_05.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_05.c | Documentation: Stopping simulation\\n\" :...",
    "content": "Stopping simulation\\n\" : \"kinetic energy too small now! Stopping!\\n\"; fprintf(ferr, \"%s\", message); fp = fopen(\"log\", \"a\"); fprintf(fp, \"%s\", message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_05.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_05.c | Documentation - Code Example: // Values taken...",
    "content": "// Values taken from the terminal\nMAXlevel = atoi(argv[1]);\nOh = atof(argv[2]);\nBo = atof(argv[3]);\nrh = atof(argv[4]);\ntmax = atof(argv[5]); // Ensure that all the variables were transferred properly from the terminal or job script.\nif (argc < 6)\n{\n    fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_05.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_05.c | Documentation - Code Example: Need %d more...",
    "content": "Need %d more arguments\\n\", 6 - argc);\n    return 1;\n}\nfprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo);\ninit_grid(1 << 10);\n// Create intermediate for all snapshots.\nchar comm[80];\nsprintf(comm, \"mkdir -p intermediate\");\nsystem(comm);\n// Name of the restart file, used in writingFiles event.\nsprintf(dumpFile, \"dump\"); rho1 = 1., rho2 = 1e-3;\n// Oha = 2e-2 * Oh;\nOha = 2e-5;\nmu1 = Oh, mu2 = Oha; f.sigma = 1.0; run();",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_05.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_05.c | Documentation - Code Example",
    "content": "assert(ke > -1e-10);\nassert(ke < 1e2);\n\nif ((ke > 1e2 || ke < 1e-6) && i > 1e1 && pid() == 0)\n{\n    const char *message = ke > 1e2 ? \"The kinetic energy blew up. Stopping simulation\\n\"\n                                   : \"kinetic energy too small now! Stopping!\\n\";\n    fprintf(ferr, \"%s\", message);\n    fp = fopen(\"log\", \"a\");\n    fprintf(fp, \"%s\", message);\n    fclose(fp);\n    dump(file = dumpFile);\n    return 1;\n}",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_05.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.3.c | Documentation: Context",
    "content": "simulationCases/bubbleinSheet_03.3.c See raw file // Bubbles inside a draining sheet. || Uses CLSVOF || Oh_a fixed instead of viscosity ratio // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps #include \u201ctwo-phase-clsvof.h\u201d #include \u201cintegral.h\u201d scalar sigmaf[]; #include \u201cdistance.h\u201d // #include \u201ctwo-phase.h\u201d // #include \u201cnavier-stokes/conserving.h\u201d // #include \u201ctension.h\u201d #define tsnap (1e-1) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define Ldomain 4 int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, tmax; char nameOut[80], dumpFile[80]; // Boundary conditions u.n[right] = dirichlet(-2 * pow(Bo,0.5) * x); u.t[right] = dirichlet(pow(Bo,0.5) * y); p[right] = dirichlet(0.); pf[right] = dirichlet(0.); u.n[top] = dirichlet(pow(Bo,0.5) * y); u.t[top] = dirichlet(-2 * pow(Bo,0.5) * x); p[top] = dirichlet(0.); pf[top] = dirichlet(0.); int main(int argc, char const *argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.3.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.3.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); tmax = atof(argv[4]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 5) { fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.3.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.3.c | Documentation: Need %d more...",
    "content": "Need %d more arguments\\n\", 5 - argc); return 1; } fprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo); init_grid(1 << 7); // Create intermediate for all snapshots. char comm[80]; sprintf(comm, \"mkdir -p intermediate\"); system(comm); // Name of the restart file, used in writingFiles event. sprintf(dumpFile, \"dump\"); rho1 = 1., rho2 = 1e-3; // Oha = 2e-2 * Oh; Oha = 2e-5; mu1 = Oh, mu2 = Oha; // f.sigma = 1.0; d.sigmaf = sigmaf; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { // fraction(f, difference(1.5625 - x * x, 1 - x * x - y * y)); foreach () { d[] = -(1 - x x - y y); d[] = fabs(x) > 1.25 ? -d[] : d[]; sigmaf[] = 1.; u.x[] = -2 * pow(Bo,0.5) * x; u.y[] = pow(Bo,0.5) * y; } boundary({f, u}); } // return 1; } event adapt(i++) { // scalar KAPPA[]; // curvature(f, KAPPA); adapt_wavelet((scalar *){f, u.x, u.y}, (double[]){fErr, VelErr, VelErr}, MAXlevel, MAXlevel - 3); } // Dumping snapshots event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } // Ending Simulation event end(t = end) { } // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %4.3f\u201d, MAXlevel, Oh, Bo); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e3); if ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e3 ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.3.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.3.c | Documentation: Stopping simulation\\n\" :...",
    "content": "Stopping simulation\\n\" : \"kinetic energy too small now! Stopping!\\n\"; fprintf(ferr, \"%s\", message); fp = fopen(\"log\", \"a\"); fprintf(fp, \"%s\", message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.3.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.3.c | Documentation - Code Example: // Values taken...",
    "content": "// Values taken from the terminal\nMAXlevel = atoi(argv[1]);\nOh = atof(argv[2]);\nBo = atof(argv[3]);\ntmax = atof(argv[4]);",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.3.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.3.c | Documentation - Code Example: // Ensure that...",
    "content": "// Ensure that all the variables were transferred properly from the terminal or job script.\nif (argc < 5)\n{\n    fprintf(ferr, \"Lack of command line arguments. Check! Need %d more arguments\\n\", 5 - argc);\n    return 1;\n}\nfprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo);\ninit_grid(1 << 7);\n// Create intermediate for all snapshots.\nchar comm[80];\nsprintf(comm, \"mkdir -p intermediate\");\nsystem(comm);\n// Name of the restart file, used in writingFiles event.\nsprintf(dumpFile, \"dump\");",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.3.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.3.c | Documentation - Code Example: Context",
    "content": "rho1 = 1., rho2 = 1e-3;\n// Oha = 2e-2 * Oh;\nOha = 2e-5;\nmu1 = Oh, mu2 = Oha; // f.sigma = 1.0;\nd.sigmaf = sigmaf; run();",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.3.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.3.c | Documentation - Code Example",
    "content": "assert(ke > -1e-10);\nassert(ke < 1e3);\n\nif ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0)\n{\n    const char *message = ke > 1e3 ? \"The kinetic energy blew up. Stopping simulation\\n\"\n                                   : \"kinetic energy too small now! Stopping!\\n\";\n    fprintf(ferr, \"%s\", message);\n    fp = fopen(\"log\", \"a\");\n    fprintf(fp, \"%s\", message);\n    fclose(fp);\n    dump(file = dumpFile);\n    return 1;\n}",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.3.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.1.c | Documentation: C/C++ Code",
    "content": "simulationCases/bubbleinSheet_03.1.c See raw file // Bubbles inside a draining sheet. || Uses CLSVOF || Reduced film thickness // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps #include \u201ctwo-phase-clsvof.h\u201d #include \u201cintegral.h\u201d scalar sigmaf[]; #include \u201cdistance.h\u201d // #include \u201ctwo-phase.h\u201d // #include \u201cnavier-stokes/conserving.h\u201d // #include \u201ctension.h\u201d #define tsnap (1e-1) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define Ldomain 4 int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, tmax; char nameOut[80], dumpFile[80]; // Boundary conditions u.n[right] = dirichlet(-2 * pow(Bo,0.5) * x); u.t[right] = dirichlet(pow(Bo,0.5) * y); p[right] = dirichlet(0.); pf[right] = dirichlet(0.); u.n[top] = dirichlet(pow(Bo,0.5) * y); u.t[top] = dirichlet(-2 * pow(Bo,0.5) * x); p[top] = dirichlet(0.); pf[top] = dirichlet(0.); int main(int argc, char const *argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.1.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.1.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); tmax = atof(argv[4]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 5) { fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.1.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.1.c | Documentation: Need %d more...",
    "content": "Need %d more arguments\\n\", 5 - argc); return 1; } fprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo); init_grid(1 << 7); // Create intermediate for all snapshots. char comm[80]; sprintf(comm, \"mkdir -p intermediate\"); system(comm); // Name of the restart file, used in writingFiles event. sprintf(dumpFile, \"dump\"); rho1 = 1., rho2 = 1e-3; // Oha = 2e-2 * Oh; Oha = 2e-5; mu1 = Oh, mu2 = Oha; // f.sigma = 1.0; d.sigmaf = sigmaf; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { // fraction(f, difference(1.5625 - x * x, 1 - x * x - y * y)); foreach () { d[] = -(1 - x x - y y); d[] = fabs(x) > 1.1 ? -d[] : d[]; sigmaf[] = 1.; u.x[] = -2 * pow(Bo,0.5) * x; u.y[] = pow(Bo,0.5) * y; } boundary({f, u}); } // return 1; } event adapt(i++) { // scalar KAPPA[]; // curvature(f, KAPPA); adapt_wavelet((scalar *){f, u.x, u.y}, (double[]){fErr, VelErr, VelErr}, MAXlevel, MAXlevel - 3); } // Dumping snapshots event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } // Ending Simulation event end(t = end) { } // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %4.3f\u201d, MAXlevel, Oh, Bo); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e3); if ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e3 ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.1.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.1.c | Documentation: Stopping simulation\\n\" :...",
    "content": "Stopping simulation\\n\" : \"kinetic energy too small now! Stopping!\\n\"; fprintf(ferr, \"%s\", message); fp = fopen(\"log\", \"a\"); fprintf(fp, \"%s\", message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.1.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.1.c | Documentation - Code Example: // Values taken...",
    "content": "// Values taken from the terminal\nMAXlevel = atoi(argv[1]);\nOh = atof(argv[2]);\nBo = atof(argv[3]);\ntmax = atof(argv[4]);",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.1.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.1.c | Documentation - Code Example: // Ensure that...",
    "content": "// Ensure that all the variables were transferred properly from the terminal or job script.\nif (argc < 5)\n{\n    fprintf(ferr, \"Lack of command line arguments. Check! Need %d more arguments\\n\", 5 - argc);\n    return 1;\n}\nfprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo);\ninit_grid(1 << 7);\n// Create intermediate for all snapshots.\nchar comm[80];\nsprintf(comm, \"mkdir -p intermediate\");\nsystem(comm);\n// Name of the restart file, used in writingFiles event.\nsprintf(dumpFile, \"dump\");",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.1.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.1.c | Documentation - Code Example: Context",
    "content": "rho1 = 1., rho2 = 1e-3;\n// Oha = 2e-2 * Oh;\nOha = 2e-5;\nmu1 = Oh, mu2 = Oha; // f.sigma = 1.0;\nd.sigmaf = sigmaf; run();",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.1.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.1.c | Documentation - Code Example",
    "content": "assert(ke > -1e-10);\nassert(ke < 1e3);\n\nif ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0)\n{\n    const char *message = ke > 1e3 ? \"The kinetic energy blew up. Stopping simulation\\n\"\n                                   : \"kinetic energy too small now! Stopping!\\n\";\n    fprintf(ferr, \"%s\", message);\n    fp = fopen(\"log\", \"a\");\n    fprintf(fp, \"%s\", message);\n    fclose(fp);\n    dump(file = dumpFile);\n    return 1;\n}",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.1.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/asyBubbleinSheet_01.c | Documentation: C/C++ Code",
    "content": "simulationCases/asyBubbleinSheet_01.c See raw file // Asymmetric Bubble inside a draining sheet. // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps #include \u201ctwo-phase.h\u201d #include \u201cnavier-stokes/conserving.h\u201d #include \u201ctension.h\u201d #define tsnap (1e-2) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using height function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define Ldomain 8 int MAXlevel; // Oh -> liquid Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, offset, tmax; char nameOut[80], dumpFile[80]; // Boundary conditions u.n[left] = dirichlet(-2 * pow(Bo,0.5) * x); u.t[left] = dirichlet(pow(Bo,0.5) * y); p[left] = dirichlet(0.); pf[left] = dirichlet(0.); u.n[right] = dirichlet(-2 * pow(Bo,0.5) * x); u.t[right] = dirichlet(pow(Bo,0.5) * y); p[right] = dirichlet(0.); pf[right] = dirichlet(0.); u.n[top] = dirichlet(pow(Bo,0.5) * y); u.t[top] = dirichlet(-2 * pow(Bo,0.5) * x); p[top] = dirichlet(0.); pf[top] = dirichlet(0.); int main(int argc, char const argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/asyBubbleinSheet_01.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/asyBubbleinSheet_01.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; X0 = -0.5 Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); offset = atof(argv[4]); tmax = atof(argv[5]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 6) { fprintf(ferr, \u201cLack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/asyBubbleinSheet_01.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/asyBubbleinSheet_01.c | Documentation: Need %d more...",
    "content": "Need %d more arguments\u201d, 6 - argc); return 1; } fprintf(ferr, \u201cLevel %d, Oh %2.1e, Bo %2.1e, offset %4.3f\u201d, MAXlevel, Oh, Bo, offset); init_grid(1 << 8); // Create intermediate for all snapshots. char comm[80]; sprintf(comm, \u201cmkdir -p intermediate\u201d); system(comm); // Name of the restart file, used in writingFiles event. sprintf(dumpFile, \u201cdump\u201d); rho1 = 1., rho2 = 1e-3; Oha = 2e-2 * Oh; mu1 = Oh, mu2 = Oha; f.sigma = 1.0; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { fraction(f, difference(2.25 - x * x, 1 - (x - offset) * (x - offset) - y * y)); foreach () { u.x[] = -2 * pow(Bo,0.5) * x; u.y[] = pow(Bo,0.5) * y; } boundary({f, u}); } // return 1; } event adapt(i++) { scalar KAPPA[]; curvature(f, KAPPA); adapt_wavelet((scalar *){f, u.x, u.y, KAPPA}, (double[]){fErr, VelErr, VelErr, KErr}, MAXlevel, MAXlevel - 3); } // Dumping snapshots event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } // Ending Simulation event end(t = end) { } // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %2.1e, offset %4.3f\u201d, MAXlevel, Oh, Bo, offset); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e3); if ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e3 ? \u201cThe kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/asyBubbleinSheet_01.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/asyBubbleinSheet_01.c | Documentation: Stopping simulation\u201d :...",
    "content": "Stopping simulation\u201d : \u201ckinetic energy too small now! Stopping!\u201d; fprintf(ferr, \u201c%s\u201d, message); fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%s\u201d, message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/asyBubbleinSheet_01.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_02.c | Documentation: Context",
    "content": "simulationCases/bubbleinSheet_02.c See raw file // Bubbles inside a draining sheet.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_02.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_02.c | Documentation: C/C++ Code",
    "content": "Three phase // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps // #include \u201ctwo-phase.h\u201d #include \u201cthree-phase.h\u201d // #include \u201cnavier-stokes/conserving.h\u201d #include \u201ctension.h\u201d #include \u201cdistance.h\u201d // #include \u201cadapt_wavelet_limited_v2.h\u201d #define tsnap (1e-1) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J // Numbers! #define Ldomain 4 // Surface tensions #define SIGMA13 (1.0) #define SIGMA12 (1.0) int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, tmax; char nameOut[80], dumpFile[80]; // boundary conditions u.n[right] = dirichlet(-2 * pow(Bo, 0.5) * x); u.t[right] = dirichlet(pow(Bo, 0.5) * y); p[right] = dirichlet(0.); pf[right] = dirichlet(0); u.n[top] = dirichlet(pow(Bo, 0.5) * y); u.t[top] = dirichlet(-2 * pow(Bo, 0.5) * x); p[top] = dirichlet(0.); pf[top] = dirichlet(0); int main(int argc, char const *argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_02.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_02.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); tmax = atof(argv[4]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 4) { fprintf(ferr, \u201cLack of command line arguments. Check! Need %d more arguments\u201d, 4 - argc); return 1; } fprintf(ferr, \u201cLevel %d, Oh %2.1e, Bo %4.3f\u201d, MAXlevel, Oh, Bo); init_grid(1 << 7); // Create a folder named intermediate where all the simulation snapshots are stored. char comm[80]; sprintf(comm, \u201cmkdir -p intermediate\u201d); system(comm); // Name of the restart file.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_02.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_02.c | Documentation: Context",
    "content": "See writingFiles event. sprintf(dumpFile, \u201cdump\u201d); rho1 = 1., rho2 = 1e-3, rho3 = 1e-3; // Oha = 2e-2 * Oh; Oha = 2e-5; mu1 = Oh, mu2 = Oha, mu3 = Oha; // f.sigma = 1.0; f1.sigma = SIGMA13; f2.sigma = SIGMA12; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { fraction(f1, 1.2 - x * x); fraction(f2, 1 - x * x - y * y); foreach () { u.x[] = -2 * pow(Bo, 0.5) * x; u.y[] = pow(Bo, 0.5) * y; } // boundary ({f1,f2,u}); } // return 1; } event adapt(i++) { scalar KAPPA1[], KAPPA2[]; curvature(f1, KAPPA1); curvature(f2, KAPPA2); adapt_wavelet((scalar *){f1, f2, u.x, u.y, KAPPA1, KAPPA2}, (double[]){fErr, fErr, VelErr, VelErr, KErr, KErr}, MAXlevel, MAXlevel - 6); } event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } event end(t = end) {} // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f1[], f2[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %4.3f\u201d, MAXlevel, Oh, Bo); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e2); if ((ke > 1e2 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e2 ? \u201cThe kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_02.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_02.c | Documentation: Stopping simulation\u201d :...",
    "content": "Stopping simulation\u201d : \u201ckinetic energy too small now! Stopping!\u201d; fprintf(ferr, \u201c%s\u201d, message); fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%s\u201d, message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_02.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCodes_snellius_singleNode.sh | Documentation: Context",
    "content": "simulationCases/runCodes_snellius_singleNode.sh See raw file runCodes_snellius_singleNode.sh #!/bin/bash #SBATCH -N 1 #SBATCH --partition=genoa #SBATCH --ntasks-per-node=32 #SBATCH --job-name=1010 #SBATCH --time=24:00:00 #SBATCH --mail-type=ALL #SBATCH --mail-type=ALL #SBATCH --error=job.%J.err #SBATCH --output=job.%J.out #SBATCH --mail-user=a.k.dixit@utwente.nl source ~/.bash_shell MAXlevel = \"9\" Oh = ( \"1.00E-03\" \"3.00E-03\" \"6.00E-03\" \"1.00E-02\" \"3.00E-02\" \"6.00E-02\" \"1.00E-01\" ) Bo = \"0.001\" tmax = \"200\" start_data = 1010 start = 1015 end = 1016 for (( i = start ; i <= end ; i ++ )); do index = \\$ (( i - start_data )) dir = \\$ i cd \\$ dir || { echo \"Failed to change directory to \\$ dir\" ; exit 1 ; } srun -n 16 --gres = cpu:16 --exclusive bubbleinSheet_01 \\$ MAXlevel \\$ {Oh [ index ] } \\$ Bo \\$ tmax & cd ../ done wait #CC99='mpicc -std=c99' qcc -Wall -O2 -D_MPI=1 bubbleinSheet_01.c -o bubbleinSheet_01 -lm -disable-dimensions #CC99='mpicc -std=c99' qcc -Wall -O2 -D_MPI=1 asyBubbleinSheet_01.c -o asyBubbleinSheet_01 -lm -disable-dimensions #srun -n 96 asyBubbleinSheets_v1 \\$MAXlevel \\$Oh \\$offset \\$tmax",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/runCodes_snellius_singleNode.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCodes_snellius_singleNode.sh | Documentation - Code Example: #!/bin/bash#SBATCH -N 1#SBATCH...",
    "content": "#!/bin/bash#SBATCH -N 1#SBATCH --partition=genoa#SBATCH --ntasks-per-node=32#SBATCH --job-name=1010#SBATCH --time=24:00:00#SBATCH --mail-type=ALL#SBATCH --mail-type=ALL#SBATCH --error=job.%J.err#SBATCH --output=job.%J.out#SBATCH --mail-user=a.k.dixit@utwente.nlsource~/.bash_shellMAXlevel=\"9\"Oh=(\"1.00E-03\"\"3.00E-03\"\"6.00E-03\"\"1.00E-02\"\"3.00E-02\"\"6.00E-02\"\"1.00E-01\")Bo=\"0.001\"tmax=\"200\"start_data=1010start=1015end=1016for((i=start;i<=end;i++));doindex=\\$((i-start_data))dir=\\$icd\\$dir||{echo\"Failed to change directory to\\$dir\";exit1;}srun-n16--gres=cpu:16--exclusivebubbleinSheet_01\\$MAXlevel\\${Oh[index]}\\$Bo\\$tmax&cd../donewait#CC99='mpicc -std=c99' qcc -Wall -O2 -D_MPI=1 bubbleinSheet_01.c -o bubbleinSheet_01 -lm -disable-dimensions#CC99='mpicc -std=c99' qcc -Wall -O2 -D_MPI=1 asyBubbleinSheet_01.c -o asyBubbleinSheet_01 -lm -disable-dimensions#srun -n 96 asyBubbleinSheets_v1 \\$MAXlevel \\$Oh \\$offset \\$tmax",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/runCodes_snellius_singleNode.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/outEqshape_01.ipynb | Documentation",
    "content": "simulationCases/outEqshape_01.ipynb See raw file outEqshape_01.ipynb Jupyter Notebook: outEqshape_01.ipynb Download Notebook View in nbviewer Open in Colab About this notebook This notebook provides visualization and analysis related to outEqshape 01. Key Features: Visualization of data and results Analysis of simulation outputs Interactive exploration of parameters Tip: For the best interactive experience, download the notebook or open it in Google Colab. Notebook Preview Notebook Preview Unavailable The notebook preview could not be loaded. This may be because: The notebook file is not yet available in the repository The nbviewer service is temporarily unavailable The repository is private or has access restrictions You can still download the notebook using the button above or view it directly through one of the external services.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/outEqshape_01.ipynb.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/asyBubbleinSheet_03.c | Documentation: C/C++ Code",
    "content": "simulationCases/asyBubbleinSheet_03.c See raw file // Asymmetric Bubble inside a draining sheet. || Uses CLSVOF // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps #include \u201ctwo-phase-clsvof.h\u201d #include \u201cintegral.h\u201d scalar sigmaf[]; #include \u201cdistance.h\u201d #define tsnap (1e-1) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using height function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define Ldomain 4 int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, offset, tmax; char nameOut[80], dumpFile[80]; // Boundary conditions u.n[left] = dirichlet(-2 * pow(Bo,0.5) * x); u.t[left] = dirichlet(pow(Bo,0.5) * y); p[left] = dirichlet(0.); pf[left] = dirichlet(0.); u.n[right] = dirichlet(-2 * pow(Bo,0.5) * x); u.t[right] = dirichlet(pow(Bo,0.5) * y); p[right] = dirichlet(0.); pf[right] = dirichlet(0.); u.n[top] = dirichlet(pow(Bo,0.5) * y); u.t[top] = dirichlet(-2 * pow(Bo,0.5) * x); p[top] = dirichlet(0.); pf[top] = dirichlet(0.); int main(int argc, char const argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/asyBubbleinSheet_03.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/asyBubbleinSheet_03.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; X0 = -0.5 Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); offset = atof(argv[4]); tmax = atof(argv[5]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 6) { fprintf(ferr, \u201cLack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/asyBubbleinSheet_03.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/asyBubbleinSheet_03.c | Documentation: Need %d more...",
    "content": "Need %d more arguments\u201d, 6 - argc); return 1; } fprintf(ferr, \u201cLevel %d, Oh %2.1e, Bo %2.1e, offset %4.3f\u201d, MAXlevel, Oh, Bo, offset); init_grid(1 << 8); // Create intermediate for all snapshots. char comm[80]; sprintf(comm, \u201cmkdir -p intermediate\u201d); system(comm); // Name of the restart file, used in writingFiles event. sprintf(dumpFile, \u201cdump\u201d); rho1 = 1., rho2 = 1e-3; Oha = 2e-5; mu1 = Oh, mu2 = Oha; // f.sigma = 1.0; d.sigmaf = sigmaf; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { // fraction(f, difference(2.25 - x * x, 1 - (x - offset) * (x - offset) - y * y)); foreach () { d[] = -(1 - (x - offset) * (x - offset) - y * y); d[] = fabs(x) > 1.2 ? -d[] : d[]; sigmaf[] = 1.; u.x[] = -2 * pow(Bo,0.5) * x; u.y[] = pow(Bo,0.5) * y; } boundary({f, u}); } // return 1; } event adapt(i++) { // scalar KAPPA[]; // curvature(f, KAPPA); adapt_wavelet((scalar *){f, u.x, u.y}, (double[]){fErr, VelErr, VelErr}, MAXlevel, MAXlevel - 3); } // Dumping snapshots event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } // Ending Simulation event end(t = end) { } // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %2.1e, offset %4.3f\u201d, MAXlevel, Oh, Bo, offset); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e4); if ((ke > 1e4 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e4 ? \u201cThe kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/asyBubbleinSheet_03.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/asyBubbleinSheet_03.c | Documentation: Stopping simulation\u201d :...",
    "content": "Stopping simulation\u201d : \u201ckinetic energy too small now! Stopping!\u201d; fprintf(ferr, \u201c%s\u201d, message); fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%s\u201d, message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/asyBubbleinSheet_03.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/makeDirs.sh | Documentation",
    "content": "simulationCases/makeDirs.sh See raw file makeDirs.sh #!/bin/bash start = \"1031\" end = \"1039\" for i in ` seq \\$ start \\$ end `; do echo \\$ i mkdir -p \\$ i cp bubbleinSheets_03 \\$ i done",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/makeDirs.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/makeDirs.sh | Documentation - Code Example",
    "content": "#!/bin/bashstart=\"1031\"end=\"1039\"foriin`seq\\$start\\$end`;doecho\\$imkdir-p\\$icpbubbleinSheets_03\\$idone",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/makeDirs.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.2.c | Documentation: Context",
    "content": "simulationCases/bubbleinSheet_03.2.c See raw file // Bubbles inside a draining sheet. || Uses CLSVOF || Reduced film thickness || Viscocapillary time scale based formulation // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps #include \u201ctwo-phase-clsvof.h\u201d #include \u201cintegral.h\u201d scalar sigmaf[]; #include \u201cdistance.h\u201d // #include \u201ctwo-phase.h\u201d // #include \u201cnavier-stokes/conserving.h\u201d // #include \u201ctension.h\u201d #define tsnap (1e-1) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define Ldomain 4 int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, tmax; char nameOut[80], dumpFile[80]; // Boundary conditions u.n[right] = dirichlet(-2 * Oh * pow(Bo,0.5) * x); u.t[right] = dirichlet(Oh * pow(Bo,0.5) * y); p[right] = dirichlet(0.); pf[right] = dirichlet(0.); u.n[top] = dirichlet(Oh * pow(Bo,0.5) * y); u.t[top] = dirichlet(-2 * Oh * pow(Bo,0.5) * x); p[top] = dirichlet(0.); pf[top] = dirichlet(0.); int main(int argc, char const *argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.2.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.2.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); tmax = atof(argv[4]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 5) { fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.2.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.2.c | Documentation: Need %d more...",
    "content": "Need %d more arguments\\n\", 5 - argc); return 1; } fprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo); init_grid(1 << 7); // Create intermediate for all snapshots. char comm[80]; sprintf(comm, \"mkdir -p intermediate\"); system(comm); // Name of the restart file, used in writingFiles event. sprintf(dumpFile, \"dump\"); rho1 = 1./(Oh*Oh), rho2 = 1e-3/(Oh*Oh); mu1 = 1., mu2 = 2e-2; // f.sigma = 1.0; d.sigmaf = sigmaf; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { // fraction(f, difference(1.5625 - x * x, 1 - x * x - y * y)); foreach () { d[] = -(1 - x x - y y); d[] = fabs(x) > 1.07 ? -d[] : d[]; sigmaf[] = 1.; u.x[] = -2 * Bo * x; u.y[] = Bo * y; } boundary({f, u}); } // return 1; } event adapt(i++) { // scalar KAPPA[]; // curvature(f, KAPPA); adapt_wavelet((scalar *){f, u.x, u.y}, (double[]){fErr, VelErr, VelErr}, MAXlevel, MAXlevel - 3); } // Dumping snapshots event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } // Ending Simulation event end(t = end) { } // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %4.3f\u201d, MAXlevel, Oh, Bo); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e3); if ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e3 ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.2.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.2.c | Documentation: Stopping simulation\\n\" :...",
    "content": "Stopping simulation\\n\" : \"kinetic energy too small now! Stopping!\\n\"; fprintf(ferr, \"%s\", message); fp = fopen(\"log\", \"a\"); fprintf(fp, \"%s\", message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.2.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.2.c | Documentation - Code Example: // Values taken...",
    "content": "// Values taken from the terminal\nMAXlevel = atoi(argv[1]);\nOh = atof(argv[2]);\nBo = atof(argv[3]);\ntmax = atof(argv[4]);",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.2.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.2.c | Documentation - Code Example: // Ensure that...",
    "content": "// Ensure that all the variables were transferred properly from the terminal or job script.\nif (argc < 5)\n{\n    fprintf(ferr, \"Lack of command line arguments. Check! Need %d more arguments\\n\", 5 - argc);\n    return 1;\n}\nfprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo);\ninit_grid(1 << 7);\n// Create intermediate for all snapshots.\nchar comm[80];\nsprintf(comm, \"mkdir -p intermediate\");\nsystem(comm);\n// Name of the restart file, used in writingFiles event.\nsprintf(dumpFile, \"dump\");",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.2.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.2.c | Documentation - Code Example: Context",
    "content": "rho1 = 1./(Oh*Oh), rho2 = 1e-3/(Oh*Oh);\nmu1 = 1., mu2 = 2e-2; // f.sigma = 1.0;\nd.sigmaf = sigmaf; run();",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.2.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_03.2.c | Documentation - Code Example",
    "content": "assert(ke > -1e-10);\nassert(ke < 1e3);\n\nif ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0)\n{\n    const char *message = ke > 1e3 ? \"The kinetic energy blew up. Stopping simulation\\n\"\n                                   : \"kinetic energy too small now! Stopping!\\n\";\n    fprintf(ferr, \"%s\", message);\n    fp = fopen(\"log\", \"a\");\n    fprintf(fp, \"%s\", message);\n    fclose(fp);\n    dump(file = dumpFile);\n    return 1;\n}",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_03.2.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_04.c | Documentation: Context",
    "content": "simulationCases/bubbleinSheet_04.c See raw file // Bubbles inside a draining sheet. || Uses CLSVOF || Oh_a fixed instead of viscosity ratio || No bubble // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps #include \u201ctwo-phase-clsvof.h\u201d #include \u201cintegral.h\u201d scalar sigmaf[]; #include \u201cdistance.h\u201d // #include \u201ctwo-phase.h\u201d // #include \u201cnavier-stokes/conserving.h\u201d // #include \u201ctension.h\u201d #define tsnap (1e-1) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define Ldomain 4 int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, tmax; char nameOut[80], dumpFile[80]; // Boundary conditions u.n[right] = dirichlet(-2 * pow(Bo,0.5) * x); u.t[right] = dirichlet(pow(Bo,0.5) * y); p[right] = dirichlet(0.); pf[right] = dirichlet(0.); u.n[top] = dirichlet(pow(Bo,0.5) * y); u.t[top] = dirichlet(-2 * pow(Bo,0.5) * x); p[top] = dirichlet(0.); pf[top] = dirichlet(0.); int main(int argc, char const *argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_04.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_04.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); tmax = atof(argv[4]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 5) { fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_04.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_04.c | Documentation: Need %d more...",
    "content": "Need %d more arguments\\n\", 5 - argc); return 1; } fprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo); init_grid(1 << 7); // Create intermediate for all snapshots. char comm[80]; sprintf(comm, \"mkdir -p intermediate\"); system(comm); // Name of the restart file, used in writingFiles event. sprintf(dumpFile, \"dump\"); rho1 = 1., rho2 = 1e-3; // Oha = 2e-2 * Oh; Oha = 2e-5; mu1 = Oh, mu2 = Oha; // f.sigma = 1.0; d.sigmaf = sigmaf; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { // fraction(f, difference(1.5625 - x * x, 1 - x * x - y * y)); foreach () { // d[] = -(1 - x x - y y); // d[] = fabs(x) > 1.25 ? -d[] : d[]; d[] = (1 - x); sigmaf[] = 1.; u.x[] = -2 * pow(Bo,0.5) * x; u.y[] = pow(Bo,0.5) * y; } boundary({f, u}); } // return 1; } event adapt(i++) { // scalar KAPPA[]; // curvature(f, KAPPA); adapt_wavelet((scalar *){f, u.x, u.y}, (double[]){fErr, VelErr, VelErr}, MAXlevel, MAXlevel - 3); } // Dumping snapshots event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } // Ending Simulation event end(t = end) { } // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %4.3f\u201d, MAXlevel, Oh, Bo); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e3); if ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e3 ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_04.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_04.c | Documentation: Stopping simulation\\n\" :...",
    "content": "Stopping simulation\\n\" : \"kinetic energy too small now! Stopping!\\n\"; fprintf(ferr, \"%s\", message); fp = fopen(\"log\", \"a\"); fprintf(fp, \"%s\", message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_04.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_04.c | Documentation - Code Example: // Values taken...",
    "content": "// Values taken from the terminal\nMAXlevel = atoi(argv[1]);\nOh = atof(argv[2]);\nBo = atof(argv[3]);\ntmax = atof(argv[4]);",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_04.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_04.c | Documentation - Code Example: // Ensure that...",
    "content": "// Ensure that all the variables were transferred properly from the terminal or job script.\nif (argc < 5)\n{\n    fprintf(ferr, \"Lack of command line arguments. Check! Need %d more arguments\\n\", 5 - argc);\n    return 1;\n}\nfprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo);\ninit_grid(1 << 7);\n// Create intermediate for all snapshots.\nchar comm[80];\nsprintf(comm, \"mkdir -p intermediate\");\nsystem(comm);\n// Name of the restart file, used in writingFiles event.\nsprintf(dumpFile, \"dump\");",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_04.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_04.c | Documentation - Code Example: Context",
    "content": "rho1 = 1., rho2 = 1e-3;\n// Oha = 2e-2 * Oh;\nOha = 2e-5;\nmu1 = Oh, mu2 = Oha; // f.sigma = 1.0;\nd.sigmaf = sigmaf; run();",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_04.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_04.c | Documentation - Code Example",
    "content": "assert(ke > -1e-10);\nassert(ke < 1e3);\n\nif ((ke > 1e3 || ke < 1e-6) && i > 1e1 && pid() == 0)\n{\n    const char *message = ke > 1e3 ? \"The kinetic energy blew up. Stopping simulation\\n\"\n                                   : \"kinetic energy too small now! Stopping!\\n\";\n    fprintf(ferr, \"%s\", message);\n    fp = fopen(\"log\", \"a\");\n    fprintf(fp, \"%s\", message);\n    fclose(fp);\n    dump(file = dumpFile);\n    return 1;\n}",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_04.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.1.c | Documentation: Context",
    "content": "simulationCases/bubbleinSheet_01.1.c See raw file // Bubbles inside a draining sheet.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.1.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.1.c | Documentation: C/C++ Code",
    "content": "Initialize with eq. shape // Id 1 is liquid pool, and Id 2 is Newtonian gas. #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #define FILTERED // Smear density and viscosity jumps #include \u201ctwo-phase.h\u201d #include \u201cnavier-stokes/conserving.h\u201d #include \u201ctension.h\u201d #include \u201cdistance.h\u201d #define tsnap (1e-1) // 0.001 only for some cases. // Error tolerancs #define fErr (1e-3) // error tolerance in f1 VOF #define KErr (1e-6) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr (1e-3) // error tolerances in velocity \u2013 Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define Ldomain 4 int MAXlevel; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // Bo -> Bond number = rhoR 3w 2/gamma double Oh, Oha, Bo, tmax; char nameOut[80], dumpFile[80]; // Boundary conditions // u.n[right] = dirichlet(-2 * Bo * x); // u.t[right] = dirichlet(Bo * y); // p[right] = dirichlet(0.); // pf[right] = dirichlet(0.); // u.n[top] = dirichlet(Bo * y); // u.t[top] = dirichlet(-2 * Bo * x); // p[top] = dirichlet(0.); // pf[top] = dirichlet(0.); u.n[right] = dirichlet(0.); u.t[top] = dirichlet(0.); int main(int argc, char const *argv[]) { dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.1.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.1.c | Documentation: L0 = Ldomain;...",
    "content": "L0 = Ldomain; // Values taken from the terminal MAXlevel = atoi(argv[1]); Oh = atof(argv[2]); Bo = atof(argv[3]); tmax = atof(argv[4]); // Ensure that all the variables were transferred properly from the terminal or job script. if (argc < 5) { fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.1.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.1.c | Documentation: Need %d more...",
    "content": "Need %d more arguments\\n\", 5 - argc); return 1; } fprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo); init_grid(1 << 10); // Create intermediate for all snapshots. char comm[80]; sprintf(comm, \"mkdir -p intermediate\"); system(comm); // Name of the restart file, used in writingFiles event. sprintf(dumpFile, \"dump\"); rho1 = 1., rho2 = 1e-3; // Oha = 2e-2 * Oh; Oha = 2e-5; mu1 = Oh, mu2 = Oha; f.sigma = 1.0; run(); } event init(t = 0) { if (!restore(file = dumpFile)) { char filename[60]; sprintf(filename, \u201cf.txt\u201d); FILE fp = fopen(filename, \u201crb\u201d); if (fp == NULL) { fprintf(ferr, \u201cThere is no file named %s\u201d, filename); return 1; } coord InitialShape; InitialShape = input_xy(fp); fclose(fp); scalar d[]; distance(d, InitialShape); while (adapt_wavelet((scalar *){f, d}, (double[]){1e-8, 1e-8}, MAXlevel).nf) ; // The distance function is defined at the center of each cell, we have // to calculate the value of this function at each vertex. vertex scalar phi[]; foreach_vertex() { phi[] = -(d[] + d[-1] + d[0, -1] + d[-1, -1]) / 4.; } // We can now initialize the volume fraction of the domain. fractions(phi, f); } // return 1; } event adapt(i++) { scalar KAPPA[]; curvature(f, KAPPA); adapt_wavelet((scalar *){f, u.x, u.y, KAPPA}, (double[]){fErr, VelErr, VelErr, KErr}, MAXlevel, MAXlevel - 3); } // Dumping snapshots event writingFiles(t = 0; t += tsnap; t <= tmax) { dump(file = dumpFile); sprintf(nameOut, \u201cintermediate/snapshot-%5.4f\u201d, t); dump(file = nameOut); } // Ending Simulation event end(t = end) { } // Log writing event logWriting(i++) { double ke = 0.; foreach (reduction(+ : ke)) { ke += (2 * pi * y) * (0.5 * rho(f[]) * (sq(u.x[]) + sq(u.y[]))) * sq(Delta); } static FILE *fp; if (pid() == 0) { if (i == 0) { fprintf(ferr, \u201ci dt t ke\u201d); fp = fopen(\u201clog\u201d, \u201cw\u201d); fprintf(fp, \u201cLevel %d, Oh %2.1e, Bo %4.3f\u201d, MAXlevel, Oh, Bo); fprintf(fp, \u201ci dt t ke\u201d); } else { fp = fopen(\u201clog\u201d, \u201ca\u201d); fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); } fprintf(fp, \u201c%d %g %g %g\u201d, i, dt, t, ke); fclose(fp); fprintf(ferr, \u201c%d %g %g %g\u201d, i, dt, t, ke); } assert(ke > -1e-10); assert(ke < 1e2); if ((ke > 1e2 || ke < 1e-6) && i > 1e1 && pid() == 0) { const char *message = ke > 1e2 ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.1.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.1.c | Documentation: Stopping simulation\\n\" :...",
    "content": "Stopping simulation\\n\" : \"kinetic energy too small now! Stopping!\\n\"; fprintf(ferr, \"%s\", message); fp = fopen(\"log\", \"a\"); fprintf(fp, \"%s\", message); fclose(fp); dump(file = dumpFile); return 1; } }",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.1.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.1.c | Documentation - Code Example: // Values taken...",
    "content": "// Values taken from the terminal\nMAXlevel = atoi(argv[1]);\nOh = atof(argv[2]);\nBo = atof(argv[3]);\ntmax = atof(argv[4]); // Ensure that all the variables were transferred properly from the terminal or job script.\nif (argc < 5)\n{\n    fprintf(ferr, \"Lack of command line arguments. Check!",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.1.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.1.c | Documentation - Code Example: Need %d more...",
    "content": "Need %d more arguments\\n\", 5 - argc);\n    return 1;\n}\nfprintf(ferr, \"Level %d, Oh %2.1e, Bo %4.3f\\n\", MAXlevel, Oh, Bo);\ninit_grid(1 << 10);\n// Create intermediate for all snapshots.\nchar comm[80];\nsprintf(comm, \"mkdir -p intermediate\");\nsystem(comm);\n// Name of the restart file, used in writingFiles event.\nsprintf(dumpFile, \"dump\"); rho1 = 1., rho2 = 1e-3;\n// Oha = 2e-2 * Oh;\nOha = 2e-5;\nmu1 = Oh, mu2 = Oha; f.sigma = 1.0; run();",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.1.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.1.c | Documentation - Code Example",
    "content": "while (adapt_wavelet((scalar *){f, d}, (double[]){1e-8, 1e-8}, MAXlevel).nf)\n        ;\n\n    // The distance function is defined at the center of each cell, we have\n    // to calculate the value of this function at each vertex.\n    vertex scalar phi[];\n    foreach_vertex()\n    {\n        phi[] = -(d[] + d[-1] + d[0, -1] + d[-1, -1]) / 4.;\n    }\n\n    // We can now initialize the volume fraction of the domain.\n    fractions(phi, f);\n}\n// return 1;",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.1.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/bubbleinSheet_01.1.c | Documentation - Code Example",
    "content": "assert(ke > -1e-10);\nassert(ke < 1e2);\n\nif ((ke > 1e2 || ke < 1e-6) && i > 1e1 && pid() == 0)\n{\n    const char *message = ke > 1e2 ? \"The kinetic energy blew up. Stopping simulation\\n\"\n                                   : \"kinetic energy too small now! Stopping!\\n\";\n    fprintf(ferr, \"%s\", message);\n    fp = fopen(\"log\", \"a\");\n    fprintf(fp, \"%s\", message);\n    fclose(fp);\n    dump(file = dumpFile);\n    return 1;\n}",
    "url": "https://comphy-lab.org/HoleySheet/simulationCases/bubbleinSheet_01.1.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files three-phase.h This file helps setup simulations for flows of three fluids separated by corresponding interfaces (i.e. immiscible fl...",
    "url": "https://comphy-lab.org/HoleySheet/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/three-phase.h | Documentation: Context",
    "content": "src-local/three-phase.h See raw file Three-phase interfacial flows This file helps setup simulations for flows of three fluids separated by corresponding interfaces (i.e. immiscible fluids). It is typically used in combination with a Navier\u2013Stokes solver . The interface between the fluids is tracked with a Volume-Of-Fluid method. The volume fraction in fluid i is \\(f_i=1\\) and \\(f_i=0\\) everywhere else.",
    "url": "https://comphy-lab.org/HoleySheet/src-local/three-phase.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/three-phase.h | Documentation: C/C++ Code",
    "content": "The densities and dynamic viscosities for fluid 1, 2 and 3 are rho1 , mu1 , rho2 , mu2 , and rho3 , mu3 respectively. #include \"vof.h\" scalar f1 [], f2 [], * interfaces = { f1 , f2 }; double rho1 = 1. , mu1 = 0. , rho2 = 1. , mu2 = 0. , rho3 = 1. , mu3 = 0. ; Auxilliary fields are necessary to define the (variable) specific volume \\(\\alpha=1/\\rho\\) as well as the cell-centered density. face vector alphav []; scalar rhov []; event defaults ( i = 0 ) { alpha = alphav ; rho = rhov ; If the viscosity is non-zero, we need to allocate the face-centered viscosity field. if ( mu1 || mu2 ) mu = new face vector ; } The density and viscosity are defined using arithmetic averages by default.",
    "url": "https://comphy-lab.org/HoleySheet/src-local/three-phase.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/three-phase.h | Documentation: Definitions - Python Function",
    "content": "The user can overload these definitions to use other types of averages (i.e. harmonic). #ifndef rho #define rho ( f1 , f2 ) ( clamp ( f1 *( 1 - f2 ), 0. , 1. ) * rho1 + clamp ( f1 * f2 , 0. , 1. ) * rho2 + clamp (( 1 - f1 ), 0. , 1. ) * rho3 ) 42 #endif #ifndef mu #define mu ( f1 , f2 ) ( clamp ( f1 *( 1 - f2 ), 0. , 1. ) * mu1 + clamp ( f1 * f2 , 0. , 1. ) * mu2 + clamp (( 1 - f1 ), 0. , 1. ) * mu3 ) 45 #endif We have the option of using some \u201csmearing\u201d of the density/viscosity jump. #ifdef FILTERED scalar sf1 [], sf2 [], * smearInterfaces = { sf1 , sf2 }; #else #define sf1 f1 55 #define sf2 f2 56 scalar * smearInterfaces = { sf1 , sf2 }; #endif event properties ( i ++) { if ( i > 1 ){ foreach (){ if (( f2 [] > 0.5 ) && ( f1 [] < 0.5 )){ f1 [] = f2 []; } } } When using smearing of the density jump, we initialise sfi with the vertex-average of fi . #ifdef FILTERED int counter1 = 0 ; for ( scalar sf in smearInterfaces ){ counter1 ++; int counter2 = 0 ; for ( scalar f in interfaces ){ counter2 ++; if ( counter1 == counter2 ){ // fprintf(ferr, \"%s %s\\n\", sf.name, f.name); #if dimension <= foreach (){ sf [] = ( 4. * f [] + 2. *( f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 1 , 0 ] + f [- 1 , 0 ]) + f [- 1 ,- 1 ] + f [ 1 ,- 1 ] + f [ 1 , 1 ] + f [- 1 , 1 ])/ 16. ; } #else // dimension == foreach (){ sf [] = ( 8. * f [] + 4. *( f [- 1 ] + f [ 1 ] + f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 0 , 0 , 1 ] + f [ 0 , 0 ,- 1 ]) + 2. *( f [- 1 , 1 ] + f [- 1 , 0 , 1 ] + f [- 1 , 0 ,- 1 ] + f [- 1 ,- 1 ] + f [ 0 , 1 , 1 ] + f [ 0 , 1 ,- 1 ] + f [ 0 ,- 1 , 1 ] + f [ 0 ,- 1 ,- 1 ] + f [ 1 , 1 ] + f [ 1 , 0 , 1 ] + f [ 1 ,- 1 ] + f [ 1 , 0 ,- 1 ]) + f [ 1 ,- 1 , 1 ] + f [- 1 , 1 , 1 ] + f [- 1 , 1 ,- 1 ] + f [ 1 , 1 , 1 ] + f [ 1 , 1 ,- 1 ] + f [- 1 ,- 1 ,- 1 ] + f [ 1 ,- 1 ,- 1 ] + f [- 1 ,- 1 , 1 ])/ 64. ; } #endif } } } #endif #if TREE for ( scalar sf in smearInterfaces ){ sf . prolongation = refine_bilinear ; boundary ({ sf }); } #endif foreach_face () { double ff1 = ( sf1 [] + sf1 [- 1 ])/ 2. ; double ff2 = ( sf2 [] + sf2 [- 1 ])/ 2. ; This is a bit of fine tuning here.",
    "url": "https://comphy-lab.org/HoleySheet/src-local/three-phase.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/three-phase.h | Documentation: We might get...",
    "content": "We might get places in the domain where density and viscosity go below those of air, we just make the properties at those locations equal to that of air // double rhoTemp = max(rho(ff1, ff2), rho3); // alphav.x[] = fm.x[]/rhoTemp; alphav . x [] = fm . x []/ rho ( ff1 , ff2 ); face vector muv = mu ; // double muTemp = max(mu(ff1, ff2), mu3); // muv.x[] = fm.x[]*muTemp; muv . x [] = fm . x []* mu ( ff1 , ff2 ); } foreach (){ // double rhoTemp = max(rho(sf1[], sf2[]), rho3); // rhov[] = cm[]*rhoTemp; rhov [] = cm []* rho ( sf1 [], sf2 []); } #if TREE for ( scalar sf in smearInterfaces ){ sf . prolongation = fraction_refine ; boundary ({ sf }); } #endif }",
    "url": "https://comphy-lab.org/HoleySheet/src-local/three-phase.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/three-phase.h | Documentation - C/C++ Code",
    "content": "#include\"vof.h\"scalar f1[],f2[],*interfaces={f1,f2};doublerho1=1.,mu1=0.,rho2=1.,mu2=0.,rho3=1.,mu3=0.;",
    "url": "https://comphy-lab.org/HoleySheet/src-local/three-phase.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/three-phase.h | Documentation - Code Example",
    "content": "face vector alphav[];scalar rhov[];event defaults(i=0){alpha=alphav;rho=rhov;",
    "url": "https://comphy-lab.org/HoleySheet/src-local/three-phase.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/three-phase.h | Documentation - Function: rho",
    "content": "#ifndef rho#define rho(f1,f2)(clamp(f1*(1-f2),0.,1.)*rho1+clamp(f1*f2,0.,1.)*rho2+clamp((1-f1),0.,1.)*rho3)42#endif#ifndef mu#define mu(f1,f2)(clamp(f1*(1-f2),0.,1.)*mu1+clamp(f1*f2,0.,1.)*mu2+clamp((1-f1),0.,1.)*mu3)45#endif",
    "url": "https://comphy-lab.org/HoleySheet/src-local/three-phase.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/three-phase.h | Documentation - Function: FILTEREDscalar",
    "content": "#ifdef FILTEREDscalar sf1[],sf2[],*smearInterfaces={sf1,sf2};#else#define sf1 f155#define sf2 f256scalar*smearInterfaces={sf1,sf2};#endifevent properties(i++){if(i>1){foreach(){if((f2[]>0.5)&&(f1[]<0.5)){f1[]=f2[];}}}",
    "url": "https://comphy-lab.org/HoleySheet/src-local/three-phase.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/three-phase.h | Documentation - Function: FILTEREDintcounter1",
    "content": "#ifdef FILTEREDintcounter1=0;for(scalar sf in smearInterfaces){counter1++;intcounter2=0;for(scalar f in interfaces){counter2++;if(counter1==counter2){// fprintf(ferr, \"%s %s\\n\", sf.name, f.name);#if dimension <=foreach(){sf[]=(4.*f[]+2.*(f[0,1]+f[0,-1]+f[1,0]+f[-1,0])+f[-1,-1]+f[1,-1]+f[1,1]+f[-1,1])/16.;}#else// dimension ==foreach(){sf[]=(8.*f[]+4.*(f[-1]+f[1]+f[0,1]+f[0,-1]+f[0,0,1]+f[0,0,-1])+2.*(f[-1,1]+f[-1,0,1]+f[-1,0,-1]+f[-1,-1]+f[0,1,1]+f[0,1,-1]+f[0,-1,1]+f[0,-1,-1]+f[1,1]+f[1,0,1]+f[1,-1]+f[1,0,-1])+f[1,-1,1]+f[-1,1,1]+f[-1,1,-1]+f[1,1,1]+f[1,1,-1]+f[-1,-1,-1]+f[1,-1,-1]+f[-1,-1,1])/64.;}#endif}}}#endif#if TREEfor(scalar sf in smearInterfaces){sf.prolongation=refine_bilinear;boundary({sf});}#endifforeach_face(){doubleff1=(sf1[]+sf1[-1])/2.;doubleff2=(sf2[]+sf2[-1])/2.;",
    "url": "https://comphy-lab.org/HoleySheet/src-local/three-phase.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/three-phase.h | Documentation - Code Example",
    "content": "// double rhoTemp = max(rho(ff1, ff2), rho3);// alphav.x[] = fm.x[]/rhoTemp;alphav.x[]=fm.x[]/rho(ff1,ff2);face vector muv=mu;// double muTemp = max(mu(ff1, ff2), mu3);// muv.x[] = fm.x[]*muTemp;muv.x[]=fm.x[]*mu(ff1,ff2);}foreach(){// double rhoTemp = max(rho(sf1[], sf2[]), rho3);// rhov[] = cm[]*rhoTemp;rhov[]=cm[]*rho(sf1[],sf2[]);}#if TREEfor(scalar sf in smearInterfaces){sf.prolongation=fraction_refine;boundary({sf});}#endif}",
    "url": "https://comphy-lab.org/HoleySheet/src-local/three-phase.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Documentation: C/C++ Code",
    "content": "postProcess/getData.c See raw file // get data #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #include \u201cfractions.h\u201d char filename[80]; int nx, ny, len; double xmin, ymin, xmax, ymax, Deltax, Deltay, Oh = 0.; scalar f[], D2c[], vel[]; scalar *list = NULL; int main(int a, char const *arguments[]) { sprintf(filename, \u201c%s\u201d, arguments[1]); xmin = atof(arguments[2]); ymin = atof(arguments[3]); xmax = atof(arguments[4]); ymax = atof(arguments[5]); ny = atoi(arguments[6]); Oh = atof(arguments[7]); list = list_add(list, D2c); list = list_add(list, vel); list = list_add(list, u.x); list = list_add(list, u.y); // boundary conditions u.n[right] = neumann(0.); p[right] = dirichlet(0.); restore(file = filename); f.prolongation = fraction_refine; boundary((scalar *){f, u.x, u.y}); foreach () { double D11 = (u.y[0, 1] - u.y[0, -1]) / (2 * Delta); double D22 = (u.y[] / y); double D33 = (u.x[1, 0] - u.x[-1, 0]) / (2 * Delta); double D13 = 0.5 * ((u.y[1, 0] - u.y[-1, 0] + u.x[0, 1] - u.x[0, -1]) / (2 * Delta)); double D2 = (sq(D11) + sq(D22) + sq(D33) + 2.0 * sq(D13)); // D2c[] = 2 * (clamp(f[], 0., 1.) * (Oh - 2e-2 * Oh) + 2e-2 * Oh) * D2; D2c[] = 2 * clamp(f[], 0., 1.) * D2; D2c[] = (D2c[] > 0.) ? log(D2c[]) / log(10) : -10; vel[] = sqrt(sq(u.x[]) + sq(u.y[])); } boundary((scalar *){D2c, vel}); FILE *fp = ferr; Deltay = (double)(ymax - ymin) / (ny); nx = (int)(xmax - xmin) / Deltay; Deltax = (double)(xmax - xmin) / (nx); len = list_len(list); double **field = (double **)matrix_new(nx, ny + 1, len * sizeof(double)); for (int i = 0; i < nx; i++) { double x = Deltax * (i + 0.5) + xmin; for (int j = 0; j < ny; j++) { double y = Deltay * (j + 0.5) + ymin; int k = 0; for (scalar s in list) { field[i][len * j + k++] = interpolate(s, x, y); } } } for (int i = 0; i < nx; i++) { double x = Deltax * (i + 0.5) + xmin; for (int j = 0; j < ny; j++) { double y = Deltay * (j + 0.5) + ymin; fprintf(fp, \"%g %g\", x, y); int k = 0; for (scalar s in list) { fprintf(fp, \" %g\", field[i][len * j + k++]); } fputc('\\n', fp); } } fflush(fp); fclose(fp); matrix_free(field); }",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Documentation - Code Example: list = list_add(list,...",
    "content": "list = list_add(list, D2c);\nlist = list_add(list, vel);\nlist = list_add(list, u.x);\nlist = list_add(list, u.y); // boundary conditions\nu.n[right] = neumann(0.);\np[right] = dirichlet(0.); restore(file = filename);\nf.prolongation = fraction_refine;\nboundary((scalar *){f, u.x, u.y});",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Documentation - Code Example: foreach () {...",
    "content": "foreach ()\n{\n    double D11 = (u.y[0, 1] - u.y[0, -1]) / (2 * Delta);\n    double D22 = (u.y[] / y);\n    double D33 = (u.x[1, 0] - u.x[-1, 0]) / (2 * Delta);\n    double D13 = 0.5 * ((u.y[1, 0] - u.y[-1, 0] + u.x[0, 1] - u.x[0, -1]) / (2 * Delta));\n    double D2 = (sq(D11) + sq(D22) + sq(D33) + 2.0 * sq(D13));\n    // D2c[] = 2 * (clamp(f[], 0., 1.) * (Oh - 2e-2 * Oh) + 2e-2 * Oh) * D2;\n    D2c[] = 2 * clamp(f[], 0., 1.) * D2;\n    D2c[] = (D2c[] > 0.) ? log(D2c[]) / log(10) : -10;\n    vel[] = sqrt(sq(u.x[]) + sq(u.y[]));\n}\nboundary((scalar *){D2c, vel});",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Documentation - Code Example: FILE *fp =...",
    "content": "FILE *fp = ferr;\nDeltay = (double)(ymax - ymin) / (ny);\nnx = (int)(xmax - xmin) / Deltay;\nDeltax = (double)(xmax - xmin) / (nx);\nlen = list_len(list);",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Documentation - Code Example: double **field =...",
    "content": "double **field = (double **)matrix_new(nx, ny + 1, len * sizeof(double));\nfor (int i = 0; i < nx; i++)\n{\n    double x = Deltax * (i + 0.5) + xmin;\n    for (int j = 0; j < ny; j++)\n    {\n        double y = Deltay * (j + 0.5) + ymin;\n        int k = 0;\n        for (scalar s in list)\n        {\n            field[i][len * j + k++] = interpolate(s, x, y);\n        }\n    }\n}",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData.c | Documentation - Code Example: for (int i...",
    "content": "for (int i = 0; i < nx; i++)\n{\n    double x = Deltax * (i + 0.5) + xmin;\n    for (int j = 0; j < ny; j++)\n    {\n        double y = Deltay * (j + 0.5) + ymin;\n        fprintf(fp, \"%g %g\", x, y);\n        int k = 0;\n        for (scalar s in list)\n        {\n            fprintf(fp, \" %g\", field[i][len * j + k++]);\n        }\n        fputc('\\n', fp);\n    }\n}\nfflush(fp);\nfclose(fp);\nmatrix_free(field);",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet.c | Documentation",
    "content": "postProcess/getFacet.c See raw file // get facets #include \u201cnavier-stokes/centered.h\u201d #include \u201cfractions.h\u201d scalar f[]; char filename[80]; int main(int a, char const arguments[]) { sprintf (filename, \u201c%s\u201d, arguments[1]); restore (file = filename); #if TREE f.prolongation = fraction_refine; #endif boundary((scalar ){f}); FILE * fp = ferr; output_facets(f,fp); fflush (fp); fclose (fp); }",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getFacet.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_02.1_tp.py | Documentation: Import Statements",
    "content": "postProcess/VideoBubbleinSheet_02.1_tp.py See raw file # To get facets for bubbles in sheets # Add theta point as well. import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import sys from scipy.optimize import fsolve matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True # matplotlib.rcParams['text.latex.preamble'] = [r''] def gettingFacets1(filename): exe = [ \"./getFacet1\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) ##segs.append((r1,z1)) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) segs.append(((r1, - z1),(r2, - z2))) segs.append((( - r1, - z1),( - r2, - z2))) skip = True return segs def gettingFacets2(filename): exe = [ \"./getFacet2\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) ##segs.append((r1,z1)) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) segs.append(((r1, - z1),(r2, - z2))) segs.append((( - r1, - z1),( - r2, - z2))) skip = True return segs def gettingfield(filename, zmin, zmax, rmax, nr, Ohs, Ohp, Oha): exe = [ \"./getData\" , filename, str (zmin), str ( 0 ), str (zmax), str (rmax), str (nr), str (Ohs), str (Ohp), str (Oha)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, D2temp, veltemp, Utemp, Vtemp, taupTemp = [],[],[],[],[],[],[] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) D2temp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) Utemp.append( float (temp3[ 4 ])) Vtemp.append( float (temp3[ 5 ])) taupTemp.append( float (temp3[ 6 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) U = np.asarray(Utemp) V = np.asarray(Vtemp) taup = np.asarray(taupTemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) U.resize((nz, nr)) V.resize((nz, nr)) taup.resize((nz, nr)) return R, Z, D2, vel, U, V, taup, nz # ---------------------------------------------------------------------------------------------------------------------- def getting_facet1(filename): exe = [ \"./getFacet1\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) lines = temp1.splitlines() x = [] y = [] for line in lines: values = line.split() if len (values) == 2 : try : x_val = float (values[ 0 ]) y_val = float (values[ 1 ]) x.append(x_val) y.append(y_val) except ValueError : continue # Convert lists to numpy arrays x = np.array(x) y = np.array(y) theta = np.arctan2(y, x) sorted_indices = np.argsort(theta) return np.array(x)[sorted_indices], np.array(y)[sorted_indices], np.array(theta)[sorted_indices] # ---------------------------------------------------------------------------------------------------------------------- def getting_facet2(filename): exe = [ \"./getFacet2\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) lines = temp1.splitlines() x = [] y = [] for line in lines: values = line.split() if len (values) == 2 : try : x_val = float (values[ 0 ]) y_val = float (values[ 1 ]) x.append(x_val) y.append(y_val) except ValueError : continue # Convert lists to numpy arrays x = np.array(x) y = np.array(y) theta = np.arctan2(y, x) sorted_indices = np.argsort(theta) return np.array(x)[sorted_indices], np.array(y)[sorted_indices], np.array(theta)[sorted_indices] # ---------------------------------------------------------------------------------------------------------------------- def func(theta): # Interpolate r_fit1 and r_fit2 at the given theta r1 = np.interp(theta, theta_fit, r_fit1) r2 = np.interp(theta, theta_fit, r_fit2) return r1 - r2 - 2e-2 def fitradius(r, theta, theta_fit): degree = 10 coefficients = np.polyfit(theta, r, degree) return np.polyval(coefficients, theta_fit) nGFS = 5000 Ldomain = 4 GridsPerR = 64 nr = int (GridsPerR * Ldomain) Ohs, Ohp, Oha = 1e-2 , 1e-2 , 1e-4 rmin, rmax, zmin, zmax = [ - Ldomain, Ldomain, - Ldomain / 2 , Ldomain / 2 ] lw = 2 folder = 'Video_02.1' # output folder if not os.path.isdir(folder): os.makedirs(folder) for ti in range (nGFS): t = 0.1 * ti place = \"intermediate/snapshot- %5.4f \" % t name = \" %s / %8.8d .png\" % (folder, int (t * 1000 )) if not os.path.exists(place): print ( \" %s File not found!\" % place) else : if os.path.exists(name): print ( \" %s Image present!\" % name) else : segs1 = gettingFacets1(place) segs2 = gettingFacets2(place) if ( len (segs1) == 0 ): print ( \"Problem in the available file %s \" % place) else : #R, Z, taus, vel, U, V, taup, nz = gettingfield(place, zmin, zmax, rmax, nr, Ohs, Ohp, Oha) #zminp, zmaxp, rminp, rmaxp = Z.min(), Z.max(), R.min(), R.max() # print(zminp, zmaxp, rminp, rmaxp) # Part to plot AxesLabel, TickLabel = [ 50 , 35 ] fig, ax = plt.subplots() fig.set_size_inches( 19.20 , 10.80 ) ax.plot([ 0 , 0 ], [zmin, zmax], '-.' ,color = 'grey' ,linewidth = lw) ax.plot([rmin, rmin], [zmin, zmax], '-' ,color = 'black' ,linewidth = lw) ax.plot([rmin, rmax], [zmin, zmin], '-' ,color = 'black' ,linewidth = lw) ax.plot([rmin, rmax], [zmax, zmax], '-' ,color = 'black' ,linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' ,color = 'black' ,linewidth = lw) ## Drawing Facets line_segments1 = LineCollection(segs1, linewidths = 3.25 , colors = 'green' , linestyle = 'solid' ) line_segments2 = LineCollection(segs2, linewidths = 3.25 , colors = 'purple' , linestyle = 'solid' ) ax.add_collection(line_segments1) ax.add_collection(line_segments2) ax.set_title( '$t/ \\\\ tau_ \\ gamma$ = %4.3f ' % t, fontsize = TickLabel) #plt.scatter(segs[0], segs[1]) #print(\"The line collection array: \",segs) x1, y1, theta1 = getting_facet1(place) x2, y2, theta2 = getting_facet2(place) r1 = np.sqrt(x1 * x1 + y1 * y1) r2 = np.sqrt(x2 * x2 + y2 * y2) theta_fit = np.linspace( 0 , np.pi / 2 , 1000 ) r_fit1 = fitradius(r1, theta1, theta_fit) r_fit2 = fitradius(r2, theta2, theta_fit) theta_sol = fsolve(func, 1.3 ) print (theta_sol) theta_sol[theta_sol < 0 ] = 0 f = open ( \"out_theta_time.txt\" , \"a\" ) f.write( \" %4.6f \" % (t)) f.write( \" \\t \" ) f.write( \" %4.6f \" % (theta_sol)) f.write( \" \\t \" ) f.write( \" \\n \" ) # Add lines theta_x_line = np.linspace( 0 , 2 , 100 ) theta_y_line = theta_x_line / np.tan(theta_sol) ax.plot(theta_x_line, theta_y_line, color = 'black' ) ## Copied Lines ax.set_aspect( 'equal' ) ax.set_xlim(rmin, rmax) ax.set_ylim(zmin, zmax) ax.axis( 'off' ) # plt.show() plt.savefig(name, bbox_inches = \"tight\" , dpi = 250 ) plt.close() f.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_02.1_tp.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_02.1_tp.py | Documentation - Code Example: # To get...",
    "content": "# To get facets for bubbles in sheets # Add theta point as well.importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportsysfromscipy.optimizeimportfsolvematplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=True# matplotlib.rcParams['text.latex.preamble'] = [r'']defgettingFacets1(filename):exe=[\"./getFacet1\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])##segs.append((r1,z1))segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))segs.append(((r1,-z1),(r2,-z2)))segs.append(((-r1,-z1),(-r2,-z2)))skip=TruereturnsegsdefgettingFacets2(filename):exe=[\"./getFacet2\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])##segs.append((r1,z1))segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))segs.append(((r1,-z1),(r2,-z2)))segs.append(((-r1,-z1),(-r2,-z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, zmax, rmax, nr, Ohs, Ohp, Oha):exe=[\"./getData\", filename,str(zmin),str(0),str(zmax),str(rmax),str(nr),str(Ohs),str(Ohp),str(Oha)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, D2temp, veltemp, Utemp, Vtemp, taupTemp=[],[],[],[],[],[],[]forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))D2temp.append(float(temp3[2]))veltemp.append(float(temp3[3]))Utemp.append(float(temp3[4]))Vtemp.append(float(temp3[5]))taupTemp.append(float(temp3[6]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)U=np.asarray(Utemp)V=np.asarray(Vtemp)taup=np.asarray(taupTemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))U.resize((nz, nr))V.resize((nz, nr))taup.resize((nz, nr))returnR, Z, D2, vel, U, V, taup, nz# ----------------------------------------------------------------------------------------------------------------------defgetting_facet1(filename):exe=[\"./getFacet1\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")lines=temp1.splitlines()x=[]y=[]forlineinlines:values=line.split()iflen(values)==2:try:x_val=float(values[0])y_val=float(values[1])x.append(x_val)y.append(y_val)exceptValueError:continue# Convert lists to numpy arraysx=np.array(x)y=np.array(y)theta=np.arctan2(y, x)sorted_indices=np.argsort(theta)returnnp.array(x)[sorted_indices], np.array(y)[sorted_indices], np.array(theta)[sorted_indices]# ----------------------------------------------------------------------------------------------------------------------defgetting_facet2(filename):exe=[\"./getFacet2\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")lines=temp1.splitlines()x=[]y=[]forlineinlines:values=line.split()iflen(values)==2:try:x_val=float(values[0])y_val=float(values[1])x.append(x_val)y.append(y_val)exceptValueError:continue# Convert lists to numpy arraysx=np.array(x)y=np.array(y)theta=np.arctan2(y, x)sorted_indices=np.argsort(theta)returnnp.array(x)[sorted_indices], np.array(y)[sorted_indices], np.array(theta)[sorted_indices]# ----------------------------------------------------------------------------------------------------------------------deffunc(theta):# Interpolate r_fit1 and r_fit2 at the given thetar1=np.interp(theta, theta_fit, r_fit1)r2=np.interp(theta, theta_fit, r_fit2)returnr1-r2-2e-2deffitradius(r, theta, theta_fit):degree=10coefficients=np.polyfit(theta, r, degree)returnnp.polyval(coefficients, theta_fit)nGFS=5000Ldomain=4GridsPerR=64nr=int(GridsPerR*Ldomain)Ohs, Ohp, Oha=1e-2,1e-2,1e-4rmin, rmax, zmin, zmax=[-Ldomain, Ldomain,-Ldomain/2, Ldomain/2]lw=2folder='Video_02.1'# output folderifnotos.path.isdir(folder):os.makedirs(folder)fortiinrange(nGFS):t=0.1*tiplace=\"intermediate/snapshot-%5.4f\"%tname=\"%s/%8.8d.png\"%(folder,int(t*1000))ifnotos.path.exists(place):print(\"%sFile not found!\"%place)else:ifos.path.exists(name):print(\"%sImage present!\"%name)else:segs1=gettingFacets1(place)segs2=gettingFacets2(place)if(len(segs1)==0):print(\"Problem in the available file%s\"%place)else:#R, Z, taus, vel, U, V, taup, nz = gettingfield(place, zmin, zmax, rmax, nr, Ohs, Ohp, Oha)#zminp, zmaxp, rminp, rmaxp = Z.min(), Z.max(), R.min(), R.max()# print(zminp, zmaxp, rminp, rmaxp)# Part to plotAxesLabel, TickLabel=[50,35]fig, ax=plt.subplots()fig.set_size_inches(19.20,10.80)ax.plot([0,0], [zmin, zmax],'-.',color='grey',linewidth=lw)ax.plot([rmin, rmin], [zmin, zmax],'-',color='black',linewidth=lw)ax.plot([rmin, rmax], [zmin, zmin],'-',color='black',linewidth=lw)ax.plot([rmin, rmax], [zmax, zmax],'-',color='black',linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-',color='black',linewidth=lw)## Drawing Facetsline_segments1=LineCollection(segs1, linewidths=3.25, colors='green', linestyle='solid')line_segments2=LineCollection(segs2, linewidths=3.25, colors='purple', linestyle='solid')ax.add_collection(line_segments1)ax.add_collection(line_segments2)ax.set_title('$t/\\\\tau_\\gamma$ =%4.3f'%t, fontsize=TickLabel)#plt.scatter(segs[0], segs[1])#print(\"The line collection array: \",segs)x1, y1, theta1=getting_facet1(place)x2, y2, theta2=getting_facet2(place)r1=np.sqrt(x1*x1+y1*y1)r2=np.sqrt(x2*x2+y2*y2)theta_fit=np.linspace(0, np.pi/2,1000)r_fit1=fitradius(r1, theta1, theta_fit)r_fit2=fitradius(r2, theta2, theta_fit)theta_sol=fsolve(func,1.3)print(theta_sol)theta_sol[theta_sol<0]=0f=open(\"out_theta_time.txt\",\"a\")f.write(\"%4.6f\"%(t))f.write(\"\\t\")f.write(\"%4.6f\"%(theta_sol))f.write(\"\\t\")f.write(\"\\n\")# Add linestheta_x_line=np.linspace(0,2,100)theta_y_line=theta_x_line/np.tan(theta_sol)ax.plot(theta_x_line, theta_y_line, color='black')## Copied Linesax.set_aspect('equal')ax.set_xlim(rmin, rmax)ax.set_ylim(zmin, zmax)ax.axis('off')# plt.show()plt.savefig(name, bbox_inches=\"tight\", dpi=250)plt.close()f.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_02.1_tp.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/runpostProcess.sh | Documentation",
    "content": "postProcess/runpostProcess.sh See raw file runpostProcess.sh #!/bin/bash #SBATCH -N 1 #SBATCH --partition=genoa #SBATCH --ntasks-per-node=32 #SBATCH --time=2:00:00 #SBATCH --error=job.%J.err #SBATCH --output=job.%J.out source ~/.bash_shell Oh = ( \"1.00E-03\" \"3.00E-03\" \"6.00E-03\" \"1.00E-02\" \"3.00E-02\" \"6.00E-02\" \"1.00E-01\" ) start_data = 1010 start = 1015 end = 1016 for (( i = start ; i <= end ; i ++ )); do dir = \\$ i index = \\$ (( i - start_data )) cd \\$ dir || { echo \"Failed to change directory to \\$ dir\" ; exit 1 ; } python3 VideoBubbleinSheet.py --Oh \\$ {Oh [ index ] } & cd ../ done wait for (( i = start ; i <= end ; i ++ )); do dir = \\$ i/Video cd \\$ dir || { echo \"Failed to change directory to \\$ dir\" ; exit 1 ; } rm -f * .mp4 mkvids \\$ i.mp4 & cd ../../ done wait",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/runpostProcess.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/runpostProcess.sh | Documentation - Code Example: #!/bin/bash#SBATCH -N 1#SBATCH...",
    "content": "#!/bin/bash#SBATCH -N 1#SBATCH --partition=genoa#SBATCH --ntasks-per-node=32#SBATCH --time=2:00:00#SBATCH --error=job.%J.err#SBATCH --output=job.%J.outsource~/.bash_shellOh=(\"1.00E-03\"\"3.00E-03\"\"6.00E-03\"\"1.00E-02\"\"3.00E-02\"\"6.00E-02\"\"1.00E-01\")start_data=1010start=1015end=1016for((i=start;i<=end;i++));dodir=\\$iindex=\\$((i-start_data))cd\\$dir||{echo\"Failed to change directory to\\$dir\";exit1;}python3VideoBubbleinSheet.py--Oh\\${Oh[index]}&cd../donewaitfor((i=start;i<=end;i++));dodir=\\$i/Videocd\\$dir||{echo\"Failed to change directory to\\$dir\";exit1;}rm-f*.mp4mkvids\\$i.mp4&cd../../donewait",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/runpostProcess.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation: Import Statements",
    "content": "postProcess/VideoBubbleinSheet.py See raw file # To get facets for bubbles in sheets import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection import multiprocessing as mp from functools import partial from pathlib import Path import argparse from matplotlib.ticker import StrMethodFormatter import random matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' def gettingFacets(filename, asy): exe = [ \"./getFacet\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() stderr_output = stderr.decode( \"utf-8\" ) points = stderr_output.split( \" \\n \" ) segments = [] if len (points) > 100 : for i in range ( len (points) - 1 ): current_point = points[i].split() if current_point: next_point = points[i + 1 ].split() if next_point: r1, z1 = float (current_point[ 1 ]), float (current_point[ 0 ]) r2, z2 = float (next_point[ 1 ]), float (next_point[ 0 ]) if asy: segment_variants = [ ((r1, z1), (r2, z2)), (( - r1, z1), ( - r2, z2)) ] else : segment_variants = [ ((r1, z1), (r2, z2)), (( - r1, z1), ( - r2, z2)), ((r1, - z1), (r2, - z2)), (( - r1, - z1), ( - r2, - z2)) ] segments.extend(segment_variants) return segments def gettingfield(filename, zmin, rmin, zmax, rmax, nr, Oh): exe = [ \"./getData\" , filename, str (zmin), str (rmin), str (zmax), str (rmax), str (nr), str (Oh)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() lines = stderr.decode( \"utf-8\" ).split( \" \\n \" ) Rtemp, Ztemp, D2temp, veltemp, Utemp, Vtemp = [],[],[],[],[],[] for i in range ( len (lines)): values = lines[i].split( \" \" ) if values == [ '' ]: pass else : Ztemp.append( float (values[ 0 ])) Rtemp.append( float (values[ 1 ])) D2temp.append( float (values[ 2 ])) veltemp.append( float (values[ 3 ])) Utemp.append( float (values[ 4 ])) Vtemp.append( float (values[ 5 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) U = np.asarray(Utemp) V = np.asarray(Vtemp) nz = int ( len (Z) / nr) # print(f\"nz is {nz}\") R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) U.resize((nz, nr)) V.resize((nz, nr)) return R, Z, D2, vel, U, V, nz def process_timestep(ti, folder, rmin, rmax, zmin, zmax, lw, asy, Oh, nr, Ldomain): t = 0.01*ti snapshot_file = Path(f\"intermediate/snapshot-{t:.4f}\") output_file = folder / f\"{int(t * 1000):08d}.png\" if not snapshot_file.exists(): print(f\"{snapshot_file} not found!\") return if output_file.exists(): print(f\"{output_file} already present!\") return segs = gettingFacets(snapshot_file, asy) if not segs: print(f\"Problem in the available file {snapshot_file}\") return R, Z, D2, vel, U, V, nz = gettingfield(snapshot_file, zmin, rmin, zmax, rmax, nr, Oh) # Part to plot AxesLabel, TickLabel = [50, 35] fig, ax = plt.subplots() fig.set_size_inches(19.20, 10.80) if not asy: rmin, rmax, zmin, zmax = 0, Ldomain, -Ldomain/2, Ldomain/2 ax.plot([0, 0], [zmin, zmax],'-.',color='grey',linewidth=lw) ax.plot([-rmax, -rmax], [zmin, zmax],'-',color='black',linewidth=lw) ax.plot([-rmax, rmax], [zmin, zmin],'-',color='black',linewidth=lw) ax.plot([-rmax, rmax], [zmax, zmax],'-',color='black',linewidth=lw) ax.plot([rmax, rmax], [zmin, zmax],'-',color='black',linewidth=lw) ## Drawing Facets line_segments = LineCollection(segs, linewidths=3.25, colors='green', linestyle='solid') ax.add_collection(line_segments) ax.set_title(f'$t/\\\\tau_\\gamma$ = {t:.3f}', fontsize=TickLabel) ## Copied Lines ax.set_aspect('equal') ax.set_xlim(-rmax, rmax) ax.set_ylim(zmin, zmax) # velmax, velmin = np.max(vel), np.min(vel) # d2max, d2min = np.max(D2), np.min(D2) # print(f\"max D2 is {d2max} and min D2 is {d2min}\") # print(f\"max vel is {velmax} and min vel is {velmin}\") # if asy: # cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin) # cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min) # else: # rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2 # cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin) # cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min) # cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, -zmax], vmax=velmax, vmin=velmin) # cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, -zmax], vmax=d2max, vmin=d2min) # l, b, w, h = ax.get_position().bounds # cb1 = fig.add_axes([l+0.05*w, b-0.05, 0.40*w, 0.03]) # c1 = plt.colorbar(cntrl1,cax=cb1,orientation='horizontal') # c1.set_label(r'$\\|\\mathbf{v}\\|/\\sqrt{\\gamma/\\rho R_0}$',fontsize=TickLabel, labelpad=-25) # c1.ax.tick_params(labelsize=TickLabel) # c1.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.3f}')) # c1.set_ticks([velmax, velmin]) # cb2 = fig.add_axes([l+0.55*w, b-0.05, 0.40*w, 0.03]) # c2 = plt.colorbar(cntrl2,cax=cb2,orientation='horizontal') # c2.ax.tick_params(labelsize=TickLabel) # c2.set_label(r\"$\\log_{10}\\left(2 Oh \\left( \\boldsymbol{\\mathcal {D} : \\mathcal {D}} \\right) \\right)$\",fontsize=TickLabel, labelpad=-25) # c2.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}')) # c2.set_ticks([d2max, d2min]) ax.axis('off') # plt.show() plt.savefig(output_file, bbox_inches=\"tight\", dpi=250) plt.close() print(f\"{ti+1} is done\") def main(): parser = argparse.ArgumentParser(description=\u201cProcess facets for bubbles in sheets.\u201d) parser.add_argument(\u2018\u2013asy\u2019, action=\u2018store_true\u2019, help=\u201cIf set, use asymmetric variants.",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation: Context",
    "content": "Default is false.\u201d) parser.add_argument(\u2018\u2013Oh\u2019, type=float, default=0.01, help=\u201cOh value.\u201d) args = parser.parse_args() nGFS = 10000 Ldomain = 4 GridsPerR = 64 nr = int(GridsPerR*Ldomain) if args.asy: rmin, rmax, zmin, zmax = 0, Ldomain, -Ldomain/2, Ldomain/2 else: rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2 lw = 2 folder = Path('Video') # output folder if not folder.is_dir(): os.makedirs(folder) # Prepare the partial function with fixed arguments # process_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, nr=nr) process_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, Oh=args.Oh, nr=nr, Ldomain=Ldomain) # Use all available CPU cores num_processes = 5 #mp.cpu_count() nGFS_list = list(range(nGFS)) random.shuffle(nGFS_list) # Create a pool of worker processes with mp.Pool(processes=num_processes) as pool: # Map the process_func to all timesteps pool.map(process_func, nGFS_list) if name == \u201c main \u201d: main()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: # To get...",
    "content": "# To get facets for bubbles in sheetsimportnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionimportmultiprocessingasmpfromfunctoolsimportpartialfrompathlibimportPathimportargparsefrommatplotlib.tickerimportStrMethodFormatterimportrandommatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'defgettingFacets(filename, asy):exe=[\"./getFacet\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()stderr_output=stderr.decode(\"utf-8\")points=stderr_output.split(\"\\n\")segments=[]iflen(points)>100:foriinrange(len(points)-1):current_point=points[i].split()ifcurrent_point:next_point=points[i+1].split()ifnext_point:r1, z1=float(current_point[1]),float(current_point[0])r2, z2=float(next_point[1]),float(next_point[0])ifasy:segment_variants=[((r1, z1), (r2, z2)),((-r1, z1), (-r2, z2))]else:segment_variants=[((r1, z1), (r2, z2)),((-r1, z1), (-r2, z2)),((r1,-z1), (r2,-z2)),((-r1,-z1), (-r2,-z2))]segments.extend(segment_variants)returnsegmentsdefgettingfield(filename, zmin, rmin, zmax, rmax, nr, Oh):exe=[\"./getData\", filename,str(zmin),str(rmin),str(zmax),str(rmax),str(nr),str(Oh)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()lines=stderr.decode(\"utf-8\").split(\"\\n\")Rtemp, Ztemp, D2temp, veltemp, Utemp, Vtemp=[],[],[],[],[],[]foriinrange(len(lines)):values=lines[i].split(\" \")ifvalues==['']:passelse:Ztemp.append(float(values[0]))Rtemp.append(float(values[1]))D2temp.append(float(values[2]))veltemp.append(float(values[3]))Utemp.append(float(values[4]))Vtemp.append(float(values[5]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)U=np.asarray(Utemp)V=np.asarray(Vtemp)nz=int(len(Z)/nr)# print(f\"nz is {nz}\")R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))U.resize((nz, nr))V.resize((nz, nr))returnR, Z, D2, vel, U, V, nzdefprocess_timestep(ti, folder, rmin, rmax, zmin, zmax, lw, asy, Oh, nr, Ldomain):",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: Context",
    "content": "t = 0.01*ti\nsnapshot_file = Path(f\"intermediate/snapshot-{t:.4f}\")\noutput_file = folder / f\"{int(t * 1000):08d}.png\" if not snapshot_file.exists():\n    print(f\"{snapshot_file} not found!\")\n    return if output_file.exists():\n    print(f\"{output_file} already present!\")\n    return segs = gettingFacets(snapshot_file, asy) if not segs:\n    print(f\"Problem in the available file {snapshot_file}\")\n    return",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: R, Z, D2,...",
    "content": "R, Z, D2, vel, U, V, nz = gettingfield(snapshot_file, zmin, rmin, zmax, rmax, nr, Oh)\n# Part to plot\nAxesLabel, TickLabel = [50, 35]\nfig, ax = plt.subplots()\nfig.set_size_inches(19.20, 10.80) if not asy:\n    rmin, rmax, zmin, zmax = 0, Ldomain, -Ldomain/2, Ldomain/2\n    \nax.plot([0, 0], [zmin, zmax],'-.',color='grey',linewidth=lw)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: Context",
    "content": "ax.plot([-rmax, -rmax], [zmin, zmax],'-',color='black',linewidth=lw)\nax.plot([-rmax, rmax], [zmin, zmin],'-',color='black',linewidth=lw)\nax.plot([-rmax, rmax], [zmax, zmax],'-',color='black',linewidth=lw)\nax.plot([rmax, rmax], [zmin, zmax],'-',color='black',linewidth=lw) ## Drawing Facets\nline_segments = LineCollection(segs, linewidths=3.25, colors='green', linestyle='solid')\nax.add_collection(line_segments)\nax.set_title(f'$t/\\\\tau_\\gamma$ = {t:.3f}', fontsize=TickLabel)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: ## Copied Lines...",
    "content": "## Copied Lines\nax.set_aspect('equal')\nax.set_xlim(-rmax, rmax)\nax.set_ylim(zmin, zmax) # velmax, velmin = np.max(vel), np.min(vel) \n# d2max, d2min = np.max(D2), np.min(D2) \n# print(f\"max D2 is {d2max} and min D2 is {d2min}\")\n# print(f\"max vel is {velmax} and min vel is {velmin}\")",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: # if asy:...",
    "content": "# if asy:\n#     cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin)\n#     cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: # else: #...",
    "content": "# else:   \n#     rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2\n    # cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin)\n    # cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min)\n    # cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, -zmax], vmax=velmax, vmin=velmin)\n    # cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, -zmax], vmax=d2max, vmin=d2min)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: # l, b,...",
    "content": "# l, b, w, h = ax.get_position().bounds\n# cb1 = fig.add_axes([l+0.05*w, b-0.05, 0.40*w, 0.03])\n# c1 = plt.colorbar(cntrl1,cax=cb1,orientation='horizontal')\n# c1.set_label(r'$\\|\\mathbf{v}\\|/\\sqrt{\\gamma/\\rho R_0}$',fontsize=TickLabel, labelpad=-25)\n# c1.ax.tick_params(labelsize=TickLabel)\n# c1.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.3f}'))\n# c1.set_ticks([velmax, velmin])\n# cb2 = fig.add_axes([l+0.55*w, b-0.05, 0.40*w, 0.03])\n# c2 = plt.colorbar(cntrl2,cax=cb2,orientation='horizontal')\n# c2.ax.tick_params(labelsize=TickLabel)\n# c2.set_label(r\"$\\log_{10}\\left(2 Oh \\left( \\boldsymbol{\\mathcal {D} : \\mathcal {D}} \\right) \\right)$\",fontsize=TickLabel, labelpad=-25)\n# c2.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}')) \n# c2.set_ticks([d2max, d2min])",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: Context",
    "content": "ax.axis('off')\n# plt.show()\nplt.savefig(output_file, bbox_inches=\"tight\", dpi=250)\nplt.close()\nprint(f\"{ti+1} is done\")",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: nGFS = 10000...",
    "content": "nGFS = 10000\nLdomain = 4\nGridsPerR = 64\nnr = int(GridsPerR*Ldomain) if args.asy:\n    rmin, rmax, zmin, zmax = 0, Ldomain, -Ldomain/2, Ldomain/2\nelse:\n    rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2\nlw = 2 folder = Path('Video')  # output folder if not folder.is_dir():\n    os.makedirs(folder)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: Function Definition",
    "content": "# Prepare the partial function with fixed arguments\n# process_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, nr=nr)\nprocess_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, Oh=args.Oh, nr=nr, Ldomain=Ldomain) # Use all available CPU cores\nnum_processes = 5 #mp.cpu_count() nGFS_list = list(range(nGFS))\nrandom.shuffle(nGFS_list)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet.py | Documentation - Code Example: # Create a...",
    "content": "# Create a pool of worker processes\nwith mp.Pool(processes=num_processes) as pool:\n    # Map the process_func to all timesteps\n    pool.map(process_func, nGFS_list)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation: C/C++ Main",
    "content": "Post-Processing Tools getab.c char filename[80], nameTrack[80]; scalar list = NULL; scalar f2[]; int main(int a, char const arguments[]) { sprintf ... getData.c char filename[80]; int nx, ny, len; double xmin, ymin, xmax, ymax, Deltax, Deltay, Oh = 0.; scalar f[], D2c[], vel[];... getData_02.c char filename[80]; int nx, ny, len; double xmin, ymin, xmax, ymax, Deltax, Deltay, Oh = 0.; scalar f[], D2c[], vel[],... getFacet.c scalar f[]; char filename[80]; int main(int a, char const arguments[]) { sprintf (filename, '%s', arguments[1]); rest... getFacet1.c scalar f1[]; char filename[80]; int main(int a, char const arguments[]) { sprintf (filename, '%s', arguments[1]); res... getFacet2.c scalar f2[]; char filename[80]; int main(int a, char const arguments[]) { sprintf (filename, '%s', arguments[1]); res... getFacet_02.c scalar f[]; char filename[80]; int main(int a, char const arguments[]) { sprintf (filename, '%s', arguments[1]); rest... geth.c char filename[80], nameTrack[80]; scalar list = NULL; scalar f[]; int main(int a, char const arguments[]) { sprintf (... out_ab_time.py import numpy as np import os import subprocess as sp def gettingab(filename): exe = ['./getab', filename] p = sp.Pope... out_h_time.py import numpy as np import os import subprocess as sp def gettingh(filename): exe = ['./geth', filename] p = sp.Popen(... out_theta_time_01.py import numpy as np import os import subprocess as sp from scipy.optimize import fsolve def gettingfacet1(filename): e... runpostProcess.sh source ~/.bashshell Oh=('1.00E-03' '3.00E-03' '6.00E-03' '1.00E-02' '3.00E-02' '6.00E-02' '1.00E-01') startdata=1010 ...",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation: Import Statements",
    "content": "VideoBubbleinSheet.py import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotli... VideoBubbleinSheet_02.1_tp.py import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotli... VideoBubbleinSheet_02_tp.py import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotli... VideoBubbleinSheet_03.py import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotli... VideoBubbleinSheet_03_all.py import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotli... VideoBubbleinSheet_04.py import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotli...",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation: Import Statements",
    "content": "postProcess/VideoBubbleinSheet_03.py See raw file # To get facets for bubbles in sheets import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection import multiprocessing as mp from functools import partial from pathlib import Path import argparse from matplotlib.ticker import StrMethodFormatter import random import matplotlib.colors as mcolors custom_colors = [ \"white\" , \"#8DCDF0\" ] custom_cmap = mcolors.LinearSegmentedColormap.from_list( \"custom_blue\" , custom_colors) matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' def gettingFacets(filename, asy): exe = [ \"./getFacet\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() stderr_output = stderr.decode( \"utf-8\" ) points = stderr_output.split( \" \\n \" ) segments = [] if len (points) > 100 : for i in range ( len (points) - 1 ): current_point = points[i].split() if current_point: next_point = points[i + 1 ].split() if next_point: r1, z1 = float (current_point[ 1 ]), float (current_point[ 0 ]) r2, z2 = float (next_point[ 1 ]), float (next_point[ 0 ]) if asy: segment_variants = [ ((r1, z1), (r2, z2)), (( - r1, z1), ( - r2, z2)) ] else : segment_variants = [ ((r1, z1), (r2, z2)), (( - r1, z1), ( - r2, z2)), ((r1, - z1), (r2, - z2)), (( - r1, - z1), ( - r2, - z2)) ] segments.extend(segment_variants) return segments def gettingfield(filename, zmin, rmin, zmax, rmax, nr, Oh): exe = [ \"./getData_02\" , filename, str (zmin), str (rmin), str (zmax), str (rmax), str (nr), str (Oh)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() lines = stderr.decode( \"utf-8\" ).split( \" \\n \" ) Rtemp, Ztemp, D2temp, veltemp, Utemp, Vtemp = [],[],[],[],[],[] for i in range ( len (lines)): values = lines[i].split( \" \" ) if values == [ '' ]: pass else : Ztemp.append( float (values[ 0 ])) Rtemp.append( float (values[ 1 ])) D2temp.append( float (values[ 2 ])) veltemp.append( float (values[ 3 ])) Utemp.append( float (values[ 4 ])) Vtemp.append( float (values[ 5 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) U = np.asarray(Utemp) V = np.asarray(Vtemp) nz = int ( len (Z) / nr) # print(f\"nz is {nz}\") R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) U.resize((nz, nr)) V.resize((nz, nr)) return R, Z, D2, vel, U, V, nz def process_timestep(ti, folder, rmin, rmax, zmin, zmax, lw, asy, Oh, nr, Ldomain): t = 0.01*ti snapshot_file = Path(f\"intermediate/snapshot-{t:.4f}\") output_file = folder / f\"{int(t * 1000):08d}.png\" if not snapshot_file.exists(): print(f\"{snapshot_file} not found!\") return if output_file.exists(): print(f\"{output_file} already present!\") return segs = gettingFacets(snapshot_file, asy) if not segs: print(f\"Problem in the available file {snapshot_file}\") return R, Z, D2, vel, U, V, nz = gettingfield(snapshot_file, zmin, rmin, zmax, rmax, nr, Oh) # Part to plot AxesLabel, TickLabel = [50, 35] fig, ax = plt.subplots() fig.set_size_inches(19.20, 10.80) if not asy: rmin, rmax, zmin, zmax = 0, Ldomain, -1.5, 1.5 ax.plot([0, 0], [zmin, zmax],'-.',color='grey',linewidth=lw) ax.plot([-rmax, -rmax], [zmin, zmax],'-',color='black',linewidth=lw) ax.plot([-rmax, rmax], [zmin, zmin],'-',color='black',linewidth=lw) ax.plot([-rmax, rmax], [zmax, zmax],'-',color='black',linewidth=lw) ax.plot([rmax, rmax], [zmin, zmax],'-',color='black',linewidth=lw) ## Copied Lines ax.set_aspect('equal') ax.set_xlim(-rmax, rmax) ax.set_ylim(zmin, zmax) velmax, velmin = np.max(vel), np.min(vel) # velmax, velmin = 1.5, 1e-3 # d2max, d2min = np.max(D2), np.min(D2) d2max, d2min = np.max(vel), np.min(vel) # print(f\"max D2 is {d2max} and min D2 is {d2min}\") # print(f\"max vel is {velmax} and min vel is {velmin}\") if asy: cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin) cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min) else: rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2 cntrl1 = ax.imshow(vel, cmap=custom_cmap, interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin) cntrl2 = ax.imshow(vel, cmap=custom_cmap, interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min) cntrl1 = ax.imshow(vel, cmap=custom_cmap, interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, -zmax], vmax=velmax, vmin=velmin) cntrl2 = ax.imshow(vel, cmap=custom_cmap, interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, -zmax], vmax=d2max, vmin=d2min) ## Drawing Facets line_segments = LineCollection(segs, linewidths=3.25, colors='black', linestyle='solid') ax.add_collection(line_segments) ax.set_title(f'$t/\\\\tau_\\gamma$ = {t:.1f}', fontsize=TickLabel) # l, b, w, h = ax.get_position().bounds # cb1 = fig.add_axes([l+0.05*w, b-0.05, 0.40*w, 0.03]) # c1 = plt.colorbar(cntrl1,cax=cb1,orientation='horizontal') # c1.set_label(r'$\\|\\mathbf{v}\\|/\\sqrt{\\gamma/\\rho R_0}$',fontsize=TickLabel, labelpad=-25) # c1.ax.tick_params(labelsize=TickLabel) # c1.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.3f}')) # c1.set_ticks([velmax, velmin]) # cb2 = fig.add_axes([l+0.55*w, b-0.05, 0.40*w, 0.03]) # c2 = plt.colorbar(cntrl2,cax=cb2,orientation='horizontal') # c2.ax.tick_params(labelsize=TickLabel) # c2.set_label(r\"$\\log_{10}\\left(2 Oh \\left( \\boldsymbol{\\mathcal {D} : \\mathcal {D}} \\right) \\right)$\",fontsize=TickLabel, labelpad=-25) # c2.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}')) # c2.set_ticks([d2max, d2min]) ax.axis('off') # plt.show() plt.savefig(output_file, bbox_inches=\"tight\", dpi=250) plt.close() print(f\"{ti+1} is done\") def main(): parser = argparse.ArgumentParser(description=\u201cProcess facets for bubbles in sheets.\u201d) parser.add_argument(\u2018\u2013asy\u2019, action=\u2018store_true\u2019, help=\u201cIf set, use asymmetric variants.",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation: Context",
    "content": "Default is false.\u201d) parser.add_argument(\u2018\u2013Oh\u2019, type=float, default=0.01, help=\u201cOh value.\u201d) args = parser.parse_args() nGFS = 10000 Ldomain = 4 GridsPerR = 64 nr = int(GridsPerR*Ldomain) if args.asy: rmin, rmax, zmin, zmax = 0, Ldomain, -Ldomain/2, Ldomain/2 else: rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2 lw = 2 folder = Path('Video_02') # output folder if not folder.is_dir(): os.makedirs(folder) # Prepare the partial function with fixed arguments # process_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, nr=nr) process_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, Oh=args.Oh, nr=nr, Ldomain=Ldomain) # Use all available CPU cores num_processes = 3 #mp.cpu_count() nGFS_list = list(range(nGFS)) random.shuffle(nGFS_list) # Create a pool of worker processes with mp.Pool(processes=num_processes) as pool: # Map the process_func to all timesteps pool.map(process_func, nGFS_list) if name == \u201c main \u201d: main()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: # To get...",
    "content": "# To get facets for bubbles in sheetsimportnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionimportmultiprocessingasmpfromfunctoolsimportpartialfrompathlibimportPathimportargparsefrommatplotlib.tickerimportStrMethodFormatterimportrandomimportmatplotlib.colorsasmcolorscustom_colors=[\"white\",\"#8DCDF0\"]custom_cmap=mcolors.LinearSegmentedColormap.from_list(\"custom_blue\", custom_colors)matplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'defgettingFacets(filename, asy):exe=[\"./getFacet\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()stderr_output=stderr.decode(\"utf-8\")points=stderr_output.split(\"\\n\")segments=[]iflen(points)>100:foriinrange(len(points)-1):current_point=points[i].split()ifcurrent_point:next_point=points[i+1].split()ifnext_point:r1, z1=float(current_point[1]),float(current_point[0])r2, z2=float(next_point[1]),float(next_point[0])ifasy:segment_variants=[((r1, z1), (r2, z2)),((-r1, z1), (-r2, z2))]else:segment_variants=[((r1, z1), (r2, z2)),((-r1, z1), (-r2, z2)),((r1,-z1), (r2,-z2)),((-r1,-z1), (-r2,-z2))]segments.extend(segment_variants)returnsegmentsdefgettingfield(filename, zmin, rmin, zmax, rmax, nr, Oh):exe=[\"./getData_02\", filename,str(zmin),str(rmin),str(zmax),str(rmax),str(nr),str(Oh)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()lines=stderr.decode(\"utf-8\").split(\"\\n\")Rtemp, Ztemp, D2temp, veltemp, Utemp, Vtemp=[],[],[],[],[],[]foriinrange(len(lines)):values=lines[i].split(\" \")ifvalues==['']:passelse:Ztemp.append(float(values[0]))Rtemp.append(float(values[1]))D2temp.append(float(values[2]))veltemp.append(float(values[3]))Utemp.append(float(values[4]))Vtemp.append(float(values[5]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)U=np.asarray(Utemp)V=np.asarray(Vtemp)nz=int(len(Z)/nr)# print(f\"nz is {nz}\")R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))U.resize((nz, nr))V.resize((nz, nr))returnR, Z, D2, vel, U, V, nzdefprocess_timestep(ti, folder, rmin, rmax, zmin, zmax, lw, asy, Oh, nr, Ldomain):",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: Context",
    "content": "t = 0.01*ti\nsnapshot_file = Path(f\"intermediate/snapshot-{t:.4f}\")\noutput_file = folder / f\"{int(t * 1000):08d}.png\" if not snapshot_file.exists():\n    print(f\"{snapshot_file} not found!\")\n    return if output_file.exists():\n    print(f\"{output_file} already present!\")\n    return segs = gettingFacets(snapshot_file, asy) if not segs:\n    print(f\"Problem in the available file {snapshot_file}\")\n    return",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: R, Z, D2,...",
    "content": "R, Z, D2, vel, U, V, nz = gettingfield(snapshot_file, zmin, rmin, zmax, rmax, nr, Oh)\n# Part to plot\nAxesLabel, TickLabel = [50, 35]\nfig, ax = plt.subplots()\nfig.set_size_inches(19.20, 10.80) if not asy:\n    rmin, rmax, zmin, zmax = 0, Ldomain, -1.5, 1.5\n    \nax.plot([0, 0], [zmin, zmax],'-.',color='grey',linewidth=lw)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: Context",
    "content": "ax.plot([-rmax, -rmax], [zmin, zmax],'-',color='black',linewidth=lw)\nax.plot([-rmax, rmax], [zmin, zmin],'-',color='black',linewidth=lw)\nax.plot([-rmax, rmax], [zmax, zmax],'-',color='black',linewidth=lw)\nax.plot([rmax, rmax], [zmin, zmax],'-',color='black',linewidth=lw) ## Copied Lines\nax.set_aspect('equal')\nax.set_xlim(-rmax, rmax)\nax.set_ylim(zmin, zmax)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: velmax, velmin =...",
    "content": "velmax, velmin = np.max(vel), np.min(vel) \n# velmax, velmin = 1.5, 1e-3\n# d2max, d2min = np.max(D2), np.min(D2) \nd2max, d2min = np.max(vel), np.min(vel) \n# print(f\"max D2 is {d2max} and min D2 is {d2min}\")\n# print(f\"max vel is {velmax} and min vel is {velmin}\")",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: if asy: cntrl1...",
    "content": "if asy:\n    cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin)\n    cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: else: rmin, rmax,...",
    "content": "else:   \n    rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2\n    cntrl1 = ax.imshow(vel, cmap=custom_cmap, interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin)\n    cntrl2 = ax.imshow(vel, cmap=custom_cmap, interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min)\n    cntrl1 = ax.imshow(vel, cmap=custom_cmap, interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, -zmax], vmax=velmax, vmin=velmin)\n    cntrl2 = ax.imshow(vel, cmap=custom_cmap, interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, -zmax], vmax=d2max, vmin=d2min)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: ## Drawing Facets...",
    "content": "## Drawing Facets\nline_segments = LineCollection(segs, linewidths=3.25, colors='black', linestyle='solid')\nax.add_collection(line_segments)\nax.set_title(f'$t/\\\\tau_\\gamma$ = {t:.1f}', fontsize=TickLabel)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: # l, b,...",
    "content": "# l, b, w, h = ax.get_position().bounds\n# cb1 = fig.add_axes([l+0.05*w, b-0.05, 0.40*w, 0.03])\n# c1 = plt.colorbar(cntrl1,cax=cb1,orientation='horizontal')\n# c1.set_label(r'$\\|\\mathbf{v}\\|/\\sqrt{\\gamma/\\rho R_0}$',fontsize=TickLabel, labelpad=-25)\n# c1.ax.tick_params(labelsize=TickLabel)\n# c1.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.3f}'))\n# c1.set_ticks([velmax, velmin])\n# cb2 = fig.add_axes([l+0.55*w, b-0.05, 0.40*w, 0.03])\n# c2 = plt.colorbar(cntrl2,cax=cb2,orientation='horizontal')\n# c2.ax.tick_params(labelsize=TickLabel)\n# c2.set_label(r\"$\\log_{10}\\left(2 Oh \\left( \\boldsymbol{\\mathcal {D} : \\mathcal {D}} \\right) \\right)$\",fontsize=TickLabel, labelpad=-25)\n# c2.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}')) \n# c2.set_ticks([d2max, d2min])",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: Context",
    "content": "ax.axis('off')\n# plt.show()\nplt.savefig(output_file, bbox_inches=\"tight\", dpi=250)\nplt.close()\nprint(f\"{ti+1} is done\")",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: nGFS = 10000...",
    "content": "nGFS = 10000\nLdomain = 4\nGridsPerR = 64\nnr = int(GridsPerR*Ldomain) if args.asy:\n    rmin, rmax, zmin, zmax = 0, Ldomain, -Ldomain/2, Ldomain/2\nelse:\n    rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2\nlw = 2 folder = Path('Video_02')  # output folder if not folder.is_dir():\n    os.makedirs(folder)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: Function Definition",
    "content": "# Prepare the partial function with fixed arguments\n# process_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, nr=nr)\nprocess_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, Oh=args.Oh, nr=nr, Ldomain=Ldomain) # Use all available CPU cores\nnum_processes = 3 #mp.cpu_count() nGFS_list = list(range(nGFS))\nrandom.shuffle(nGFS_list)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03.py | Documentation - Code Example: # Create a...",
    "content": "# Create a pool of worker processes\nwith mp.Pool(processes=num_processes) as pool:\n    # Map the process_func to all timesteps\n    pool.map(process_func, nGFS_list)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet1.c | Documentation",
    "content": "postProcess/getFacet1.c See raw file /* Title: Getting Facets # Author: Vatsal Sanjay # vatsalsanjay@gmail.com # Physics of Fluids #include \u201cnavier-stokes/centered.h\u201d #include \u201cfractions.h\u201d scalar f1[]; char filename[80]; int main(int a, char const arguments[]) { sprintf (filename, \u201c%s\u201d, arguments[1]); restore (file = filename); #if TREE f1.prolongation = fraction_refine; #endif boundary((scalar ){f1}); FILE * fp = ferr; output_facets(f1,fp); fflush (fp); fclose (fp); }",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getFacet1.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/geth.c | Documentation",
    "content": "postProcess/geth.c See raw file // get film thickness h #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #include \u201cfractions.h\u201d char filename[80], nameTrack[80]; scalar * list = NULL; scalar f[]; int main(int a, char const *arguments[]) { sprintf (filename, \u201c%s\u201d, arguments[1]); restore (file = filename); boundary((scalar *){f, u.x, u.y}); double xmax = -HUGE; double y_xmax = 0; foreach(){ if (x > xmax && f[] > 1-1e-3 && y < 0.05) { xmax = x; y_xmax = y; } } FILE * fp = ferr; fprintf(ferr, \u201c%f %7.6e %7.6e\u201d, t, xmax, y_xmax); fflush (fp); fclose (fp); }",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/geth.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet_02.c | Documentation",
    "content": "postProcess/getFacet_02.c See raw file // get facets #include \u201cnavier-stokes/centered.h\u201d #include \u201cfractions.h\u201d #include \u201ctag.h\u201d scalar f[]; char filename[80]; int main(int a, char const arguments[]) { sprintf (filename, \u201c%s\u201d, arguments[1]); restore (file = filename); #if TREE f.prolongation = fraction_refine; #endif boundary((scalar ){f}); remove_droplets(f, 200, 1e-1, true); FILE * fp = ferr; output_facets(f,fp); fflush (fp); fclose (fp); }",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getFacet_02.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData_02.c | Documentation: C/C++ Code",
    "content": "postProcess/getData_02.c See raw file // get data #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #include \u201cfractions.h\u201d char filename[80]; int nx, ny, len; double xmin, ymin, xmax, ymax, Deltax, Deltay, Oh = 0.; scalar f[], D2c[], vel[], rhov[]; scalar *list = NULL; int main(int a, char const *arguments[]) { sprintf(filename, \u201c%s\u201d, arguments[1]); xmin = atof(arguments[2]); ymin = atof(arguments[3]); xmax = atof(arguments[4]); ymax = atof(arguments[5]); ny = atoi(arguments[6]); Oh = atof(arguments[7]); list = list_add(list, D2c); list = list_add(list, vel); list = list_add(list, u.x); list = list_add(list, u.y); // boundary conditions u.n[right] = neumann(0.); p[right] = dirichlet(0.); restore(file = filename); f.prolongation = fraction_refine; boundary((scalar *){f, u.x, u.y}); foreach () { double D11 = (u.y[0, 1] - u.y[0, -1]) / (2 * Delta); double D22 = (u.y[] / y); double D33 = (u.x[1, 0] - u.x[-1, 0]) / (2 * Delta); double D13 = 0.5 * ((u.y[1, 0] - u.y[-1, 0] + u.x[0, 1] - u.x[0, -1]) / (2 * Delta)); double D2 = (sq(D11) + sq(D22) + sq(D33) + 2.0 * sq(D13)); D2c[] = 2 * (clamp(f[], 0., 1.) * (Oh - 2e-2 * Oh) + 2e-2 * Oh) * D2; D2c[] = (D2c[] > 0.) ? log(D2c[]) / log(10) : -10; // vel[] = clamp(f[], 0., 1.)*(sqrt(sq(u.x[]) + sq(u.y[]))); vel[] = clamp(f[], 0., 1.-1e-6); } boundary((scalar *){D2c, vel}); FILE *fp = ferr; Deltay = (double)(ymax - ymin) / (ny); nx = (int)(xmax - xmin) / Deltay; Deltax = (double)(xmax - xmin) / (nx); len = list_len(list); double **field = (double **)matrix_new(nx, ny + 1, len * sizeof(double)); for (int i = 0; i < nx; i++) { double x = Deltax * (i + 0.5) + xmin; for (int j = 0; j < ny; j++) { double y = Deltay * (j + 0.5) + ymin; int k = 0; for (scalar s in list) { field[i][len * j + k++] = interpolate(s, x, y); } } } for (int i = 0; i < nx; i++) { double x = Deltax * (i + 0.5) + xmin; for (int j = 0; j < ny; j++) { double y = Deltay * (j + 0.5) + ymin; fprintf(fp, \"%g %g\", x, y); int k = 0; for (scalar s in list) { fprintf(fp, \" %g\", field[i][len * j + k++]); } fputc('\\n', fp); } } fflush(fp); fclose(fp); matrix_free(field); }",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData_02.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData_02.c | Documentation - Code Example: list = list_add(list,...",
    "content": "list = list_add(list, D2c);\nlist = list_add(list, vel);\nlist = list_add(list, u.x);\nlist = list_add(list, u.y); // boundary conditions\nu.n[right] = neumann(0.);\np[right] = dirichlet(0.); restore(file = filename);\nf.prolongation = fraction_refine;\nboundary((scalar *){f, u.x, u.y});",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData_02.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData_02.c | Documentation - Code Example: foreach () {...",
    "content": "foreach ()\n{\n    double D11 = (u.y[0, 1] - u.y[0, -1]) / (2 * Delta);\n    double D22 = (u.y[] / y);\n    double D33 = (u.x[1, 0] - u.x[-1, 0]) / (2 * Delta);\n    double D13 = 0.5 * ((u.y[1, 0] - u.y[-1, 0] + u.x[0, 1] - u.x[0, -1]) / (2 * Delta));\n    double D2 = (sq(D11) + sq(D22) + sq(D33) + 2.0 * sq(D13));\n    D2c[] = 2 * (clamp(f[], 0., 1.) * (Oh - 2e-2 * Oh) + 2e-2 * Oh) * D2;",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData_02.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData_02.c | Documentation - Code Example: D2c[] = (D2c[]...",
    "content": "D2c[] = (D2c[] > 0.) ? log(D2c[]) / log(10) : -10;\n    // vel[] = clamp(f[], 0., 1.)*(sqrt(sq(u.x[]) + sq(u.y[])));\n    vel[] = clamp(f[], 0., 1.-1e-6);\n}\nboundary((scalar *){D2c, vel}); FILE *fp = ferr;\nDeltay = (double)(ymax - ymin) / (ny);\nnx = (int)(xmax - xmin) / Deltay;\nDeltax = (double)(xmax - xmin) / (nx);\nlen = list_len(list);",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData_02.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData_02.c | Documentation - Code Example: double **field =...",
    "content": "double **field = (double **)matrix_new(nx, ny + 1, len * sizeof(double));\nfor (int i = 0; i < nx; i++)\n{\n    double x = Deltax * (i + 0.5) + xmin;\n    for (int j = 0; j < ny; j++)\n    {\n        double y = Deltay * (j + 0.5) + ymin;\n        int k = 0;\n        for (scalar s in list)\n        {\n            field[i][len * j + k++] = interpolate(s, x, y);\n        }\n    }\n}",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData_02.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData_02.c | Documentation - Code Example: for (int i...",
    "content": "for (int i = 0; i < nx; i++)\n{\n    double x = Deltax * (i + 0.5) + xmin;\n    for (int j = 0; j < ny; j++)\n    {\n        double y = Deltay * (j + 0.5) + ymin;\n        fprintf(fp, \"%g %g\", x, y);\n        int k = 0;\n        for (scalar s in list)\n        {\n            fprintf(fp, \" %g\", field[i][len * j + k++]);\n        }\n        fputc('\\n', fp);\n    }\n}\nfflush(fp);\nfclose(fp);\nmatrix_free(field);",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getData_02.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/out_ab_time.py | Documentation: Python Function",
    "content": "postProcess/out_ab_time.py See raw file # To out major axis a, and minor axis b, over time import numpy as np import os import subprocess as sp def getting_ab(filename): exe = [ \"./getab\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) temp3 = temp2[ 0 ].split( \" \" ) return float (temp3[ 0 ]), float (temp3[ 1 ]), float (temp3[ 2 ]), float (temp3[ 3 ]), float (temp3[ 4 ]) # ---------------------------------------------------------------------------------------------------------------------- nGFS = 10000 tsnap = 0.1 for ti in range (nGFS): t = tsnap * ti place = \"intermediate/snapshot- %5.4f \" % t if not os.path.exists(place): print ( \" %s File not found!\" % place) else : tp, xmax, y_xmax, x_ymax, ymax = getting_ab(place) # time, number od drops, volume, x, y print (tp) print ( \"Time: %4.3f , xmax: %4.3f , y_xmax: %4.3f , x_ymax: %4.3f , ymax: %4.3f \" % (tp, xmax, y_xmax, x_ymax, ymax)) f = open ( \"out_ab_time.txt\" , \"a\" ) f.write( \" %4.6f \" % (tp)) f.write( \" \\t \" ) f.write( \" %4.6f \" % (xmax)) f.write( \" \\t \" ) f.write( \" %4.6f \" % (y_xmax)) f.write( \" \\t \" ) f.write( \" %4.6f \" % (x_ymax)) f.write( \" \\t \" ) f.write( \" %4.6f \" % (ymax)) f.write( \" \\t \" ) f.write( \" \\n \" ) f.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/out_ab_time.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/out_ab_time.py | Documentation - Code Example: # To out...",
    "content": "# To out major axis a, and minor axis b, over timeimportnumpyasnpimportosimportsubprocessasspdefgetting_ab(filename):exe=[\"./getab\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")temp3=temp2[0].split(\" \")returnfloat(temp3[0]),float(temp3[1]),float(temp3[2]),float(temp3[3]),float(temp3[4])# ----------------------------------------------------------------------------------------------------------------------nGFS=10000tsnap=0.1fortiinrange(nGFS):t=tsnap*tiplace=\"intermediate/snapshot-%5.4f\"%tifnotos.path.exists(place):print(\"%sFile not found!\"%place)else:tp, xmax, y_xmax, x_ymax, ymax=getting_ab(place)# time, number od drops, volume, x, yprint(tp)print(\"Time:%4.3f, xmax:%4.3f, y_xmax:%4.3f, x_ymax:%4.3f, ymax:%4.3f\"%(tp, xmax, y_xmax, x_ymax, ymax))f=open(\"out_ab_time.txt\",\"a\")f.write(\"%4.6f\"%(tp))f.write(\"\\t\")f.write(\"%4.6f\"%(xmax))f.write(\"\\t\")f.write(\"%4.6f\"%(y_xmax))f.write(\"\\t\")f.write(\"%4.6f\"%(x_ymax))f.write(\"\\t\")f.write(\"%4.6f\"%(ymax))f.write(\"\\t\")f.write(\"\\n\")f.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/out_ab_time.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getab.c | Documentation",
    "content": "postProcess/getab.c See raw file // get major axis a, and minor axis b of the bubble #include \u201caxi.h\u201d #include \u201cnavier-stokes/centered.h\u201d #include \u201cfractions.h\u201d char filename[80], nameTrack[80]; scalar * list = NULL; scalar f2[]; int main(int a, char const *arguments[]) { sprintf (filename, \u201c%s\u201d, arguments[1]); restore (file = filename); boundary((scalar *){f2, u.x, u.y}); double xmax = -HUGE; double ymax = -HUGE; double x_ymax = 0, y_xmax = 0; foreach(){ if (x > xmax && f2[] > 1-1e-3) { xmax = x; y_xmax = y; } if (y > ymax && f2[] > 1-1e-3) { ymax = y; x_ymax = x; } } FILE * fp = ferr; fprintf(ferr, \u201c%f %7.6e %7.6e %7.6e %7.6e\u201d, t, xmax, y_xmax, x_ymax, ymax); fflush (fp); fclose (fp); }",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getab.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_02_tp.py | Documentation: Import Statements",
    "content": "postProcess/VideoBubbleinSheet_02_tp.py See raw file # To get facets for bubbles in sheets import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import sys matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True # matplotlib.rcParams['text.latex.preamble'] = [r''] def gettingFacets1(filename): exe = [ \"./getFacet1\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) ##segs.append((r1,z1)) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) segs.append(((r1, - z1),(r2, - z2))) segs.append((( - r1, - z1),( - r2, - z2))) skip = True return segs def gettingFacets2(filename): exe = [ \"./getFacet2\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) ##segs.append((r1,z1)) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) segs.append(((r1, - z1),(r2, - z2))) segs.append((( - r1, - z1),( - r2, - z2))) skip = True return segs def gettingfield(filename, zmin, zmax, rmax, nr, Ohs, Ohp, Oha): exe = [ \"./getData\" , filename, str (zmin), str ( 0 ), str (zmax), str (rmax), str (nr), str (Ohs), str (Ohp), str (Oha)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, D2temp, veltemp, Utemp, Vtemp, taupTemp = [],[],[],[],[],[],[] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) D2temp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) Utemp.append( float (temp3[ 4 ])) Vtemp.append( float (temp3[ 5 ])) taupTemp.append( float (temp3[ 6 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) U = np.asarray(Utemp) V = np.asarray(Vtemp) taup = np.asarray(taupTemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) U.resize((nz, nr)) V.resize((nz, nr)) taup.resize((nz, nr)) return R, Z, D2, vel, U, V, taup, nz def getting_ab(filename): exe = [ \"./getab\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) temp3 = temp2[ 0 ].split( \" \" ) return float (temp3[ 0 ]), float (temp3[ 1 ]), float (temp3[ 2 ]), float (temp3[ 3 ]), float (temp3[ 4 ]) # ---------------------------------------------------------------------------------------------------------------------- nGFS = 5000 Ldomain = 4 GridsPerR = 64 nr = int (GridsPerR * Ldomain) Ohs, Ohp, Oha = 1e-2 , 1e-2 , 1e-4 rmin, rmax, zmin, zmax = [ - Ldomain, Ldomain, - Ldomain / 2 , Ldomain / 2 ] lw = 2 folder = 'Video' # output folder if not os.path.isdir(folder): os.makedirs(folder) for ti in range (nGFS): t = 0.1 * ti place = \"intermediate/snapshot- %5.4f \" % t name = \" %s / %8.8d .png\" % (folder, int (t * 1000 )) if not os.path.exists(place): print ( \" %s File not found!\" % place) else : if os.path.exists(name): print ( \" %s Image present!\" % name) else : segs1 = gettingFacets1(place) segs2 = gettingFacets2(place) if ( len (segs1) == 0 ): print ( \"Problem in the available file %s \" % place) else : # R, Z, taus, vel, U, V, taup, nz = gettingfield(place, zmin, zmax, rmax, nr, Ohs, Ohp, Oha) # zminp, zmaxp, rminp, rmaxp = Z.min(), Z.max(), R.min(), R.max() t, xmax, y_xmax, x_ymax, ymax = getting_ab(place) # Part to plot AxesLabel, TickLabel = [ 50 , 35 ] fig, ax = plt.subplots() fig.set_size_inches( 19.20 , 10.80 ) ax.plot([ 0 , 0 ], [zmin, zmax], '-.' ,color = 'grey' ,linewidth = lw) ax.plot([rmin, rmin], [zmin, zmax], '-' ,color = 'black' ,linewidth = lw) ax.plot([rmin, rmax], [zmin, zmin], '-' ,color = 'black' ,linewidth = lw) ax.plot([rmin, rmax], [zmax, zmax], '-' ,color = 'black' ,linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' ,color = 'black' ,linewidth = lw) ## Drawing Facets line_segments1 = LineCollection(segs1, linewidths = 3.25 , colors = 'green' , linestyle = 'solid' ) line_segments2 = LineCollection(segs2, linewidths = 3.25 , colors = 'purple' , linestyle = 'solid' ) ax.add_collection(line_segments1) ax.add_collection(line_segments2) ax.set_title( '$t/ \\\\ tau_ \\ gamma$ = %4.3f ' % t, fontsize = TickLabel) #plt.scatter(segs[0], segs[1]) #print(\"The line collection array: \",segs) # Plotting the points ax.plot(xmax, y_xmax, 'ro' , markersize = 10 ) ax.plot(x_ymax, ymax, 'bo' , markersize = 10 ) ## Copied Lines ax.set_aspect( 'equal' ) ax.set_xlim(rmin, rmax) ax.set_ylim(zmin, zmax) ax.axis( 'off' ) # plt.show() plt.savefig(name, bbox_inches = \"tight\" , dpi = 250 ) plt.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_02_tp.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_02_tp.py | Documentation - Code Example: # To get...",
    "content": "# To get facets for bubbles in sheetsimportnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportsysmatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=True# matplotlib.rcParams['text.latex.preamble'] = [r'']defgettingFacets1(filename):exe=[\"./getFacet1\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])##segs.append((r1,z1))segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))segs.append(((r1,-z1),(r2,-z2)))segs.append(((-r1,-z1),(-r2,-z2)))skip=TruereturnsegsdefgettingFacets2(filename):exe=[\"./getFacet2\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])##segs.append((r1,z1))segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))segs.append(((r1,-z1),(r2,-z2)))segs.append(((-r1,-z1),(-r2,-z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, zmax, rmax, nr, Ohs, Ohp, Oha):exe=[\"./getData\", filename,str(zmin),str(0),str(zmax),str(rmax),str(nr),str(Ohs),str(Ohp),str(Oha)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, D2temp, veltemp, Utemp, Vtemp, taupTemp=[],[],[],[],[],[],[]forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))D2temp.append(float(temp3[2]))veltemp.append(float(temp3[3]))Utemp.append(float(temp3[4]))Vtemp.append(float(temp3[5]))taupTemp.append(float(temp3[6]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)U=np.asarray(Utemp)V=np.asarray(Vtemp)taup=np.asarray(taupTemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))U.resize((nz, nr))V.resize((nz, nr))taup.resize((nz, nr))returnR, Z, D2, vel, U, V, taup, nzdefgetting_ab(filename):exe=[\"./getab\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")temp3=temp2[0].split(\" \")returnfloat(temp3[0]),float(temp3[1]),float(temp3[2]),float(temp3[3]),float(temp3[4])# ----------------------------------------------------------------------------------------------------------------------nGFS=5000Ldomain=4GridsPerR=64nr=int(GridsPerR*Ldomain)Ohs, Ohp, Oha=1e-2,1e-2,1e-4rmin, rmax, zmin, zmax=[-Ldomain, Ldomain,-Ldomain/2, Ldomain/2]lw=2folder='Video'# output folderifnotos.path.isdir(folder):os.makedirs(folder)fortiinrange(nGFS):t=0.1*tiplace=\"intermediate/snapshot-%5.4f\"%tname=\"%s/%8.8d.png\"%(folder,int(t*1000))ifnotos.path.exists(place):print(\"%sFile not found!\"%place)else:ifos.path.exists(name):print(\"%sImage present!\"%name)else:segs1=gettingFacets1(place)segs2=gettingFacets2(place)if(len(segs1)==0):print(\"Problem in the available file%s\"%place)else:# R, Z, taus, vel, U, V, taup, nz = gettingfield(place, zmin, zmax, rmax, nr, Ohs, Ohp, Oha)# zminp, zmaxp, rminp, rmaxp = Z.min(), Z.max(), R.min(), R.max()t, xmax, y_xmax, x_ymax, ymax=getting_ab(place)# Part to plotAxesLabel, TickLabel=[50,35]fig, ax=plt.subplots()fig.set_size_inches(19.20,10.80)ax.plot([0,0], [zmin, zmax],'-.',color='grey',linewidth=lw)ax.plot([rmin, rmin], [zmin, zmax],'-',color='black',linewidth=lw)ax.plot([rmin, rmax], [zmin, zmin],'-',color='black',linewidth=lw)ax.plot([rmin, rmax], [zmax, zmax],'-',color='black',linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-',color='black',linewidth=lw)## Drawing Facetsline_segments1=LineCollection(segs1, linewidths=3.25, colors='green', linestyle='solid')line_segments2=LineCollection(segs2, linewidths=3.25, colors='purple', linestyle='solid')ax.add_collection(line_segments1)ax.add_collection(line_segments2)ax.set_title('$t/\\\\tau_\\gamma$ =%4.3f'%t, fontsize=TickLabel)#plt.scatter(segs[0], segs[1])#print(\"The line collection array: \",segs)# Plotting the pointsax.plot(xmax, y_xmax,'ro', markersize=10)ax.plot(x_ymax, ymax,'bo', markersize=10)## Copied Linesax.set_aspect('equal')ax.set_xlim(rmin, rmax)ax.set_ylim(zmin, zmax)ax.axis('off')# plt.show()plt.savefig(name, bbox_inches=\"tight\", dpi=250)plt.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_02_tp.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/out_theta_time_01.py | Documentation: Python Function",
    "content": "postProcess/out_theta_time_01.py See raw file # To out theta over time import numpy as np import os import subprocess as sp from scipy.optimize import fsolve def getting_facet1(filename): exe = [ \"./getFacet1\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) lines = temp1.splitlines() x = [] y = [] for line in lines: values = line.split() if len (values) == 2 : try : x_val = float (values[ 0 ]) y_val = float (values[ 1 ]) x.append(x_val) y.append(y_val) except ValueError : continue # Convert lists to numpy arrays x = np.array(x) y = np.array(y) theta = np.arctan2(y, x) sorted_indices = np.argsort(theta) return np.array(x)[sorted_indices], np.array(y)[sorted_indices], np.array(theta)[sorted_indices] # ---------------------------------------------------------------------------------------------------------------------- def getting_facet2(filename): exe = [ \"./getFacet2\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) lines = temp1.splitlines() x = [] y = [] for line in lines: values = line.split() if len (values) == 2 : try : x_val = float (values[ 0 ]) y_val = float (values[ 1 ]) x.append(x_val) y.append(y_val) except ValueError : continue # Convert lists to numpy arrays x = np.array(x) y = np.array(y) theta = np.arctan2(y, x) sorted_indices = np.argsort(theta) return np.array(x)[sorted_indices], np.array(y)[sorted_indices], np.array(theta)[sorted_indices] # ---------------------------------------------------------------------------------------------------------------------- def func(theta): # Interpolate r_fit1 and r_fit2 at the given theta r1 = np.interp(theta, theta_fit, r_fit1) r2 = np.interp(theta, theta_fit, r_fit2) return r1 - r2 - 2e-2 def fitradius(r, theta, theta_fit): degree = 10 coefficients = np.polyfit(theta, r, degree) return np.polyval(coefficients, theta_fit) nGFS = 10000 tsnap = 0.1 for ti in range ( 1 ): t = tsnap * ti place = \"intermediate/snapshot- %5.4f \" % t if not os.path.exists(place): print ( \" %s File not found!\" % place) else : x1, y1, theta1 = getting_facet1(place) x2, y2, theta2 = getting_facet2(place) r1 = np.sqrt(x1 * x1 + y1 * y1) r2 = np.sqrt(x2 * x2 + y2 * y2) theta_fit = np.linspace( 0 , np.pi / 2 , 1000 ) r_fit1 = fitradius(r1, theta1, theta_fit) r_fit2 = fitradius(r2, theta2, theta_fit) theta_sol = fsolve(func, 1.3 ) print (theta_sol) # print(\"x: %4.3f\" % (x)) f = open ( \"out_theta_time.txt\" , \"a\" ) f.write( \" %4.6f \" % (t)) f.write( \" \\t \" ) f.write( \" %4.6f \" % (theta_sol)) f.write( \" \\t \" ) f.write( \" \\n \" ) f.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/out_theta_time_01.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/out_theta_time_01.py | Documentation - Code Example: # To out...",
    "content": "# To out theta over timeimportnumpyasnpimportosimportsubprocessasspfromscipy.optimizeimportfsolvedefgetting_facet1(filename):exe=[\"./getFacet1\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")lines=temp1.splitlines()x=[]y=[]forlineinlines:values=line.split()iflen(values)==2:try:x_val=float(values[0])y_val=float(values[1])x.append(x_val)y.append(y_val)exceptValueError:continue# Convert lists to numpy arraysx=np.array(x)y=np.array(y)theta=np.arctan2(y, x)sorted_indices=np.argsort(theta)returnnp.array(x)[sorted_indices], np.array(y)[sorted_indices], np.array(theta)[sorted_indices]# ----------------------------------------------------------------------------------------------------------------------defgetting_facet2(filename):exe=[\"./getFacet2\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")lines=temp1.splitlines()x=[]y=[]forlineinlines:values=line.split()iflen(values)==2:try:x_val=float(values[0])y_val=float(values[1])x.append(x_val)y.append(y_val)exceptValueError:continue# Convert lists to numpy arraysx=np.array(x)y=np.array(y)theta=np.arctan2(y, x)sorted_indices=np.argsort(theta)returnnp.array(x)[sorted_indices], np.array(y)[sorted_indices], np.array(theta)[sorted_indices]# ----------------------------------------------------------------------------------------------------------------------deffunc(theta):# Interpolate r_fit1 and r_fit2 at the given thetar1=np.interp(theta, theta_fit, r_fit1)r2=np.interp(theta, theta_fit, r_fit2)returnr1-r2-2e-2deffitradius(r, theta, theta_fit):degree=10coefficients=np.polyfit(theta, r, degree)returnnp.polyval(coefficients, theta_fit)nGFS=10000tsnap=0.1fortiinrange(1):t=tsnap*tiplace=\"intermediate/snapshot-%5.4f\"%tifnotos.path.exists(place):print(\"%sFile not found!\"%place)else:x1, y1, theta1=getting_facet1(place)x2, y2, theta2=getting_facet2(place)r1=np.sqrt(x1*x1+y1*y1)r2=np.sqrt(x2*x2+y2*y2)theta_fit=np.linspace(0, np.pi/2,1000)r_fit1=fitradius(r1, theta1, theta_fit)r_fit2=fitradius(r2, theta2, theta_fit)theta_sol=fsolve(func,1.3)print(theta_sol)# print(\"x: %4.3f\" % (x))f=open(\"out_theta_time.txt\",\"a\")f.write(\"%4.6f\"%(t))f.write(\"\\t\")f.write(\"%4.6f\"%(theta_sol))f.write(\"\\t\")f.write(\"\\n\")f.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/out_theta_time_01.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation: Import Statements",
    "content": "postProcess/VideoBubbleinSheet_04.py See raw file # To get facets for bubbles in sheets || Add vectors in the velocity plot import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection import multiprocessing as mp from functools import partial from pathlib import Path import argparse from matplotlib.ticker import StrMethodFormatter import random matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' def gettingFacets(filename, asy): exe = [ \"./getFacet\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() stderr_output = stderr.decode( \"utf-8\" ) points = stderr_output.split( \" \\n \" ) segments = [] if len (points) > 100 : for i in range ( len (points) - 1 ): current_point = points[i].split() if current_point: next_point = points[i + 1 ].split() if next_point: r1, z1 = float (current_point[ 1 ]), float (current_point[ 0 ]) r2, z2 = float (next_point[ 1 ]), float (next_point[ 0 ]) if asy: segment_variants = [ ((r1, z1), (r2, z2)), (( - r1, z1), ( - r2, z2)) ] else : segment_variants = [ ((r1, z1), (r2, z2)), (( - r1, z1), ( - r2, z2)), ((r1, - z1), (r2, - z2)), (( - r1, - z1), ( - r2, - z2)) ] segments.extend(segment_variants) return segments def gettingfield(filename, zmin, rmin, zmax, rmax, nr, Oh): exe = [ \"./getData\" , filename, str (zmin), str (rmin), str (zmax), str (rmax), str (nr), str (Oh)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() lines = stderr.decode( \"utf-8\" ).split( \" \\n \" ) Rtemp, Ztemp, D2temp, veltemp, Utemp, Vtemp = [],[],[],[],[],[] for i in range ( len (lines)): values = lines[i].split( \" \" ) if values == [ '' ]: pass else : Ztemp.append( float (values[ 0 ])) Rtemp.append( float (values[ 1 ])) D2temp.append( float (values[ 2 ])) veltemp.append( float (values[ 3 ])) Utemp.append( float (values[ 4 ])) Vtemp.append( float (values[ 5 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) U = np.asarray(Utemp) V = np.asarray(Vtemp) nz = int ( len (Z) / nr) # print(f\"nz is {nz}\") R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) U.resize((nz, nr)) V.resize((nz, nr)) return R, Z, D2, vel, U, V, nz def process_timestep(ti, folder, rmin, rmax, zmin, zmax, lw, asy, Oh, nr, Ldomain): t = 0.1*ti snapshot_file = Path(f\"intermediate/snapshot-{t:.4f}\") output_file = folder / f\"{int(t * 1000):08d}.png\" if not snapshot_file.exists(): print(f\"{snapshot_file} not found!\") return if output_file.exists(): print(f\"{output_file} already present!\") return segs = gettingFacets(snapshot_file, asy) if not segs: print(f\"Problem in the available file {snapshot_file}\") return R, Z, D2, vel, U, V, nz = gettingfield(snapshot_file, zmin, rmin, zmax, rmax, nr, Oh) # Part to plot AxesLabel, TickLabel = [50, 35] fig, ax = plt.subplots() fig.set_size_inches(19.20, 10.80) if not asy: rmin, rmax, zmin, zmax = 0, Ldomain, -Ldomain/2, Ldomain/2 ax.plot([0, 0], [zmin, zmax],'-.',color='grey',linewidth=lw) ax.plot([-rmax, -rmax], [zmin, zmax],'-',color='black',linewidth=lw) ax.plot([-rmax, rmax], [zmin, zmin],'-',color='black',linewidth=lw) ax.plot([-rmax, rmax], [zmax, zmax],'-',color='black',linewidth=lw) ax.plot([rmax, rmax], [zmin, zmax],'-',color='black',linewidth=lw) ## Drawing Facets line_segments = LineCollection(segs, linewidths=3.25, colors='green', linestyle='solid') ax.add_collection(line_segments) ax.set_title(f'$t/\\\\tau_\\gamma$ = {t:.3f}', fontsize=TickLabel) ## Copied Lines ax.set_aspect('equal') ax.set_xlim(-rmax, rmax) ax.set_ylim(zmin, zmax) velmax, velmin = 0.05, 0.00 d2max, d2min = -1, -4 # print(f\"max D2 is {d2max} and min D2 is {d2min}\") # print(f\"max vel is {velmax} and min vel is {velmin}\") if asy: cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin) cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min) else: rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2 cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin) cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min) cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, -zmax], vmax=velmax, vmin=velmin) cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, -zmax], vmax=d2max, vmin=d2min) l, b, w, h = ax.get_position().bounds cb1 = fig.add_axes([l+0.05*w, b-0.05, 0.40*w, 0.03]) c1 = plt.colorbar(cntrl1,cax=cb1,orientation='horizontal') c1.set_label(r'$\\|\\mathbf{v}\\|/\\sqrt{\\gamma/\\rho R_0}$',fontsize=TickLabel, labelpad=-25) c1.ax.tick_params(labelsize=TickLabel) c1.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.2f}')) c1.set_ticks([velmax, velmin]) cb2 = fig.add_axes([l+0.55*w, b-0.05, 0.40*w, 0.03]) c2 = plt.colorbar(cntrl2,cax=cb2,orientation='horizontal') c2.ax.tick_params(labelsize=TickLabel) c2.set_label(r\"$\\log_{10}\\left(2\\left( \\boldsymbol{\\mathcal {D} : \\mathcal {D}} \\right) \\right)$\",fontsize=TickLabel, labelpad=-25) c2.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}')) c2.set_ticks([d2max, d2min]) n = 14 # Adjust this value to control the density R_reduced = R[::n, ::n] Z_reduced = Z[::n, ::n] U_reduced = U[::n, ::n] V_reduced = V[::n, ::n] magnitude = np.sqrt(U_reduced**2 + V_reduced**2) U_reduced = U_reduced/magnitude V_reduced = V_reduced/magnitude # Plot vectors # ax.quiver(-R_filtered, Z_filtered, -V_filtered, U_filtered, color='black', scale=20, headwidth=3, headlength=4, headaxislength=4, width=0.002) # ax.quiver(-R_filtered, Z_filtered, -V_filtered, U_filtered) ax.quiver(-R_reduced, Z_reduced, -V_reduced, U_reduced, color='black', scale=75, headwidth=3.5, headlength=4, headaxislength=3.8, width=0.0018) # ax.quiver(R_filtered, Z_filtered, V_filtered, U_filtered, color='#1F77B4', scale=10, headwidth=3, headlength=4, headaxislength=4, width=0.002) # ax.quiver(R, Z, ux, uy, color='black', scale=1000) ax.axis('off') # plt.show() plt.savefig(output_file, bbox_inches=\"tight\", dpi=250) plt.close() print(f\"{ti+1} is done\") def main(): parser = argparse.ArgumentParser(description=\u201cProcess facets for bubbles in sheets.\u201d) parser.add_argument(\u2018\u2013asy\u2019, action=\u2018store_true\u2019, help=\u201cIf set, use asymmetric variants.",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation: Context",
    "content": "Default is false.\u201d) parser.add_argument(\u2018\u2013Oh\u2019, type=float, default=0.01, help=\u201cOh value.\u201d) args = parser.parse_args() nGFS = 10000 Ldomain = 4 GridsPerR = 64 nr = int(GridsPerR*Ldomain) if args.asy: rmin, rmax, zmin, zmax = 0, Ldomain, -Ldomain/2, Ldomain/2 else: rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2 lw = 2 folder = Path('Video') # output folder if not folder.is_dir(): os.makedirs(folder) # Prepare the partial function with fixed arguments # process_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, nr=nr) process_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, Oh=args.Oh, nr=nr, Ldomain=Ldomain) # Use all available CPU cores num_processes = 6 #mp.cpu_count() nGFS_list = list(range(250, nGFS)) random.shuffle(nGFS_list) # Create a pool of worker processes with mp.Pool(processes=num_processes) as pool: # Map the process_func to all timesteps pool.map(process_func, nGFS_list) if name == \u201c main \u201d: main()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: # To get...",
    "content": "# To get facets for bubbles in sheets || Add vectors in the velocity plotimportnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionimportmultiprocessingasmpfromfunctoolsimportpartialfrompathlibimportPathimportargparsefrommatplotlib.tickerimportStrMethodFormatterimportrandommatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'defgettingFacets(filename, asy):exe=[\"./getFacet\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()stderr_output=stderr.decode(\"utf-8\")points=stderr_output.split(\"\\n\")segments=[]iflen(points)>100:foriinrange(len(points)-1):current_point=points[i].split()ifcurrent_point:next_point=points[i+1].split()ifnext_point:r1, z1=float(current_point[1]),float(current_point[0])r2, z2=float(next_point[1]),float(next_point[0])ifasy:segment_variants=[((r1, z1), (r2, z2)),((-r1, z1), (-r2, z2))]else:segment_variants=[((r1, z1), (r2, z2)),((-r1, z1), (-r2, z2)),((r1,-z1), (r2,-z2)),((-r1,-z1), (-r2,-z2))]segments.extend(segment_variants)returnsegmentsdefgettingfield(filename, zmin, rmin, zmax, rmax, nr, Oh):exe=[\"./getData\", filename,str(zmin),str(rmin),str(zmax),str(rmax),str(nr),str(Oh)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()lines=stderr.decode(\"utf-8\").split(\"\\n\")Rtemp, Ztemp, D2temp, veltemp, Utemp, Vtemp=[],[],[],[],[],[]foriinrange(len(lines)):values=lines[i].split(\" \")ifvalues==['']:passelse:Ztemp.append(float(values[0]))Rtemp.append(float(values[1]))D2temp.append(float(values[2]))veltemp.append(float(values[3]))Utemp.append(float(values[4]))Vtemp.append(float(values[5]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)U=np.asarray(Utemp)V=np.asarray(Vtemp)nz=int(len(Z)/nr)# print(f\"nz is {nz}\")R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))U.resize((nz, nr))V.resize((nz, nr))returnR, Z, D2, vel, U, V, nzdefprocess_timestep(ti, folder, rmin, rmax, zmin, zmax, lw, asy, Oh, nr, Ldomain):",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: Context",
    "content": "t = 0.1*ti\nsnapshot_file = Path(f\"intermediate/snapshot-{t:.4f}\")\noutput_file = folder / f\"{int(t * 1000):08d}.png\" if not snapshot_file.exists():\n    print(f\"{snapshot_file} not found!\")\n    return if output_file.exists():\n    print(f\"{output_file} already present!\")\n    return segs = gettingFacets(snapshot_file, asy) if not segs:\n    print(f\"Problem in the available file {snapshot_file}\")\n    return",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: R, Z, D2,...",
    "content": "R, Z, D2, vel, U, V, nz = gettingfield(snapshot_file, zmin, rmin, zmax, rmax, nr, Oh)\n# Part to plot\nAxesLabel, TickLabel = [50, 35]\nfig, ax = plt.subplots()\nfig.set_size_inches(19.20, 10.80) if not asy:\n    rmin, rmax, zmin, zmax = 0, Ldomain, -Ldomain/2, Ldomain/2\n    \nax.plot([0, 0], [zmin, zmax],'-.',color='grey',linewidth=lw)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: Context",
    "content": "ax.plot([-rmax, -rmax], [zmin, zmax],'-',color='black',linewidth=lw)\nax.plot([-rmax, rmax], [zmin, zmin],'-',color='black',linewidth=lw)\nax.plot([-rmax, rmax], [zmax, zmax],'-',color='black',linewidth=lw)\nax.plot([rmax, rmax], [zmin, zmax],'-',color='black',linewidth=lw) ## Drawing Facets\nline_segments = LineCollection(segs, linewidths=3.25, colors='green', linestyle='solid')\nax.add_collection(line_segments)\nax.set_title(f'$t/\\\\tau_\\gamma$ = {t:.3f}', fontsize=TickLabel)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: ## Copied Lines...",
    "content": "## Copied Lines\nax.set_aspect('equal')\nax.set_xlim(-rmax, rmax)\nax.set_ylim(zmin, zmax) velmax, velmin = 0.05, 0.00\nd2max, d2min = -1, -4 \n# print(f\"max D2 is {d2max} and min D2 is {d2min}\")\n# print(f\"max vel is {velmax} and min vel is {velmin}\")",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: if asy: cntrl1...",
    "content": "if asy:\n    cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin)\n    cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: else: rmin, rmax,...",
    "content": "else:   \n    rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2\n    cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, zmax], vmax=velmax, vmin=velmin)\n    cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, zmax], vmax=d2max, vmin=d2min)\n    cntrl1 = ax.imshow(vel, cmap=\"Blues\", interpolation='Bilinear', origin='lower', extent=[rmin, -rmax, zmin, -zmax], vmax=velmax, vmin=velmin)\n    cntrl2 = ax.imshow(D2, cmap=\"hot_r\", interpolation='Bilinear', origin='lower', extent=[rmin, rmax, zmin, -zmax], vmax=d2max, vmin=d2min)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: l, b, w,...",
    "content": "l, b, w, h = ax.get_position().bounds\ncb1 = fig.add_axes([l+0.05*w, b-0.05, 0.40*w, 0.03])\nc1 = plt.colorbar(cntrl1,cax=cb1,orientation='horizontal')\nc1.set_label(r'$\\|\\mathbf{v}\\|/\\sqrt{\\gamma/\\rho R_0}$',fontsize=TickLabel, labelpad=-25)\nc1.ax.tick_params(labelsize=TickLabel)\nc1.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.2f}'))\nc1.set_ticks([velmax, velmin])\ncb2 = fig.add_axes([l+0.55*w, b-0.05, 0.40*w, 0.03])\nc2 = plt.colorbar(cntrl2,cax=cb2,orientation='horizontal')\nc2.ax.tick_params(labelsize=TickLabel)\nc2.set_label(r\"$\\log_{10}\\left(2\\left( \\boldsymbol{\\mathcal {D} : \\mathcal {D}} \\right) \\right)$\",fontsize=TickLabel, labelpad=-25)\nc2.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}')) \nc2.set_ticks([d2max, d2min])",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: n = 14...",
    "content": "n = 14  # Adjust this value to control the density\nR_reduced = R[::n, ::n]\nZ_reduced = Z[::n, ::n]\nU_reduced = U[::n, ::n]\nV_reduced = V[::n, ::n] magnitude = np.sqrt(U_reduced**2 + V_reduced**2) U_reduced = U_reduced/magnitude\nV_reduced = V_reduced/magnitude",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: # Plot vectors...",
    "content": "# Plot vectors\n# ax.quiver(-R_filtered, Z_filtered, -V_filtered, U_filtered, color='black', scale=20, headwidth=3, headlength=4, headaxislength=4, width=0.002)\n# ax.quiver(-R_filtered, Z_filtered, -V_filtered, U_filtered)\nax.quiver(-R_reduced, Z_reduced, -V_reduced, U_reduced, color='black', scale=75, headwidth=3.5, headlength=4, headaxislength=3.8, width=0.0018)\n# ax.quiver(R_filtered, Z_filtered, V_filtered, U_filtered, color='#1F77B4', scale=10, headwidth=3, headlength=4, headaxislength=4, width=0.002)     \n# ax.quiver(R, Z, ux, uy, color='black', scale=1000)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: Context",
    "content": "ax.axis('off')\n# plt.show()\nplt.savefig(output_file, bbox_inches=\"tight\", dpi=250)\nplt.close()\nprint(f\"{ti+1} is done\")",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: nGFS = 10000...",
    "content": "nGFS = 10000\nLdomain = 4\nGridsPerR = 64\nnr = int(GridsPerR*Ldomain) if args.asy:\n    rmin, rmax, zmin, zmax = 0, Ldomain, -Ldomain/2, Ldomain/2\nelse:\n    rmin, rmax, zmin, zmax = 0, Ldomain, 0, Ldomain/2\nlw = 2 folder = Path('Video')  # output folder if not folder.is_dir():\n    os.makedirs(folder)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: Function Definition",
    "content": "# Prepare the partial function with fixed arguments\n# process_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, nr=nr)\nprocess_func = partial(process_timestep, folder=folder, rmin=rmin, rmax=rmax, zmin=zmin, zmax=zmax, lw=lw, asy=args.asy, Oh=args.Oh, nr=nr, Ldomain=Ldomain) # Use all available CPU cores\nnum_processes = 6 #mp.cpu_count() nGFS_list = list(range(250, nGFS))\nrandom.shuffle(nGFS_list)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_04.py | Documentation - Code Example: # Create a...",
    "content": "# Create a pool of worker processes\nwith mp.Pool(processes=num_processes) as pool:\n    # Map the process_func to all timesteps\n    pool.map(process_func, nGFS_list)",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_04.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03_all.py | Documentation: Import Statements",
    "content": "postProcess/VideoBubbleinSheet_03_all.py See raw file # To get facets for bubbles in sheets import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import sys matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True # matplotlib.rcParams['text.latex.preamble'] = [r''] def gettingFacets1(filename): exe = [ \"./getFacet1\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) ##segs.append((r1,z1)) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) segs.append(((r1, - z1),(r2, - z2))) segs.append((( - r1, - z1),( - r2, - z2))) skip = True return segs def gettingFacets2(filename): exe = [ \"./getFacet2\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) ##segs.append((r1,z1)) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) segs.append(((r1, - z1),(r2, - z2))) segs.append((( - r1, - z1),( - r2, - z2))) skip = True return segs def gettingFacets(filename): exe = [ \"./getFacet\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) ##segs.append((r1,z1)) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) segs.append(((r1, - z1),(r2, - z2))) segs.append((( - r1, - z1),( - r2, - z2))) skip = True return segs # ---------------------------------------------------------------------------------------------------------------------- nGFS = 1000 Ldomain = 4 GridsPerR = 64 nr = int (GridsPerR * Ldomain) rmin, rmax, zmin, zmax = [ - Ldomain, Ldomain, - Ldomain / 2 , Ldomain / 2 ] lw = 2 folder = 'Video_all' # output folder if not os.path.isdir(folder): os.makedirs(folder) for ti in range (nGFS): t = 0.1 * ti place = \"snapshot- %5.4f \" % t place2 = \"intermediate/snapshot- %5.4f \" % 0e0 name = \" %s / %8.8d .png\" % (folder, int (t * 1000 )) if not os.path.exists(place): print ( \" %s File not found!\" % place) else : if os.path.exists(name): print ( \" %s Image present!\" % name) else : segs1 = gettingFacets1(place) segs2 = gettingFacets2(place) segs = gettingFacets(place2) if ( len (segs1) == 0 ): print ( \"Problem in the available file %s \" % place) else : # Part to plot AxesLabel, TickLabel = [ 50 , 35 ] fig, ax = plt.subplots() fig.set_size_inches( 19.20 , 10.80 ) ax.plot([ 0 , 0 ], [zmin, zmax], '-.' ,color = 'grey' ,linewidth = lw) ax.plot([rmin, rmin], [zmin, zmax], '-' ,color = 'black' ,linewidth = lw) ax.plot([rmin, rmax], [zmin, zmin], '-' ,color = 'black' ,linewidth = lw) ax.plot([rmin, rmax], [zmax, zmax], '-' ,color = 'black' ,linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' ,color = 'black' ,linewidth = lw) ## Drawing Facets line_segments1 = LineCollection(segs1, linewidths = 3.25 , colors = 'green' , linestyle = 'solid' ) line_segments2 = LineCollection(segs2, linewidths = 3.25 , colors = 'purple' , linestyle = 'solid' ) line_segments3 = LineCollection(segs, linewidths = 1.25 , colors = 'black' , linestyle = 'solid' ) ax.add_collection(line_segments1) ax.add_collection(line_segments2) ax.add_collection(line_segments3) ax.set_title( '$t/ \\\\ tau_ \\ gamma$ = %4.3f ' % t, fontsize = TickLabel) #plt.scatter(segs[0], segs[1]) #print(\"The line collection array: \",segs) ## Copied Lines ax.set_aspect( 'equal' ) ax.set_xlim(rmin, rmax) ax.set_ylim(zmin, zmax) ax.axis( 'off' ) # plt.show() plt.savefig(name, bbox_inches = \"tight\" , dpi = 250 ) plt.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03_all.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoBubbleinSheet_03_all.py | Documentation - Code Example: # To get...",
    "content": "# To get facets for bubbles in sheetsimportnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportsysmatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=True# matplotlib.rcParams['text.latex.preamble'] = [r'']defgettingFacets1(filename):exe=[\"./getFacet1\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])##segs.append((r1,z1))segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))segs.append(((r1,-z1),(r2,-z2)))segs.append(((-r1,-z1),(-r2,-z2)))skip=TruereturnsegsdefgettingFacets2(filename):exe=[\"./getFacet2\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])##segs.append((r1,z1))segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))segs.append(((r1,-z1),(r2,-z2)))segs.append(((-r1,-z1),(-r2,-z2)))skip=TruereturnsegsdefgettingFacets(filename):exe=[\"./getFacet\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])##segs.append((r1,z1))segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))segs.append(((r1,-z1),(r2,-z2)))segs.append(((-r1,-z1),(-r2,-z2)))skip=Truereturnsegs# ----------------------------------------------------------------------------------------------------------------------nGFS=1000Ldomain=4GridsPerR=64nr=int(GridsPerR*Ldomain)rmin, rmax, zmin, zmax=[-Ldomain, Ldomain,-Ldomain/2, Ldomain/2]lw=2folder='Video_all'# output folderifnotos.path.isdir(folder):os.makedirs(folder)fortiinrange(nGFS):t=0.1*tiplace=\"snapshot-%5.4f\"%tplace2=\"intermediate/snapshot-%5.4f\"%0e0name=\"%s/%8.8d.png\"%(folder,int(t*1000))ifnotos.path.exists(place):print(\"%sFile not found!\"%place)else:ifos.path.exists(name):print(\"%sImage present!\"%name)else:segs1=gettingFacets1(place)segs2=gettingFacets2(place)segs=gettingFacets(place2)if(len(segs1)==0):print(\"Problem in the available file%s\"%place)else:# Part to plotAxesLabel, TickLabel=[50,35]fig, ax=plt.subplots()fig.set_size_inches(19.20,10.80)ax.plot([0,0], [zmin, zmax],'-.',color='grey',linewidth=lw)ax.plot([rmin, rmin], [zmin, zmax],'-',color='black',linewidth=lw)ax.plot([rmin, rmax], [zmin, zmin],'-',color='black',linewidth=lw)ax.plot([rmin, rmax], [zmax, zmax],'-',color='black',linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-',color='black',linewidth=lw)## Drawing Facetsline_segments1=LineCollection(segs1, linewidths=3.25, colors='green', linestyle='solid')line_segments2=LineCollection(segs2, linewidths=3.25, colors='purple', linestyle='solid')line_segments3=LineCollection(segs, linewidths=1.25, colors='black', linestyle='solid')ax.add_collection(line_segments1)ax.add_collection(line_segments2)ax.add_collection(line_segments3)ax.set_title('$t/\\\\tau_\\gamma$ =%4.3f'%t, fontsize=TickLabel)#plt.scatter(segs[0], segs[1])#print(\"The line collection array: \",segs)## Copied Linesax.set_aspect('equal')ax.set_xlim(rmin, rmax)ax.set_ylim(zmin, zmax)ax.axis('off')# plt.show()plt.savefig(name, bbox_inches=\"tight\", dpi=250)plt.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/VideoBubbleinSheet_03_all.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/out_h_time.py | Documentation: Python Function",
    "content": "postProcess/out_h_time.py See raw file # To out film thickness import numpy as np import os import subprocess as sp def getting_h(filename): exe = [ \"./geth\" , filename] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) temp3 = temp2[ 0 ].split( \" \" ) return float (temp3[ 0 ]), float (temp3[ 1 ]), float (temp3[ 2 ]) # ---------------------------------------------------------------------------------------------------------------------- nGFS = 10000 tsnap = 0.1 for ti in range (nGFS): t = tsnap * ti place = \"intermediate/snapshot- %5.4f \" % t if not os.path.exists(place): print ( \" %s File not found!\" % place) else : tp, xmax, y_xmax = getting_h(place) print (tp) print ( \"Time: %4.3f , xmax: %4.3f , y_xmax: %4.3f \" % (tp, xmax, y_xmax)) f = open ( \"out_h_time.txt\" , \"a\" ) f.write( \" %4.6f \" % (tp)) f.write( \" \\t \" ) f.write( \" %4.6f \" % (xmax)) f.write( \" \\t \" ) f.write( \" %4.6f \" % (y_xmax)) f.write( \" \\t \" ) f.write( \" \\n \" ) f.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/out_h_time.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/out_h_time.py | Documentation - Code Example: # To out...",
    "content": "# To out film thicknessimportnumpyasnpimportosimportsubprocessasspdefgetting_h(filename):exe=[\"./geth\", filename]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")temp3=temp2[0].split(\" \")returnfloat(temp3[0]),float(temp3[1]),float(temp3[2])# ----------------------------------------------------------------------------------------------------------------------nGFS=10000tsnap=0.1fortiinrange(nGFS):t=tsnap*tiplace=\"intermediate/snapshot-%5.4f\"%tifnotos.path.exists(place):print(\"%sFile not found!\"%place)else:tp, xmax, y_xmax=getting_h(place)print(tp)print(\"Time:%4.3f, xmax:%4.3f, y_xmax:%4.3f\"%(tp, xmax, y_xmax))f=open(\"out_h_time.txt\",\"a\")f.write(\"%4.6f\"%(tp))f.write(\"\\t\")f.write(\"%4.6f\"%(xmax))f.write(\"\\t\")f.write(\"%4.6f\"%(y_xmax))f.write(\"\\t\")f.write(\"\\n\")f.close()",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/out_h_time.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2.c | Documentation",
    "content": "postProcess/getFacet2.c See raw file /* Title: Getting Facets # Author: Vatsal Sanjay # vatsalsanjay@gmail.com # Physics of Fluids #include \u201cnavier-stokes/centered.h\u201d #include \u201cfractions.h\u201d scalar f2[]; char filename[80]; int main(int a, char const arguments[]) { sprintf (filename, \u201c%s\u201d, arguments[1]); restore (file = filename); #if TREE f2.prolongation = fraction_refine; #endif boundary((scalar ){f2}); FILE * fp = ferr; output_facets(f2,fp); fflush (fp); fclose (fp); }",
    "url": "https://comphy-lab.org/HoleySheet/postProcess/getFacet2.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "MultiRheoFlow | MultiRheoFlow: MultiRheoFlow An extensible...",
    "content": "MultiRheoFlow An extensible framework for multiphase flows with complex rheology, built on Basilisk C Overview RheoMultiFlow is an open-source multiphase multirheology extension of the ElastoFlow solver. Here, we provide a catalogue of several models implemnented in Basilisk C . Building upon Basilisk\u2019s powerful adaptive mesh capabilities, this framework enables high-fidelity simulations of non-Newtonian fluids and viscoelastic materials with free surfaces, interfaces, and capillary effects. Developed at the Computational Multiphase Physics (CoMPhy) Lab at the University of Twente, RheoMultiFlow provides a modular platform where different rheological constitutive equations can be seamlessly integrated with multiphase flow scenarios.",
    "url": "https://comphy-lab.org/MultiRheoFlow/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "MultiRheoFlow | MultiRheoFlow: Key Features Diverse...",
    "content": "Key Features Diverse Rheology Models : Simulates a wide spectrum of material behaviors: Newtonian fluids (done \u2705) Viscoelastic fluids (Oldroyd-B - done \u2705, Giesekus - good to have \ud83c\udf40, FENE-P - urgent \ud83d\udccc) Yield-stress materials (Bingham - done \u2705, Herschel-Bulkley - done \u2705) Elastoviscoplastic materials (Saramito model - good to have \ud83c\udf40) Multiphase Capabilities : Handles interfacial dynamics with: Two-phase and multiphase flow support Accurate surface tension and capillary effects Interface capturing via Volume-of-Fluid method Arbitary Density and viscosity contrasts High-Performance Computing : Leverages Basilisk\u2019s advantages: Adaptive mesh refinement for computational efficiency Parallelization for large-scale simulations 2D, Axisymmetric, and 3D simulation capabilities Log-Conformation Method : Ensures stability for highly elastic flows using advanced numerical techniques Test Cases RheoMultiFlow is particularly well-suited for simulating: Running the code Install Basilisk.",
    "url": "https://comphy-lab.org/MultiRheoFlow/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "MultiRheoFlow | MultiRheoFlow: Follow the instructions...",
    "content": "Follow the instructions here to install Basilisk. For MacOS and Linux (we have tested some but not all the different Linux distros), you can use the reset_install_requirements.sh script to install Basilisk. For Windows, we recommend using the Windows Subsystem for Linux (WSL). However, people have reported issues with this. If you find issues, please let us know. # Prerequisites: Basilisk installation (http://basilisk.fr) git clone https://github.com/comphy-lab/RheoMultiFlow.git cd RheoMultiFlow bash reset_install_requirements.sh --hard # use --hard to force the installation from scratch. Compile the code Using makefile and visualization on the fly cd simulationCases/ CFLAGS = -DDISPLAY=-1 make caseToRun.tst Using makefile but no visualization on the fly cd simulationCases/ make caseToRun.tst Using bash script Use the run_case.sh script to run a case. bash run_case.sh caseToRun # no display.",
    "url": "https://comphy-lab.org/MultiRheoFlow/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "MultiRheoFlow | MultiRheoFlow: Compile and run...",
    "content": "Compile and run from cli qcc -O2 -Wall -disable-dimensions caseToRun.c -o caseToRun -lm ./caseToRun Compile and run with MPI (MACOS) Note: you should have OpenMPI installed. CC99 = 'mpicc -std=c99 -D_GNU_SOURCE=1' qcc -Wall -O2 -D_MPI = 1 -disable-dimensions caseToRun.c -o caseToRun -lm mpirun -np $NUM_PROCESSORS_TO_USE ./caseToRun Contributing Contributions to RheoMultiFlow are welcome! Please see our Contributing guide for details on how to submit code, report bugs, or request features. License This project is licensed under the GNU GPLv3 License - see the LICENSE file for details, consistent with Basilisk\u2019s licensing. Acknowledgments RheoMultiFlow builds upon ElastoFlow and the Basilisk C framework.",
    "url": "https://comphy-lab.org/MultiRheoFlow/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "MultiRheoFlow | MultiRheoFlow: Generated Documentation Root...",
    "content": "Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/VideoAxi.py postProcess/getData-elastic-scalar2D.c postProcess/getFacet2D.c simulationCases simulationCases/Makefile simulationCases/cleanup.sh simulationCases/dropAtomisation.c simulationCases/dropImpact.c simulationCases/pinchOff.c simulationCases/runCases.sh simulationCases/testEigenDecomposition.c src-local src-local/eigen_decomposition.h src-local/log-conform-viscoelastic-scalar-2D.h src-local/log-conform-viscoelastic-scalar-3D.h src-local/log-conform-viscoelastic.h src-local/two-phaseVE.h",
    "url": "https://comphy-lab.org/MultiRheoFlow/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "MultiRheoFlow | MultiRheoFlow - Code Example",
    "content": "# Prerequisites: Basilisk installation (http://basilisk.fr)gitclone https://github.com/comphy-lab/RheoMultiFlow.gitcdRheoMultiFlowbashreset_install_requirements.sh--hard# use --hard to force the installation from scratch.",
    "url": "https://comphy-lab.org/MultiRheoFlow/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "MultiRheoFlow | MultiRheoFlow - Code Example",
    "content": "cdsimulationCases/CFLAGS=-DDISPLAY=-1makecaseToRun.tst",
    "url": "https://comphy-lab.org/MultiRheoFlow/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "MultiRheoFlow | MultiRheoFlow - Code Example",
    "content": "qcc-O2-Wall-disable-dimensionscaseToRun.c-ocaseToRun-lm./caseToRun",
    "url": "https://comphy-lab.org/MultiRheoFlow/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "MultiRheoFlow | MultiRheoFlow - Code Example",
    "content": "CC99='mpicc -std=c99 -D_GNU_SOURCE=1'qcc-Wall-O2-D_MPI=1-disable-dimensionscaseToRun.c-ocaseToRun-lmmpirun-np$NUM_PROCESSORS_TO_USE./caseToRun",
    "url": "https://comphy-lab.org/MultiRheoFlow/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | MultiRheoFlow",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # MacOS only. modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk rm -rf basilisk rm -rf .project_config darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make -k make echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config",
    "url": "https://comphy-lab.org/MultiRheoFlow/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | MultiRheoFlow - Code Example",
    "content": "#!/bin/zsh# MacOS only. modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basiliskrm-rfbasiliskrm-rf.project_configdarcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake-kmakeecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config",
    "url": "https://comphy-lab.org/MultiRheoFlow/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow: Context",
    "content": "simulationCases/dropImpact.c See raw file @file dropImpact.c @brief This file contains the simulation code for the drop impact on a solid surface. @author Vatsal Sanjay @version 0.2 @date Oct 18, 2024 #include \"axi.h\" // #include \"grid/octree.h\" // #include \"grid/quadtree.h\" #include \"navier-stokes/centered.h\" #define VANILLA 0 14 #if VANILLA #include \"log-conform-viscoelastic.h\" #define logFile \"logAxi-vanilla.dat\" 17 #else #if AXI #include \"log-conform-viscoelastic-scalar-2D.h\" #define logFile \"logAxi-scalar.dat\" 21 #else #include \"log-conform-viscoelastic-scalar-3D.h\" #define logFile \"log3D-scalar.dat\" 24 #endif #endif #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #define tsnap ( 1e-2 ) 34 // Error tolerancs #define fErr ( 1e-3 ) // error tolerance in f1 VOF #define KErr ( 1e-6 ) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr ( 1e-2 ) // error tolerances in velocity -- Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define xDist ( 5e-2 ) 41 #define R2 ( x , y , z ) ( sq ( x - 1. - xDist ) + sq ( y ) + sq ( z )) 42 // boundary conditions // u.t[left] = dirichlet(0.); // todo: later on use no-slip.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow: JavaScript",
    "content": "For testing, free-slip is faster. // u.r[left] = dirichlet(0.); // todo: later on use no-slip. For testing, free-slip is faster. f [ left ] = dirichlet ( 0.0 ); int MAXlevel ; // We -> Weber number of the drop // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // De -> Deborah number // Ec -> Elasto-capillary number // for now there is no viscoelasticity double We , Oh , Oha , De , Ec , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; int main ( int argc , char const * argv []) { dtmax = 1e-5 ; L0 = 4.0 ; // Values taken from the terminal MAXlevel = 8 ; tmax = 4.0 ; We = 5.0 ; Oh = 1e-2 ; Oha = 1e-2 * Oh ; De = 1.0 ; Ec = 1.0 ; init_grid ( 1 << 4 ); // Create a folder named intermediate where all the simulation snapshots are stored. char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow: Context",
    "content": "See writingFiles event. sprintf ( dumpFile , \"restart\" ); rho1 = 1. , rho2 = 1e-3 ; mu1 = Oh / sqrt ( We ), mu2 = Oha / sqrt ( We ); G1 = Ec / We , G2 = 0.0 ; lambda1 = De * sqrt ( We ), lambda2 = 0.0 ; f . sigma = 1.0 / We ; run (); } event init ( t = 0 ) { if (! restore ( file = dumpFile )){ refine ( R2 ( x , y , z ) < ( 1.1 ) && R2 ( x , y , z ) > ( 0.9 ) && level < MAXlevel ); fraction ( f , ( 1 - R2 ( x , y , z ))); foreach (){ u . x [] = - f []* 1.0 ; p [] = 2 * f []; } } } Adaptive Mesh Refinement event adapt ( i ++){ scalar KAPPA [], trA []; curvature ( f , KAPPA ); #if dimension == foreach (){ trA [] = A11 []+ A22 []+ A33 []; } adapt_wavelet (( scalar *){ f , u . x , u . y , u . z , KAPPA }, ( double []){ fErr , VelErr , VelErr , VelErr , KErr }, MAXlevel , 4 ); #else adapt_wavelet (( scalar *){ f , u . x , u . y , KAPPA }, ( double []){ fErr , VelErr , VelErr , KErr }, MAXlevel , 4 ); #endif } Dumping snapshots event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { p . nodump = false ; dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Ending Simulation event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); } Log writing event logWriting ( i ++) { double ke = 0. ; foreach ( reduction (+: ke )){ ke += ( 2 * pi * y )*( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y [])))* sq ( Delta ); } static FILE * fp ; if ( pid () == 0 ) { const char * mode = ( i == 0 ) ? \"w\" : \"a\" ; fp = fopen ( logFile , mode ); if ( fp == NULL ) { fprintf ( ferr , \"Error opening log file \\n \" ); return 1 ; } if ( i == 0 ) { fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( ferr , \"i dt t ke \\n \" ); fprintf ( fp , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( fp , \"i dt t ke rM \\n \" ); } fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); fflush ( fp ); fclose ( fp ); } assert ( ke > - 1e-10 ); if ( i > 1e1 && pid () == 0 ) { if ( ke > 1e2 || ke < 1e-8 ) { const char * message = ( ke > 1e2 ) ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" : \"kinetic energy too small now! Stopping! \\n \" ; fprintf ( ferr , \" %s \" , message ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %s \" , message ); fflush ( fp ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } }",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow - C/C++ Code: C/C++ Code",
    "content": "#include\"axi.h\"// #include \"grid/octree.h\"// #include \"grid/quadtree.h\"#include\"navier-stokes/centered.h\"#define VANILLA014#if VANILLA#include\"log-conform-viscoelastic.h\"#define logFile\"logAxi-vanilla.dat\"17#else#if AXI#include\"log-conform-viscoelastic-scalar-2D.h\"#define logFile\"logAxi-scalar.dat\"21#else#include\"log-conform-viscoelastic-scalar-3D.h\"#define logFile\"log3D-scalar.dat\"24#endif#endif#define FILTERED// Smear density and viscosity jumps#include\"two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#define tsnap(1e-2)34// Error tolerancs#define fErr(1e-3)// error tolerance in f1 VOF#define KErr(1e-6)// error tolerance in VoF curvature calculated using heigh function method (see adapt event)#define VelErr(1e-2)// error tolerances in velocity -- Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J#define xDist(5e-2)41#define R2(x,y,z)(sq(x-1.-xDist)+sq(y)+sq(z))42// boundary conditions// u.t[left] = dirichlet(0.); // todo: later on use no-slip.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow - C/C++ Code: For testing, free-slip...",
    "content": "For testing, free-slip is faster.// u.r[left] = dirichlet(0.); // todo: later on use no-slip.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow - C/C++ Code: For testing, free-slip...",
    "content": "For testing, free-slip is faster.f[left]=dirichlet(0.0);intMAXlevel;// We -> Weber number of the drop// Oh -> Solvent Ohnesorge number// Oha -> air Ohnesorge number// De -> Deborah number// Ec -> Elasto-capillary number// for now there is no viscoelasticitydoubleWe,Oh,Oha,De,Ec,tmax;charnameOut[80],dumpFile[80];intmain(intargc,charconst*argv[]){dtmax=1e-5;L0=4.0;// Values taken from the terminalMAXlevel=8;tmax=4.0;We=5.0;Oh=1e-2;Oha=1e-2*Oh;De=1.0;Ec=1.0;init_grid(1<<4);// Create a folder named intermediate where all the simulation snapshots are stored.charcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow - C/C++ Code: Context",
    "content": "See writingFiles event.sprintf(dumpFile,\"restart\");rho1=1.,rho2=1e-3;mu1=Oh/sqrt(We),mu2=Oha/sqrt(We);G1=Ec/We,G2=0.0;lambda1=De*sqrt(We),lambda2=0.0;f.sigma=1.0/We;run();}event init(t=0){if(!restore(file=dumpFile)){refine(R2(x,y,z)<(1.1)&&R2(x,y,z)>(0.9)&&level<MAXlevel);fraction(f,(1-R2(x,y,z)));foreach(){u.x[]=-f[]*1.0;p[]=2*f[];}}}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow - Code Example",
    "content": "event adapt(i++){scalar KAPPA[],trA[];curvature(f,KAPPA);#if dimension ==foreach(){trA[]=A11[]+A22[]+A33[];}adapt_wavelet((scalar*){f,u.x,u.y,u.z,KAPPA},(double[]){fErr,VelErr,VelErr,VelErr,KErr},MAXlevel,4);#elseadapt_wavelet((scalar*){f,u.x,u.y,KAPPA},(double[]){fErr,VelErr,VelErr,KErr},MAXlevel,4);#endif}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){p.nodump=false;dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow - Code Example: Context",
    "content": "event logWriting(i++){doubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])))*sq(Delta);}staticFILE*fp;if(pid()==0){constchar*mode=(i==0)?\"w\":\"a\";fp=fopen(logFile,mode);if(fp==NULL){fprintf(ferr,\"Error opening log file\\n\");return1;}if(i==0){fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(ferr,\"i dt t ke\\n\");fprintf(fp,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(fp,\"i dt t ke rM\\n\");}fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);fflush(fp);fclose(fp);}assert(ke>-1e-10);if(i>1e1&&pid()==0){if(ke>1e2||ke<1e-8){constchar*message=(ke>1e2)?\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropImpact.c | MultiRheoFlow - Code Example: Stopping simulation\\n\":\"kinetic energy...",
    "content": "Stopping simulation\\n\":\"kinetic energy too small now! Stopping!\\n\";fprintf(ferr,\"%s\",message);fp=fopen(\"log\",\"a\");fprintf(fp,\"%s\",message);fflush(fp);fclose(fp);dump(file=dumpFile);return1;}}}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropImpact.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow: C/C++ Code",
    "content": "simulationCases/testEigenDecomposition.c See raw file #include <stdio.h> #include <math.h> #include <stdlib.h> #include \u201c../src-local/eigen_decomposition.h\u201d #define EPSILON 1e-9 #define RELATIVE_TOLERANCE 1e-6 #define sq(x) ((x)*(x)) typedef struct { long double x, y, z; } pseudo_v3d; typedef struct { pseudo_v3d x, y, z; } pseudo_t3d; static void diagonalization_3D(pseudo_v3d* Lambda, pseudo_t3d* R, pseudo_t3d* A) { // Check if the matrix is already diagonal if (sq(A->x.y) + sq(A->x.z) + sq(A->y.z) < 1e-15) { R->x.x = R->y.y = R->z.z = 1.; R->y.x = R->x.y = R->z.x = R->x.z = R->z.y = R->y.z = 0.; Lambda->x = A->x.x; Lambda->y = A->y.y; Lambda->z = A->z.z; return; } // Compute eigenvalues using the eigen_decomposition function double matrix[3][3] = { {A->x.x, A->x.y, A->x.z}, {A->x.y, A->y.y, A->y.z}, {A->x.z, A->y.z, A->z.z} }; double eigenvectors[3][3]; double eigenvalues[3]; compute_eigensystem_symmetric_3x3(matrix, eigenvectors, eigenvalues); // Corrected: Store eigenvalues and eigenvectors with proper index mapping Lambda->x = eigenvalues[0]; Lambda->y = eigenvalues[1]; Lambda->z = eigenvalues[2]; R->x.x = eigenvectors[0][0]; R->x.y = eigenvectors[0][1]; R->x.z = eigenvectors[0][2]; R->y.x = eigenvectors[1][0]; R->y.y = eigenvectors[1][1]; R->y.z = eigenvectors[1][2]; R->z.x = eigenvectors[2][0]; R->z.y = eigenvectors[2][1]; R->z.z = eigenvectors[2][2]; } // Helper function to print a pseudo_t3d void print_pseudo_t3d(const char* name, const pseudo_t3d* matrix) { printf(\u201c%s:\u201d, name); printf(\u201c%12.9Lf %12.9Lf %12.9Lf\u201d, matrix->x.x, matrix->x.y, matrix->x.z); printf(\u201c%12.9Lf %12.9Lf %12.9Lf\u201d, matrix->y.x, matrix->y.y, matrix->y.z); printf(\u201c%12.9Lf %12.9Lf %12.9Lf\u201d, matrix->z.x, matrix->z.y, matrix->z.z); printf(\u201c\u201d); } // Helper function to print a pseudo_v3d void print_pseudo_v3d(const char* name, const pseudo_v3d* vector) { printf(\u201c%s: %12.9Lf %12.9Lf %12.9Lf\u201d, name, vector->x, vector->y, vector->z); } // Function to verify the orthonormality of eigenvectors int verify_orthonormality(const pseudo_t3d* R) { for (int i = 0; i < 3; i++) { long double norm = sq(((long double )R)[i]) + sq(((long double )R)[i+3]) + sq(((long double*)R)[i+6]); if (fabsl(norm - 1.0L) > EPSILON) { printf(\u201cEigenvector %d is not normalized.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow: Norm = %Lf\u201d,...",
    "content": "Norm = %Lf\u201d, i, sqrtl(norm)); return 0; } for (int j = i + 1; j < 3; j++) { long double dot_product = ((long double*)R)[i] * ((long double*)R)[j] + ((long double*)R)[i+3] * ((long double*)R)[j+3] + ((long double*)R)[i+6] * ((long double*)R)[j+6]; if (fabsl(dot_product) > EPSILON) { printf(\"Eigenvectors %d and %d are not orthogonal.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow: JavaScript",
    "content": "Dot product = %Lf\\n\", i, j, dot_product); return 0; } } } return 1; } // Function to verify the diagonalization int verify_diagonalization(const pseudo_t3d* A, const pseudo_t3d* R, const pseudo_v3d* Lambda) { pseudo_t3d temp, diagonalized; // Compute R^T * A * R for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { ((long double*)&temp)[i*3 + j] = 0; for (int k = 0; k < 3; k++) { ((long double*)&temp)[i*3 + j] += ((long double*)R)[k*3 + i] * ((long double*)A)[k*3 + j]; } } } for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { ((long double*)&diagonalized)[i*3 + j] = 0; for (int k = 0; k < 3; k++) { ((long double*)&diagonalized)[i*3 + j] += ((long double*)&temp)[i*3 + k] * ((long double*)R)[k*3 + j]; } } } // Print the diagonalized matrix print_pseudo_t3d(\"Diagonalized matrix: (R^T * A * R)\", &diagonalized); for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { if (i == j) { long double relative_error = fabsl(((long double*)&diagonalized)[i*3 + j] - ((long double*)Lambda)[i]) / (fabsl(((long double*)Lambda)[i]) + EPSILON); if (relative_error > RELATIVE_TOLERANCE) { printf(\"Diagonal element (%d,%d) does not match eigenvalue. %Lf != %Lf (relative error: %Lf)\\n\", i, j, ((long double*)&diagonalized)[i*3 + j], ((long double*)Lambda)[i], relative_error); } } else { if (fabsl(((long double*)&diagonalized)[i*3 + j]) > EPSILON) { printf(\"Off-diagonal element (%d,%d) is not zero.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow: JavaScript",
    "content": "Value = %Lf\\n\", i, j, ((long double*)&diagonalized)[i*3 + j]); } } } } return 1; } // Function to verify A * v = \u03bb * v for each eigenpair int verify_eigenpairs(const pseudo_t3d* A, const pseudo_t3d* R, const pseudo_v3d* Lambda) { printf(\u201cVerifying A * v = \u03bb * v for each eigenpair:\u201d); for (int i = 0; i < 3; i++) { pseudo_v3d Av = {0}, lambda_v = {0}; // Compute A * v for (int j = 0; j < 3; j++) { ((double*)&Av)[j] = ((double*)A)[j*3] * ((double*)R)[i] + ((double*)A)[j*3+1] * ((double*)R)[i+3] + ((double*)A)[j*3+2] * ((double*)R)[i+6]; } // Compute \u03bb * v for (int j = 0; j < 3; j++) { ((double*)&lambda_v)[j] = ((double*)Lambda)[i] * ((double*)R)[i+j*3]; } printf(\"Eigenpair %d:\\n\", i + 1); printf(\"A * v = %8.4Lf %8.4Lf %8.4Lf\\n\", Av.x, Av.y, Av.z); printf(\"\u03bb * v = %8.4Lf %8.4Lf %8.4Lf\\n\", lambda_v.x, lambda_v.y, lambda_v.z); // Check if A * v \u2248 \u03bb * v for (int j = 0; j < 3; j++) { if (fabs(((double*)&Av)[j] - ((double*)&lambda_v)[j]) > EPSILON) { printf(\"Mismatch for eigenpair %d, component %d\\n\", i + 1, j + 1); } } printf(\"Verification A * v = \u03bb * v for each eigenpair done.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow: Function Definition",
    "content": "See the messages above!\\n\\n\"); } return 1; } // Main verification function int verify_eigendecomposition(const pseudo_t3d* A, const pseudo_t3d* R, const pseudo_v3d* Lambda) { if (!verify_orthonormality(R)) { printf(\u201cEigenvectors are not orthonormal.\u201d); } else { printf(\u201cEigenvectors are orthonormal.\u201d); } printf(\u201c\u201d); if (!verify_diagonalization(A, R, Lambda)) { printf(\"Matrix is not properly diagonalized.\\n\"); } else { printf(\"Matrix is properly diagonalized.\\n\"); } if (!verify_eigenpairs(A, R, Lambda)) { printf(\"Eigenpair verification failed.\\n\"); } else { printf(\"Eigenpair verification passed.\\n\"); } printf(\"Eigendecomposition verification completed.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow: JavaScript",
    "content": "See the messages above!\\n\"); return 1; } // verify A = R * Lambda * R^T int verify_reconstruction(const pseudo_t3d* A, const pseudo_t3d* R, const pseudo_v3d* Lambda) { pseudo_t3d Lambda_diag, temp, A_reconstructed; // Create diagonal matrix from Lambda for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { ((long double*)&Lambda_diag)[i*3 + j] = (i == j) ? ((long double*)Lambda)[i] : 0.0L; } } // Compute R * Lambda for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { ((long double*)&temp)[i*3 + j] = 0; for (int k = 0; k < 3; k++) { ((long double*)&temp)[i*3 + j] += ((long double*)R)[i*3 + k] * ((long double*)&Lambda_diag)[k*3 + j]; } } } // Compute (R * Lambda) * R^T for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { ((long double*)&A_reconstructed)[i*3 + j] = 0; for (int k = 0; k < 3; k++) { ((long double*)&A_reconstructed)[i*3 + j] += ((long double*)&temp)[i*3 + k] * ((long double*)R)[j*3 + k]; } } } print_pseudo_t3d(\"Reconstructed A = R * Lambda * R^T\", &A_reconstructed); // Compare original A with reconstructed A for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { long double diff = fabsl(((long double*)A)[i*3 + j] - ((long double*)&A_reconstructed)[i*3 + j]); if (diff > EPSILON) { printf(\"Mismatch at (%d,%d): original = %Lf, reconstructed = %Lf, difference = %Lf\\n\", i, j, ((long double*)A)[i*3 + j], ((long double*)&A_reconstructed)[i*3 + j], diff); } } } printf(\"A = R * Lambda * R^T verification completed.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow: C/C++ Main",
    "content": "See the messages above!\\n\"); return 1; } int main(int argc, char *argv[]) { pseudo_t3d A, R; pseudo_v3d Lambda; // Initialize A with the given values /* this is a diagonal not I matrix // A.x.x = 1; A.x.y = 0; A.x.z = 0; // A.y.x = 0; A.y.y = 2; A.y.z = 0; // A.z.x = 0; A.z.y = 0; A.z.z = 3; /* this is a identity matrix */ // A.x.x = 1; A.x.y = 0; A.x.z = 0; // A.y.x = 0; A.y.y = 1; A.y.z = 0; // A.z.x = 0; A.z.y = 0; A.z.z = 1; /* this is a non-diagonal matrix */ // A.x.x = 1; A.x.y = 2; A.x.z = 3; // A.y.x = 2; A.y.y = 4; A.y.z = 5; // A.z.x = 3; A.z.y = 5; A.z.z = -6; /* this is a small matrix */ // A.x.x = 1e-6; A.x.y = 0; A.x.z = 0; // A.y.x = 0; A.y.y = 1e-12; A.y.z = 0; // A.z.x = 0; A.z.y = 0; A.z.z = 1e-10; /* this is a large matrix */ // A.x.x = 100; A.x.y = 100; A.x.z = 10; // A.y.x = 100; A.y.y = 10; A.y.z = 1; // A.z.x = 10; A.z.y = 1; A.z.z = 0.1; if (argc != 7) { A.x.x = 1; A.x.y = 2; A.x.z = 3; A.y.x = 2; A.y.y = 4; A.y.z = 5; A.z.x = 3; A.z.y = 5; A.z.z = -6; } else { // get Aij from terminal A.x.x = atof(argv[1]); A.x.y = atof(argv[2]); A.x.z = atof(argv[3]); A.y.x = atof(argv[2]); A.y.y = atof(argv[4]); A.y.z = atof(argv[5]); A.z.x = atof(argv[3]); A.z.y = atof(argv[5]); A.z.z = atof(argv[6]); } print_pseudo_t3d(\"Original matrix A\", &A); diagonalization_3D(&Lambda, &R, &A); print_pseudo_t3d(\"Eigenvectors R\", &R); print_pseudo_v3d(\"Eigenvalues Lambda\", &Lambda); verify_eigendecomposition(&A, &R, &Lambda); // lastly check if A = R * Lambda * R^T verify_reconstruction(&A, &R, &Lambda); return 0; }",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: // Compute eigenvalues...",
    "content": "// Compute eigenvalues using the eigen_decomposition function\ndouble matrix[3][3] = {\n    {A->x.x, A->x.y, A->x.z},\n    {A->x.y, A->y.y, A->y.z},\n    {A->x.z, A->y.z, A->z.z}\n};\ndouble eigenvectors[3][3];\ndouble eigenvalues[3]; compute_eigensystem_symmetric_3x3(matrix, eigenvectors, eigenvalues); // Corrected: Store eigenvalues and eigenvectors with proper index mapping\nLambda->x = eigenvalues[0];\nLambda->y = eigenvalues[1];\nLambda->z = eigenvalues[2];",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: Context",
    "content": "R->x.x = eigenvectors[0][0]; R->x.y = eigenvectors[0][1]; R->x.z = eigenvectors[0][2];\nR->y.x = eigenvectors[1][0]; R->y.y = eigenvectors[1][1]; R->y.z = eigenvectors[1][2];\nR->z.x = eigenvectors[2][0]; R->z.y = eigenvectors[2][1]; R->z.z = eigenvectors[2][2];",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example",
    "content": "for (int j = i + 1; j < 3; j++) {\n        long double dot_product = ((long double*)R)[i] * ((long double*)R)[j] + \n                                  ((long double*)R)[i+3] * ((long double*)R)[j+3] + \n                                  ((long double*)R)[i+6] * ((long double*)R)[j+6];\n        if (fabsl(dot_product) > EPSILON) {\n            printf(\"Eigenvectors %d and %d are not orthogonal. Dot product = %Lf\\n\", i, j, dot_product);\n            return 0;\n        }\n    }\n}\nreturn 1;",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: // Compute R^T...",
    "content": "// Compute R^T * A * R\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        ((long double*)&temp)[i*3 + j] = 0;\n        for (int k = 0; k < 3; k++) {\n            ((long double*)&temp)[i*3 + j] += ((long double*)R)[k*3 + i] * ((long double*)A)[k*3 + j];\n        }\n    }\n}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: for (int i...",
    "content": "for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        ((long double*)&diagonalized)[i*3 + j] = 0;\n        for (int k = 0; k < 3; k++) {\n            ((long double*)&diagonalized)[i*3 + j] += ((long double*)&temp)[i*3 + k] * ((long double*)R)[k*3 + j];\n        }\n    }\n} // Print the diagonalized matrix\nprint_pseudo_t3d(\"Diagonalized matrix: (R^T * A * R)\", &diagonalized);",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: for (int i...",
    "content": "for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        if (i == j) {\n            long double relative_error = fabsl(((long double*)&diagonalized)[i*3 + j] - ((long double*)Lambda)[i]) / \n                                         (fabsl(((long double*)Lambda)[i]) + EPSILON);\n            if (relative_error > RELATIVE_TOLERANCE) {\n                printf(\"Diagonal element (%d,%d) does not match eigenvalue. %Lf != %Lf (relative error: %Lf)\\n\", \n                       i, j, ((long double*)&diagonalized)[i*3 + j], ((long double*)Lambda)[i], relative_error);\n            }\n        } else {\n            if (fabsl(((long double*)&diagonalized)[i*3 + j]) > EPSILON) {\n                printf(\"Off-diagonal element (%d,%d) is not zero.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: Value = %Lf\\n\",...",
    "content": "Value = %Lf\\n\", \n                       i, j, ((long double*)&diagonalized)[i*3 + j]);\n            }\n        }\n    }\n}\nreturn 1;",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: // Compute A...",
    "content": "// Compute A * v\n    for (int j = 0; j < 3; j++) {\n        ((double*)&Av)[j] = ((double*)A)[j*3] * ((double*)R)[i] + \n                            ((double*)A)[j*3+1] * ((double*)R)[i+3] + \n                            ((double*)A)[j*3+2] * ((double*)R)[i+6];\n    } // Compute \u03bb * v\n    for (int j = 0; j < 3; j++) {\n        ((double*)&lambda_v)[j] = ((double*)Lambda)[i] * ((double*)R)[i+j*3];\n    }",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: printf(\"Eigenpair %d:\\n\", i...",
    "content": "printf(\"Eigenpair %d:\\n\", i + 1);\n    printf(\"A * v = %8.4Lf %8.4Lf %8.4Lf\\n\", Av.x, Av.y, Av.z);\n    printf(\"\u03bb * v = %8.4Lf %8.4Lf %8.4Lf\\n\", lambda_v.x, lambda_v.y, lambda_v.z);",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: // Check if...",
    "content": "// Check if A * v \u2248 \u03bb * v\n    for (int j = 0; j < 3; j++) {\n        if (fabs(((double*)&Av)[j] - ((double*)&lambda_v)[j]) > EPSILON) {\n            printf(\"Mismatch for eigenpair %d, component %d\\n\", i + 1, j + 1);\n        }\n    }\n    printf(\"Verification A * v = \u03bb * v for each eigenpair done. See the messages above!\\n\\n\");\n}\nreturn 1;",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example",
    "content": "if (!verify_diagonalization(A, R, Lambda)) {\n    printf(\"Matrix is not properly diagonalized.\\n\");\n} else {\n    printf(\"Matrix is properly diagonalized.\\n\");\n}\n\nif (!verify_eigenpairs(A, R, Lambda)) {\n    printf(\"Eigenpair verification failed.\\n\");\n} else {\n    printf(\"Eigenpair verification passed.\\n\");\n}\n\nprintf(\"Eigendecomposition verification completed. See the messages above!\\n\");\nreturn 1;",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: // Create diagonal...",
    "content": "// Create diagonal matrix from Lambda\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        ((long double*)&Lambda_diag)[i*3 + j] = (i == j) ? ((long double*)Lambda)[i] : 0.0L;\n    }\n}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: // Compute R...",
    "content": "// Compute R * Lambda\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        ((long double*)&temp)[i*3 + j] = 0;\n        for (int k = 0; k < 3; k++) {\n            ((long double*)&temp)[i*3 + j] += ((long double*)R)[i*3 + k] * ((long double*)&Lambda_diag)[k*3 + j];\n        }\n    }\n}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: // Compute (R...",
    "content": "// Compute (R * Lambda) * R^T\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        ((long double*)&A_reconstructed)[i*3 + j] = 0;\n        for (int k = 0; k < 3; k++) {\n            ((long double*)&A_reconstructed)[i*3 + j] += ((long double*)&temp)[i*3 + k] * ((long double*)R)[j*3 + k];\n        }\n    }\n} print_pseudo_t3d(\"Reconstructed A = R * Lambda * R^T\", &A_reconstructed);",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: // Compare original...",
    "content": "// Compare original A with reconstructed A\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        long double diff = fabsl(((long double*)A)[i*3 + j] - ((long double*)&A_reconstructed)[i*3 + j]);\n        if (diff > EPSILON) {\n            printf(\"Mismatch at (%d,%d): original = %Lf, reconstructed = %Lf, difference = %Lf\\n\",\n                   i, j, ((long double*)A)[i*3 + j], ((long double*)&A_reconstructed)[i*3 + j], diff);\n        }\n    }\n}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: printf(\"A = R...",
    "content": "printf(\"A = R * Lambda * R^T verification completed. See the messages above!\\n\");\nreturn 1;",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: // Initialize A...",
    "content": "// Initialize A with the given values /*\nthis is a diagonal not I matrix",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/testEigenDecomposition.c | MultiRheoFlow - Code Example: Context",
    "content": "// A.x.x = 1;  A.x.y = 0; A.x.z = 0;\n// A.y.x = 0; A.y.y = 2;  A.y.z = 0;\n// A.z.x = 0;  A.z.y = 0;  A.z.z = 3;\n/*\nthis is a identity matrix\n*/\n// A.x.x = 1;  A.x.y = 0; A.x.z = 0;\n// A.y.x = 0; A.y.y = 1;  A.y.z = 0;\n// A.z.x = 0;  A.z.y = 0;  A.z.z = 1;\n/*\nthis is a non-diagonal matrix\n*/\n// A.x.x = 1;  A.x.y = 2; A.x.z = 3;\n// A.y.x = 2; A.y.y = 4;  A.y.z = 5;\n// A.z.x = 3;  A.z.y = 5;  A.z.z = -6;\n/*\nthis is a small matrix\n*/  \n// A.x.x = 1e-6;  A.x.y = 0; A.x.z = 0;\n// A.y.x = 0; A.y.y = 1e-12;  A.y.z = 0;\n// A.z.x = 0;  A.z.y = 0;  A.z.z = 1e-10;\n/*\nthis is a large matrix\n*/\n// A.x.x = 100;  A.x.y = 100; A.x.z = 10;\n// A.y.x = 100; A.y.y = 10;  A.y.z = 1;\n// A.z.x = 10;  A.z.y = 1;  A.z.z = 0.1;\nif (argc != 7) {\n    A.x.x = 1;  A.x.y = 2; A.x.z = 3;\n    A.y.x = 2; A.y.y = 4;  A.y.z = 5;\n    A.z.x = 3;  A.z.y = 5;  A.z.z = -6;\n} else {\n    // get Aij from terminal \n    A.x.x = atof(argv[1]);  A.x.y = atof(argv[2]); A.x.z = atof(argv[3]);\n    A.y.x = atof(argv[2]); A.y.y = atof(argv[4]);  A.y.z = atof(argv[5]);\n    A.z.x = atof(argv[3]);  A.z.y = atof(argv[5]);  A.z.z = atof(argv[6]);\n}\nprint_pseudo_t3d(\"Original matrix A\", &A);\ndiagonalization_3D(&Lambda, &R, &A);\nprint_pseudo_t3d(\"Eigenvectors R\", &R);\nprint_pseudo_v3d(\"Eigenvalues Lambda\", &Lambda);\nverify_eigendecomposition(&A, &R, &Lambda);\n// lastly check if A = R * Lambda * R^T\nverify_reconstruction(&A, &R, &Lambda);\nreturn 0;",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/testEigenDecomposition.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases cleanup.sh rm -rf \\$1 dropAtomisation.c u.n[left] = dirichlet(1.); 46 // p[left] = dirichlet(0); 47 48 // outflow: right 49 u.n[right] = neumann(0.); 50 p[ri... dropImpact.c f[left] = dirichlet(0.0); 47 48 int MAXlevel; 49 // We -> Weber number of the drop 50 // Oh -> Solvent Ohnesorge numb... Makefile ifeq (\\$(wildcard ../.projectconfig),) \\$(error '../.projectconfig not found') endif BASILISK := \\$(shell . ../.proje... pinchOff.c u.n[top] = neumann(0.0); 45 p[top] = dirichlet(0.0); 46 47 int MAXlevel; 48 // Oh -> Solvent Ohnesorge number 49 // O... runCases.sh ORIGDIR=\\$(pwd) mkdir -p \\$1 cp \\$1.c \\$1/ cd \\$1 qcc -I\\${ORIGDIR}/src-local -I\\${ORIGDIR}/../src-local -O2 -Wall -d... testEigenDecomposition.c typedef struct { long double x, y, z; } pseudov3d; typedef struct { pseudov3d x, y, z; } pseudot3d; static void diago...",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/cleanup.sh | MultiRheoFlow",
    "content": "simulationCases/cleanup.sh See raw file cleanup.sh #!/bin/bash rm -rf \\$ 1",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/cleanup.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | MultiRheoFlow: Context",
    "content": "simulationCases/pinchOff.c See raw file @file pinchOff.c @brief This file contains the simulation code for the pinch-off of a viscoelastic liquid jet. @author Vatsal Sanjay @version 0.2 @date Oct 18, 2024 #include \"axi.h\" // #include \"grid/octree.h\" // #include \"grid/quadtree.h\" #include \"navier-stokes/centered.h\" #define VANILLA 1 14 #if VANILLA #include \"../src-local/log-conform-viscoelastic.h\" #define logFile \"logAxi-vanilla.dat\" 17 #else #if AXI #include \"../src-local/log-conform-viscoelastic-scalar-2D.h\" #define logFile \"logAxi-scalar.dat\" 21 #else #include \"../src-local/log-conform-viscoelastic-scalar-3D.h\" #define logFile \"log3D-scalar.dat\" 24 #endif #endif #define FILTERED // Smear density and viscosity jumps #include \"../src-local/two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #define tsnap ( 1e-2 ) 34 // Error tolerancs #define fErr ( 1e-3 ) // error tolerance in f1 VOF #define KErr ( 1e-6 ) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr ( 1e-2 ) // error tolerances in velocity -- Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define epsilon ( 0.5 ) 41 #define R2 ( x , y , z , e ) ( sqrt ( sq ( y ) + sq ( z )) + ( e * sin ( x / 4. ))) 42 // boundary conditions u . n [ top ] = neumann ( 0.0 ); p [ top ] = dirichlet ( 0.0 ); int MAXlevel ; // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // De -> Deborah number // Ec -> Elasto-capillary number // for now there is no viscoelasticity double Oh , Oha , De , Ec , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; int main ( int argc , char const * argv []) { L0 = 2 * pi ; // Values taken from the terminal MAXlevel = 6 ; tmax = 10 ; Oh = 1e-2 ; Oha = 1e-2 * Oh ; De = 1.0 ; // 1e-1; Ec = 1.0 ; // 1e-2; init_grid ( 1 << 4 ); // Create a folder named intermediate where all the simulation snapshots are stored. char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | MultiRheoFlow: Context",
    "content": "See writingFiles event. sprintf ( dumpFile , \"restart\" ); rho1 = 1. , rho2 = 1e-3 ; mu1 = Oh , mu2 = Oha ; lambda1 = De , lambda2 = 0. ; G1 = Ec , G2 = 0. ; f . sigma = 1.0 ; run (); } event init ( t = 0 ) { if (! restore ( file = dumpFile )){ refine ( R2 ( x , y , z , epsilon ) < ( 1 + epsilon ) && R2 ( x , y , z , epsilon ) > ( 1 - epsilon ) && level < MAXlevel ); fraction ( f , ( 1 - R2 ( x , y , z , epsilon ))); } } Adaptive Mesh Refinement event adapt ( i ++){ scalar KAPPA []; curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , u . x , u . y , KAPPA }, ( double []){ fErr , VelErr , VelErr , KErr }, MAXlevel , 4 ); } Dumping snapshots event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Ending Simulation event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , Oh %2.1e\\n \" , MAXlevel , Oh ); } Log writing event logWriting ( i ++) { double ke = 0. ; foreach ( reduction (+: ke )){ ke += ( 2 * pi * y )*( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y [])+ sq ( u . z [])))* sq ( Delta ); } static FILE * fp ; if ( pid () == 0 ) { const char * mode = ( i == 0 ) ? \"w\" : \"a\" ; fp = fopen ( logFile , mode ); if ( fp == NULL ) { fprintf ( ferr , \"Error opening log file \\n \" ); return 1 ; } scalar pos []; position ( f , pos , { 0 , 1 , 0 }); double ymin = statsf ( pos ). min ; if ( i == 0 ) { fprintf ( ferr , \"Level %d , Oh %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , Oha , De , Ec ); fprintf ( ferr , \"i dt t ke ymin \\n \" ); fprintf ( fp , \"Level %d , Oh %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , Oha , De , Ec ); fprintf ( fp , \"i dt t ke ymin \\n \" ); } fprintf ( fp , \" %d %g %g %g %g\\n \" , i , dt , t , ke , ymin ); fprintf ( ferr , \" %d %g %g %g %g\\n \" , i , dt , t , ke , ymin ); fflush ( fp ); fclose ( fp ); } assert ( ke > - 1e-10 ); if ( i > 1e1 && pid () == 0 ) { if ( ke > 1e2 || ke < 1e-8 ) { const char * message = ( ke > 1e2 ) ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | MultiRheoFlow: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" : \"kinetic energy too small now! Stopping! \\n \" ; fprintf ( ferr , \" %s \" , message ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %s \" , message ); fflush ( fp ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } }",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/pinchOff.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | MultiRheoFlow - C/C++ Code: C/C++ Code",
    "content": "#include\"axi.h\"// #include \"grid/octree.h\"// #include \"grid/quadtree.h\"#include\"navier-stokes/centered.h\"#define VANILLA114#if VANILLA#include\"../src-local/log-conform-viscoelastic.h\"#define logFile\"logAxi-vanilla.dat\"17#else#if AXI#include\"../src-local/log-conform-viscoelastic-scalar-2D.h\"#define logFile\"logAxi-scalar.dat\"21#else#include\"../src-local/log-conform-viscoelastic-scalar-3D.h\"#define logFile\"log3D-scalar.dat\"24#endif#endif#define FILTERED// Smear density and viscosity jumps#include\"../src-local/two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#define tsnap(1e-2)34// Error tolerancs#define fErr(1e-3)// error tolerance in f1 VOF#define KErr(1e-6)// error tolerance in VoF curvature calculated using heigh function method (see adapt event)#define VelErr(1e-2)// error tolerances in velocity -- Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J#define epsilon(0.5)41#define R2(x,y,z,e)(sqrt(sq(y)+sq(z))+(e*sin(x/4.)))42// boundary conditionsu.n[top]=neumann(0.0);p[top]=dirichlet(0.0);intMAXlevel;// Oh -> Solvent Ohnesorge number// Oha -> air Ohnesorge number// De -> Deborah number// Ec -> Elasto-capillary number// for now there is no viscoelasticitydoubleOh,Oha,De,Ec,tmax;charnameOut[80],dumpFile[80];intmain(intargc,charconst*argv[]){L0=2*pi;// Values taken from the terminalMAXlevel=6;tmax=10;Oh=1e-2;Oha=1e-2*Oh;De=1.0;// 1e-1;Ec=1.0;// 1e-2;init_grid(1<<4);// Create a folder named intermediate where all the simulation snapshots are stored.charcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | MultiRheoFlow - C/C++ Code: Context",
    "content": "See writingFiles event.sprintf(dumpFile,\"restart\");rho1=1.,rho2=1e-3;mu1=Oh,mu2=Oha;lambda1=De,lambda2=0.;G1=Ec,G2=0.;f.sigma=1.0;run();}event init(t=0){if(!restore(file=dumpFile)){refine(R2(x,y,z,epsilon)<(1+epsilon)&&R2(x,y,z,epsilon)>(1-epsilon)&&level<MAXlevel);fraction(f,(1-R2(x,y,z,epsilon)));}}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | MultiRheoFlow - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);adapt_wavelet((scalar*){f,u.x,u.y,KAPPA},(double[]){fErr,VelErr,VelErr,KErr},MAXlevel,4);}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | MultiRheoFlow - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | MultiRheoFlow - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, Oh%2.1e\\n\",MAXlevel,Oh);}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | MultiRheoFlow - Code Example: Context",
    "content": "event logWriting(i++){doubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])+sq(u.z[])))*sq(Delta);}staticFILE*fp;if(pid()==0){constchar*mode=(i==0)?\"w\":\"a\";fp=fopen(logFile,mode);if(fp==NULL){fprintf(ferr,\"Error opening log file\\n\");return1;}scalar pos[];position(f,pos,{0,1,0});doubleymin=statsf(pos).min;if(i==0){fprintf(ferr,\"Level%d, Oh%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,Oha,De,Ec);fprintf(ferr,\"i dt t ke ymin\\n\");fprintf(fp,\"Level%d, Oh%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,Oha,De,Ec);fprintf(fp,\"i dt t ke ymin\\n\");}fprintf(fp,\"%d%g%g%g%g\\n\",i,dt,t,ke,ymin);fprintf(ferr,\"%d%g%g%g%g\\n\",i,dt,t,ke,ymin);fflush(fp);fclose(fp);}assert(ke>-1e-10);if(i>1e1&&pid()==0){if(ke>1e2||ke<1e-8){constchar*message=(ke>1e2)?\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/pinchOff.c | MultiRheoFlow - Code Example: Stopping simulation\\n\":\"kinetic energy...",
    "content": "Stopping simulation\\n\":\"kinetic energy too small now! Stopping!\\n\";fprintf(ferr,\"%s\",message);fp=fopen(\"log\",\"a\");fprintf(fp,\"%s\",message);fflush(fp);fclose(fp);dump(file=dumpFile);return1;}}}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/pinchOff.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/runCases.sh | MultiRheoFlow",
    "content": "simulationCases/runCases.sh See raw file runCases.sh #!/bin/bash # Save the original directory ORIG_DIR = \\$ ( pwd ) mkdir -p \\$ 1 cp \\$ 1.c \\$ 1/ cd \\$ 1 qcc -I\\${ORIG_DIR} /src-local -I\\${ORIG_DIR} /../src-local -O2 -Wall -disable-dimensions \\$ 1.c -o \\$ 1 -lm ./\\$1",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/runCases.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCases.sh | MultiRheoFlow - Code Example",
    "content": "#!/bin/bash# Save the original directoryORIG_DIR=\\$(pwd)mkdir-p\\$1cp\\$1.c\\$1/cd\\$1qcc-I\\${ORIG_DIR}/src-local-I\\${ORIG_DIR}/../src-local-O2-Wall-disable-dimensions\\$1.c-o\\$1-lm./\\$1",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/runCases.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | MultiRheoFlow",
    "content": "simulationCases/Makefile See raw file Makefile # Check if .project_config exists ifeq ( \\$ ( wildcard ../.project_config ) , ) \\$ ( error \"../.project_config not found\" ) endif BASILISK := \\$ ( shell . ../.project_config && echo \\$\\$ BASILISK ) CFLAGS += -O2 -disable-dimensions CFLAGS += -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local # Fix permissions for runtest script fix-permissions: @chmod +x \\$ ( BASILISK ) /src/runtest # Make all test targets depend on fix-permissions %.tst: fix-permissions include \\$ ( BASILISK ) /Makefile.defs",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/Makefile.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | MultiRheoFlow - Code Example",
    "content": "# Check if .project_config existsifeq(\\$(wildcard../.project_config),)\\$(error\"../.project_config not found\")endifBASILISK:=\\$(shell. ../.project_config&&echo\\$\\$BASILISK)CFLAGS+=-O2-disable-dimensionsCFLAGS+=-I\\$(PWD)/src-local-I\\$(PWD)/../src-local# Fix permissions for runtest scriptfix-permissions:@chmod+x\\$(BASILISK)/src/runtest# Make all test targets depend on fix-permissions%.tst:fix-permissionsinclude\\$(BASILISK)/Makefile.defs",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/Makefile.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow: Context",
    "content": "simulationCases/dropAtomisation.c See raw file @file dropAtomisation.c @brief This file contains the simulation code for the drop atomisation. @author Ayush Dixit & Vatsal Sanjay @version 5.0 @date Oct 20, 2024 // #include \"axi.h\" #include \"grid/octree.h\" // #include \"grid/quadtree.h\" #include \"navier-stokes/centered.h\" #define VANILLA 0 // vanilla cannot do 3D #if VANILLA #include \"../src-local/log-conform-viscoelastic.h\" #define logFile \"logAxi-vanilla.dat\" 17 #else #if AXI #include \"../src-local/log-conform-viscoelastic-scalar-2D.h\" #define logFile \"logAxi-scalar.dat\" 21 #else #include \"../src-local/log-conform-viscoelastic-scalar-3D.h\" #define logFile \"log3D-scalar.dat\" 24 #endif #endif #define FILTERED // Smear density and viscosity jumps #include \"../src-local/two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #define tsnap ( 0.1 ) // 0.001 only for some cases. // Error tolerancs #define fErr ( 1e-2 ) // error tolerance in f1 VOF #define KErr ( 1e-4 ) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr ( 1e-2 ) // error tolerances in velocity -- Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define AErr ( 1e-3 ) // error tolerances in conformation inside the liquid #define R2 ( x , y , z ) ( sq ( x - 3. ) + sq ( y ) + sq ( z )) 42 // boundary conditions // inflow: left u . n [ left ] = dirichlet ( 1. ); // p[left] = dirichlet(0); // outflow: right u . n [ right ] = neumann ( 0. ); p [ right ] = dirichlet ( 0 ); int MAXlevel ; // We -> Weber number // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // De -> Deborah number // Ec -> Elasto-capillary number double Oh , Oha , De , We , RhoInOut , Ec , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; int main ( int argc , char const * argv []) { // dtmax = 1e-5; // BEWARE of this for stability issues.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow: L0 = 20...",
    "content": "L0 = 20 ; init_grid ( 1 << 6 ); origin ( 0 , - L0 / #if dimension == , - L0 / #endif ); // Values taken from the terminal MAXlevel = 7 ; RhoInOut = 830. ; // elastic parts De = 0.0 ; Ec = 0.0 ; // Newtonian parts We = 15000 ; // based on the density of the gas Oh = 3e-3 ; // based on the density of the liquid Oha = 0.018 * Oh ; // based on the density of the liquid tmax = 200 ; // Create a folder named intermediate where all the simulation snapshots are stored. char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow: Context",
    "content": "See writingFiles event. sprintf ( dumpFile , \"restart\" ); rho1 = RhoInOut , rho2 = 1e0 ; // as both densities are based on the density of the liquid, we must multiply the Ohnesorge number by the square root of the density ratio mu1 = sqrt ( RhoInOut )* Oh / sqrt ( We ), mu2 = sqrt ( RhoInOut )* Oha / sqrt ( We ); // elastic parts // in G1, we need to mutiply by the density ratio (again, because Ec is based on the density of the liquid but in the code it is based on the density of the gas) G1 = Ec / We , G2 = 0.0 ; // Here, lambda is essentially the Weissenberg number, so there is no density in the expression. lambda1 = De * sqrt ( We ), lambda2 = 0.0 ; // surface tension -- the Weber number is based on the density of the gas!",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow: Context",
    "content": "So, all good. f . sigma = 1.0 / We ; run (); } event init ( t = 0 ) { if (! restore ( file = dumpFile )){ refine ( R2 ( x , y , z ) < 1.1 && R2 ( x , y , z ) > 0.9 && level < MAXlevel ); fraction ( f , 1. - R2 ( x , y , z )); } } Adaptive Mesh Refinement event adapt ( i ++){ scalar KAPPA []; curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , KAPPA , u . x , u . y #if dimension == , u . z #endif },( double []){ fErr , KErr , VelErr , VelErr , #if dimension == VelErr #endif }, MAXlevel , 4 ); } Dumping snapshots event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Ending Simulation event end ( t = end ) { if ( pid () == 0 ) fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); } Log writing event logWriting ( i ++) { double ke = 0. ; foreach ( reduction (+: ke )){ ke += ( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y []) #if dimension == + sq ( u . z []) #endif ))* pow ( Delta , dimension ); } static FILE * fp ; if ( pid () == 0 ) { const char * mode = ( i == 0 ) ? \"w\" : \"a\" ; fp = fopen ( logFile , mode ); if ( fp == NULL ) { fprintf ( ferr , \"Error opening log file \\n \" ); return 1 ; } if ( i == 0 ) { fprintf ( ferr , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( ferr , \"i dt t ke \\n \" ); fprintf ( fp , \"Level %d , Oh %2.1e , We %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Oh , We , Oha , De , Ec ); fprintf ( fp , \"i dt t ke rM \\n \" ); } fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); fflush ( fp ); fclose ( fp ); } assert ( ke > - 1e-10 ); if ( i > 1e1 && pid () == 0 ) { if ( ke > 1e6 || ke < 1e-6 ) { const char * message = ( ke > 1e6 ) ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" : \"kinetic energy too small now! Stopping! \\n \" ; fprintf ( ferr , \" %s \" , message ); fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %s \" , message ); fflush ( fp ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } }",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow - C/C++ Code: C/C++ Code",
    "content": "// #include \"axi.h\"#include\"grid/octree.h\"// #include \"grid/quadtree.h\"#include\"navier-stokes/centered.h\"#define VANILLA0// vanilla cannot do 3D#if VANILLA#include\"../src-local/log-conform-viscoelastic.h\"#define logFile\"logAxi-vanilla.dat\"17#else#if AXI#include\"../src-local/log-conform-viscoelastic-scalar-2D.h\"#define logFile\"logAxi-scalar.dat\"21#else#include\"../src-local/log-conform-viscoelastic-scalar-3D.h\"#define logFile\"log3D-scalar.dat\"24#endif#endif#define FILTERED// Smear density and viscosity jumps#include\"../src-local/two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#define tsnap(0.1)// 0.001 only for some cases.// Error tolerancs#define fErr(1e-2)// error tolerance in f1 VOF#define KErr(1e-4)// error tolerance in VoF curvature calculated using heigh function method (see adapt event)#define VelErr(1e-2)// error tolerances in velocity -- Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J#define AErr(1e-3)// error tolerances in conformation inside the liquid#define R2(x,y,z)(sq(x-3.)+sq(y)+sq(z))42// boundary conditions// inflow: leftu.n[left]=dirichlet(1.);// p[left] = dirichlet(0);// outflow: rightu.n[right]=neumann(0.);p[right]=dirichlet(0);intMAXlevel;// We -> Weber number// Oh -> Solvent Ohnesorge number// Oha -> air Ohnesorge number// De -> Deborah number// Ec -> Elasto-capillary numberdoubleOh,Oha,De,We,RhoInOut,Ec,tmax;charnameOut[80],dumpFile[80];intmain(intargc,charconst*argv[]){// dtmax = 1e-5; //  BEWARE of this for stability issues.L0=20;init_grid(1<<6);origin(0,-L0/#if dimension ==,-L0/#endif);// Values taken from the terminalMAXlevel=7;RhoInOut=830.;// elastic partsDe=0.0;Ec=0.0;// Newtonian partsWe=15000;// based on the density of the gasOh=3e-3;// based on the density of the liquidOha=0.018*Oh;// based on the density of the liquidtmax=200;// Create a folder named intermediate where all the simulation snapshots are stored.charcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow - C/C++ Code: Context",
    "content": "See writingFiles event.sprintf(dumpFile,\"restart\");rho1=RhoInOut,rho2=1e0;// as both densities are based on the density of the liquid, we must multiply the Ohnesorge number by the square root of the density ratiomu1=sqrt(RhoInOut)*Oh/sqrt(We),mu2=sqrt(RhoInOut)*Oha/sqrt(We);// elastic parts// in G1, we need to mutiply by the density ratio (again, because Ec is based on the density of the liquid but in the code it is based on the density of the gas)G1=Ec/We,G2=0.0;// Here, lambda is essentially the Weissenberg number, so there is no density in the expression.lambda1=De*sqrt(We),lambda2=0.0;// surface tension -- the Weber number is based on the density of the gas!",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow - C/C++ Code: Context",
    "content": "So, all good.f.sigma=1.0/We;run();}event init(t=0){if(!restore(file=dumpFile)){refine(R2(x,y,z)<1.1&&R2(x,y,z)>0.9&&level<MAXlevel);fraction(f,1.-R2(x,y,z));}}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);adapt_wavelet((scalar*){f,KAPPA,u.x,u.y#if dimension ==,u.z#endif},(double[]){fErr,KErr,VelErr,VelErr,#if dimension ==VelErr#endif},MAXlevel,4);}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow - Code Example",
    "content": "event end(t=end){if(pid()==0)fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow - Code Example: Context",
    "content": "event logWriting(i++){doubleke=0.;foreach(reduction(+:ke)){ke+=(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])#if dimension ==+sq(u.z[])#endif))*pow(Delta,dimension);}staticFILE*fp;if(pid()==0){constchar*mode=(i==0)?\"w\":\"a\";fp=fopen(logFile,mode);if(fp==NULL){fprintf(ferr,\"Error opening log file\\n\");return1;}if(i==0){fprintf(ferr,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(ferr,\"i dt t ke\\n\");fprintf(fp,\"Level%d, Oh%2.1e, We%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Oh,We,Oha,De,Ec);fprintf(fp,\"i dt t ke rM\\n\");}fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);fflush(fp);fclose(fp);}assert(ke>-1e-10);if(i>1e1&&pid()==0){if(ke>1e6||ke<1e-6){constchar*message=(ke>1e6)?\"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/dropAtomisation.c | MultiRheoFlow - Code Example: Stopping simulation\\n\":\"kinetic energy...",
    "content": "Stopping simulation\\n\":\"kinetic energy too small now! Stopping!\\n\";fprintf(ferr,\"%s\",message);fp=fopen(\"log\",\"a\");fprintf(fp,\"%s\",message);fflush(fp);fclose(fp);dump(file=dumpFile);return1;}}}",
    "url": "https://comphy-lab.org/MultiRheoFlow/simulationCases/dropAtomisation.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData-elastic-scalar2D.c This program extracts fluid dynamic properties from simulation snapshots, specifically designed for analyzing deforma... getFacet2D.c This program extracts and outputs facets from a Basilisk simulation file, primarily used for interface reconstruction... VideoAxi.py Basilisk C Simulation Data Post-Processor and Visualizer This script processes time-series data from Basilisk C multi...",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Context",
    "content": "postProcess/VideoAxi.py See raw file #!/usr/bin/env python3 # -*- coding: utf-8 -*- Basilisk C Simulation Data Post-Processor and Visualizer This script processes time-series data from Basilisk C multiphase flow simulations, generating high-quality visualizations of interfacial dynamics and flow fields. It creates contour plots showing strain rate tensor magnitude (D2), velocity fields, and viscoelastic stress traces for bubble/drop dynamics studies. The script supports parallel processing for efficient handling of large time-series datasets and produces publication-quality figures with proper LaTeX formatting.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Context",
    "content": "Usage: python viz_simulation.py [\u2013CPUs 8] [\u2013nGFS 550] [\u2013ZMAX 4.0] [\u2013RMAX 2.0] [\u2013ZMIN -4.0] Dependencies: - numpy: Numerical array operations - matplotlib: Plotting and visualization - subprocess: External executable communication - multiprocessing: Parallel processing support - argparse: Command-line argument parsing External Dependencies: - ./getFacet2D: Basilisk executable for interface extraction - ./getData-elastic-scalar2D: Basilisk executable for field data extraction Author: Vatsal Sanjay Contact: vatsalsanjay@gmail.com Affiliation: Physics of Fluids Group Last updated: Jul 24, 2024 import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import multiprocessing as mp from functools import partial import argparse import matplotlib.colors as mcolors # =============================== # Configuration and Settings # =============================== # Custom colormap for viscoelastic stress visualization custom_colors = [ \"white\" , \"#DA8A67\" , \"#A0522D\" , \"#400000\" ] CUSTOM_CMAP = mcolors.LinearSegmentedColormap.from_list( \"custom_hot\" , custom_colors) # Global matplotlib settings for publication-quality output matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' # Default visualization parameters DEFAULT_CONFIG = { 'grids_per_r' : 128 , # Grid resolution factor 'line_width' : 2 , # Interface line width 'axes_label_size' : 50 , # Font size for axis labels 'tick_label_size' : 20 , # Font size for tick labels 'interface_line_width' : 4 , # Line width for interface boundaries 'strain_vmax' : 2.0 , # Maximum strain rate for colorbar 'strain_vmin' : - 3.0 , # Minimum strain rate for colorbar 'stress_vmax' : 2.0 , # Maximum stress trace for colorbar 'stress_vmin' : - 3.0 , # Minimum stress trace for colorbar } # =============================== # Interface Extraction Functions # =============================== def gettingFacets(filename, includeCoat = 'true' ): Extract interface facets from Basilisk simulation data.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Function Definition",
    "content": "This function communicates with the Basilisk getFacet2D executable to extract interface polygons from simulation snapshots. It handles both axisymmetric coordinates (r,z) and creates symmetric segments for visualization. Args: filename (str): Path to the Basilisk snapshot file includeCoat (str): Whether to include coating layer in extraction. Accepts \u2018true\u2019 or \u2018false\u2019. Defaults to \u2018true\u2019. Returns: list: List of line segments [(start_point, end_point)] for visualization. Each segment is a tuple ((r1, z1), (r2, z2)) representing interface boundaries. Raises: subprocess.CalledProcessError: If the getFacet2D executable fails FileNotFoundError: If the specified snapshot file doesn\u2019t exist Note: The function assumes axisymmetric geometry and creates symmetric segments by mirroring across r=0.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: This is typical...",
    "content": "This is typical for bubble/drop simulations. exe = [ \"./getFacet2D\" , filename, includeCoat] try : p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() except FileNotFoundError : raise FileNotFoundError ( f\"getFacet2D executable not found.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Ensure it's compiled...",
    "content": "Ensure it's compiled and in the current directory.\" ) temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False # Process interface data - skip empty lines and extract coordinate pairs if len (temp2) > 1e2 : # Ensure we have sufficient data points for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: # Extract paired coordinate points temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) # Add symmetric segments for axisymmetric visualization segs.append(((r1, z1), (r2, z2))) segs.append((( - r1, z1), ( - r2, z2))) skip = True return segs def gettingfield(filename, zmin, zmax, rmax, nr): Extract field data from Basilisk simulation snapshots.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Communicates with the...",
    "content": "Communicates with the getData-elastic-scalar2D executable to extract flow field variables including strain rate, velocity, and stress tensors on a uniform grid for visualization.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Args: filename (str):...",
    "content": "Args: filename (str): Path to the Basilisk snapshot file zmin (float): Minimum z-coordinate for data extraction zmax (float): Maximum z-coordinate for data extraction rmax (float): Maximum r-coordinate for data extraction nr (int): Number of grid points in radial direction Returns: tuple: (R, Z, D2, vel, taup, nz) where: - R (numpy.ndarray): Radial coordinate mesh (nz x nr) - Z (numpy.ndarray): Axial coordinate mesh (nz x nr) - D2 (numpy.ndarray): Strain rate tensor magnitude (nz x nr) - vel (numpy.ndarray): Velocity magnitude (nz x nr) - taup (numpy.ndarray): Stress tensor trace (nz x nr) - nz (int): Number of grid points in axial direction Raises: subprocess.CalledProcessError: If the getData-elastic-scalar2D executable fails ValueError: If the extracted data dimensions are inconsistent Note: The function automatically determines nz based on the total data points and the specified nr.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: All returned arrays...",
    "content": "All returned arrays are reshaped to 2D meshgrids. exe = [ \"./getData-elastic-scalar2D\" , filename, str (zmin), str ( 0 ), str (zmax), str (rmax), str (nr)] try : p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() except FileNotFoundError : raise FileNotFoundError ( f\"getData-elastic-scalar2D executable not found.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Ensure it's compiled...",
    "content": "Ensure it's compiled and in the current directory.\" ) temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # Initialize temporary lists for field data Rtemp, Ztemp, D2temp, veltemp, taupTemp = [], [], [], [], [] # Parse field data from executable output for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) D2temp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) taupTemp.append( float (temp3[ 4 ])) # Convert to numpy arrays and reshape to 2D mesh R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) taup = np.asarray(taupTemp) # Calculate number of axial grid points nz = int ( len (Z) / nr) print ( f\"Grid dimensions: nr= { nr } , nz= { nz } \" ) # Reshape arrays to 2D mesh format R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) taup.resize((nz, nr)) return R, Z, D2, vel, taup, nz # =============================== # Visualization Functions # =============================== def process_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw): Process and visualize a single simulation timestep.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Results - Function Definition",
    "content": "This function handles the complete visualization pipeline for one timestep: extracting interface data, field data, creating dual-sided contour plots with colorbars, and saving the result as a high-resolution image.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Args: ti (int):...",
    "content": "Args: ti (int): Timestep index (will be converted to simulation time) folder (str): Output directory for saved images nGFS (int): Total number of simulation files (used for validation) GridsPerR (int): Grid resolution parameter (grids per unit radius) rmin (float): Minimum radial coordinate for plotting rmax (float): Maximum radial coordinate for plotting zmin (float): Minimum axial coordinate for plotting zmax (float): Maximum axial coordinate for plotting lw (float): Line width for boundary boxes Returns: None: Function saves visualization directly to file Note: - Creates symmetric visualization about r=0 axis - Uses logarithmic scaling for strain rate and stress data - Implements custom colormap for viscoelastic stress fields - Handles missing files gracefully with informative error messages # Convert timestep index to simulation time t = 0.01 * ti place = f\"intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" # Check if input file exists if not os.path.exists(place): print ( f\" { place } File not found!\" ) return # Skip if output already exists if os.path.exists(name): print ( f\" { name } Image present!\" ) return # Extract interface data with and without coating segs1 = gettingFacets(place) # With coating segs2 = gettingFacets(place, 'false' ) # Without coating # Validate interface data if not segs1 and not segs2: print ( f\"Problem in the available file { place } \" ) return # Extract field data on uniform grid nr = int (GridsPerR * rmax) R, Z, taus, vel, taup, nz = gettingfield(place, zmin, zmax, rmax, nr) zminp, zmaxp, rminp, rmaxp = Z. min (), Z. max (), R. min (), R. max () # =============================== # Create Visualization # =============================== AxesLabel, TickLabel = DEFAULT_CONFIG[ 'axes_label_size' ], DEFAULT_CONFIG[ 'tick_label_size' ] fig, ax = plt.subplots() fig.set_size_inches( 19.20 , 10.80 ) # High-resolution output # Draw boundary box and symmetry axis ax.plot([ 0 , 0 ], [zmin, zmax], '-.' , color = 'grey' , linewidth = lw) # Symmetry axis ax.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Add interface lines line_segments = LineCollection(segs2, linewidths = DEFAULT_CONFIG[ 'interface_line_width' ], colors = 'green' , linestyle = 'solid' ) ax.add_collection(line_segments) line_segments = LineCollection(segs1, linewidths = DEFAULT_CONFIG[ 'interface_line_width' ], colors = 'blue' , linestyle = 'solid' ) ax.add_collection(line_segments) # Create strain rate contour plot (left side, mirrored) cntrl1 = ax.imshow(taus, cmap = \"hot_r\" , interpolation = 'Bilinear' , origin = 'lower' , extent = [ - rminp, - rmaxp, zminp, zmaxp], vmax = DEFAULT_CONFIG[ 'strain_vmax' ], vmin = DEFAULT_CONFIG[ 'strain_vmin' ]) # Create stress trace contour plot (right side) cntrl2 = ax.imshow(taup, interpolation = 'Bilinear' , cmap = CUSTOM_CMAP, origin = 'lower' , extent = [rminp, rmaxp, zminp, zmaxp], vmax = DEFAULT_CONFIG[ 'stress_vmax' ], vmin = DEFAULT_CONFIG[ 'stress_vmin' ]) # Set plot properties ax.set_aspect( 'equal' ) ax.set_xlim(rmin, rmax) ax.set_ylim(zmin, zmax) ax.set_title( f'$t/ \\\\ tau_ \\\\ gamma$ = { t :4.3f} ' , fontsize = TickLabel) # Add colorbars l, b, w, h = ax.get_position().bounds # Left colorbar for strain rate cb1 = fig.add_axes([l - 0.04 , b, 0.03 , h]) c1 = plt.colorbar(cntrl1, cax = cb1, orientation = 'vertical' ) c1.set_label( r' $ \\ log_ {10} \\ left ( \\| \\m athcal{D} \\|\\r ight ) $ ' , fontsize = TickLabel, labelpad = 5 ) c1.ax.tick_params(labelsize = TickLabel) c1.ax.yaxis.set_ticks_position( 'left' ) c1.ax.yaxis.set_label_position( 'left' ) c1.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.1f} ' )) # Right colorbar for stress trace cb2 = fig.add_axes([l + w + 0.01 , b, 0.03 , h]) c2 = plt.colorbar(cntrl2, cax = cb2, orientation = 'vertical' ) c2.ax.tick_params(labelsize = TickLabel) c2.set_label( r' $ \\ log_ {10} \\ left ( \\t ext{tr} \\ left ( \\m athcal{A} \\r ight ) -1 \\r ight ) $ ' , fontsize = TickLabel) c2.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.2f} ' )) ax.axis( 'off' ) # Remove axis ticks and labels for cleaner look # Save high-quality output plt.savefig(name, bbox_inches = \"tight\" , dpi = 300 ) plt.close() # Free memory # =============================== # Main Execution Function # =============================== def main(): Main function that orchestrates the parallel processing of simulation data.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Sets up command-line...",
    "content": "Sets up command-line argument parsing, configures multiprocessing pool, and coordinates the visualization of multiple timesteps in parallel. Uses all available CPU cores by default for optimal performance. Command-line Arguments: \u2013CPUs (int): Number of CPU cores to use (default: all available) \u2013nGFS (int): Number of simulation timesteps to process (default: 550) \u2013ZMAX (float): Maximum axial coordinate (default: 4.0) \u2013RMAX (float): Maximum radial coordinate (default: 2.0) \u2013ZMIN (float): Minimum axial coordinate (default: -4.0) Returns: None: Creates output directory and processes all timesteps Example: # Process 1000 timesteps using 16 CPU cores python viz_simulation.py \u2013CPUs 16 \u2013nGFS 1000 \u2013ZMAX 5.0 Note: The output directory \u2018Video\u2019 is created automatically if it doesn\u2019t exist.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Each timestep is...",
    "content": "Each timestep is processed independently, allowing for efficient parallel execution. # Set up command-line argument parsing parser = argparse.ArgumentParser(description = \"Process Basilisk simulation data for visualization\" ) parser.add_argument( '--CPUs' , type = int , default = mp.cpu_count(), help = 'Number of CPUs to use (default: all available)' ) parser.add_argument( '--nGFS' , type = int , default = 550 , help = 'Number of restart files to process (default: 550)' ) parser.add_argument( '--ZMAX' , type = float , default = 4.0 , help = 'Maximum Z value (default: 4.0)' ) parser.add_argument( '--RMAX' , type = float , default = 2.0 , help = 'Maximum R value (default: 2.0)' ) parser.add_argument( '--ZMIN' , type = float , default =- 4.0 , help = 'Minimum Z value (default: -4.0)' ) args = parser.parse_args() # Extract parameters CPUStoUse = args.CPUs nGFS = args.nGFS ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN # Set processing parameters num_processes = CPUStoUse rmin, rmax, zmin, zmax = [ - RMAX, RMAX, ZMIN, ZMAX] GridsPerR = DEFAULT_CONFIG[ 'grids_per_r' ] lw = DEFAULT_CONFIG[ 'line_width' ] folder = 'Video' # Create output directory if not os.path.isdir(folder): os.makedirs(folder) print ( f\"Created output directory: { folder } \" ) print ( f\"Starting visualization process with { num_processes } CPUs...\" ) print ( f\"Processing { nGFS } timesteps from { ZMIN } to { ZMAX } in Z and { - RMAX } to { RMAX } in R\" ) # Create multiprocessing pool and process all timesteps with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments process_func = partial(process_timestep, folder = folder, nGFS = nGFS, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw) # Map the processing function to all timesteps timesteps = list ( range (nGFS)) pool. map (process_func, timesteps) print ( f\"Visualization complete!",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow: Images saved in...",
    "content": "Images saved in { folder } /\" ) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow - Code Example: Methods",
    "content": "importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportmultiprocessingasmpfromfunctoolsimportpartialimportargparseimportmatplotlib.colorsasmcolors# ===============================# Configuration and Settings# ===============================# Custom colormap for viscoelastic stress visualizationcustom_colors=[\"white\",\"#DA8A67\",\"#A0522D\",\"#400000\"]CUSTOM_CMAP=mcolors.LinearSegmentedColormap.from_list(\"custom_hot\", custom_colors)# Global matplotlib settings for publication-quality outputmatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'# Default visualization parametersDEFAULT_CONFIG={'grids_per_r':128,# Grid resolution factor'line_width':2,# Interface line width'axes_label_size':50,# Font size for axis labels'tick_label_size':20,# Font size for tick labels'interface_line_width':4,# Line width for interface boundaries'strain_vmax':2.0,# Maximum strain rate for colorbar'strain_vmin':-3.0,# Minimum strain rate for colorbar'stress_vmax':2.0,# Maximum stress trace for colorbar'stress_vmin':-3.0,# Minimum stress trace for colorbar}# ===============================# Interface Extraction Functions# ===============================defgettingFacets(filename, includeCoat='true'):",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow - Code Example: Context",
    "content": "exe=[\"./getFacet2D\", filename, includeCoat]try:p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()exceptFileNotFoundError:raiseFileNotFoundError(f\"getFacet2D executable not found.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow - Code Example: Ensure it's compiled...",
    "content": "Ensure it's compiled and in the current directory.\")temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=False# Process interface data - skip empty lines and extract coordinate pairsiflen(temp2)>1e2:# Ensure we have sufficient data pointsforn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:# Extract paired coordinate pointstemp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])# Add symmetric segments for axisymmetric visualizationsegs.append(((r1, z1), (r2, z2)))segs.append(((-r1, z1), (-r2, z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, zmax, rmax, nr):",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow - Code Example: Context",
    "content": "exe=[\"./getData-elastic-scalar2D\", filename,str(zmin),str(0),str(zmax),str(rmax),str(nr)]try:p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()exceptFileNotFoundError:raiseFileNotFoundError(f\"getData-elastic-scalar2D executable not found.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow - Code Example: Ensure it's compiled...",
    "content": "Ensure it's compiled and in the current directory.\")temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# Initialize temporary lists for field dataRtemp, Ztemp, D2temp, veltemp, taupTemp=[], [], [], [], []# Parse field data from executable outputforn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))D2temp.append(float(temp3[2]))veltemp.append(float(temp3[3]))taupTemp.append(float(temp3[4]))# Convert to numpy arrays and reshape to 2D meshR=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)taup=np.asarray(taupTemp)# Calculate number of axial grid pointsnz=int(len(Z)/nr)print(f\"Grid dimensions: nr={nr}, nz={nz}\")# Reshape arrays to 2D mesh formatR.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))taup.resize((nz, nr))returnR, Z, D2, vel, taup, nz# ===============================# Visualization Functions# ===============================defprocess_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw):",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow - Code Example: # Convert timestep...",
    "content": "# Convert timestep index to simulation timet=0.01*tiplace=f\"intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"# Check if input file existsifnotos.path.exists(place):print(f\"{place}File not found!\")return# Skip if output already existsifos.path.exists(name):print(f\"{name}Image present!\")return# Extract interface data with and without coatingsegs1=gettingFacets(place)# With coatingsegs2=gettingFacets(place,'false')# Without coating# Validate interface dataifnotsegs1andnotsegs2:print(f\"Problem in the available file{place}\")return# Extract field data on uniform gridnr=int(GridsPerR*rmax)R, Z, taus, vel, taup, nz=gettingfield(place, zmin, zmax, rmax, nr)zminp, zmaxp, rminp, rmaxp=Z.min(), Z.max(), R.min(), R.max()# ===============================# Create Visualization# ===============================AxesLabel, TickLabel=DEFAULT_CONFIG['axes_label_size'], DEFAULT_CONFIG['tick_label_size']fig, ax=plt.subplots()fig.set_size_inches(19.20,10.80)# High-resolution output# Draw boundary box and symmetry axisax.plot([0,0], [zmin, zmax],'-.', color='grey', linewidth=lw)# Symmetry axisax.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Add interface linesline_segments=LineCollection(segs2, linewidths=DEFAULT_CONFIG['interface_line_width'],colors='green', linestyle='solid')ax.add_collection(line_segments)line_segments=LineCollection(segs1, linewidths=DEFAULT_CONFIG['interface_line_width'],colors='blue', linestyle='solid')ax.add_collection(line_segments)# Create strain rate contour plot (left side, mirrored)cntrl1=ax.imshow(taus, cmap=\"hot_r\", interpolation='Bilinear', origin='lower',extent=[-rminp,-rmaxp, zminp, zmaxp],vmax=DEFAULT_CONFIG['strain_vmax'], vmin=DEFAULT_CONFIG['strain_vmin'])# Create stress trace contour plot (right side)cntrl2=ax.imshow(taup, interpolation='Bilinear', cmap=CUSTOM_CMAP, origin='lower',extent=[rminp, rmaxp, zminp, zmaxp],vmax=DEFAULT_CONFIG['stress_vmax'], vmin=DEFAULT_CONFIG['stress_vmin'])# Set plot propertiesax.set_aspect('equal')ax.set_xlim(rmin, rmax)ax.set_ylim(zmin, zmax)ax.set_title(f'$t/\\\\tau_\\\\gamma$ ={t:4.3f}', fontsize=TickLabel)# Add colorbarsl, b, w, h=ax.get_position().bounds# Left colorbar for strain ratecb1=fig.add_axes([l-0.04, b,0.03, h])c1=plt.colorbar(cntrl1, cax=cb1, orientation='vertical')c1.set_label(r'$\\log_{10}\\left(\\|\\mathcal{D}\\|\\right)$', fontsize=TickLabel, labelpad=5)c1.ax.tick_params(labelsize=TickLabel)c1.ax.yaxis.set_ticks_position('left')c1.ax.yaxis.set_label_position('left')c1.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}'))# Right colorbar for stress tracecb2=fig.add_axes([l+w+0.01, b,0.03, h])c2=plt.colorbar(cntrl2, cax=cb2, orientation='vertical')c2.ax.tick_params(labelsize=TickLabel)c2.set_label(r'$\\log_{10}\\left(\\text{tr}\\left(\\mathcal{A}\\right)-1\\right)$', fontsize=TickLabel)c2.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.2f}'))ax.axis('off')# Remove axis ticks and labels for cleaner look# Save high-quality outputplt.savefig(name, bbox_inches=\"tight\", dpi=300)plt.close()# Free memory# ===============================# Main Execution Function# ===============================defmain():",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow - Code Example: # Set up...",
    "content": "# Set up command-line argument parsingparser=argparse.ArgumentParser(description=\"Process Basilisk simulation data for visualization\")parser.add_argument('--CPUs',type=int, default=mp.cpu_count(),help='Number of CPUs to use (default: all available)')parser.add_argument('--nGFS',type=int, default=550,help='Number of restart files to process (default: 550)')parser.add_argument('--ZMAX',type=float, default=4.0,help='Maximum Z value (default: 4.0)')parser.add_argument('--RMAX',type=float, default=2.0,help='Maximum R value (default: 2.0)')parser.add_argument('--ZMIN',type=float, default=-4.0,help='Minimum Z value (default: -4.0)')args=parser.parse_args()# Extract parametersCPUStoUse=args.CPUsnGFS=args.nGFSZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMIN# Set processing parametersnum_processes=CPUStoUsermin, rmax, zmin, zmax=[-RMAX, RMAX, ZMIN, ZMAX]GridsPerR=DEFAULT_CONFIG['grids_per_r']lw=DEFAULT_CONFIG['line_width']folder='Video'# Create output directoryifnotos.path.isdir(folder):os.makedirs(folder)print(f\"Created output directory:{folder}\")print(f\"Starting visualization process with{num_processes}CPUs...\")print(f\"Processing{nGFS}timesteps from{ZMIN}to{ZMAX}in Z and{-RMAX}to{RMAX}in R\")# Create multiprocessing pool and process all timestepswithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed argumentsprocess_func=partial(process_timestep,folder=folder, nGFS=nGFS,GridsPerR=GridsPerR, rmin=rmin, rmax=rmax,zmin=zmin, zmax=zmax, lw=lw)# Map the processing function to all timestepstimesteps=list(range(nGFS))pool.map(process_func, timesteps)print(f\"Visualization complete!",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | MultiRheoFlow - Code Example: Context",
    "content": "Images saved in{folder}/\")if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow: Context",
    "content": "postProcess/getData-elastic-scalar2D.c See raw file Simulation Snapshot Data Extractor for Multiphase Fluid Dynamics This program extracts fluid dynamic properties from simulation snapshots, specifically designed for analyzing deformable soft matter systems including liquid drops, sheets, and bubbles. The code computes various tensor fields relevant to non-Newtonian fluid dynamics and viscoelastic material behavior.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow: Physical Quantities Computed...",
    "content": "Physical Quantities Computed Deformation Rate Tensor Analysis Computes the symmetric deformation rate tensor components D_ij Calculates the second invariant of the deformation rate tensor Applies logarithmic scaling for visualization of wide dynamic ranges Conformation Tensor Properties Extracts viscoelastic polymer conformation tensor components Computes trace deviations from equilibrium state Logarithmic scaling for polymer stretching visualization Velocity Field Analysis Calculates velocity magnitude from vector components Provides interpolation capabilities for field extraction Author Information Author: Vatsal Sanjay Email: vatsalsanjay@gmail.com Affiliation: Physics of Fluids Group Institution: University of Twente #include \"utils.h\" #include \"output.h\" Global Variables and Field Declarations Scalar Fields f[] : Volume fraction field for multiphase identification conform_qq[] : Out-of-plane conformation tensor component (q,q) D2c[] : Logarithm of second invariant of deformation rate tensor vel[] : Velocity magnitude field trA[] : Logarithm of trace deviation of conformation tensor Vector Fields u[] : Velocity field components (u.x, u.y) Conformation Tensor Components A11[] : In-plane conformation tensor component (1,1) A12[] : In-plane conformation tensor component (1,2) A22[] : In-plane conformation tensor component (2,2) Simulation Parameters filename[80] : Input snapshot filename nx, ny : Grid resolution in x and y directions len : Number of scalar fields in output list xmin, ymin, xmax, ymax : Domain boundaries Deltax, Deltay : Grid spacing in x and y directions scalar f []; vector u []; scalar A11 [], A12 [], A22 []; scalar conform_qq []; char filename [ 80 ]; int nx , ny , len ; double xmin , ymin , xmax , ymax , Deltax , Deltay ; scalar D2c [], vel [], trA []; scalar * list = NULL ; Main Function Purpose Extracts and processes fluid dynamic fields from simulation snapshots, computing deformation rates, velocity magnitudes, and polymer conformation properties for visualization and analysis.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow: Arguments a :...",
    "content": "Arguments a : Number of command line arguments arguments[] : Command line argument array containing: arguments[1] : Input snapshot filename arguments[2] : Minimum x-coordinate (xmin) arguments[3] : Minimum y-coordinate (ymin) arguments[4] : Maximum x-coordinate (xmax) arguments[5] : Maximum y-coordinate (ymax) arguments[6] : Number of grid points in y-direction (ny) Physical Implementation Details Deformation Rate Tensor Calculation The deformation rate tensor components are computed using finite differences: - D11 = \u2202u_y/\u2202y : Extensional rate in y-direction - D22 = u_y/y : Azimuthal extensional rate (cylindrical coordinates) - D33 = \u2202u_x/\u2202x : Extensional rate in x-direction - D13 = 0.5(\u2202u_y/\u2202x + \u2202u_x/\u2202y) : Shear rate component Second Invariant Computation The second invariant of the deformation rate tensor: D2 = D11\u00b2 + D22\u00b2 + D33\u00b2 + 2\u00d7D13\u00b2 Logarithmic Scaling For visualization across multiple decades: log_scale = log\u2081\u2080(value) if value > 0, else -10 Return Value 0 on successful execution Non-zero on error (implicit from system) int main ( int a , char const * arguments []) { // Parse command line arguments sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); // Build output field list list = list_add ( list , D2c ); list = list_add ( list , vel ); list = list_add ( list , trA ); // Load simulation snapshot restore ( file = filename ); Computational Loop for Field Processing This loop processes each grid cell to compute: - Deformation rate tensor components using central differences - Second invariant of deformation rate tensor - Velocity magnitude - Polymer conformation trace deviation foreach () { // Compute deformation rate tensor components double D11 = ( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ])/( 2 * Delta ); double D22 = ( u . y []/ y ); double D33 = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2 * Delta ); double D13 = 0.5 *( ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 2 * Delta ) ); // Calculate second invariant double D2 = ( sq ( D11 )+ sq ( D22 )+ sq ( D33 )+ 2.0 * sq ( D13 )); D2c [] = f []* D2 ; // Mask with volume fraction // Apply logarithmic scaling for deformation rate if ( D2c [] > 0. ){ D2c [] = log ( D2c [])/ log ( 10 ); } else { D2c [] = - 10 ; } // Compute velocity magnitude vel [] = sqrt ( sq ( u . x [])+ sq ( u . y [])); // Compute polymer conformation trace deviation trA [] = ( A11 [] + A22 [] + conform_qq [])/ 3.0 - 1.0 ; if ( trA [] > 0. ){ trA [] = log ( trA [])/ log ( 10 ); } else { trA [] = - 10 ; } } Grid Setup and Data Extraction Creates a uniform grid for data extraction and interpolation.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow: The grid spacing...",
    "content": "The grid spacing is determined by the specified y-resolution, maintaining aspect ratio for the x-direction. FILE * fp = ferr ; Deltay = ( double )(( ymax - ymin )/( ny )); nx = ( int )(( xmax - xmin )/ Deltay ); Deltax = ( double )(( xmax - xmin )/( nx )); len = list_len ( list ); // Allocate memory for extracted field data double ** field = ( double **) matrix_new ( nx , ny + 1 , len * sizeof ( double )); Field Interpolation Loop Interpolates field values at regular grid points using the simulation\u2019s interpolation routines.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow: This provides smooth...",
    "content": "This provides smooth field representations suitable for visualization. for ( int i = 0 ; i < nx ; i ++) { double x = Deltax *( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay *( j + 1. / 2 ) + ymin ; int k = 0 ; for ( scalar s in list ){ field [ i ][ len * j + k ++] = interpolate ( s , x , y ); } } } Data Output Writes the extracted field data in ASCII format: - First two columns: x and y coordinates - Subsequent columns: Field values in order added to list for ( int i = 0 ; i < nx ; i ++) { double x = Deltax *( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay *( j + 1. / 2 ) + ymin ; fprintf ( fp , \" %g %g \" , x , y ); int k = 0 ; for ( scalar s in list ){ fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } // Cleanup fflush ( fp ); fclose ( fp ); matrix_free ( field ); }",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow - Code Example",
    "content": "scalar f[];vector u[];scalar A11[],A12[],A22[];scalar conform_qq[];charfilename[80];intnx,ny,len;doublexmin,ymin,xmax,ymax,Deltax,Deltay;scalar D2c[],vel[],trA[];scalar*list=NULL;",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow - Code Example",
    "content": "intmain(inta,charconst*arguments[]){// Parse command line argumentssprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);// Build output field listlist=list_add(list,D2c);list=list_add(list,vel);list=list_add(list,trA);// Load simulation snapshotrestore(file=filename);",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow - Code Example: foreach(){// Compute deformation...",
    "content": "foreach(){// Compute deformation rate tensor componentsdoubleD11=(u.y[0,1]-u.y[0,-1])/(2*Delta);doubleD22=(u.y[]/y);doubleD33=(u.x[1,0]-u.x[-1,0])/(2*Delta);doubleD13=0.5*((u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(2*Delta));// Calculate second invariantdoubleD2=(sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13));D2c[]=f[]*D2;// Mask with volume fraction// Apply logarithmic scaling for deformation rateif(D2c[]>0.){D2c[]=log(D2c[])/log(10);}else{D2c[]=-10;}// Compute velocity magnitudevel[]=sqrt(sq(u.x[])+sq(u.y[]));// Compute polymer conformation trace deviationtrA[]=(A11[]+A22[]+conform_qq[])/3.0-1.0;if(trA[]>0.){trA[]=log(trA[])/log(10);}else{trA[]=-10;}}",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow - Code Example",
    "content": "FILE*fp=ferr;Deltay=(double)((ymax-ymin)/(ny));nx=(int)((xmax-xmin)/Deltay);Deltax=(double)((xmax-xmin)/(nx));len=list_len(list);// Allocate memory for extracted field datadouble**field=(double**)matrix_new(nx,ny+1,len*sizeof(double));",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow - Code Example",
    "content": "for(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y);}}}",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | MultiRheoFlow - Code Example",
    "content": "for(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;fprintf(fp,\"%g%g\",x,y);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}// Cleanupfflush(fp);fclose(fp);matrix_free(field);}",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | MultiRheoFlow: Context",
    "content": "postProcess/getFacet2D.c See raw file Facet Extraction Tool for Multiphase Flow Simulations This program extracts and outputs facets from a Basilisk simulation file, primarily used for interface reconstruction in multiphase flow simulations. In multiphase flow simulations, facets represent the reconstructed interface between different phases (e.g., liquid-gas interfaces). These facets are computed using Volume-of-Fluid (VOF) methods where the interface is approximated by piecewise linear segments within each cell. Overview The facet extraction process involves: - Restoring a simulation state from a saved file - Extracting interface facets from the volume fraction field - Outputting facet data for visualization or post-processing Physical Context In VOF methods, each computational cell contains a volume fraction f that represents the proportion of the cell occupied by one phase (typically the liquid phase).",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | MultiRheoFlow: Facets are linear...",
    "content": "Facets are linear approximations of the interface within cells where 0 < f < 1 , computed using interface reconstruction algorithms such as PLIC (Piecewise Linear Interface Calculation). Usage ./getFacet2D < input_file > Where input_file is a Basilisk simulation output file containing volume fraction data.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | MultiRheoFlow: Author Information Author...",
    "content": "Author Information Author : Vatsal Sanjay Email : vatsalsanjay@gmail.com Affiliation : Physics of Fluids Group Date : 2025-05-13 Dependencies This program requires the following Basilisk modules: - utils.h : Core utilities and data structures - output.h : Output functions including facet output routines - fractions.h : Volume fraction handling and interface reconstruction #include \"utils.h\" #include \"output.h\" #include \"fractions.h\" Global Variables Volume Fraction Field scalar f []; < Volume fraction field representing the liquid phase Filename Buffer char filename [ 80 ]; < Buffer to store input filename from command line Main Function Purpose Extracts facets from a Basilisk simulation file and outputs them to stderr. This is the primary entry point for the facet extraction process. Implementation Details The function performs the following operations: 1. Parses command line arguments to get the input filename 2. Restores the simulation state from the specified file 3.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | MultiRheoFlow: Extracts and outputs...",
    "content": "Extracts and outputs facets from the volume fraction field 4. Ensures output is flushed and closed properly Parameters a : Number of command line arguments arguments : Array of command line argument strings arguments[0] : Program name (unused) arguments[1] : Input simulation file path Return Value Returns EXIT_SUCCESS (0) on successful completion, or EXIT_FAILURE if an error occurs during file operations. Side Effects Reads and modifies program state by restoring simulation data Outputs facet data to stderr May produce error messages if file operations fail Error Handling Basic error handling is provided through Basilisk\u2019s internal mechanisms. The program will exit with an error code if the input file cannot be read.",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | MultiRheoFlow: Function Definition",
    "content": "Notes Output is directed to stderr ( ferr ) rather than stdout to separate data output from potential error messages The output format depends on the output_facets() function implementation Facet output typically includes coordinates, normals, and other interface properties for visualization tools int main ( int a , char const * arguments []) { // Parse command line argument for input filename sprintf ( filename , \" %s \" , arguments [ 1 ]); // Restore simulation state from file restore ( file = filename ); // Set output destination to stderr FILE * fp = ferr ; // Extract and output facets from volume fraction field output_facets ( f , fp ); // Ensure all output is written fflush ( fp ); // Close file pointer (stderr alias) fclose ( fp ); return 0 ; }",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | MultiRheoFlow - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"fractions.h\"",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | MultiRheoFlow - Code Example",
    "content": "intmain(inta,charconst*arguments[]){// Parse command line argument for input filenamesprintf(filename,\"%s\",arguments[1]);// Restore simulation state from filerestore(file=filename);// Set output destination to stderrFILE*fp=ferr;// Extract and output facets from volume fraction fieldoutput_facets(f,fp);// Ensure all output is writtenfflush(fp);// Close file pointer (stderr alias)fclose(fp);return0;}",
    "url": "https://comphy-lab.org/MultiRheoFlow/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "FIBER: Flow-Induced Breakup of Elastic Rheology | FIBER: Flow-Induced Breakup of Elastic Rheology: FIBER: Flow-Induced Breakup...",
    "content": "FIBER: Flow-Induced Breakup of Elastic Rheology \ud83d\ude80 Fiber is a state-of-the-art, open-source framework for simulating viscoelastic fluid flows in 2D and 3D, built as an extension to the Basilisk C CFD library.",
    "url": "https://comphy-lab.org/fiber/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "FIBER: Flow-Induced Breakup of Elastic Rheology | FIBER: Flow-Induced Breakup of Elastic Rheology: Methods",
    "content": "It implements the log-conformation method for robust, high-Weissenberg number simulations, with a focus on clarity, extensibility, and scientific rigor. \u2728 Key Features Full 3D Log-Conformation Method : Complete scalar implementation for 3D viscoelastic fluids ( log-conform-viscoelastic-scalar-3D.h ) Robust 2D/Axi Support : Scalar and tensor-based log-conformation for 2D and axisymmetric cases ( log-conform-viscoelastic-scalar-2D.h , log-conform-viscoelastic.h ) Optimized Matrix Algebra : Efficient, stable eigenvalue and tensor operations ( eigen_decomposition.h ) Advanced Initialization : Functions for pseudo vectors/tensors in 2D/3D Error Handling : Negative eigenvalue checks, eigenvalue clamping, and detailed diagnostics Performance : Simplified acceleration term calculations and optimized tensor operations Documentation : Extensive inline documentation, mathematical background, and verification notes Compatibility : GPLv3 license, fully compatible with Basilisk and previous versions \ud83d\udc1b Bug Fixes (v2.5/v2.6) Corrected matrix algebra in 3D Fixed rotation tensor and eigenvalue edge cases Improved error reporting and diagnostics Enhanced axisymmetric and 2D/3D compatibility \ud83d\uddc2\ufe0f Repository Structure basilisk/src/ - # Core Basilisk CFD library (reference only, do not modify) src-local/ - # Custom viscoelastic solvers and tensor utilities log-conform-viscoelastic-scalar-2D.h - # 2D/axi log-conformation (scalar) two-phaseVE.h - # Two-phase viscoelastic extension simulationCases/ - # Example/test cases and post-processing scripts filamentExt.c - # Pinch-off of viscoelastic jet (2D/axi) postProcess/ - # Project-specific post-processing tools and utilities getData-elastic-scalar2D.c - # Data extraction utility getFacet2D.c - # Facet extraction utility VideoAxi.py - # Python visualization script \ud83d\udcda Documentation Inline documentation in all major headers (see src-local/ ) Example simulation and post-processing scripts in simulationCases/ \ud83d\ude80 Quick Start 1.",
    "url": "https://comphy-lab.org/fiber/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "FIBER: Flow-Induced Breakup of Elastic Rheology | FIBER: Flow-Induced Breakup of Elastic Rheology: Prerequisites Basilisk C...",
    "content": "Prerequisites Basilisk C (included as submodule in basilisk/ ) C compiler (e.g., gcc) Python 3 (for post-processing) Optional: Jupyter for notebooks 2. Compiling & Running Simulations A. Vanilla Basilisk method: qcc -O2 -Wall -I. /src-local -disable-dimensions simulationCases/{CaseName}.c -o {CaseName} -lm ./{CaseName} B. Using the Makefile (with bview browser): CFLAGS = -DDISPLAY=-1 make simulationCases/{CaseName}.tst For interactive visualization, open the generated display.html in your browser (see Basilisk bview ). 3. Post-Processing & Analysis Python scripts and Jupyter notebooks for data extraction and visualization are in simulationCases/ (e.g., VideoAxi.py , verifyWtihPlots.ipynb ).",
    "url": "https://comphy-lab.org/fiber/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "FIBER: Flow-Induced Breakup of Elastic Rheology | FIBER: Flow-Induced Breakup of Elastic Rheology: Examples",
    "content": "Example utilities: getData-elastic-scalar2D.c , getFacet2D.c . \ud83d\udcdd Example: Running a 3D Drop Atomisation Simulation qcc -O2 -Wall -I. /src-local -disable-dimensions simulationCases/dropAtomisation.c -o dropAtomisation -lm ./dropAtomisation \ud83d\udd0d Technical Details Log-Conformation Method : See src-local/log-conform-viscoelastic-scalar-3D.h and src-local/log-conform-viscoelastic-scalar-2D.h for mathematical background and implementation notes. Eigenvalue Solver : src-local/eigen_decomposition.h provides robust 3x3 symmetric eigensystem routines. Two-Phase Flows : src-local/two-phaseVE.h extends Basilisk\u2019s two-phase solver for viscoelasticity. Axisymmetric/2D/3D : Use the appropriate header for your geometry (see comments in each header for guidance). \ud83e\uddd1\u200d\ud83d\udcbb Contributing See CLAUDE.md for code style and development guidelines. Issue templates and feature requests: GitHub Issue Templates Pull requests are welcome!",
    "url": "https://comphy-lab.org/fiber/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "FIBER: Flow-Induced Breakup of Elastic Rheology | FIBER: Flow-Induced Breakup of Elastic Rheology: Examples",
    "content": "Please document your changes and update relevant tests/examples. \ud83d\udccb License This project is licensed under the GNU GPLv3 , in line with the Basilisk codebase. \ud83d\ude4f Acknowledgments Thanks to all contributors and the Basilisk community \ud83d\udd17 References Fattal & Kupferman (2004, 2005): Log-conformation method Comminal et al. (2015): Constitutive model functions Hao & Pan (2007): Split scheme implementation Basilisk C For detailed documentation, see the docs/ folder or open docs/index.html in your browser. Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/VideoAxi.py postProcess/getData-elastic-scalar2D.c postProcess/getFacet2D.c simulationCases simulationCases/Makefile simulationCases/cleanup.sh simulationCases/filamentExt.c simulationCases/runCases.sh src-local src-local/log-conform-viscoelastic-scalar-2D.h src-local/two-phaseVE.h",
    "url": "https://comphy-lab.org/fiber/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "FIBER: Flow-Induced Breakup of Elastic Rheology | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "qcc-O2-Wall-I./src-local-disable-dimensionssimulationCases/{CaseName}.c-o{CaseName}-lm./{CaseName}",
    "url": "https://comphy-lab.org/fiber/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "FIBER: Flow-Induced Breakup of Elastic Rheology | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "CFLAGS=-DDISPLAY=-1makesimulationCases/{CaseName}.tst",
    "url": "https://comphy-lab.org/fiber/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "FIBER: Flow-Induced Breakup of Elastic Rheology | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "qcc-O2-Wall-I./src-local-disable-dimensionssimulationCases/dropAtomisation.c-odropAtomisation-lm./dropAtomisation",
    "url": "https://comphy-lab.org/fiber/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | FIBER: Flow-Induced Breakup of Elastic Rheology",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # MacOS only. modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk rm -rf basilisk rm -rf .project_config darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make -k make echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config",
    "url": "https://comphy-lab.org/fiber/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "#!/bin/zsh# MacOS only. modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basiliskrm-rfbasiliskrm-rf.project_configdarcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake-kmakeecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config",
    "url": "https://comphy-lab.org/fiber/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases cleanup.sh rm -rf \\$1 filamentExt.c u.n[top] = neumann(0.0); 34 p[top] = dirichlet(0.0); 35 u.n[right] = neumann(0.0); 36 p[right] = dirichlet(0.0); 37 3... Makefile ifeq (\\$(wildcard ../.projectconfig),) \\$(error '../.projectconfig not found') endif BASILISK := \\$(shell . ../.proje... runCases.sh ORIGDIR=\\$(pwd) mkdir -p \\$1 cp \\$1.c \\$1/ cd \\$1 qcc -I\\${ORIGDIR}/src-local -I\\${ORIGDIR}/../src-local -O2 -Wall -d...",
    "url": "https://comphy-lab.org/fiber/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/cleanup.sh | FIBER: Flow-Induced Breakup of Elastic Rheology",
    "content": "simulationCases/cleanup.sh See raw file cleanup.sh #!/bin/bash rm -rf \\$ 1",
    "url": "https://comphy-lab.org/fiber/simulationCases/cleanup.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCases.sh | FIBER: Flow-Induced Breakup of Elastic Rheology",
    "content": "simulationCases/runCases.sh See raw file runCases.sh #!/bin/bash # Save the original directory ORIG_DIR = \\$ ( pwd ) mkdir -p \\$ 1 cp \\$ 1.c \\$ 1/ cd \\$ 1 qcc -I\\${ORIG_DIR} /src-local -I\\${ORIG_DIR} /../src-local -O2 -Wall -disable-dimensions \\$ 1.c -o \\$ 1 -lm ./\\$1",
    "url": "https://comphy-lab.org/fiber/simulationCases/runCases.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCases.sh | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "#!/bin/bash# Save the original directoryORIG_DIR=\\$(pwd)mkdir-p\\$1cp\\$1.c\\$1/cd\\$1qcc-I\\${ORIG_DIR}/src-local-I\\${ORIG_DIR}/../src-local-O2-Wall-disable-dimensions\\$1.c-o\\$1-lm./\\$1",
    "url": "https://comphy-lab.org/fiber/simulationCases/runCases.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | FIBER: Flow-Induced Breakup of Elastic Rheology",
    "content": "simulationCases/Makefile See raw file Makefile # Check if .project_config exists ifeq ( \\$ ( wildcard ../.project_config ) , ) \\$ ( error \"../.project_config not found\" ) endif BASILISK := \\$ ( shell . ../.project_config && echo \\$\\$ BASILISK ) CFLAGS += -O2 -disable-dimensions CFLAGS += -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local # Fix permissions for runtest script fix-permissions: @chmod +x \\$ ( BASILISK ) /src/runtest # Make all test targets depend on fix-permissions %.tst: fix-permissions include \\$ ( BASILISK ) /Makefile.defs",
    "url": "https://comphy-lab.org/fiber/simulationCases/Makefile.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "# Check if .project_config existsifeq(\\$(wildcard../.project_config),)\\$(error\"../.project_config not found\")endifBASILISK:=\\$(shell. ../.project_config&&echo\\$\\$BASILISK)CFLAGS+=-O2-disable-dimensionsCFLAGS+=-I\\$(PWD)/src-local-I\\$(PWD)/../src-local# Fix permissions for runtest scriptfix-permissions:@chmod+x\\$(BASILISK)/src/runtest# Make all test targets depend on fix-permissions%.tst:fix-permissionsinclude\\$(BASILISK)/Makefile.defs",
    "url": "https://comphy-lab.org/fiber/simulationCases/Makefile.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology: Context",
    "content": "simulationCases/filamentExt.c See raw file @file filamentExt.c @brief This code will give an initial condition where the filament is stretched out, to be used for filament_retraction_VE.c The relaxation time is taken as infinity here to ensure that the polymers undergo affine deformation while stretching. @author Vatsal Sanjay @version 1.1 @date 2025-05-09 #include \"axi.h\" #include \"navier-stokes/centered.h\" #include \"log-conform-viscoelastic-scalar-2D.h\" #define logFile \"logAxi-scalar.dat\" 14 #define FILTERED // Smear density and viscosity jumps #include \"two-phaseVE.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #include \"reduced.h\" #define tsnap ( 5e-2 ) 23 // Error tolerancs #define fErr ( 1e-3 ) // error tolerance in f1 VOF #define KErr ( 1e-6 ) // error tolerance in VoF curvature calculated using heigh function method (see adapt event) #define VelErr ( 1e-2 ) // error tolerances in velocity -- Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J #define trAErr ( 1e-3 ) // error tolerance in trace of conformation tensor #define R2 ( x , y , z ) ( sqrt ( sq ( x ) + sq ( y ))) 31 // boundary conditions u . n [ top ] = neumann ( 0.0 ); p [ top ] = dirichlet ( 0.0 ); u . n [ right ] = neumann ( 0.0 ); p [ right ] = dirichlet ( 0.0 ); int MAXlevel ; // Bond number -> dimensionless driving... // Oh -> Solvent Ohnesorge number // Oha -> air Ohnesorge number // De -> Deborah number // Ec -> Elasto-capillary number // for now there is no viscoelasticity double Bo , Oh , Oha , De , Ec , tmax ; char nameOut [ 80 ], dumpFile [ 80 ]; static FILE * logFp = NULL ; int main ( int argc , char const * argv []) { L0 = 16. ; // Values taken from the terminal MAXlevel = 10 ; tmax = 10.0 ; Bo = 4e0 ; Oh = 1e-1 ; Oha = 1e-5 ; De = 1e30 ; // 1e-1; Ec = 1.0 ; // 1e-2; init_grid ( 1 << 6 ); // Create a folder named intermediate where all the simulation snapshots are stored. char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); // Name of the restart file.",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology: Context",
    "content": "See writingFiles event. sprintf ( dumpFile , \"restart\" ); rho1 = 1. , rho2 = 1e-3 ; mu1 = Oh , mu2 = Oha ; lambda1 = De , lambda2 = 0. ; G1 = Ec , G2 = 0. ; G . x = Bo ; f . sigma = 1.0 ; run (); } event init ( t = 0 ) { if (! restore ( file = dumpFile )){ refine ( R2 ( x , y , z ) < ( 1.1 ) && R2 ( x , y , z ) > ( 0.9 ) && level < MAXlevel ); fraction ( f , ( 1 - R2 ( x , y , z ))); } } Adaptive Mesh Refinement scalar KAPPA [], trA []; event adapt ( i ++){ curvature ( f , KAPPA ); foreach () { trA [] = ( A11 [] + A22 [] + AThTh []); } adapt_wavelet (( scalar *){ f , u . x , u . y , KAPPA , trA }, ( double []){ fErr , VelErr , VelErr , KErr , trAErr }, MAXlevel , 4 ); } Dumping snapshots event writingFiles ( t = 0 ; t += tsnap ; t <= tmax ) { dump ( file = dumpFile ); sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Ending Simulation event end ( t = end ) { if ( pid () == 0 ) { fprintf ( ferr , \"Level %d , Oh %2.1e\\n \" , MAXlevel , Oh ); // Close log file if ( logFp != NULL ) { fclose ( logFp ); logFp = NULL ; } } } Log file initialization event logInit ( i = 0 ) { if ( pid () == 0 ) { logFp = fopen ( logFile , \"w\" ); if ( logFp == NULL ) { fprintf ( ferr , \"Error opening log file \\n \" ); return 1 ; } fprintf ( ferr , \"Level %d , Bo %2.1e , Oh %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Bo , Oh , Oha , De , Ec ); fprintf ( ferr , \"i dt t ke \\n \" ); fprintf ( logFp , \"Level %d , Bo %2.1e , Oh %2.1e , Oha %2.1e , De %2.1e , Ec %2.1e\\n \" , MAXlevel , Bo , Oh , Oha , De , Ec ); fprintf ( logFp , \"i dt t ke \\n \" ); fflush ( logFp ); } } Log writing event logWriting ( i ++) { double ke = 0. ; foreach ( reduction (+: ke )){ ke += ( 2 * pi * y )*( 0.5 * rho ( f [])*( sq ( u . x []) + sq ( u . y [])+ sq ( u . z [])))* sq ( Delta ); } if ( pid () == 0 ) { fprintf ( logFp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); fflush ( logFp ); } assert ( ke > - 1e-10 ); if ( i > 1e4 && pid () == 0 ) { if ( ke > 1e2 || ke < 1e-8 ) { const char * message = ( ke > 1e2 ) ? \"The kinetic energy blew up.",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology: Stopping simulation \\n...",
    "content": "Stopping simulation \\n \" : \"kinetic energy too small now! Stopping! \\n \" ; fprintf ( ferr , \" %s \" , message ); FILE * fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %s \" , message ); fflush ( fp ); fclose ( fp ); dump ( file = dumpFile ); return 1 ; } } }",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology - C/C++ Code: C/C++ Code",
    "content": "#include\"axi.h\"#include\"navier-stokes/centered.h\"#include\"log-conform-viscoelastic-scalar-2D.h\"#define logFile\"logAxi-scalar.dat\"14#define FILTERED// Smear density and viscosity jumps#include\"two-phaseVE.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#include\"reduced.h\"#define tsnap(5e-2)23// Error tolerancs#define fErr(1e-3)// error tolerance in f1 VOF#define KErr(1e-6)// error tolerance in VoF curvature calculated using heigh function method (see adapt event)#define VelErr(1e-2)// error tolerances in velocity -- Use 1e-2 for low Oh and 1e-3 to 5e-3 for high Oh/moderate to high J#define trAErr(1e-3)// error tolerance in trace of conformation tensor#define R2(x,y,z)(sqrt(sq(x)+sq(y)))31// boundary conditionsu.n[top]=neumann(0.0);p[top]=dirichlet(0.0);u.n[right]=neumann(0.0);p[right]=dirichlet(0.0);intMAXlevel;// Bond number -> dimensionless driving...// Oh -> Solvent Ohnesorge number// Oha -> air Ohnesorge number// De -> Deborah number// Ec -> Elasto-capillary number// for now there is no viscoelasticitydoubleBo,Oh,Oha,De,Ec,tmax;charnameOut[80],dumpFile[80];staticFILE*logFp=NULL;intmain(intargc,charconst*argv[]){L0=16.;// Values taken from the terminalMAXlevel=10;tmax=10.0;Bo=4e0;Oh=1e-1;Oha=1e-5;De=1e30;// 1e-1;Ec=1.0;// 1e-2;init_grid(1<<6);// Create a folder named intermediate where all the simulation snapshots are stored.charcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);// Name of the restart file.",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology - C/C++ Code: Context",
    "content": "See writingFiles event.sprintf(dumpFile,\"restart\");rho1=1.,rho2=1e-3;mu1=Oh,mu2=Oha;lambda1=De,lambda2=0.;G1=Ec,G2=0.;G.x=Bo;f.sigma=1.0;run();}event init(t=0){if(!restore(file=dumpFile)){refine(R2(x,y,z)<(1.1)&&R2(x,y,z)>(0.9)&&level<MAXlevel);fraction(f,(1-R2(x,y,z)));}}",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "scalar KAPPA[],trA[];event adapt(i++){curvature(f,KAPPA);foreach(){trA[]=(A11[]+A22[]+AThTh[]);}adapt_wavelet((scalar*){f,u.x,u.y,KAPPA,trA},(double[]){fErr,VelErr,VelErr,KErr,trAErr},MAXlevel,4);}",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax){dump(file=dumpFile);sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "event end(t=end){if(pid()==0){fprintf(ferr,\"Level%d, Oh%2.1e\\n\",MAXlevel,Oh);// Close log fileif(logFp!=NULL){fclose(logFp);logFp=NULL;}}}",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "event logInit(i=0){if(pid()==0){logFp=fopen(logFile,\"w\");if(logFp==NULL){fprintf(ferr,\"Error opening log file\\n\");return1;}fprintf(ferr,\"Level%d, Bo%2.1e, Oh%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Bo,Oh,Oha,De,Ec);fprintf(ferr,\"i dt t ke\\n\");fprintf(logFp,\"Level%d, Bo%2.1e, Oh%2.1e, Oha%2.1e, De%2.1e, Ec%2.1e\\n\",MAXlevel,Bo,Oh,Oha,De,Ec);fprintf(logFp,\"i dt t ke\\n\");fflush(logFp);}}",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: Context",
    "content": "event logWriting(i++){doubleke=0.;foreach(reduction(+:ke)){ke+=(2*pi*y)*(0.5*rho(f[])*(sq(u.x[])+sq(u.y[])+sq(u.z[])))*sq(Delta);}if(pid()==0){fprintf(logFp,\"%d%g%g%g\\n\",i,dt,t,ke);fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);fflush(logFp);}assert(ke>-1e-10);if(i>1e4&&pid()==0){if(ke>1e2||ke<1e-8){constchar*message=(ke>1e2)?\"The kinetic energy blew up. Stopping simulation\\n\":\"kinetic energy too small now!",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/filamentExt.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: Context",
    "content": "Stopping!\\n\";fprintf(ferr,\"%s\",message);FILE*fp=fopen(\"log\",\"a\");fprintf(fp,\"%s\",message);fflush(fp);fclose(fp);dump(file=dumpFile);return1;}}}",
    "url": "https://comphy-lab.org/fiber/simulationCases/filamentExt.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files log-conform-viscoelastic-scalar-2D.h Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation. Therefore these materia... two-phaseVE.h This is a modified version of [two-phase.h](http://basilisk.fr/src/two-phase.h). It contains the implementation of Vi...",
    "url": "https://comphy-lab.org/fiber/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Context",
    "content": "src-local/two-phaseVE.h See raw file Modification by Vatsal Sanjay Version 2.0, Oct 17, 2024 Changelog Oct 17, 2024: added support for VE simulations. Brief history v1.0 is the vanilla Basilisk code for two-phase flows: http://basilisk.fr/src/two-phase.h + http://basilisk.fr/src/two-phase-generic.h v2.0 is the modification for viscoelastic fluids using the log-conformation method. Two-phase interfacial flows This is a modified version of two-phase.h . It contains the implementation of Viscoplastic Fluid (Bingham Fluid). This file helps setup simulations for flows of two fluids separated by an interface (i.e. immiscible fluids). It is typically used in combination with a Navier\u2013Stokes solver . The interface between the fluids is tracked with a Volume-Of-Fluid method. The volume fraction in fluid 1 is \\(f=1\\) and \\(f=0\\) in fluid 2.",
    "url": "https://comphy-lab.org/fiber/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | FIBER: Flow-Induced Breakup of Elastic Rheology: C/C++ Code",
    "content": "The densities and dynamic viscosities for fluid 1 and 2 are rho1 , mu1 , rho2 , mu2 , respectively. #include \"vof.h\" scalar f [], * interfaces = { f }; double rho1 = 1. , mu1 = 0. , rho2 = 1. , mu2 = 0. ; double G1 = 0. , G2 = 0. ; // elastic moduli double lambda1 = 0. , lambda2 = 0. ; // relaxation times double TOLelastic = 1e-2 ; // tolerance for elastic modulus #TOFIX: this must always be a very small number. Auxilliary fields are necessary to define the (variable) specific volume \\(\\alpha=1/\\rho\\) as well as the cell-centered density. face vector alphav []; scalar rhov []; scalar Gpd []; scalar lambdapd []; event defaults ( i = 0 ) { alpha = alphav ; rho = rhov ; Gp = Gpd ; lambda = lambdapd ; If the viscosity is non-zero, we need to allocate the face-centered viscosity field. mu = new face vector ; } The density and viscosity are defined using arithmetic averages by default.",
    "url": "https://comphy-lab.org/fiber/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Definitions - Python Function",
    "content": "The user can overload these definitions to use other types of averages (i.e. harmonic). #ifndef rho # define rho ( f ) ( clamp ( f , 0. , 1. )*( rho1 - rho2 ) + rho2 ) 62 #endif #ifndef mu // for Arithmetic mean, use this # define mu ( f ) ( clamp ( f , 0. , 1. )*( mu1 - mu2 ) + mu2 ) 66 #endif We have the option of using some \u201csmearing\u201d of the density/viscosity jump. #ifdef FILTERED scalar sf []; #else # define sf f 76 #endif event tracer_advection ( i ++) { When using smearing of the density jump, we initialise sf with the vertex-average of f . #ifndef sf #if dimension <= foreach () sf [] = ( 4. * f [] + 2. *( f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 1 , 0 ] + f [- 1 , 0 ]) + f [- 1 ,- 1 ] + f [ 1 ,- 1 ] + f [ 1 , 1 ] + f [- 1 , 1 ])/ 16. ; #else // dimension == foreach () sf [] = ( 8. * f [] + 4. *( f [- 1 ] + f [ 1 ] + f [ 0 , 1 ] + f [ 0 ,- 1 ] + f [ 0 , 0 , 1 ] + f [ 0 , 0 ,- 1 ]) + 2. *( f [- 1 , 1 ] + f [- 1 , 0 , 1 ] + f [- 1 , 0 ,- 1 ] + f [- 1 ,- 1 ] + f [ 0 , 1 , 1 ] + f [ 0 , 1 ,- 1 ] + f [ 0 ,- 1 , 1 ] + f [ 0 ,- 1 ,- 1 ] + f [ 1 , 1 ] + f [ 1 , 0 , 1 ] + f [ 1 ,- 1 ] + f [ 1 , 0 ,- 1 ]) + f [ 1 ,- 1 , 1 ] + f [- 1 , 1 , 1 ] + f [- 1 , 1 ,- 1 ] + f [ 1 , 1 , 1 ] + f [ 1 , 1 ,- 1 ] + f [- 1 ,- 1 ,- 1 ] + f [ 1 ,- 1 ,- 1 ] + f [- 1 ,- 1 , 1 ])/ 64. ; #endif #endif #if TREE sf . prolongation = refine_bilinear ; sf . dirty = true ; // boundary conditions need to be updated #endif } event properties ( i ++) { foreach_face () { double ff = ( sf [] + sf [- 1 ])/ 2. ; alphav . x [] = fm . x []/ rho ( ff ); face vector muv = mu ; muv . x [] = fm . x []* mu ( ff ); } foreach (){ rhov [] = cm []* rho ( sf []); Gpd [] = 0. ; lambdapd [] = 0. ; if ( clamp ( sf [], 0. , 1. ) > TOLelastic ){ Gpd [] += G1 * clamp ( sf [], 0. , 1. ); lambdapd [] += lambda1 * clamp ( sf [], 0. , 1. ); } if ( clamp (( 1 - sf []), 0. , 1. ) > TOLelastic ){ Gpd [] += G2 * clamp (( 1 - sf []), 0. , 1. ); lambdapd [] += lambda2 * clamp (( 1 - sf []), 0. , 1. ); } } #if TREE sf . prolongation = fraction_refine ; sf . dirty = true ; // boundary conditions need to be updated #endif }",
    "url": "https://comphy-lab.org/fiber/src-local/two-phaseVE.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | FIBER: Flow-Induced Breakup of Elastic Rheology - C/C++ Code",
    "content": "#include\"vof.h\"scalar f[],*interfaces={f};doublerho1=1.,mu1=0.,rho2=1.,mu2=0.;doubleG1=0.,G2=0.;// elastic modulidoublelambda1=0.,lambda2=0.;// relaxation timesdoubleTOLelastic=1e-2;// tolerance for elastic modulus #TOFIX: this must always be a very small number.",
    "url": "https://comphy-lab.org/fiber/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "face vector alphav[];scalar rhov[];scalar Gpd[];scalar lambdapd[];event defaults(i=0){alpha=alphav;rho=rhov;Gp=Gpd;lambda=lambdapd;",
    "url": "https://comphy-lab.org/fiber/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Function: rho",
    "content": "#ifndef rho# define rho(f)(clamp(f,0.,1.)*(rho1-rho2)+rho2)62#endif#ifndef mu// for Arithmetic mean, use this# define mu(f)(clamp(f,0.,1.)*(mu1-mu2)+mu2)66#endif",
    "url": "https://comphy-lab.org/fiber/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Function: FILTEREDscalar",
    "content": "#ifdef FILTEREDscalar sf[];#else# define sf f76#endifevent tracer_advection(i++){",
    "url": "https://comphy-lab.org/fiber/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/two-phaseVE.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Function: sf",
    "content": "#ifndef sf#if dimension <=foreach()sf[]=(4.*f[]+2.*(f[0,1]+f[0,-1]+f[1,0]+f[-1,0])+f[-1,-1]+f[1,-1]+f[1,1]+f[-1,1])/16.;#else// dimension ==foreach()sf[]=(8.*f[]+4.*(f[-1]+f[1]+f[0,1]+f[0,-1]+f[0,0,1]+f[0,0,-1])+2.*(f[-1,1]+f[-1,0,1]+f[-1,0,-1]+f[-1,-1]+f[0,1,1]+f[0,1,-1]+f[0,-1,1]+f[0,-1,-1]+f[1,1]+f[1,0,1]+f[1,-1]+f[1,0,-1])+f[1,-1,1]+f[-1,1,1]+f[-1,1,-1]+f[1,1,1]+f[1,1,-1]+f[-1,-1,-1]+f[1,-1,-1]+f[-1,-1,1])/64.;#endif#endif#if TREEsf.prolongation=refine_bilinear;sf.dirty=true;// boundary conditions need to be updated#endif}event properties(i++){foreach_face(){doubleff=(sf[]+sf[-1])/2.;alphav.x[]=fm.x[]/rho(ff);face vector muv=mu;muv.x[]=fm.x[]*mu(ff);}foreach(){rhov[]=cm[]*rho(sf[]);Gpd[]=0.;lambdapd[]=0.;if(clamp(sf[],0.,1.)>TOLelastic){Gpd[]+=G1*clamp(sf[],0.,1.);lambdapd[]+=lambda1*clamp(sf[],0.,1.);}if(clamp((1-sf[]),0.,1.)>TOLelastic){Gpd[]+=G2*clamp((1-sf[]),0.,1.);lambdapd[]+=lambda2*clamp((1-sf[]),0.,1.);}}#if TREEsf.prolongation=fraction_refine;sf.dirty=true;// boundary conditions need to be updated#endif}",
    "url": "https://comphy-lab.org/fiber/src-local/two-phaseVE.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Methods",
    "content": "src-local/log-conform-viscoelastic-scalar-2D.h See raw file Log-Conformation Method for 2D Viscoelastic Fluids Overview Title : log-conform-viscoelastic-scalar-2D.h Version : 2.5 Description : 2D and axisymmetric scalar implementation of viscoelastic fluid dynamics using the log-conformation method Key Features Conformation tensor A exists across domain and relaxes according to \u03bb Stress acts according to elastic modulus G Supports both 2D and axisymmetric configurations Scalar implementation approach for better performance Compatible with log-conform-viscoelastic.h Author Information Name : Vatsal Sanjay Email : vatsalsanjay@gmail.com Institution : Physics of Fluids Last Updated : Nov 23, 2024 Implementation Notes Based on http://basilisk.fr/src/log-conform.h with key improvements: Uses G-\u03bb formulation for better physical interpretation Fixes surface tension coupling bug where [\u03c3_p] = 0 & [\u03c3_s] = \u03b3\u03ba Ensures [\u03c3_s+\u03c3_p] = \u03b3\u03ba for correct interface behavior Version History v1.0 (Oct 18, 2024) Initial implementation with 2D+axi support Scalar-based implementation for efficiency v2.0 (Nov 3, 2024) Major documentation improvements Made code an axisymmetric mirror of log-conform-viscoelastic-scalar-3D.h Added negative eigenvalue detection with location reporting Added initialization functions for pseudo_v and pseudo_t v2.1 (Nov 14, 2024) Added support for infinite Deborah number cases v2.5 (Nov 23, 2024) Enhanced documentation clarity and completeness Future Work Tensor Formulation Convert to consistent tensor formulation for: Improved readability and maintainability Better computational efficiency Reduced potential for bugs Prerequisites for axi compatibility in 3D version Related issues: https://github.com/comphy-lab/Viscoelastic3D/issues/11 https://github.com/comphy-lab/Viscoelastic3D/issues/5 Code Improvements Enforce tensor usage throughout codebase Implement foreach_dimension compatibility The log-conformation method for viscoelastic constitutive models Introduction Viscoelastic fluids exhibit both viscous and elastic behaviour when subjected to deformation.",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Therefore these materials...",
    "content": "Therefore these materials are governed by the Navier\u2013Stokes equations enriched with an extra elastic stress \\(Tij\\) \\[ \\rho\\left[\\partial_t\\mathbf{u}+\\nabla\\cdot(\\mathbf{u}\\otimes\\mathbf{u})\\right] = - \\nabla p + \\nabla\\cdot(2\\mu_s\\mathbf{D}) + \\nabla\\cdot\\mathbf{T} + \\rho\\mathbf{a} \\] where \\(\\mathbf{D}=[\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^T]/2\\) is the deformation tensor and \\(\\mu_s\\) is the solvent viscosity of the viscoelastic fluid. The polymeric stress \\(\\mathbf{T}\\) represents memory effects due to the polymers. Several constitutive rheological models are available in the literature where the polymeric stress \\(\\mathbf{T}\\) is typically a function \\(\\mathbf{f_s}(\\cdot)\\) of the conformation tensor \\(\\mathbf{A}\\) such as \\[ \\mathbf{T} = G_p \\mathbf{f_s}(\\mathbf{A}) \\] where \\(G_p\\) is the elastic modulus and \\(\\mathbf{f_s}(\\cdot)\\) is the relaxation function.",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: The conformation tensor...",
    "content": "The conformation tensor \\(\\mathbf{A}\\) is related to the deformation of the polymer chains. \\(\\mathbf{A}\\) is governed by the equation \\[ D_t \\mathbf{A} - \\mathbf{A} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{A} = -\\frac{\\mathbf{f_r}(\\mathbf{A})}{\\lambda} \\] where \\(D_t\\) denotes the material derivative and \\(\\mathbf{f_r}(\\cdot)\\) is the relaxation function. Here, \\(\\lambda\\) is the relaxation time. In the case of an Oldroyd-B viscoelastic fluid, \\(\\mathbf{f}_s (\\mathbf{A}) = \\mathbf{f}_r (\\mathbf{A}) = \\mathbf{A} -\\mathbf{I}\\) , and the above equations can be combined to avoid the use of \\(\\mathbf{A}\\) \\[ \\mathbf{T} + \\lambda (D_t \\mathbf{T} - \\mathbf{T} \\cdot \\nabla \\mathbf{u} - \\nabla \\mathbf{u}^{T} \\cdot \\mathbf{T}) = 2 G_p\\lambda \\mathbf{D} \\] Comminal et al. (2015) gathered the functions \\(\\mathbf{f}_s (\\mathbf{A})\\) and \\(\\mathbf{f}_r (\\mathbf{A})\\) for different constitutive models.",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Parameters The primary...",
    "content": "Parameters The primary parameters are the relaxation time \\(\\lambda\\) and the elastic modulus \\(G_p\\) . The solvent viscosity \\(\\mu_s\\) is defined in the Navier-Stokes solver . Gp and lambda are defined in two-phaseVE.h . The log conformation approach The numerical resolution of viscoelastic fluid problems often faces the High-Weissenberg Number Problem . This is a numerical instability appearing when strongly elastic flows create regions of high stress and fine features. This instability poses practical limits to the values of the relaxation time of the viscoelastic fluid, \\(\\lambda\\) . Fattal & Kupferman (2004, 2005) identified the exponential nature of the solution as the origin of the instability. They proposed to use the logarithm of the conformation tensor \\(\\Psi = \\log \\, \\mathbf{A}\\) rather than the viscoelastic stress tensor to circumvent the instability.",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: The constitutive equation...",
    "content": "The constitutive equation for the log of the conformation tensor is \\[ D_t \\Psi = (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) + 2 \\mathbf{B} + \\frac{e^{-\\Psi} \\mathbf{f}_r (e^{\\Psi})}{\\lambda} \\] where \\(\\Omega\\) and \\(\\mathbf{B}\\) are tensors that result from the decomposition of the transpose of the tensor gradient of the velocity \\[ (\\nabla \\mathbf{u})^T = \\Omega + \\mathbf{B} + N \\mathbf{A}^{-1} \\] The antisymmetric tensor \\(\\Omega\\) requires only the memory of a scalar in 2D since, \\[ \\Omega = \\left( \\begin{array}{cc} 0 & \\Omega_{12} \\\\ -\\Omega_{12} & 0 \\end{array} \\right) \\] For 3D, \\(\\Omega\\) is a skew-symmetric tensor given by \\[ \\Omega = \\left( \\begin{array}{ccc} 0 & \\Omega_{12} & \\Omega_{13} \\\\ -\\Omega_{12} & 0 & \\Omega_{23} \\\\ -\\Omega_{13} & -\\Omega_{23} & 0 \\end{array} \\right) \\] The log-conformation tensor, \\(\\Psi\\) , is related to the polymeric stress tensor \\(\\mathbf{T}\\) , by the strain function \\(\\mathbf{f}_s (\\mathbf{A})\\) \\[ \\Psi = \\log \\, \\mathbf{A} \\quad \\mathrm{and} \\quad \\mathbf{T} = \\frac{G_p}{\\lambda} \\mathbf{f}_s (\\mathbf{A}) \\] where \\(Tr\\) denotes the trace of the tensor and \\(L\\) is an additional property of the viscoelastic fluid.",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: We will use...",
    "content": "We will use the Bell\u2013Collela\u2013Glaz scheme to advect the log-conformation tensor \\(\\Psi\\) .",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: TODO: - Perhaps,...",
    "content": "TODO: - Perhaps, instead of the Bell\u2013Collela\u2013Glaz scheme, we can use the conservative form of the advection equation and transport the log-conformation tensor with the VoF color function, similar to http://basilisk.fr/src/navier-stokes/conserving.h #include \"bcg.h\" ( const ) scalar Gp = unity ; // elastic modulus ( const ) scalar lambda = unity ; // relaxation time scalar A11 [], A12 [], A22 []; // conformation tensor scalar T11 [], T12 [], T22 []; // stress tensor #if AXI scalar AThTh [], T_ThTh []; #endif event defaults ( i = 0 ) { if ( is_constant ( a . x )) a = new face vector ; /* initialize A and T */ for ( scalar s in { A11 , A22 }) { foreach () { s [] = 1. ; } } for ( scalar s in { T11 , T12 , T22 , A12 }) { foreach (){ s [] = 0. ; } } #if AXI foreach (){ T_ThTh [] = 0 ; AThTh [] = 1. ; } #endif for ( scalar s in { T11 , T12 , T22 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } for ( scalar s in { A11 , A12 , A22 }) { if ( s . boundary [ left ] != periodic_bc ) { s [ left ] = neumann ( 0 ); s [ right ] = neumann ( 0 ); } } #if AXI T12 [ bottom ] = dirichlet ( 0. ); A12 [ bottom ] = dirichlet ( 0. ); #endif } Useful functions in 2D The first step is to implement a routine to calculate the eigenvalues and eigenvectors of the conformation tensor \\(\\mathbf{A}\\) .",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Python Function",
    "content": "These structs ressemble Basilisk vectors and tensors but are just arrays not related to the grid. typedef struct { double x , y ;} pseudo_v ; typedef struct { pseudo_v x , y ;} pseudo_t ; // Function to initialize pseudo_v static inline void init_pseudo_v ( pseudo_v * v , double value ) { v -> x = value ; v -> y = value ; } // Function to initialize pseudo_t static inline void init_pseudo_t ( pseudo_t * t , double value ) { init_pseudo_v (& t -> x , value ); init_pseudo_v (& t -> y , value ); } static void diagonalization_2D ( pseudo_v * Lambda , pseudo_t * R , pseudo_t * A ) { The eigenvalues are saved in vector \\(\\Lambda\\) computed from the trace and the determinant of the symmetric conformation tensor \\(\\mathbf{A}\\) . if ( sq ( A -> x . y ) < 1e-15 ) { R -> x . x = R -> y . y = 1. ; R -> y . x = R -> x . y = 0. ; Lambda -> x = A -> x . x ; Lambda -> y = A -> y . y ; return ; } double T = A -> x . x + A -> y . y ; // Trace of the tensor double D = A -> x . x * A -> y . y - sq ( A -> x . y ); // Determinant The eigenvectors, \\(\\mathbf{v}_i\\) are saved by columns in tensor \\(\\mathbf{R} = (\\mathbf{v}_1|\\mathbf{v}_2)\\) .",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Context",
    "content": "R -> x . x = R -> x . y = A -> x . y ; R -> y . x = R -> y . y = - A -> x . x ; double s = 1. ; for ( int i = 0 ; i < dimension ; i ++) { double * ev = ( double *) Lambda ; ev [ i ] = T / 2 + s * sqrt ( sq ( T )/ 4. - D ); s *= - 1 ; double * Rx = ( double *) & R -> x ; double * Ry = ( double *) & R -> y ; Ry [ i ] += ev [ i ]; double mod = sqrt ( sq ( Rx [ i ]) + sq ( Ry [ i ])); Rx [ i ] /= mod ; Ry [ i ] /= mod ; } } The stress tensor depends on previous instants and has to be integrated in time. In the log-conformation scheme the advection of the stress tensor is circumvented, instead the conformation tensor, \\(\\mathbf{A}\\) (or more precisely the related variable \\(\\Psi\\) ) is advanced in time. In what follows we will adopt a scheme similar to that of Hao & Pan (2007) .",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: We use a...",
    "content": "We use a split scheme, solving successively the upper convective term: \\[ \\partial_t \\Psi = 2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega) \\] the advection term: \\[ \\partial_t \\Psi + \\nabla \\cdot (\\Psi \\mathbf{u}) = 0 \\] the model term (but set in terms of the conformation tensor \\(\\mathbf{A}\\) ).",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: In an Oldroyd-B...",
    "content": "In an Oldroyd-B viscoelastic fluid, the model is \\[ \\partial_t \\mathbf{A} = -\\frac{\\mathbf{f}_r (\\mathbf{A})}{\\lambda} \\] event tracer_advection ( i ++) { scalar Psi11 = A11 ; scalar Psi12 = A12 ; scalar Psi22 = A22 ; #if AXI scalar Psiqq = AThTh ; #endif Computation of \\(\\Psi = \\log \\mathbf{A}\\) and upper convective term foreach () { We assume that the stress tensor \\(\\mathbf{\\tau}_p\\) depends on the conformation tensor \\(\\mathbf{A}\\) as follows \\[ \\mathbf{\\tau}_p = G_p (\\mathbf{A}) = G_p (\\mathbf{A} - I) \\] pseudo_t A ; A . x . x = A11 []; A . y . y = A22 []; A . x . y = A12 []; #if AXI double Aqq = AThTh []; Psiqq [] = log ( Aqq ); #endif The conformation tensor is diagonalized through the eigenvector tensor \\(\\mathbf{R}\\) and the eigenvalues diagonal tensor, \\(\\Lambda\\) . pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); pseudo_t R ; init_pseudo_t (& R , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); /* Check for negative eigenvalues -- this should never happen.",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: If it does,...",
    "content": "If it does, print the location and value of the offending eigenvalue. Please report this bug by opening an issue on the GitHub repository. */ if ( Lambda . x <= 0. || Lambda . y <= 0. ) { fprintf ( ferr , \"Negative eigenvalue detected: Lambda.x = %g , Lambda.y = %g\\n \" , Lambda . x , Lambda . y ); fprintf ( ferr , \"x = %g , y = %g\\n \" , x , y ); exit ( 1 ); } \\(\\Psi = \\log \\mathbf{A}\\) is easily obtained after diagonalization, \\(\\Psi = R \\cdot \\log(\\Lambda) \\cdot R^T\\) . Psi12 [] = R . x . x * R . y . x * log ( Lambda . x ) + R . y . y * R . x . y * log ( Lambda . y ); Psi11 [] = sq ( R . x . x )* log ( Lambda . x ) + sq ( R . x . y )* log ( Lambda . y ); Psi22 [] = sq ( R . y . y )* log ( Lambda . y ) + sq ( R . y . x )* log ( Lambda . x ); We now compute the upper convective term \\(2 \\mathbf{B} + (\\Omega \\cdot \\Psi -\\Psi \\cdot \\Omega)\\) .",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: The diagonalization will...",
    "content": "The diagonalization will be applied to the velocity gradient \\((\\nabla u)^T\\) to obtain the antisymmetric tensor \\(\\Omega\\) and the traceless, symmetric tensor, \\(\\mathbf{B}\\) . If the conformation tensor is \\(\\mathbf{I}\\) , \\(\\Omega = 0\\) and \\(\\mathbf{B}= \\mathbf{D}\\) . Otherwise, compute M = R * (nablaU)^T * R^T, where nablaU is the velocity gradient tensor. Then, Calculate omega using the off-diagonal elements of M and eigenvalues: omega = (Lambda.y M.x.y + Lambda.x M.y.x)/(Lambda.y - Lambda.x) This represents the rotation rate in the eigenvector basis. Transform omega back to physical space to get OM: OM = (R.x.x R.y.y - R.x.y R.y.x)*omega This gives us the rotation tensor Omega in the original coordinate system.",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Compute B tensor...",
    "content": "Compute B tensor components using M and R: B is related to M and R through: In 2D: \\[ B_{xx} = R_{xx}^2 M_{xx} + R_{xy}^2 M_{yy} \\\\ B_{xy} = R_{xx}R_{yx} M_{xx} + R_{xy}R_{yy} M_{yy} \\\\ B_{yx} = B_{xy} \\\\ B_{yy} = -B_{xx} \\] Where: R is the eigenvector matrix of the conformation tensor M is the velocity gradient tensor in the eigenvector basis The construction ensures B is symmetric and traceless pseudo_t B ; init_pseudo_t (& B , 0.0 ); double OM = 0. ; if ( fabs ( Lambda . x - Lambda . y ) <= 1e-20 ) { B . x . y = ( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ])/( 4. * Delta ); foreach_dimension () B . x . x = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ])/( 2. * Delta ); } else { pseudo_t M ; init_pseudo_t (& M , 0.0 ); foreach_dimension () { M . x . x = ( sq ( R . x . x )*( u . x [ 1 ] - u . x [- 1 ]) + sq ( R . y . x )*( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]) + R . x . x * R . y . x *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ] + u . y [ 1 ] - u . y [- 1 ]))/( 2. * Delta ); M . x . y = ( R . x . x * R . x . y *( u . x [ 1 ] - u . x [- 1 ]) + R . x . y * R . y . x *( u . y [ 1 ] - u . y [- 1 ]) + R . x . x * R . y . y *( u . x [ 0 , 1 ] - u . x [ 0 ,- 1 ]) + R . y . x * R . y . y *( u . y [ 0 , 1 ] - u . y [ 0 ,- 1 ]))/( 2. * Delta ); } double omega = ( Lambda . y * M . x . y + Lambda . x * M . y . x )/( Lambda . y - Lambda . x ); OM = ( R . x . x * R . y . y - R . x . y * R . y . x )* omega ; B . x . y = M . x . x * R . x . x * R . y . x + M . y . y * R . y . y * R . x . y ; foreach_dimension () B . x . x = M . x . x * sq ( R . x . x )+ M . y . y * sq ( R . x . y ); } We now advance \\(\\Psi\\) in time, adding the upper convective contribution. double s = - Psi12 []; Psi12 [] += dt * ( 2. * B . x . y + OM * ( Psi22 [] - Psi11 [])); s *= - 1 ; Psi11 [] += dt * 2. * ( B . x . x + s * OM ); s *= - 1 ; Psi22 [] += dt * 2. * ( B . y . y + s * OM ); In the axisymmetric case, the governing equation for \\(\\Psi_{\\theta \\theta}\\) only involves that component, \\[ \\Psi_{\\theta \\theta}|_t - 2 L_{\\theta \\theta} = \\frac{\\mathbf{f}_r(e^{-\\Psi_{\\theta \\theta}})}{\\lambda} \\] with \\(L_{\\theta \\theta} = u_y/y\\) .",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Therefore step (a)...",
    "content": "Therefore step (a) for \\(\\Psi_{\\theta \\theta}\\) is #if AXI Psiqq [] += dt * 2. * u . y []/ max ( y , 1e-20 ); #endif } Advection of \\(\\Psi\\) We proceed with step (b), the advection of the log of the conformation tensor \\(\\Psi\\) . #if AXI advection ({ Psi11 , Psi12 , Psi22 , Psiqq }, uf , dt ); #else advection ({ Psi11 , Psi12 , Psi22 }, uf , dt ); #endif Convert back to Aij foreach () { It is time to undo the log-conformation, again by diagonalization, to recover the conformation tensor \\(\\mathbf{A}\\) and to perform step (c). pseudo_t A = {{ Psi11 [], Psi12 []}, { Psi12 [], Psi22 []}}, R ; init_pseudo_t (& R , 0.0 ); pseudo_v Lambda ; init_pseudo_v (& Lambda , 0.0 ); diagonalization_2D (& Lambda , & R , & A ); Lambda . x = exp ( Lambda . x ), Lambda . y = exp ( Lambda . y ); A . x . y = R . x . x * R . y . x * Lambda . x + R . y . y * R . x . y * Lambda . y ; foreach_dimension () A . x . x = sq ( R . x . x )* Lambda . x + sq ( R . x . y )* Lambda . y ; #if AXI double Aqq = exp ( Psiqq []); #endif We perform now step (c) by integrating \\(\\mathbf{A}_t = -\\mathbf{f}_r (\\mathbf{A})/\\lambda\\) to obtain \\(\\mathbf{A}^{n+1}\\) .",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: This step is...",
    "content": "This step is analytic, \\[ \\int_{t^n}^{t^{n+1}}\\frac{d \\mathbf{A}}{\\mathbf{I}- \\mathbf{A}} = \\frac{\\Delta t}{\\lambda} \\] double intFactor = ( lambda [] != 0. ? ( lambda [] == 1e30 ? 1 : exp (- dt / lambda [])): 0. ); #if AXI Aqq = ( 1. - intFactor ) + intFactor * exp ( Psiqq []); #endif A . x . y *= intFactor ; foreach_dimension () A . x . x = ( 1. - intFactor ) + A . x . x * intFactor ; Then the Conformation tensor \\(\\mathcal{A}_p^{n+1}\\) is restored from \\(\\mathbf{A}^{n+1}\\) . A12 [] = A . x . y ; T12 [] = Gp []* A . x . y ; #if AXI AThTh [] = Aqq ; T_ThTh [] = Gp []*( Aqq - 1. ); #endif A11 [] = A . x . x ; T11 [] = Gp []*( A . x . x - 1. ); A22 [] = A . y . y ; T22 [] = Gp []*( A . y . y - 1. ); } } Divergence of the viscoelastic stress tensor The viscoelastic stress tensor \\(\\mathbf{\\tau}_p\\) is defined at cell centers while the corresponding force (acceleration) will be defined at cell faces. Two terms contribute to each component of the momentum equation.",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Examples",
    "content": "For example the \\(x\\) -component in Cartesian coordinates has the following terms: \\(\\partial_x \\mathbf{\\tau}_{p_{xx}} + \\partial_y \\mathbf{\\tau}_{p_{xy}}\\) . The first term is easy to compute since it can be calculated directly from center values of cells sharing the face. The other one is harder. It will be computed from vertex values. The vertex values are obtained by averaging centered values.",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology: Results",
    "content": "Note that as a result of the vertex averaging cells [] and [-1,0] are not involved in the computation of shear. event acceleration ( i ++) { face vector av = a ; foreach_face ( x ){ if ( fm . x [] > 1e-20 ) { double shearX = ( T12 [ 0 , 1 ]* cm [ 0 , 1 ] + T12 [- 1 , 1 ]* cm [- 1 , 1 ] - T12 [ 0 ,- 1 ]* cm [ 0 ,- 1 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . x [] += ( shearX + cm []* T11 [] - cm [- 1 ]* T11 [- 1 ])* alpha . x []/( sq ( fm . x [])* Delta ); } } foreach_face ( y ){ if ( fm . y [] > 1e-20 ) { double shearY = ( T12 [ 1 , 0 ]* cm [ 1 , 0 ] + T12 [ 1 ,- 1 ]* cm [ 1 ,- 1 ] - T12 [- 1 , 0 ]* cm [- 1 , 0 ] - T12 [- 1 ,- 1 ]* cm [- 1 ,- 1 ])/ 4. ; av . y [] += ( shearY + cm []* T22 [] - cm [ 0 ,- 1 ]* T22 [ 0 ,- 1 ])* alpha . y []/( sq ( fm . y [])* Delta ); } } #if AXI foreach_face ( y ) if ( y > 1e-20 ) av . y [] -= ( T_ThTh [] + T_ThTh [ 0 ,- 1 ])* alpha . y []/ sq ( y )/ 2. ; #endif }",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - C/C++ Code: C/C++ Code",
    "content": "#include\"bcg.h\"(const)scalar Gp=unity;// elastic modulus(const)scalar lambda=unity;// relaxation timescalar A11[],A12[],A22[];// conformation tensorscalar T11[],T12[],T22[];// stress tensor#if AXIscalar AThTh[],T_ThTh[];#endifevent defaults(i=0){if(is_constant(a.x))a=new face vector;/*initialize A and T*/for(scalar s in{A11,A22}){foreach(){s[]=1.;}}for(scalar s in{T11,T12,T22,A12}){foreach(){s[]=0.;}}#if AXIforeach(){T_ThTh[]=0;AThTh[]=1.;}#endiffor(scalar s in{T11,T12,T22}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}for(scalar s in{A11,A12,A22}){if(s.boundary[left]!=periodic_bc){s[left]=neumann(0);s[right]=neumann(0);}}#if AXIT12[bottom]=dirichlet(0.);A12[bottom]=dirichlet(0.);#endif}",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "typedefstruct{doublex,y;}pseudo_v;typedefstruct{pseudo_v x,y;}pseudo_t;// Function to initialize pseudo_vstaticinlinevoidinit_pseudo_v(pseudo_v*v,doublevalue){v->x=value;v->y=value;}// Function to initialize pseudo_tstaticinlinevoidinit_pseudo_t(pseudo_t*t,doublevalue){init_pseudo_v(&t->x,value);init_pseudo_v(&t->y,value);}staticvoiddiagonalization_2D(pseudo_v*Lambda,pseudo_t*R,pseudo_t*A){",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "if(sq(A->x.y)<1e-15){R->x.x=R->y.y=1.;R->y.x=R->x.y=0.;Lambda->x=A->x.x;Lambda->y=A->y.y;return;}doubleT=A->x.x+A->y.y;// Trace of the tensordoubleD=A->x.x*A->y.y-sq(A->x.y);// Determinant",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "R->x.x=R->x.y=A->x.y;R->y.x=R->y.y=-A->x.x;doubles=1.;for(inti=0;i<dimension;i++){double*ev=(double*)Lambda;ev[i]=T/2+s*sqrt(sq(T)/4.-D);s*=-1;double*Rx=(double*)&R->x;double*Ry=(double*)&R->y;Ry[i]+=ev[i];doublemod=sqrt(sq(Rx[i])+sq(Ry[i]));Rx[i]/=mod;Ry[i]/=mod;}}",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "event tracer_advection(i++){scalar Psi11=A11;scalar Psi12=A12;scalar Psi22=A22;#if AXIscalar Psiqq=AThTh;#endif",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "pseudo_t A;A.x.x=A11[];A.y.y=A22[];A.x.y=A12[];#if AXIdoubleAqq=AThTh[];Psiqq[]=log(Aqq);#endif",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);pseudo_t R;init_pseudo_t(&R,0.0);diagonalization_2D(&Lambda,&R,&A);/*Check for negative eigenvalues -- this should never happen. If it does, print the location and value of the offending eigenvalue.Please report this bug by opening an issue on the GitHub repository.*/if(Lambda.x<=0.||Lambda.y<=0.){fprintf(ferr,\"Negative eigenvalue detected: Lambda.x =%g, Lambda.y =%g\\n\",Lambda.x,Lambda.y);fprintf(ferr,\"x =%g, y =%g\\n\",x,y);exit(1);}",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "Psi12[]=R.x.x*R.y.x*log(Lambda.x)+R.y.y*R.x.y*log(Lambda.y);Psi11[]=sq(R.x.x)*log(Lambda.x)+sq(R.x.y)*log(Lambda.y);Psi22[]=sq(R.y.y)*log(Lambda.y)+sq(R.y.x)*log(Lambda.x);",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: Context",
    "content": "pseudo_t B;init_pseudo_t(&B,0.0);doubleOM=0.;if(fabs(Lambda.x-Lambda.y)<=1e-20){B.x.y=(u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(4.*Delta);foreach_dimension()B.x.x=(u.x[1,0]-u.x[-1,0])/(2.*Delta);}else{pseudo_t M;init_pseudo_t(&M,0.0);foreach_dimension(){M.x.x=(sq(R.x.x)*(u.x[1]-u.x[-1])+sq(R.y.x)*(u.y[0,1]-u.y[0,-1])+R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1]+u.y[1]-u.y[-1]))/(2.*Delta);M.x.y=(R.x.x*R.x.y*(u.x[1]-u.x[-1])+R.x.y*R.y.x*(u.y[1]-u.y[-1])+R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1])+R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);}doubleomega=(Lambda.y*M.x.y+Lambda.x*M.y.x)/(Lambda.y-Lambda.x);OM=(R.x.x*R.y.y-R.x.y*R.y.x)*omega;B.x.y=M.x.x*R.x.x*R.y.x+M.y.y*R.y.y*R.x.y;foreach_dimension()B.x.x=M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);}",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "doubles=-Psi12[];Psi12[]+=dt*(2.*B.x.y+OM*(Psi22[]-Psi11[]));s*=-1;Psi11[]+=dt*2.*(B.x.x+s*OM);s*=-1;Psi22[]+=dt*2.*(B.y.y+s*OM);",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "#if AXIadvection({Psi11,Psi12,Psi22,Psiqq},uf,dt);#elseadvection({Psi11,Psi12,Psi22},uf,dt);#endif",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "pseudo_t A={{Psi11[],Psi12[]},{Psi12[],Psi22[]}},R;init_pseudo_t(&R,0.0);pseudo_v Lambda;init_pseudo_v(&Lambda,0.0);diagonalization_2D(&Lambda,&R,&A);Lambda.x=exp(Lambda.x),Lambda.y=exp(Lambda.y);A.x.y=R.x.x*R.y.x*Lambda.x+R.y.y*R.x.y*Lambda.y;foreach_dimension()A.x.x=sq(R.x.x)*Lambda.x+sq(R.x.y)*Lambda.y;#if AXIdoubleAqq=exp(Psiqq[]);#endif",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "doubleintFactor=(lambda[]!=0.?(lambda[]==1e30?1:exp(-dt/lambda[])):0.);#if AXIAqq=(1.-intFactor)+intFactor*exp(Psiqq[]);#endifA.x.y*=intFactor;foreach_dimension()A.x.x=(1.-intFactor)+A.x.x*intFactor;",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "A12[]=A.x.y;T12[]=Gp[]*A.x.y;#if AXIAThTh[]=Aqq;T_ThTh[]=Gp[]*(Aqq-1.);#endifA11[]=A.x.x;T11[]=Gp[]*(A.x.x-1.);A22[]=A.y.y;T22[]=Gp[]*(A.y.y-1.);}}",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/log-conform-viscoelastic-scalar-2D.h | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: event acceleration(i++){face vector...",
    "content": "event acceleration(i++){face vector av=a;foreach_face(x){if(fm.x[]>1e-20){doubleshearX=(T12[0,1]*cm[0,1]+T12[-1,1]*cm[-1,1]-T12[0,-1]*cm[0,-1]-T12[-1,-1]*cm[-1,-1])/4.;av.x[]+=(shearX+cm[]*T11[]-cm[-1]*T11[-1])*alpha.x[]/(sq(fm.x[])*Delta);}}foreach_face(y){if(fm.y[]>1e-20){doubleshearY=(T12[1,0]*cm[1,0]+T12[1,-1]*cm[1,-1]-T12[-1,0]*cm[-1,0]-T12[-1,-1]*cm[-1,-1])/4.;av.y[]+=(shearY+cm[]*T22[]-cm[0,-1]*T22[0,-1])*alpha.y[]/(sq(fm.y[])*Delta);}}#if AXIforeach_face(y)if(y>1e-20)av.y[]-=(T_ThTh[]+T_ThTh[0,-1])*alpha.y[]/sq(y)/2.;#endif}",
    "url": "https://comphy-lab.org/fiber/src-local/log-conform-viscoelastic-scalar-2D.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getData-elastic-scalar2D.c This program extracts and processes data from fluid dynamics simulation snapshots, specifically designed for viscoela... getFacet2D.c A utility for extracting interface facets from fluid simulation data. VideoAxi.py Viscoelastic Visualization Tool =========================================== This script processes and visualizes flui...",
    "url": "https://comphy-lab.org/fiber/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | FIBER: Flow-Induced Breakup of Elastic Rheology: Context",
    "content": "postProcess/VideoAxi.py See raw file #!/usr/bin/env python3 # -*- coding: utf-8 -*- Viscoelastic Visualization Tool This script processes and visualizes fluid dynamics simulation data, particularly focused on droplet impact and deformable soft matter like liquid drops, sheets, and bubbles. It extracts interface positions and scalar field data from simulation files and creates visualizations showing physical quantities like strain rates and stresses. The script is designed to process multiple simulation snapshots in parallel, extracting data using external executables and generating visualizations with proper colormaps, scales, and mathematical labels.",
    "url": "https://comphy-lab.org/fiber/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | FIBER: Flow-Induced Breakup of Elastic Rheology: Features: - Extracts...",
    "content": "Features: - Extracts fluid interfaces and scalar fields from simulation files - Generates visualizations with proper colormaps and mathematical labels - Processes multiple timesteps in parallel using multiprocessing - Configurable via command-line arguments for different simulation cases - Creates publication-quality figures with LaTeX-rendered mathematical expressions Usage: python fluid_vis.py [options] Command-line Arguments: \u2013CPUs Number of CPUs to use for parallel processing (default: all available) \u2013nGFS Number of restart files to process (default: 550) \u2013ZMAX Maximum Z coordinate for visualization (default: 4.0) \u2013RMAX Maximum R coordinate for visualization (default: 2.0) \u2013ZMIN Minimum Z coordinate for visualization (default: -4.0) \u2013caseToProcess Path to simulation case directory (default: \u2018../simulationCases/dropImpact\u2019) \u2013folderToSave Directory to save visualization images (default: \u2018dropImpact\u2019) Dependencies: External executables: getFacet2D, getData-elastic-scalar2D Python libraries: numpy, matplotlib, subprocess, multiprocessing Author: Vatsal Sanjay Email: vatsalsanjay@gmail.com Affiliation: Physics of Fluids Last updated: Jul 24, 2024 import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt from matplotlib.collections import LineCollection from matplotlib.ticker import StrMethodFormatter import multiprocessing as mp from functools import partial import argparse import matplotlib.colors as mcolors custom_colors = [ \"white\" , \"#DA8A67\" , \"#A0522D\" , \"#400000\" ] custom_cmap = mcolors.LinearSegmentedColormap.from_list( \"custom_hot\" , custom_colors) # Configure matplotlib for publication-quality figures with LaTeX rendering matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True matplotlib.rcParams[ 'text.latex.preamble' ] = r' \\ usepackage{amsmath}' def gettingFacets(filename, includeCoat = 'true' ): Extract interface positions (facets) from simulation files.",
    "url": "https://comphy-lab.org/fiber/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | FIBER: Flow-Induced Breakup of Elastic Rheology: Args: filename (str):...",
    "content": "Args: filename (str): Path to simulation snapshot file includeCoat (str, optional): Whether to include coating layer. Defaults to \u2018true\u2019. Returns: list: List of line segments defining fluid interfaces exe = [ \"./getFacet2D\" , filename, includeCoat] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) segs = [] skip = False if ( len (temp2) > 1e2 ): for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: skip = False pass else : if not skip: temp4 = temp2[n1 + 1 ].split( \" \" ) r1, z1 = np.array([ float (temp3[ 1 ]), float (temp3[ 0 ])]) r2, z2 = np.array([ float (temp4[ 1 ]), float (temp4[ 0 ])]) segs.append(((r1, z1),(r2, z2))) segs.append((( - r1, z1),( - r2, z2))) skip = True return segs def gettingfield(filename, zmin, zmax, rmax, nr): Extract scalar field data from simulation files.",
    "url": "https://comphy-lab.org/fiber/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | FIBER: Flow-Induced Breakup of Elastic Rheology: Args: filename (str):...",
    "content": "Args: filename (str): Path to simulation snapshot file zmin (float): Minimum Z coordinate zmax (float): Maximum Z coordinate rmax (float): Maximum R coordinate nr (int): Number of grid points in R direction Returns: tuple: (R, Z, D2, vel, taup, nz) arrays of coordinates and field values exe = [ \"./getData-elastic-scalar2D\" , filename, str (zmin), str ( 0 ), str (zmax), str (rmax), str (nr)] p = sp.Popen(exe, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() temp1 = stderr.decode( \"utf-8\" ) temp2 = temp1.split( \" \\n \" ) # print(temp2) #debugging Rtemp, Ztemp, D2temp, veltemp, taupTemp = [],[],[],[],[] for n1 in range ( len (temp2)): temp3 = temp2[n1].split( \" \" ) if temp3 == [ '' ]: pass else : Ztemp.append( float (temp3[ 0 ])) Rtemp.append( float (temp3[ 1 ])) D2temp.append( float (temp3[ 2 ])) veltemp.append( float (temp3[ 3 ])) taupTemp.append( float (temp3[ 4 ])) R = np.asarray(Rtemp) Z = np.asarray(Ztemp) D2 = np.asarray(D2temp) vel = np.asarray(veltemp) taup = np.asarray(taupTemp) nz = int ( len (Z) / nr) # print(\"nr is %d %d\" % (nr, len(R))) # debugging print ( \"nz is %d \" % nz) R.resize((nz, nr)) Z.resize((nz, nr)) D2.resize((nz, nr)) vel.resize((nz, nr)) taup.resize((nz, nr)) return R, Z, D2, vel, taup, nz # ---------------------------------------------------------------------------------------------------------------------- def process_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw, caseToProcess): Process a single timestep from simulation data and generate visualization.",
    "url": "https://comphy-lab.org/fiber/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | FIBER: Flow-Induced Breakup of Elastic Rheology: Args: ti (int):...",
    "content": "Args: ti (int): Timestep index folder (str): Directory to save output images nGFS (int): Total number of timesteps GridsPerR (int): Grid points per unit length in R direction rmin (float): Minimum R coordinate rmax (float): Maximum R coordinate zmin (float): Minimum Z coordinate zmax (float): Maximum Z coordinate lw (float): Line width for plot elements caseToProcess (str): Path to simulation case directory t = 0.01 * ti place = f\" { caseToProcess } /intermediate/snapshot- { t :.4f} \" name = f\" { folder } / { int (t * 1000 ) :08d} .png\" if not os.path.exists(place): print ( f\" { place } File not found!\" ) return if os.path.exists(name): print ( f\" { name } Image present!\" ) return segs1 = gettingFacets(place) segs2 = gettingFacets(place, 'false' ) if not segs1 and not segs2: print ( f\"Problem in the available file { place } \" ) return nr = int (GridsPerR * rmax) R, Z, taus, vel, taup, nz = gettingfield(place, zmin, zmax, rmax, nr) zminp, zmaxp, rminp, rmaxp = Z. min (), Z. max (), R. min (), R. max () # Plotting AxesLabel, TickLabel = 50 , 20 fig, ax = plt.subplots() fig.set_size_inches( 19.20 , 10.80 ) # Draw domain boundaries ax.plot([ 0 , 0 ], [zmin, zmax], '-.' , color = 'grey' , linewidth = lw) ax.plot([rmin, rmin], [zmin, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmin, zmin], '-' , color = 'black' , linewidth = lw) ax.plot([rmin, rmax], [zmax, zmax], '-' , color = 'black' , linewidth = lw) ax.plot([rmax, rmax], [zmin, zmax], '-' , color = 'black' , linewidth = lw) # Add fluid interfaces line_segments = LineCollection(segs2, linewidths = 4 , colors = 'green' , linestyle = 'solid' ) ax.add_collection(line_segments) line_segments = LineCollection(segs1, linewidths = 4 , colors = 'blue' , linestyle = 'solid' ) ax.add_collection(line_segments) # Plot scalar fields with colormaps cntrl1 = ax.imshow(taus, cmap = \"hot_r\" , interpolation = 'Bilinear' , origin = 'lower' , extent = [ - rminp, - rmaxp, zminp, zmaxp], vmax = 2.0 , vmin =- 3.0 ) # TODO : fixme the colorbar bounds for taup must be set manually based on the simulated case. cntrl2 = ax.imshow(taup, interpolation = 'Bilinear' , cmap = custom_cmap, origin = 'lower' , extent = [rminp, rmaxp, zminp, zmaxp], vmax = 2.0 , vmin =- 3.0 ) # Set plot properties ax.set_aspect( 'equal' ) ax.set_xlim(rmin, rmax) ax.set_ylim(zmin, zmax) ax.set_title( f'$t/ \\\\ tau_ \\\\ gamma$ = { t :4.3f} ' , fontsize = TickLabel) # Add colorbars l, b, w, h = ax.get_position().bounds # Left colorbar cb1 = fig.add_axes([l - 0.04 , b, 0.03 , h]) c1 = plt.colorbar(cntrl1, cax = cb1, orientation = 'vertical' ) c1.set_label( r' $ \\ log_ {10} \\ left ( \\| \\m athcal{D} \\|\\r ight ) $ ' , fontsize = TickLabel, labelpad = 5 ) c1.ax.tick_params(labelsize = TickLabel) c1.ax.yaxis.set_ticks_position( 'left' ) c1.ax.yaxis.set_label_position( 'left' ) c1.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.1f} ' )) # Right colorbar cb2 = fig.add_axes([l + w + 0.01 , b, 0.03 , h]) c2 = plt.colorbar(cntrl2, cax = cb2, orientation = 'vertical' ) c2.ax.tick_params(labelsize = TickLabel) c2.set_label( r' $ \\ log_ {10} \\ left ( \\t ext{tr} \\ left ( \\m athcal{A} \\r ight ) -1 \\r ight ) $ ' , fontsize = TickLabel) c2.ax.yaxis.set_major_formatter(StrMethodFormatter( ' {x:,.2f} ' )) ax.axis( 'off' ) plt.savefig(name, bbox_inches = \"tight\" ) plt.close() def main(): Main function that parses command-line arguments and parallelizes processing of timesteps. # Set up command-line argument parsing parser = argparse.ArgumentParser(description = 'Process fluid dynamics simulation data and create visualizations' ) parser.add_argument( '--CPUs' , type = int , default = mp.cpu_count(), help = 'Number of CPUs to use (default: all available)' ) parser.add_argument( '--nGFS' , type = int , default = 550 , help = 'Number of restart files to process (default: 550)' ) parser.add_argument( '--ZMAX' , type = float , default = 4.0 , help = 'Maximum Z value (default: 4.0)' ) parser.add_argument( '--RMAX' , type = float , default = 2.0 , help = 'Maximum R value (default: 2.0)' ) parser.add_argument( '--ZMIN' , type = float , default =- 4.0 , help = 'Minimum Z value (default: -4.0)' ) parser.add_argument( '--caseToProcess' , type = str , default = '../simulationCases/dropImpact' , help = 'Case to process (default: ../simulationCases/dropImpact)' ) parser.add_argument( '--folderToSave' , type = str , default = 'dropImpact' , help = 'Folder to save output images (default: dropImpact)' ) args = parser.parse_args() # Extract arguments CPUStoUse = args.CPUs nGFS = args.nGFS ZMAX = args.ZMAX RMAX = args.RMAX ZMIN = args.ZMIN num_processes = CPUStoUse rmin, rmax, zmin, zmax = [ - RMAX, RMAX, ZMIN, ZMAX] GridsPerR = 128 # Grid resolution parameter lw = 2 # Line width for plot elements folder = args.folderToSave caseToProcess = args.caseToProcess # Create output directory if it doesn't exist if not os.path.isdir(folder): os.makedirs(folder) # Create a pool of worker processes for parallel processing with mp.Pool(processes = num_processes) as pool: # Create partial function with fixed arguments process_func = partial(process_timestep, folder = folder, nGFS = nGFS, GridsPerR = GridsPerR, rmin = rmin, rmax = rmax, zmin = zmin, zmax = zmax, lw = lw, caseToProcess = caseToProcess) # Map the process_func to all timesteps pool. map (process_func, range (nGFS)) if __name__ == \"__main__\" : main()",
    "url": "https://comphy-lab.org/fiber/postProcess/VideoAxi.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: Methods",
    "content": "importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltfrommatplotlib.collectionsimportLineCollectionfrommatplotlib.tickerimportStrMethodFormatterimportmultiprocessingasmpfromfunctoolsimportpartialimportargparseimportmatplotlib.colorsasmcolorscustom_colors=[\"white\",\"#DA8A67\",\"#A0522D\",\"#400000\"]custom_cmap=mcolors.LinearSegmentedColormap.from_list(\"custom_hot\", custom_colors)# Configure matplotlib for publication-quality figures with LaTeX renderingmatplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=Truematplotlib.rcParams['text.latex.preamble']=r'\\usepackage{amsmath}'defgettingFacets(filename, includeCoat='true'):",
    "url": "https://comphy-lab.org/fiber/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: Context",
    "content": "exe=[\"./getFacet2D\", filename, includeCoat]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")segs=[]skip=Falseif(len(temp2)>1e2):forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:skip=Falsepasselse:ifnotskip:temp4=temp2[n1+1].split(\" \")r1, z1=np.array([float(temp3[1]),float(temp3[0])])r2, z2=np.array([float(temp4[1]),float(temp4[0])])segs.append(((r1, z1),(r2, z2)))segs.append(((-r1, z1),(-r2, z2)))skip=Truereturnsegsdefgettingfield(filename, zmin, zmax, rmax, nr):",
    "url": "https://comphy-lab.org/fiber/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: Context",
    "content": "exe=[\"./getData-elastic-scalar2D\", filename,str(zmin),str(0),str(zmax),str(rmax),str(nr)]p=sp.Popen(exe, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()temp1=stderr.decode(\"utf-8\")temp2=temp1.split(\"\\n\")# print(temp2) #debuggingRtemp, Ztemp, D2temp, veltemp, taupTemp=[],[],[],[],[]forn1inrange(len(temp2)):temp3=temp2[n1].split(\" \")iftemp3==['']:passelse:Ztemp.append(float(temp3[0]))Rtemp.append(float(temp3[1]))D2temp.append(float(temp3[2]))veltemp.append(float(temp3[3]))taupTemp.append(float(temp3[4]))R=np.asarray(Rtemp)Z=np.asarray(Ztemp)D2=np.asarray(D2temp)vel=np.asarray(veltemp)taup=np.asarray(taupTemp)nz=int(len(Z)/nr)# print(\"nr is %d %d\" % (nr, len(R))) # debuggingprint(\"nz is%d\"%nz)R.resize((nz, nr))Z.resize((nz, nr))D2.resize((nz, nr))vel.resize((nz, nr))taup.resize((nz, nr))returnR, Z, D2, vel, taup, nz# ----------------------------------------------------------------------------------------------------------------------defprocess_timestep(ti, folder, nGFS, GridsPerR, rmin, rmax, zmin, zmax, lw, caseToProcess):",
    "url": "https://comphy-lab.org/fiber/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: Context",
    "content": "t=0.01*tiplace=f\"{caseToProcess}/intermediate/snapshot-{t:.4f}\"name=f\"{folder}/{int(t*1000):08d}.png\"ifnotos.path.exists(place):print(f\"{place}File not found!\")returnifos.path.exists(name):print(f\"{name}Image present!\")returnsegs1=gettingFacets(place)segs2=gettingFacets(place,'false')ifnotsegs1andnotsegs2:print(f\"Problem in the available file{place}\")returnnr=int(GridsPerR*rmax)R, Z, taus, vel, taup, nz=gettingfield(place, zmin, zmax, rmax, nr)zminp, zmaxp, rminp, rmaxp=Z.min(), Z.max(), R.min(), R.max()# PlottingAxesLabel, TickLabel=50,20fig, ax=plt.subplots()fig.set_size_inches(19.20,10.80)# Draw domain boundariesax.plot([0,0], [zmin, zmax],'-.', color='grey', linewidth=lw)ax.plot([rmin, rmin], [zmin, zmax],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmin, zmin],'-', color='black', linewidth=lw)ax.plot([rmin, rmax], [zmax, zmax],'-', color='black', linewidth=lw)ax.plot([rmax, rmax], [zmin, zmax],'-', color='black', linewidth=lw)# Add fluid interfacesline_segments=LineCollection(segs2, linewidths=4, colors='green', linestyle='solid')ax.add_collection(line_segments)line_segments=LineCollection(segs1, linewidths=4, colors='blue', linestyle='solid')ax.add_collection(line_segments)# Plot scalar fields with colormapscntrl1=ax.imshow(taus, cmap=\"hot_r\", interpolation='Bilinear', origin='lower',extent=[-rminp,-rmaxp, zminp, zmaxp], vmax=2.0, vmin=-3.0)#TODO: fixme the colorbar bounds for taup must be set manually based on the simulated case.cntrl2=ax.imshow(taup, interpolation='Bilinear', cmap=custom_cmap, origin='lower',extent=[rminp, rmaxp, zminp, zmaxp], vmax=2.0, vmin=-3.0)# Set plot propertiesax.set_aspect('equal')ax.set_xlim(rmin, rmax)ax.set_ylim(zmin, zmax)ax.set_title(f'$t/\\\\tau_\\\\gamma$ ={t:4.3f}', fontsize=TickLabel)# Add colorbarsl, b, w, h=ax.get_position().bounds# Left colorbarcb1=fig.add_axes([l-0.04, b,0.03, h])c1=plt.colorbar(cntrl1, cax=cb1, orientation='vertical')c1.set_label(r'$\\log_{10}\\left(\\|\\mathcal{D}\\|\\right)$', fontsize=TickLabel, labelpad=5)c1.ax.tick_params(labelsize=TickLabel)c1.ax.yaxis.set_ticks_position('left')c1.ax.yaxis.set_label_position('left')c1.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}'))# Right colorbarcb2=fig.add_axes([l+w+0.01, b,0.03, h])c2=plt.colorbar(cntrl2, cax=cb2, orientation='vertical')c2.ax.tick_params(labelsize=TickLabel)c2.set_label(r'$\\log_{10}\\left(\\text{tr}\\left(\\mathcal{A}\\right)-1\\right)$', fontsize=TickLabel)c2.ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.2f}'))ax.axis('off')plt.savefig(name, bbox_inches=\"tight\")plt.close()defmain():",
    "url": "https://comphy-lab.org/fiber/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/VideoAxi.py | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: # Set up...",
    "content": "# Set up command-line argument parsingparser=argparse.ArgumentParser(description='Process fluid dynamics simulation data and create visualizations')parser.add_argument('--CPUs',type=int, default=mp.cpu_count(),help='Number of CPUs to use (default: all available)')parser.add_argument('--nGFS',type=int, default=550,help='Number of restart files to process (default: 550)')parser.add_argument('--ZMAX',type=float, default=4.0,help='Maximum Z value (default: 4.0)')parser.add_argument('--RMAX',type=float, default=2.0,help='Maximum R value (default: 2.0)')parser.add_argument('--ZMIN',type=float, default=-4.0,help='Minimum Z value (default: -4.0)')parser.add_argument('--caseToProcess',type=str,default='../simulationCases/dropImpact',help='Case to process (default: ../simulationCases/dropImpact)')parser.add_argument('--folderToSave',type=str, default='dropImpact',help='Folder to save output images (default: dropImpact)')args=parser.parse_args()# Extract argumentsCPUStoUse=args.CPUsnGFS=args.nGFSZMAX=args.ZMAXRMAX=args.RMAXZMIN=args.ZMINnum_processes=CPUStoUsermin, rmax, zmin, zmax=[-RMAX, RMAX, ZMIN, ZMAX]GridsPerR=128# Grid resolution parameterlw=2# Line width for plot elementsfolder=args.folderToSavecaseToProcess=args.caseToProcess# Create output directory if it doesn't existifnotos.path.isdir(folder):os.makedirs(folder)# Create a pool of worker processes for parallel processingwithmp.Pool(processes=num_processes)aspool:# Create partial function with fixed argumentsprocess_func=partial(process_timestep,folder=folder, nGFS=nGFS,GridsPerR=GridsPerR, rmin=rmin, rmax=rmax,zmin=zmin, zmax=zmax, lw=lw, caseToProcess=caseToProcess)# Map the process_func to all timestepspool.map(process_func,range(nGFS))if__name__==\"__main__\":main()",
    "url": "https://comphy-lab.org/fiber/postProcess/VideoAxi.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology: Context",
    "content": "postProcess/getData-elastic-scalar2D.c See raw file Simulation Data Extraction and Processing This program extracts and processes data from fluid dynamics simulation snapshots, specifically designed for viscoelastic fluid simulations with conformation tensor analysis. It computes important derived quantities including deformation rate tensor components, velocity magnitude, and conformation tensor trace. The program interpolates these quantities onto a regular grid and outputs the results for further analysis or visualization. Physics Background This code handles viscoelastic fluid simulation data where the fluid stress tensor includes both a viscous component (proportional to the deformation rate) and an elastic component (represented by the conformation tensor).",
    "url": "https://comphy-lab.org/fiber/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology: C/C++ Code",
    "content": "The trace of the conformation tensor provides a measure of polymer stretching in the fluid. #include \"utils.h\" #include \"output.h\" scalar f []; // Volume fraction field vector u []; // Velocity field scalar A11 [], A12 [], A22 []; // Conformation tensor components scalar conform_qq []; // Additional conformation tensor component char filename [ 80 ]; // Input file name int nx , ny , len ; // Grid dimensions and field count double xmin , ymin , xmax , ymax , Deltax , Deltay ; // Domain boundaries and grid spacing Derived Fields D2c: Log10 of squared deformation rate tensor weighted by volume fraction vel: Magnitude of velocity trA: Log10 of excess trace of conformation tensor scalar D2c [], vel [], trA []; scalar * list = NULL ; // List to store output fields Main Function Processes simulation data and computes derived quantities Arguments: arguments[1]: Input filename arguments[2-5]: Domain boundaries (xmin, ymin, xmax, ymax) arguments[6]: Number of grid points in y-direction (ny) Returns: 0 on successful execution int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); xmin = atof ( arguments [ 2 ]); ymin = atof ( arguments [ 3 ]); xmax = atof ( arguments [ 4 ]); ymax = atof ( arguments [ 5 ]); ny = atoi ( arguments [ 6 ]); // Initialize list of fields to output list = list_add ( list , D2c ); list = list_add ( list , vel ); list = list_add ( list , trA ); Data Processing Workflow Restore simulation state from snapshot file Compute derived quantities at each grid point Interpolate fields onto regular grid Output data to file restore ( file = filename ); Field Computation For each cell, compute: - Components of the deformation rate tensor D - Squared magnitude of D weighted by volume fraction - Velocity magnitude - Excess trace of the conformation tensor foreach () { // Compute deformation rate tensor components double D11 = ( u . y [ 0 , 1 ] - u . y [ 0 , - 1 ]) / ( 2 * Delta ); double D22 = ( u . y [] / y ); double D33 = ( u . x [ 1 , 0 ] - u . x [- 1 , 0 ]) / ( 2 * Delta ); double D13 = 0.5 * (( u . y [ 1 , 0 ] - u . y [- 1 , 0 ] + u . x [ 0 , 1 ] - u . x [ 0 , - 1 ]) / ( 2 * Delta )); double D2 = ( sq ( D11 ) + sq ( D22 ) + sq ( D33 ) + 2.0 * sq ( D13 )); D2c [] = f [] * D2 ; // Take log10 of D2c for better visualization if ( D2c [] > 0. ) { D2c [] = log ( D2c []) / log ( 10 ); } else { D2c [] = - 10 ; } // Compute velocity magnitude vel [] = sqrt ( sq ( u . x []) + sq ( u . y [])); // Compute excess trace of conformation tensor trA [] = ( A11 [] + A22 [] + conform_qq []) / 3.0 - 1.0 ; // Take log10 of trA for better visualization if ( trA [] > 0. ) { trA [] = log ( trA []) / log ( 10 ); } else { trA [] = - 10 ; } } Grid Interpolation and Output Calculate grid spacing based on domain size and ny Allocate memory for interpolated field values Interpolate field values onto regular grid Output grid coordinates and field values FILE * fp = ferr ; Deltay = ( double )(( ymax - ymin ) / ( ny )); nx = ( int )(( xmax - xmin ) / Deltay ); Deltax = ( double )(( xmax - xmin ) / ( nx )); len = list_len ( list ); // Allocate memory for field values double ** field = ( double **) matrix_new ( nx , ny + 1 , len * sizeof ( double )); // Interpolate field values onto regular grid for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; int k = 0 ; for ( scalar s in list ) { field [ i ][ len * j + k ++] = interpolate ( s , x , y ); } } } // Output grid coordinates and field values for ( int i = 0 ; i < nx ; i ++) { double x = Deltax * ( i + 1. / 2 ) + xmin ; for ( int j = 0 ; j < ny ; j ++) { double y = Deltay * ( j + 1. / 2 ) + ymin ; fprintf ( fp , \" %g %g \" , x , y ); int k = 0 ; for ( scalar s in list ) { fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } // Clean up fflush ( fp ); fclose ( fp ); matrix_free ( field ); return 0 ; }",
    "url": "https://comphy-lab.org/fiber/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"scalar f[];// Volume fraction fieldvector u[];// Velocity fieldscalar A11[],A12[],A22[];// Conformation tensor componentsscalar conform_qq[];// Additional conformation tensor componentcharfilename[80];// Input file nameintnx,ny,len;// Grid dimensions and field countdoublexmin,ymin,xmax,ymax,Deltax,Deltay;// Domain boundaries and grid spacing",
    "url": "https://comphy-lab.org/fiber/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "scalar D2c[],vel[],trA[];scalar*list=NULL;// List to store output fields",
    "url": "https://comphy-lab.org/fiber/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);xmin=atof(arguments[2]);ymin=atof(arguments[3]);xmax=atof(arguments[4]);ymax=atof(arguments[5]);ny=atoi(arguments[6]);// Initialize list of fields to outputlist=list_add(list,D2c);list=list_add(list,vel);list=list_add(list,trA);",
    "url": "https://comphy-lab.org/fiber/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: foreach(){// Compute deformation...",
    "content": "foreach(){// Compute deformation rate tensor componentsdoubleD11=(u.y[0,1]-u.y[0,-1])/(2*Delta);doubleD22=(u.y[]/y);doubleD33=(u.x[1,0]-u.x[-1,0])/(2*Delta);doubleD13=0.5*((u.y[1,0]-u.y[-1,0]+u.x[0,1]-u.x[0,-1])/(2*Delta));doubleD2=(sq(D11)+sq(D22)+sq(D33)+2.0*sq(D13));D2c[]=f[]*D2;// Take log10 of D2c for better visualizationif(D2c[]>0.){D2c[]=log(D2c[])/log(10);}else{D2c[]=-10;}// Compute velocity magnitudevel[]=sqrt(sq(u.x[])+sq(u.y[]));// Compute excess trace of conformation tensortrA[]=(A11[]+A22[]+conform_qq[])/3.0-1.0;// Take log10 of trA for better visualizationif(trA[]>0.){trA[]=log(trA[])/log(10);}else{trA[]=-10;}}",
    "url": "https://comphy-lab.org/fiber/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getData-elastic-scalar2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example: Context",
    "content": "FILE*fp=ferr;Deltay=(double)((ymax-ymin)/(ny));nx=(int)((xmax-xmin)/Deltay);Deltax=(double)((xmax-xmin)/(nx));len=list_len(list);// Allocate memory for field valuesdouble**field=(double**)matrix_new(nx,ny+1,len*sizeof(double));// Interpolate field values onto regular gridfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y);}}}// Output grid coordinates and field valuesfor(inti=0;i<nx;i++){doublex=Deltax*(i+1./2)+xmin;for(intj=0;j<ny;j++){doubley=Deltay*(j+1./2)+ymin;fprintf(fp,\"%g%g\",x,y);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}// Clean upfflush(fp);fclose(fp);matrix_free(field);return0;}",
    "url": "https://comphy-lab.org/fiber/postProcess/getData-elastic-scalar2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology: Context",
    "content": "postProcess/getFacet2D.c See raw file Getting Facets A utility for extracting interface facets from fluid simulation data. Description This program extracts and outputs the facets representing the interface between different phases in a multiphase flow simulation. The facets define the boundary between fluid phases, useful for geometric analysis and visualization of the interface morphology. Physics Background In multiphase fluid simulations, interfaces between different fluids are critical features that determine many physical phenomena like surface tension effects, droplet formation, and coalescence events. This utility identifies these interfaces by extracting facets from volume fraction data, allowing for quantitative analysis of interfacial dynamics.",
    "url": "https://comphy-lab.org/fiber/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology: C/C++ Code",
    "content": "Usage ./getFacets input_file Author: Vatsal Sanjay vatsalsanjay@gmail.com Physics of Fluids Department University of Twente #include \"utils.h\" #include \"output.h\" #include \"fractions.h\" scalar f []; // Volume fraction field char filename [ 80 ]; Main Function Loads a simulation snapshot and extracts the interface facets. Input parameters: arguments[1] : Filename of the simulation snapshot to process Process: Restores the simulation state from the specified file Extracts interface facets from the volume fraction field Outputs facet data to standard error Return value: Returns 0 on successful completion Note: The facet extraction algorithm identifies where the volume fraction field crosses a threshold value (typically 0.5) between adjacent cells. int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); restore ( file = filename ); FILE * fp = ferr ; output_facets ( f , fp ); fflush ( fp ); fclose ( fp ); return 0 ; }",
    "url": "https://comphy-lab.org/fiber/postProcess/getFacet2D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology - C/C++ Code",
    "content": "#include\"utils.h\"#include\"output.h\"#include\"fractions.h\"scalar f[];// Volume fraction fieldcharfilename[80];",
    "url": "https://comphy-lab.org/fiber/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacet2D.c | FIBER: Flow-Induced Breakup of Elastic Rheology - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);restore(file=filename);FILE*fp=ferr;output_facets(f,fp);fflush(fp);fclose(fp);return0;}",
    "url": "https://comphy-lab.org/fiber/postProcess/getFacet2D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Jumping Bubbles | Jumping Bubbles: Jumping Bubbles A...",
    "content": "Jumping Bubbles A high-performance computational framework for studying bubble coalescence and jumping phenomena on substrates using Basilisk C . This repository provides a complete suite of simulation tools, post-processing utilities, and validated test cases for investigating two-phase free-surface flows with adaptive mesh refinement. Key Features Advanced Two-Phase Flow Modeling Volume of Fluid (VOF) method for sharp interface tracking Conservative momentum advection coupled with VOF field Accurate surface tension implementation using the Brackbill method Reduced gravity approach for specific physical scenarios. This keeps the system of equations well-balanced.",
    "url": "https://comphy-lab.org/JumpingBubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Jumping Bubbles | Jumping Bubbles: High-Performance Computing Adaptive...",
    "content": "High-Performance Computing Adaptive octree mesh refinement based on multiple criteria: Interface fraction gradients Local curvature Velocity field variations Parallel computation support: OpenMP for shared-memory systems MPI for distributed computing (HPC clusters) Comprehensive Analysis Tools Real-time monitoring of physical quantities Advanced post-processing capabilities: 2D/3D visualization scripts Interface reconstruction Energy and momentum analysis Trajectory tracking Project Structure basilisk/src/ - # Core Basilisk C framework navier-stokes/ - # Flow solvers centered.h - # Main centered NS solver conserving.h - # Conservative form solver two-phase*.h - # Two-phase flow implementations vof.h - # Volume of Fluid method curvature.h - # Interface property calculations tension.h - # Surface tension (Brackbill) integral.h - # Surface tension integral form viscosity.h - # Implicit viscous stress solver axi.h - # Axisymmetric computations src-local/ - # Project-specific modifications postProcess/ - # Analysis and visualization Video2DSlice.py - # 2D slice animations Video3D.py - # 3D visualization Visualization3D.ipynb - # Interactive 3D notebook getFacets3D.c - # Interface extraction simulationCases/ - # Validation cases JumpingBubbles.c - # Standard test case JumpingBubbles-hydrophilic.c - # Hydrophilic substrate runCases*.sh - # Execution scripts Installation Prerequisites GCC compiler (version 7.0+) MPI implementation (OpenMPI or MPICH) Python 3.7+ (for post-processing) Required Python packages: numpy, matplotlib, scipy Xcode Command Line Tools (for MacOS users) Setting up Basilisk Clone this repository: git clone https://github.com/VatsalSy/jumping-bubbles.git cd jumping-bubbles Run the installation script: ./reset_install_requirements.sh This script will: Install Basilisk if not present (use --hard flag for fresh installation) Configure the environment automatically Create .project_config with required paths Verify the installation Verify installation: source .project_config qcc --version Usage Running Simulations Local Development (OpenMP) # Compile qcc -O2 -Wall -disable-dimensions -fopenmp -I $( PWD ) /src-local testCases/JumpingBubbles.c -o JumpingBubbles -lm # Run with 4 threads export OMP_NUM_THREADS = 4 ./JumpingBubbles HPC Deployment (MPI) Generate initial condition locally first Compile with MPI support: CC99 = 'mpicc -std=c99' qcc -Wall -O2 -D_MPI = 1 -disable-dimensions \\ -I $( PWD ) /src-local testCases/JumpingBubbles.c -o JumpingBubbles -lm Use provided Slurm script: testCases/runSnellius.sbatch Post-Processing Visualization 2D Slice Videos: python postProcess/Video2DSlice.py < simulation_directory > 3D Visualization: python postProcess/Video3D.py < simulation_directory > Interactive Analysis: Open postProcess/Visualization3D.ipynb in Jupyter Data Analysis Use getFacets3D.c to extract interface geometry Various slice extraction tools available in postProcess/ Contributing We welcome contributions to improve Jumping Bubbles!",
    "url": "https://comphy-lab.org/JumpingBubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Jumping Bubbles | Jumping Bubbles: Here\u2019s how you...",
    "content": "Here\u2019s how you can help: Reporting Issues Click on the \u201cIssues\u201d tab above or use these quick links: - Report a Bug - Request a Feature - Ask a Question - Open a Blank Issue Making Changes Fork the repository Create a feature branch ( git checkout -b feature/AmazingFeature ) Make your changes Run tests and ensure they pass Update documentation if needed Commit your changes ( git commit -m 'Add some AmazingFeature' ) Push to the branch ( git push origin feature/AmazingFeature ) Open a Pull Request Please ensure your PR: - Clearly describes the changes - Includes any relevant tests - Updates documentation as needed - References any related issues License This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details.",
    "url": "https://comphy-lab.org/JumpingBubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Jumping Bubbles | Jumping Bubbles: Citation If you...",
    "content": "Citation If you use this code in your research, please cite: @software{jumping_bubbles_2024, author = {Sanjay, V. and Yang, R.}, title = {Jumping Bubbles: A Computational Framework for Studying Bubble Coalescence}, year = {2024}, publisher = {Zenodo}, version = {v1.0}, doi = {10.5281/zenodo.14602622}, url = {https://doi.org/10.5281/zenodo.14602622} } Acknowledgments Based on the Basilisk C framework. Generated Documentation Root Directory reset_install_requirements.sh postProcess postProcess/Video2DSlice.py postProcess/Video3D.py postProcess/Visulization3D.ipynb postProcess/getCells_bottomPlate.c postProcess/getDataXSlice.c postProcess/getDataZSlice.c postProcess/getFacets3D.c simulationCases simulationCases/DataFile/retrieveDataFile.sh simulationCases/JumpingBubbles-hydrophilic.c simulationCases/JumpingBubbles.c simulationCases/Makefile simulationCases/runCasesOpenMP.sh simulationCases/runCasesOpenMPI.sh src-local src-local/contact-fixed.h",
    "url": "https://comphy-lab.org/JumpingBubbles/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "Jumping Bubbles | Jumping Bubbles - Code Example",
    "content": "gitclone https://github.com/VatsalSy/jumping-bubbles.gitcdjumping-bubbles",
    "url": "https://comphy-lab.org/JumpingBubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Jumping Bubbles | Jumping Bubbles - Code Example",
    "content": "# Compileqcc-O2-Wall-disable-dimensions-fopenmp-I$(PWD)/src-local testCases/JumpingBubbles.c-oJumpingBubbles-lm# Run with 4 threadsexportOMP_NUM_THREADS=4./JumpingBubbles",
    "url": "https://comphy-lab.org/JumpingBubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Jumping Bubbles | Jumping Bubbles - Code Example",
    "content": "CC99='mpicc -std=c99'qcc-Wall-O2-D_MPI=1-disable-dimensions\\-I$(PWD)/src-local testCases/JumpingBubbles.c-oJumpingBubbles-lm",
    "url": "https://comphy-lab.org/JumpingBubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Jumping Bubbles | Jumping Bubbles - Code Example",
    "content": "pythonpostProcess/Video2DSlice.py<simulation_directory>",
    "url": "https://comphy-lab.org/JumpingBubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Jumping Bubbles | Jumping Bubbles - Code Example",
    "content": "pythonpostProcess/Video3D.py<simulation_directory>",
    "url": "https://comphy-lab.org/JumpingBubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Jumping Bubbles | Jumping Bubbles - Code Example",
    "content": "@software{jumping_bubbles_2024,author       = {Sanjay, V. and Yang, R.},title        = {Jumping Bubbles: A Computational Framework for Studying Bubble Coalescence},year         = {2024},publisher    = {Zenodo},version      = {v1.0},doi          = {10.5281/zenodo.14602622},url          = {https://doi.org/10.5281/zenodo.14602622}}",
    "url": "https://comphy-lab.org/JumpingBubbles/index.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Jumping Bubbles: Context",
    "content": "reset_install_requirements.sh See raw file reset_install_requirements.sh #!/bin/zsh # tested on MacOS only.",
    "url": "https://comphy-lab.org/JumpingBubbles/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Jumping Bubbles: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue. # modify using http://basilisk.fr/src/INSTALL # ensures that we are always using the latest version of basilisk # Check if --hard flag is passed HARD_RESET = \\f alse if [[ \" \\$ 1\" == \"--hard\" ]]; then HARD_RESET = \\t rue fi # Function to install basilisk install_basilisk() { darcs clone http://basilisk.fr/basilisk cd basilisk/src if [[ \" \\$ OSTYPE\" == \"darwin\" * ]]; then echo \"Using MacOS\" ln -s config.osx config else echo \"Using Linux\" ln -s config.gcc config fi make } # Remove project config always rm -rf .project_config # Check if basilisk needs to be installed if [[ \" \\$ HARD_RESET\" == true ]] || [[ ! -d \"basilisk\" ]]; then echo \"Installing basilisk...\" rm -rf basilisk install_basilisk else echo \"Using existing basilisk installation...\" cd basilisk/src fi # Setup environment variables echo \"export BASILISK= \\$ PWD\" >> ../../.project_config echo \"export PATH= \\\\ $PATH : \\\\ $BASILISK \" >> ../../.project_config source ../../.project_config # Check if qcc is working properly echo \"\\nChecking qcc installation...\" if ! qcc --version > /dev/null 2 >& 1 ; then echo \"\\033[0;31mError: qcc is not working properly.\\033[0m\" echo \"Please ensure you have Xcode Command Line Tools installed.\" echo \"You can install them by running: xcode-select --install\" echo \"For more details, visit: http://basilisk.fr/src/INSTALL\" exit 1 else echo \"\\033[0;32mqcc is properly installed.\\033[0m\" qcc --version fi",
    "url": "https://comphy-lab.org/JumpingBubbles/reset_install_requirements.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Jumping Bubbles - Code Example: #!/bin/zsh# tested on...",
    "content": "#!/bin/zsh# tested on MacOS only.",
    "url": "https://comphy-lab.org/JumpingBubbles/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "reset_install_requirements.sh | Jumping Bubbles - Code Example: Let us know...",
    "content": "Let us know if you find issues running with Linux by opening an issue.# modify using http://basilisk.fr/src/INSTALL# ensures that we are always using the latest version of basilisk# Check if --hard flag is passedHARD_RESET=\\falseif[[\"\\$1\"==\"--hard\"]];thenHARD_RESET=\\truefi# Function to install basiliskinstall_basilisk(){darcsclone http://basilisk.fr/basiliskcdbasilisk/srcif[[\"\\$OSTYPE\"==\"darwin\"*]];thenecho\"Using MacOS\"ln-sconfig.osx configelseecho\"Using Linux\"ln-sconfig.gcc configfimake}# Remove project config alwaysrm-rf.project_config# Check if basilisk needs to be installedif[[\"\\$HARD_RESET\"==true]]||[[!-d\"basilisk\"]];thenecho\"Installing basilisk...\"rm-rfbasiliskinstall_basiliskelseecho\"Using existing basilisk installation...\"cdbasilisk/srcfi# Setup environment variablesecho\"export BASILISK=\\$PWD\">>../../.project_configecho\"export PATH=\\\\$PATH:\\\\$BASILISK\">>../../.project_configsource../../.project_config# Check if qcc is working properlyecho\"\\nChecking qcc installation...\"if!qcc--version>/dev/null2>&1;thenecho\"\\033[0;31mError: qcc is not working properly.\\033[0m\"echo\"Please ensure you have Xcode Command Line Tools installed.\"echo\"You can install them by running: xcode-select --install\"echo\"For more details, visit: http://basilisk.fr/src/INSTALL\"exit1elseecho\"\\033[0;32mqcc is properly installed.\\033[0m\"qcc--versionfi",
    "url": "https://comphy-lab.org/JumpingBubbles/reset_install_requirements.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Simulation Cases | Documentation",
    "content": "Simulation Cases JumpingBubbles-hydrophilic.c This code simulates the coalescence and subsequent jumping of two bubbles sitting on a hydrophilic substrate using th... JumpingBubbles.c A computational fluid dynamics simulation of two bubbles coalescing and jumping off a substrate using Basilisk C. Thi... Makefile ifeq (\\$(wildcard ../.projectconfig),) \\$(error '../.projectconfig not found') endif BASILISK := \\$(shell . ../.proje... runCasesOpenMP.sh qcc -O2 -Wall -disable-dimensions -fopenmp -I\\$(PWD)/src-local JumpingBubbles.c -o JumpingBubbles -lm export OMPNUMTH... runCasesOpenMPI.sh CC99='mpicc -std=c99' qcc -Wall -O2 -DMPI=1 -disable-dimensions -I\\$(PWD)/src-local JumpingBubbles.c -o JumpingBubble...",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCasesOpenMP.sh | Jumping Bubbles",
    "content": "simulationCases/runCasesOpenMP.sh See raw file runCasesOpenMP.sh #!/bin/bash qcc -O2 -Wall -disable-dimensions -fopenmp -I\\$ ( PWD ) /src-local JumpingBubbles.c -o JumpingBubbles -lm export OMP_NUM_THREADS = 4 ./JumpingBubbles",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/runCasesOpenMP.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCasesOpenMP.sh | Jumping Bubbles - Code Example",
    "content": "#!/bin/bashqcc-O2-Wall-disable-dimensions-fopenmp-I\\$(PWD)/src-localJumpingBubbles.c-oJumpingBubbles-lmexportOMP_NUM_THREADS=4./JumpingBubbles",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/runCasesOpenMP.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Jumping Bubbles",
    "content": "simulationCases/Makefile See raw file Makefile # Check if .project_config exists ifeq ( \\$ ( wildcard ../.project_config ) , ) \\$ ( error \"../.project_config not found\" ) endif BASILISK := \\$ ( shell . ../.project_config && echo \\$\\$ BASILISK ) CFLAGS += -O2 -disable-dimensions CFLAGS += -I\\$ ( PWD ) /src-local -I\\$ ( PWD ) /../src-local include \\$ ( BASILISK ) /Makefile.defs",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/Makefile.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/Makefile | Jumping Bubbles - Code Example",
    "content": "# Check if .project_config existsifeq(\\$(wildcard../.project_config),)\\$(error\"../.project_config not found\")endifBASILISK:=\\$(shell. ../.project_config&&echo\\$\\$BASILISK)CFLAGS+=-O2-disable-dimensionsCFLAGS+=-I\\$(PWD)/src-local-I\\$(PWD)/../src-localinclude\\$(BASILISK)/Makefile.defs",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/Makefile.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles: Context",
    "content": "simulationCases/JumpingBubbles.c See raw file Jumping Bubbles Simulation A computational fluid dynamics simulation of two bubbles coalescing and jumping off a substrate using Basilisk C. This simulation employs an adaptive octree grid for spatial discretization and models two-phase flow with surface tension effects. Overview The simulation captures the complex physics of bubble coalescence and subsequent jumping behavior. It reads bubble geometry from an STL file and tracks the gas-liquid interface evolution using the Volume-of-Fluid (VOF) method, providing high-fidelity results for studying bubble dynamics on surfaces.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles: Context",
    "content": "Changelog Version 1.5 (January 5, 2025) Extended support for arbitrary contact angle implementation Enhanced contact angle boundary condition handling Author Information Author : Vatsal Version : 1.5 Date : January 5, 2025 #include \"grid/octree.h\" #include \"navier-stokes/centered.h\" //#define FILTERED #include \"contact-fixed.h\" #include \"two-phase.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #if !_MPI #include \"distance.h\" #endif #include \"reduced.h\" Configuration Parameters Grid Resolution Control MINlevel : Minimum refinement level for the coarsest grid resolution MAXlevel : Maximum refinement level controlling the finest grid resolution Time Control Parameters tsnap : Time interval between solution snapshots (default: 1e-2) tsnap2 : Time interval for log file outputs (default: 1e-4) Error Tolerances fErr : Error tolerance for VOF field adaptation (default: 1e-3) KErr : Error tolerance for curvature field adaptation (default: 1e-4) VelErr : Error tolerance for velocity field adaptation (default: 1e-4) Physical Properties Mu21 : Viscosity ratio of gas phase to liquid phase (default: 1e-3) Rho21 : Density ratio of gas phase to liquid phase (default: 1e-3) Ldomain : Characteristic length of the simulation domain (default: 4) #define MINlevel 2 64 #define tsnap ( 1e-2 ) 65 #define tsnap2 ( 1e-4 ) 66 #define fErr ( 1e-3 ) 67 #define KErr ( 1e-4 ) 68 #define VelErr ( 1e-4 ) 69 #define hErr ( 1e-3 ) 70 #define Mu21 ( 1.00e-3 ) 71 #define Rho21 ( 1.00e-3 ) 72 #define Ldomain 4 73 74 Boundary Conditions The simulation implements specific boundary conditions at the substrate (bottom boundary): - Tangential velocity component: No-slip condition (u.t = 0) - Radial velocity component: No-penetration condition (u.r = 0) - Face velocities: Enforced to ensure mass conservation - Contact angle: Specified through the contact angle boundary condition u . t [ bottom ] = dirichlet ( 0. ); u . r [ bottom ] = dirichlet ( 0. ); uf . t [ bottom ] = dirichlet ( 0. ); uf . r [ bottom ] = dirichlet ( 0. ); Contact Angle Implementation The contact angle is imposed through a height function vector field that specifies the interface orientation at the substrate boundary. double theta0 , patchR ; vector h []; h . t [ bottom ] = contact_angle ( theta0 * pi / 180. ); h . r [ bottom ] = contact_angle ( theta0 * pi / 180. ); Global Variables Simulation Parameters tmax : Maximum simulation time Oh : Ohnesorge number (\u03b7_l/\u221a(\u03c1_l\u00b7\u03b3\u00b7R_equiv)) MAXlevel : Maximum refinement level theta0 : Contact angle in degrees patchR : Normalized contact patch radius (R_cont/R_equiv) Bo : Bond number (\u03c1_l\u00b7g\u00b7R_equiv\u00b2/\u03b3) double tmax , Oh , Bo ; int MAXlevel ; char nameOut [ 80 ]; Main Function Initializes the simulation parameters and computational domain.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles: Sets up the...",
    "content": "Sets up the two-phase flow properties including density and viscosity ratios, surface tension, and gravitational effects. Key Parameters Set: Oh : Ohnesorge number controlling viscous effects MAXlevel : Maximum grid refinement level theta0 : Contact angle at the substrate patchR : Size of the contact patch Bo : Bond number for gravitational effects int main () { #if !_MPI tmax = 1e-2 ; #else tmax = 2e0 ; #endif Oh = 0.0066 ; MAXlevel = 8 ; theta0 = 15 ; patchR = 0.184 ; Bo = 0.016 ; init_grid ( 1 << MINlevel ); L0 = Ldomain ; fprintf ( ferr , \"tmax = %g . Oh = %g\\n \" , tmax , Oh ); rho1 = 1.0 ; mu1 = Oh ; rho2 = Rho21 ; mu2 = Mu21 * Oh ; f . height = h ; f . sigma = 1.0 ; G . y = - Bo ; char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); sprintf ( dumpFile , \"restartFile\" ); run (); } Initialization Event Sets up the initial condition for the simulation. This event attempts to restore from a previous dump file if available.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles: If no dump...",
    "content": "If no dump file exists, it reads the bubble geometry from an STL file and constructs the initial interface.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles: Function Definition",
    "content": "Process: First attempts to restore from restartFile If restoration fails, reads InitialCondition.stl Computes distance function from STL geometry Constructs VOF field using the distance function Performs initial mesh adaptation Saves initial condition for verification Notes: MPI version only supports restoration from dump files Non-MPI version can initialize from STL files using the distance function event init ( t = 0 ) { #if _MPI if (! restore ( file = dumpFile )) { fprintf ( ferr , \"Cannot restored from a dump file! \\n \" ); } #else if (! restore ( file = dumpFile )) { char filename [ 60 ]; sprintf ( filename , \"InitialCondition.stl\" ); FILE * fp = fopen ( filename , \"r\" ); if ( fp == NULL ) { fprintf ( ferr , \"There is no file named %s\\n \" , filename ); return 1 ; } coord * p = input_stl ( fp ); fclose ( fp ); coord min , max ; bounding_box ( p , & min , & max ); fprintf ( ferr , \"xmin %g xmax %g\\n ymin %g ymax %g\\n zmin %g zmax %g\\n \" , min . x , max . x , min . y , max . y , min . z , max . z ); fprintf ( ferr , \"x0 = %g , y0 = %g , z0 = %g\\n \" , 0. , - 1.0 , ( min . z + max . z ) / 2. ); origin ( 0. , - 1.0 - 0.025 , ( min . z + max . z ) / 2. ); scalar d []; distance ( d , p ); while ( adapt_wavelet (( scalar *){ f , d }, ( double []){ 1e-6 , 1e-6 * L0 }, MAXlevel ). nf ); vertex scalar phi []; foreach_vertex () { phi [] = -( d [] + d [- 1 ] + d [ 0 ,- 1 ] + d [- 1 ,- 1 ] + d [ 0 , 0 ,- 1 ] + d [- 1 , 0 ,- 1 ] + d [ 0 ,- 1 ,- 1 ] + d [- 1 ,- 1 ,- 1 ]) / 8. ; } fractions ( phi , f ); foreach () { foreach_dimension () { u . x [] = 0.0 ; } } dump ( file = \"dumpInit\" ); fprintf ( ferr , \"Done with initial condition! \\n \" ); } #endif } Adaptive Mesh Refinement Event Performs adaptive mesh refinement at each timestep based on error estimates in various fields.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles: Function Definition",
    "content": "This ensures computational efficiency while maintaining accuracy in regions of high gradients. Refined Fields: Volume fraction field (f) Velocity components (u.x, u.y, u.z) Height function components (h.x, h.y, h.z) Error Tolerances: Interface tracking: fErr Velocity field: VelErr Height function: hErr event adapt ( i ++) { adapt_wavelet_limited (( scalar *){ f , u . x , u . y , u . z , h . x , h . y , h . z }, ( double []){ fErr , VelErr , VelErr , VelErr , hErr , hErr , hErr }, MAXlevel , MINlevel ); } File Output Event Writes simulation snapshots at regular intervals for post-processing and analysis. Creates both a restart file and timestamped snapshots.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles: Output Files: restartFile...",
    "content": "Output Files: restartFile : Continuously updated for simulation restart capability intermediate/snapshot-*.dump : Timestamped snapshots for analysis Timing: Triggered at t = 0 and every tsnap interval thereafter Continues until tmax + tsnap to ensure final state capture event writingFiles ( t = 0 ; t += tsnap ; t <= tmax + tsnap ) { dump ( file = dumpFile ); char nameOut [ 80 ]; sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Diagnostic Logging Event Computes and logs diagnostic quantities at fine temporal intervals for monitoring simulation progress and analyzing bubble dynamics.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles: Logged Quantities: Iteration...",
    "content": "Logged Quantities: Iteration number (i) Timestep size (dt) Simulation time (t) Kinetic energy in the gas phase (ke) Implementation Details: Kinetic energy computed only in gas phase using (1-f) weighting Volume integral performed using cube(Delta) for cell volumes Output written to both stderr and log file for monitoring event logWriting ( t = 0 ; t += tsnap2 ; t <= tmax + tsnap ) { double ke = 0. ; foreach ( reduction (+: ke )) { ke += 0.5 * ( sq ( u . x []) + sq ( u . y []) + sq ( u . z [])) * clamp ( 1. - f [], 0. , 1. ) * cube ( Delta ); } if ( pid () == 0 ) { static FILE * fp ; if ( i == 0 ) { fprintf ( ferr , \"i dt t ke \\n \" ); fp = fopen ( \"log\" , \"w\" ); fprintf ( fp , \"i dt t ke \\n \" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } else { fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); } }",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles - C/C++ Code",
    "content": "#include\"grid/octree.h\"#include\"navier-stokes/centered.h\"//#define FILTERED#include\"contact-fixed.h\"#include\"two-phase.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#if !_MPI#include\"distance.h\"#endif#include\"reduced.h\"",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles - Code Example",
    "content": "#define MINlevel264#define tsnap(1e-2)65#define tsnap2(1e-4)66#define fErr(1e-3)67#define KErr(1e-4)68#define VelErr(1e-4)69#define hErr(1e-3)70#define Mu21(1.00e-3)71#define Rho21(1.00e-3)72#define Ldomain47374",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles - Code Example",
    "content": "u.t[bottom]=dirichlet(0.);u.r[bottom]=dirichlet(0.);uf.t[bottom]=dirichlet(0.);uf.r[bottom]=dirichlet(0.);",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles - Code Example",
    "content": "doubletheta0,patchR;vector h[];h.t[bottom]=contact_angle(theta0*pi/180.);h.r[bottom]=contact_angle(theta0*pi/180.);",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles - Code Example",
    "content": "intmain(){#if !_MPItmax=1e-2;#elsetmax=2e0;#endifOh=0.0066;MAXlevel=8;theta0=15;patchR=0.184;Bo=0.016;init_grid(1<<MINlevel);L0=Ldomain;fprintf(ferr,\"tmax =%g. Oh =%g\\n\",tmax,Oh);rho1=1.0;mu1=Oh;rho2=Rho21;mu2=Mu21*Oh;f.height=h;f.sigma=1.0;G.y=-Bo;charcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);sprintf(dumpFile,\"restartFile\");run();}",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles - Code Example: event init(t=0){#if _MPIif(!restore(file=dumpFile)){fprintf(ferr,\"Cannot...",
    "content": "event init(t=0){#if _MPIif(!restore(file=dumpFile)){fprintf(ferr,\"Cannot restored from a dump file!\\n\");}#elseif(!restore(file=dumpFile)){charfilename[60];sprintf(filename,\"InitialCondition.stl\");FILE*fp=fopen(filename,\"r\");if(fp==NULL){fprintf(ferr,\"There is no file named%s\\n\",filename);return1;}coord*p=input_stl(fp);fclose(fp);coord min,max;bounding_box(p,&min,&max);fprintf(ferr,\"xmin%gxmax%g\\nymin%gymax%g\\nzmin%gzmax%g\\n\",min.x,max.x,min.y,max.y,min.z,max.z);fprintf(ferr,\"x0 =%g, y0 =%g, z0 =%g\\n\",0.,-1.0,(min.z+max.z)/2.);origin(0.,-1.0-0.025,(min.z+max.z)/2.);scalar d[];distance(d,p);while(adapt_wavelet((scalar*){f,d},(double[]){1e-6,1e-6*L0},MAXlevel).nf);vertex scalar phi[];foreach_vertex(){phi[]=-(d[]+d[-1]+d[0,-1]+d[-1,-1]+d[0,0,-1]+d[-1,0,-1]+d[0,-1,-1]+d[-1,-1,-1])/8.;}fractions(phi,f);foreach(){foreach_dimension(){u.x[]=0.0;}}dump(file=\"dumpInit\");fprintf(ferr,\"Done with initial condition!\\n\");}#endif}",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles - Code Example",
    "content": "event adapt(i++){adapt_wavelet_limited((scalar*){f,u.x,u.y,u.z,h.x,h.y,h.z},(double[]){fErr,VelErr,VelErr,VelErr,hErr,hErr,hErr},MAXlevel,MINlevel);}",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax+tsnap){dump(file=dumpFile);charnameOut[80];sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles.c | Jumping Bubbles - Code Example",
    "content": "event logWriting(t=0;t+=tsnap2;t<=tmax+tsnap){doubleke=0.;foreach(reduction(+:ke)){ke+=0.5*(sq(u.x[])+sq(u.y[])+sq(u.z[]))*clamp(1.-f[],0.,1.)*cube(Delta);}if(pid()==0){staticFILE*fp;if(i==0){fprintf(ferr,\"i dt t ke\\n\");fp=fopen(\"log\",\"w\");fprintf(fp,\"i dt t ke\\n\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}else{fp=fopen(\"log\",\"a\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);}}",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles: Context",
    "content": "simulationCases/JumpingBubbles-hydrophilic.c See raw file Jumping Bubbles Simulation Overview This code simulates the coalescence and subsequent jumping of two bubbles sitting on a hydrophilic substrate using the Basilisk C framework. The simulation employs an adaptive octree grid for spatial discretization and models two-phase flow with surface tension effects. Physics Description The simulation captures the dynamics of bubble coalescence-induced jumping, a phenomenon where two bubbles merge and the resulting bubble jumps away from the substrate due to the conversion of surface energy into kinetic energy. The Volume-of-Fluid (VOF) method tracks the gas-liquid interface evolution throughout the process.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles: Key Features Adaptive...",
    "content": "Key Features Adaptive mesh refinement based on interface location and flow gradients Two-phase flow modeling with large density and viscosity contrasts Surface tension effects via the Continuum Surface Force (CSF) method STL file input for complex initial bubble geometries Simulation Parameters Dimensionless Numbers Oh : Ohnesorge number - ratio of viscous to inertial-capillary forces Controls the damping of interface oscillations Default: 0.01 Grid Parameters MAXlevel : Maximum refinement level Determines the finest grid resolution (2^MAXlevel cells) Default: 9 MINlevel : Minimum refinement level Controls the coarsest grid resolution Fixed at: 2 Temporal Parameters tmax : Maximum simulation time Default: 1e-2 (MPI disabled) or 2.0 (MPI enabled) tsnap : Time interval between solution snapshots Fixed at: 1e-2 tsnap2 : Time interval for log file outputs Fixed at: 1e-4 Physical Parameters Ldomain : Length of the cubic simulation domain Fixed at: 4 Rho21 : Density ratio (gas/liquid) Fixed at: 1e-3 Mu21 : Viscosity ratio (gas/liquid) Fixed at: 1e-3 Refinement Tolerances fErr : Interface (VOF) refinement tolerance Fixed at: 1e-3 KErr : Curvature refinement tolerance Fixed at: 1e-4 VelErr : Velocity field refinement tolerance Fixed at: 1e-4 Boundary Conditions Bottom Boundary (Substrate) No-slip condition: tangential and radial velocities set to zero Wetting condition: interface fraction f = 1 (liquid phase) Implementation Details Solver Configuration Base solver: navier-stokes/centered for momentum conservation Two-phase model: Handles density and viscosity jumps Surface tension: Implemented via tension.h module Conservation: Uses navier-stokes/conserving.h for mass conservation Geometric Processing distance() : Computes signed distance from STL geometry fractions() : Constructs VOF field from distance function Compilation and Execution Example Compilation qcc -O2 -Wall -disable-dimensions -fopenmp JumpingBubbles.c \\ -o JumpingBubbles -lm Execution ./JumpingBubbles Output Files dumpFile : Restart file for continuing simulations intermediate/snapshot-*.dump : Solution snapshots at regular intervals log : Kinetic energy evolution data Author Information Author: Vatsal Version: 1.0 Date: January 4, 2025 #include \"grid/octree.h\" #include \"navier-stokes/centered.h\" #define FILTERED 105 #include \"two-phase.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #if !_MPI #include \"distance.h\" #endif #define MINlevel 2 114 #define tsnap ( 1e-2 ) 115 #define tsnap2 ( 1e-4 ) 116 #define fErr ( 1e-3 ) 117 #define KErr ( 1e-4 ) 118 #define VelErr ( 1e-4 ) 119 #define Mu21 ( 1.00e-3 ) 120 #define Rho21 ( 1.00e-3 ) 121 #define Ldomain 4 122 // Boundary conditions u . t [ bottom ] = dirichlet ( 0. ); u . r [ bottom ] = dirichlet ( 0. ); uf . t [ bottom ] = dirichlet ( 0. ); uf . r [ bottom ] = dirichlet ( 0. ); f [ bottom ] = dirichlet ( 1. ); double tmax , Oh ; int MAXlevel ; char nameOut [ 80 ]; Main Function Initializes simulation parameters and executes the run.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles: Function Definition",
    "content": "The function sets different maximum times based on whether MPI is enabled, configures the Ohnesorge number and grid parameters, and initializes the computational domain. Key Operations Sets simulation duration based on parallelization mode Configures physical parameters (Oh number, refinement levels) Initializes the grid with minimum refinement level Sets fluid properties based on dimensionless parameters Creates output directory structure int main () { #if !_MPI tmax = 1e-2 ; #else tmax = 2e0 ; #endif Oh = 0.01 ; MAXlevel = 9 ; init_grid ( 1 << MINlevel ); L0 = Ldomain ; fprintf ( ferr , \"tmax = %g .",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles: Oh = %g\\n...",
    "content": "Oh = %g\\n \" , tmax , Oh ); rho1 = 1.0 ; mu1 = Oh ; rho2 = Rho21 ; mu2 = Mu21 * Oh ; f . sigma = 1.0 ; char comm [ 80 ]; sprintf ( comm , \"mkdir -p intermediate\" ); system ( comm ); sprintf ( dumpFile , \"restartFile\" ); run (); } Initialization Event Sets up the initial bubble configuration either by restoring from a previous simulation or by reading an STL file containing the bubble geometry.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles: Function Definition",
    "content": "Workflow Attempts to restore from a dump file if available If restoration fails, reads bubble geometry from STL file Computes signed distance function from STL geometry Performs initial adaptive refinement based on distance field Converts distance function to VOF field using fractions() Initializes velocity field to zero STL Processing Details Reads \u201cInitialCondition.stl\u201d file Computes bounding box of geometry Centers domain around bubble configuration Applies small vertical offset (-0.025) for substrate contact Error Handling Reports if dump file restoration fails Exits with error if STL file is not found Logs bounding box coordinates for verification event init ( t = 0 ) { #if _MPI if (! restore ( file = dumpFile )) { fprintf ( ferr , \"Cannot restored from a dump file! \\n \" ); } #else if (! restore ( file = dumpFile )) { char filename [ 60 ]; sprintf ( filename , \"InitialCondition.stl\" ); FILE * fp = fopen ( filename , \"r\" ); if ( fp == NULL ) { fprintf ( ferr , \"There is no file named %s\\n \" , filename ); return 1 ; } coord * p = input_stl ( fp ); fclose ( fp ); coord min , max ; bounding_box ( p , & min , & max ); fprintf ( ferr , \"xmin %g xmax %g\\n ymin %g ymax %g\\n zmin %g zmax %g\\n \" , min . x , max . x , min . y , max . y , min . z , max . z ); fprintf ( ferr , \"x0 = %g , y0 = %g , z0 = %g\\n \" , 0. , - 1.0 , ( min . z + max . z ) / 2. ); origin ( 0. , - 1.0 - 0.025 , ( min . z + max . z ) / 2. ); scalar d []; distance ( d , p ); while ( adapt_wavelet (( scalar *){ f , d }, ( double []){ 1e-6 , 1e-6 * L0 }, MAXlevel ). nf ); vertex scalar phi []; foreach_vertex () { phi [] = -( d [] + d [- 1 ] + d [ 0 ,- 1 ] + d [- 1 ,- 1 ] + d [ 0 , 0 ,- 1 ] + d [- 1 , 0 ,- 1 ] + d [ 0 ,- 1 ,- 1 ] + d [- 1 ,- 1 ,- 1 ]) / 8. ; } fractions ( phi , f ); foreach () { foreach_dimension () { u . x [] = 0.0 ; } } dump ( file = \"dumpInit\" ); fprintf ( ferr , \"Done with initial condition! \\n \" ); } #endif } Adaptive Refinement Event Performs dynamic mesh refinement at each timestep based on solution gradients.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles: This ensures computational...",
    "content": "This ensures computational resources are concentrated in regions of high activity while maintaining accuracy. Refinement Criteria Interface location (VOF field f) Interface curvature (computed from VOF field) Velocity components (all three directions) Implementation Computes local curvature using the curvature() function Applies wavelet-based error estimation Refines/coarsens cells based on error tolerances Maintains refinement between MINlevel and MAXlevel event adapt ( i ++) { scalar KAPPA []; curvature ( f , KAPPA ); adapt_wavelet (( scalar *){ f , KAPPA , u . x , u . y , u . z }, ( double []){ fErr , KErr , VelErr , VelErr , VelErr }, MAXlevel , MINlevel ); } File Output Event Writes solution snapshots at regular intervals for post-processing and visualization. Creates both restart files and timestamped snapshots.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles: Output Schedule Triggers...",
    "content": "Output Schedule Triggers at t = 0 and every tsnap interval Continues until tmax + tsnap File Structure Overwrites main restart file at each output Creates timestamped snapshots in intermediate/ directory Uses 5.4f format for time in filenames event writingFiles ( t = 0 ; t += tsnap ; t <= tmax + tsnap ) { dump ( file = dumpFile ); char nameOut [ 80 ]; sprintf ( nameOut , \"intermediate/snapshot- %5.4f \" , t ); dump ( file = nameOut ); } Logging Event Records integral quantities at high frequency for quantitative analysis. Specifically tracks the kinetic energy of the gas phase to monitor bubble dynamics.",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles: Computed Quantities Kinetic...",
    "content": "Computed Quantities Kinetic energy of gas phase: KE = 0.5 * \u03c1 * (u\u00b2 + v\u00b2 + w\u00b2) * (1-f) * \u0394V Uses clamp() to ensure clean phase separation Output Format Headers: i (iteration), dt (timestep), t (time), ke (kinetic energy) Writes to both stderr and \u201clog\u201d file Appends to existing log file after initial write Parallel Considerations Uses reduction operation for parallel summation Only process 0 performs file I/O event logWriting ( t = 0 ; t += tsnap2 ; t <= tmax + tsnap ) { double ke = 0. ; foreach ( reduction (+: ke )) { ke += 0.5 * ( sq ( u . x []) + sq ( u . y []) + sq ( u . z [])) * clamp ( 1. - f [], 0. , 1. ) * cube ( Delta ); } if ( pid () == 0 ) { static FILE * fp ; if ( i == 0 ) { fprintf ( ferr , \"i dt t ke \\n \" ); fp = fopen ( \"log\" , \"w\" ); fprintf ( fp , \"i dt t ke \\n \" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } else { fp = fopen ( \"log\" , \"a\" ); fprintf ( fp , \" %d %g %g %g\\n \" , i , dt , t , ke ); fclose ( fp ); } fprintf ( ferr , \" %d %g %g %g\\n \" , i , dt , t , ke ); } }",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles - Code Example",
    "content": "qcc-O2-Wall-disable-dimensions-fopenmpJumpingBubbles.c\\-oJumpingBubbles-lm",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles - C/C++ Code: C/C++ Code",
    "content": "#include\"grid/octree.h\"#include\"navier-stokes/centered.h\"#define FILTERED105#include\"two-phase.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#if !_MPI#include\"distance.h\"#endif#define MINlevel2114#define tsnap(1e-2)115#define tsnap2(1e-4)116#define fErr(1e-3)117#define KErr(1e-4)118#define VelErr(1e-4)119#define Mu21(1.00e-3)120#define Rho21(1.00e-3)121#define Ldomain4122// Boundary conditionsu.t[bottom]=dirichlet(0.);u.r[bottom]=dirichlet(0.);uf.t[bottom]=dirichlet(0.);uf.r[bottom]=dirichlet(0.);f[bottom]=dirichlet(1.);doubletmax,Oh;intMAXlevel;charnameOut[80];",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles - Code Example",
    "content": "intmain(){#if !_MPItmax=1e-2;#elsetmax=2e0;#endifOh=0.01;MAXlevel=9;init_grid(1<<MINlevel);L0=Ldomain;fprintf(ferr,\"tmax =%g. Oh =%g\\n\",tmax,Oh);rho1=1.0;mu1=Oh;rho2=Rho21;mu2=Mu21*Oh;f.sigma=1.0;charcomm[80];sprintf(comm,\"mkdir -p intermediate\");system(comm);sprintf(dumpFile,\"restartFile\");run();}",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles - Code Example: event init(t=0){#if _MPIif(!restore(file=dumpFile)){fprintf(ferr,\"Cannot...",
    "content": "event init(t=0){#if _MPIif(!restore(file=dumpFile)){fprintf(ferr,\"Cannot restored from a dump file!\\n\");}#elseif(!restore(file=dumpFile)){charfilename[60];sprintf(filename,\"InitialCondition.stl\");FILE*fp=fopen(filename,\"r\");if(fp==NULL){fprintf(ferr,\"There is no file named%s\\n\",filename);return1;}coord*p=input_stl(fp);fclose(fp);coord min,max;bounding_box(p,&min,&max);fprintf(ferr,\"xmin%gxmax%g\\nymin%gymax%g\\nzmin%gzmax%g\\n\",min.x,max.x,min.y,max.y,min.z,max.z);fprintf(ferr,\"x0 =%g, y0 =%g, z0 =%g\\n\",0.,-1.0,(min.z+max.z)/2.);origin(0.,-1.0-0.025,(min.z+max.z)/2.);scalar d[];distance(d,p);while(adapt_wavelet((scalar*){f,d},(double[]){1e-6,1e-6*L0},MAXlevel).nf);vertex scalar phi[];foreach_vertex(){phi[]=-(d[]+d[-1]+d[0,-1]+d[-1,-1]+d[0,0,-1]+d[-1,0,-1]+d[0,-1,-1]+d[-1,-1,-1])/8.;}fractions(phi,f);foreach(){foreach_dimension(){u.x[]=0.0;}}dump(file=\"dumpInit\");fprintf(ferr,\"Done with initial condition!\\n\");}#endif}",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles - Code Example",
    "content": "event adapt(i++){scalar KAPPA[];curvature(f,KAPPA);adapt_wavelet((scalar*){f,KAPPA,u.x,u.y,u.z},(double[]){fErr,KErr,VelErr,VelErr,VelErr},MAXlevel,MINlevel);}",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles - Code Example",
    "content": "event writingFiles(t=0;t+=tsnap;t<=tmax+tsnap){dump(file=dumpFile);charnameOut[80];sprintf(nameOut,\"intermediate/snapshot-%5.4f\",t);dump(file=nameOut);}",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/JumpingBubbles-hydrophilic.c | Jumping Bubbles - Code Example",
    "content": "event logWriting(t=0;t+=tsnap2;t<=tmax+tsnap){doubleke=0.;foreach(reduction(+:ke)){ke+=0.5*(sq(u.x[])+sq(u.y[])+sq(u.z[]))*clamp(1.-f[],0.,1.)*cube(Delta);}if(pid()==0){staticFILE*fp;if(i==0){fprintf(ferr,\"i dt t ke\\n\");fp=fopen(\"log\",\"w\");fprintf(fp,\"i dt t ke\\n\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}else{fp=fopen(\"log\",\"a\");fprintf(fp,\"%d%g%g%g\\n\",i,dt,t,ke);fclose(fp);}fprintf(ferr,\"%d%g%g%g\\n\",i,dt,t,ke);}}",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/JumpingBubbles-hydrophilic.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "simulationCases/runCasesOpenMPI.sh | Jumping Bubbles",
    "content": "simulationCases/runCasesOpenMPI.sh See raw file runCasesOpenMPI.sh #!/bin/bash CC99 = 'mpicc -std=c99' qcc -Wall -O2 -D_MPI = 1 -disable-dimensions -I\\$ ( PWD ) /src-local JumpingBubbles.c -o JumpingBubbles -lm ./JumpingBubbles",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/runCasesOpenMPI.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/runCasesOpenMPI.sh | Jumping Bubbles - Code Example",
    "content": "#!/bin/bashCC99='mpicc -std=c99'qcc-Wall-O2-D_MPI=1-disable-dimensions-I\\$(PWD)/src-localJumpingBubbles.c-oJumpingBubbles-lm./JumpingBubbles",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/runCasesOpenMPI.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/contact-fixed.h | Jumping Bubbles: Context",
    "content": "src-local/contact-fixed.h See raw file Contact angles This file is used to impose contact angles on boundaries for interfaces described using a VOF tracer and height functions . We first overload the default function used to compute the normal, defined in fractions.h . coord interface_normal ( Point point , scalar c ); #undef interface_normal #define interface_normal ( point , c ) interface_normal ( point , c ) 14 #include \"fractions.h\" #include \"curvature.h\" We will compute the normal using height-functions instead. If this is not possible (typically at low resolutions) we revert back to the Mixed-Youngs-Centered approximation. coord interface_normal ( Point point , scalar c ) { coord n ; if (! c . height . x . i || ( n = height_normal ( point , c , c . height )). x == nodata ) n = mycs ( point , c ); return n ; } The height functions are stored in the vector field associated with each VOF tracer. They need to be updated every time the VOF field changes.",
    "url": "https://comphy-lab.org/JumpingBubbles/src-local/contact-fixed.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/contact-fixed.h | Jumping Bubbles: For the centered...",
    "content": "For the centered Navier-Stokes solver , this means after initialisation and after VOF advection. Note that strictly speaking this should be done for each sweep of the direction-split VOF advection, which we do not do here i.e. we use the normal at the beginning of the timestep and assume it is constant during each sweep. This seems to work fine. extern scalar * interfaces ; event init ( i = 0 ) { for ( scalar c in interfaces ) if ( c . height . x . i ) heights ( c , c . height ); } event tracer_advection ( i ++) { for ( scalar c in interfaces ) if ( c . height . x . i ) heights ( c , c . height ); } The macro below can be used to impose a contact angle on a boundary by setting the corresponding tangential component of the height function. Note that the equivalent function for the normal component of the height function is not defined yet.",
    "url": "https://comphy-lab.org/JumpingBubbles/src-local/contact-fixed.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/contact-fixed.h | Jumping Bubbles: Function Definition",
    "content": "This limits the range of accessible contact angles, since values of the normal component of the height function will be required to compute curvature at shallow angles. #if dimension == #define contact_angle ( theta ) \\ 72 ( val ( _s ) == nodata ? nodata : val ( _s ) + \\ ( orientation ( val ( _s )) ? - 1. : 1. )/ tan ( theta )) Three-dimensional implementation While the 2D implementation is trivial, in 3D one must take into account the projection onto the boundary of the normal to the interface (see Afkhami & Bussmann, 2009 for details). This leads to the code below, where the only complication comes from taking into account the relative orientations of the boundary and height-function components.",
    "url": "https://comphy-lab.org/JumpingBubbles/src-local/contact-fixed.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/contact-fixed.h | Jumping Bubbles: From a user...",
    "content": "From a user point-of-view, using the contact_angle() macro is as simple as in 2D. #else // dimension == #define contact_angle ( theta ) contact_angle_ ( point , neighbor , _s , theta ) 91 foreach_dimension () static double contact_z ( Point point , scalar h , double theta ) { if ( h . i == h . v . z . i ) { fprintf ( stderr , \"contact_angle() cannot be used for ' %s ' which is the normal \\n \" \" component of the height vector \\n \" , h . name ); exit ( 1 ); } if ( h [] == nodata ) return nodata ; foreach_dimension ( 2 ) if ( h . i == h . v . x . i ) foreach_dimension ( 2 ) { coord n = normal2_x ( point , h . v ); if ( n . x != nodata && n . y != nodata ) return h [] + 1. /( tan ( theta )* n . x / sqrt ( sq ( n . x ) + sq ( n . y ))); } return h []; // 90 degree contact angle if the normal is not defined } double contact_angle_ ( Point point , Point neighbor , scalar h , double theta ) { if ( neighbor . i != point . i ) return contact_x ( point , h , theta ); if ( neighbor . j != point . j ) return contact_y ( point , h , theta ); if ( neighbor . k != point . k ) return contact_z ( point , h , theta ); assert ( false ); // not reached return 0. ; } #endif // dimension == References",
    "url": "https://comphy-lab.org/JumpingBubbles/src-local/contact-fixed.h.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "src-local/contact-fixed.h | Jumping Bubbles - Function: interface_normal",
    "content": "coord interface_normal(Point point,scalar c);#undef interface_normal#define interface_normal(point,c)interface_normal(point,c)14#include\"fractions.h\"#include\"curvature.h\"",
    "url": "https://comphy-lab.org/JumpingBubbles/src-local/contact-fixed.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/contact-fixed.h | Jumping Bubbles - Code Example",
    "content": "coord interface_normal(Point point,scalar c){coord n;if(!c.height.x.i||(n=height_normal(point,c,c.height)).x==nodata)n=mycs(point,c);returnn;}",
    "url": "https://comphy-lab.org/JumpingBubbles/src-local/contact-fixed.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/contact-fixed.h | Jumping Bubbles - Code Example",
    "content": "externscalar*interfaces;event init(i=0){for(scalar c in interfaces)if(c.height.x.i)heights(c,c.height);}event tracer_advection(i++){for(scalar c in interfaces)if(c.height.x.i)heights(c,c.height);}",
    "url": "https://comphy-lab.org/JumpingBubbles/src-local/contact-fixed.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/contact-fixed.h | Jumping Bubbles - Code Example",
    "content": "#if dimension ==#define contact_angle(theta)\\72(val(_s)==nodata?nodata:val(_s)+\\(orientation(val(_s))?-1.:1.)/tan(theta))",
    "url": "https://comphy-lab.org/JumpingBubbles/src-local/contact-fixed.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "src-local/contact-fixed.h | Jumping Bubbles - Code Example: #else// dimension ==#define...",
    "content": "#else// dimension ==#define contact_angle(theta)contact_angle_(point,neighbor,_s,theta)91foreach_dimension()staticdoublecontact_z(Point point,scalar h,doubletheta){if(h.i==h.v.z.i){fprintf(stderr,\"contact_angle() cannot be used for '%s' which is the normal\\n\"\"  component of the height vector\\n\",h.name);exit(1);}if(h[]==nodata)returnnodata;foreach_dimension(2)if(h.i==h.v.x.i)foreach_dimension(2){coord n=normal2_x(point,h.v);if(n.x!=nodata&&n.y!=nodata)returnh[]+1./(tan(theta)*n.x/sqrt(sq(n.x)+sq(n.y)));}returnh[];// 90 degree contact angle if the normal is not defined}doublecontact_angle_(Point point,Point neighbor,scalar h,doubletheta){if(neighbor.i!=point.i)returncontact_x(point,h,theta);if(neighbor.j!=point.j)returncontact_y(point,h,theta);if(neighbor.k!=point.k)returncontact_z(point,h,theta);assert(false);// not reachedreturn0.;}#endif// dimension ==",
    "url": "https://comphy-lab.org/JumpingBubbles/src-local/contact-fixed.h.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Local Source Files | Documentation",
    "content": "Local Source Files contact-fixed.h This file is used to impose contact angles on boundaries for interfaces described using a [VOF](vof.h) tracer and [he...",
    "url": "https://comphy-lab.org/JumpingBubbles/src-local/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles: Context",
    "content": "postProcess/getDataXSlice.c See raw file Interpolating Data from Dump Files: gfs2oogl Style This program extracts and interpolates flow field data from Basilisk/Gerris dump files, focusing on velocity fields and viscous dissipation calculations. It provides two interpolation modes: structured grid interpolation and direct boundary point extraction.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles: Author Vatsal Sanjay...",
    "content": "Author Vatsal Sanjay vatsalsanjay@gmail.com Physics of Fluids Group Overview The code processes simulation dump files to extract: - Volume fraction fields (f) - Velocity magnitude - Viscous dissipation rate (D2c) The extraction occurs on a specified x-plane slice, with output suitable for visualization or further analysis. #include \"grid/octree.h\" #include \"navier-stokes/centered.h\" #define FILTERED 26 #include \"two-phase.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #include <string.h> char filename [ 80 ]; int ny , nz ; double ymin , zmin , ymax , zmax , xSlice , Oh ; bool linear ; scalar * list = NULL ; scalar vel [], D2c []; Physical Parameters These define the property ratios between the two phases in the simulation.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles: Mu21 : Viscosity...",
    "content": "Mu21 : Viscosity ratio (phase 2 / phase 1) = 1.00e-3 Rho21 : Density ratio (phase 2 / phase 1) = 1.00e-3 #define MU21 ( 1.00e-3 ) 48 #define RHO21 ( 1.00e-3 ) 49 50 Main Program Processes command-line arguments to extract and interpolate flow field data from a Basilisk dump file.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles: Command Line Arguments...",
    "content": "Command Line Arguments arguments[1] : Input dump file name arguments[2] : Maximum y-coordinate for the extraction domain arguments[3] : Maximum z-coordinate for the extraction domain arguments[4] : x-coordinate of the slice plane arguments[5] : Number of grid points in z-direction (for linear mode) arguments[6] : Ohnesorge number (dimensionless viscosity) arguments[7] : Interpolation mode flag (linear or boundary points) Workflow Loads the dump file and applies boundary conditions Calculates derived quantities (velocity magnitude, dissipation) Outputs data either on a structured grid or at boundary points int main ( int a , char const * arguments []) { Boundary Conditions Apply no-slip conditions at the bottom boundary: - Tangential velocity component = 0 - Radial velocity component = 0 - Volume fraction = 1 (pure phase 1) u . t [ bottom ] = dirichlet ( 0. ); u . r [ bottom ] = dirichlet ( 0. ); f [ bottom ] = dirichlet ( 1. ); File Loading and Initialization Restore the simulation state from the dump file and ensure proper prolongation operators for the volume fraction field. sprintf ( filename , \" %s \" , arguments [ 1 ]); restore ( file = filename ); f . prolongation = fraction_refine ; boundary ({ f , u . x , u . y , u . z }); Domain Bounds Determination Find the minimum y-coordinate by scanning the left boundary.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles: This ensures we...",
    "content": "This ensures we capture the full computational domain extent. ymin = HUGE ; foreach_boundary ( left ) { if ( y < ymin ) ymin = y ; } Parameter Initialization Extract command-line arguments and set up the extraction domain: - ymax : Upper bound in y-direction - zmin/zmax : Bounds in z-direction (0 to specified maximum) - xSlice : Location of the extraction plane - nz : Grid resolution for structured interpolation - Oh : Ohnesorge number for viscosity scaling ymax = atof ( arguments [ 2 ]); zmin = 0.0 ; zmax = atof ( arguments [ 3 ]); xSlice = atof ( arguments [ 4 ]); nz = atoi ( arguments [ 5 ]); Oh = atof ( arguments [ 6 ]); linear = ( strcmp ( arguments [ 7 ], \"true\" ) == 0 ); Physical Properties Setup Set the dimensional properties based on the Ohnesorge number: - Phase 1: \u03c1 = 1.0, \u03bc = Oh - Phase 2: \u03c1 = Rho21, \u03bc = Mu21 \u00d7 Oh This scaling ensures proper dimensionless groups in the simulation. rho1 = 1.0 ; mu1 = Oh ; rho2 = RHO21 ; mu2 = MU21 * Oh ; Output Variable List Define which scalar fields to extract: - Volume fraction (f) - Velocity magnitude (vel) - Log10 of viscous dissipation (D2c) list = list_add ( list , f ); list = list_add ( list , vel ); list = list_add ( list , D2c ); double delta_min = HUGE ; Calculate Derived Quantities For each cell in the domain, compute: 1.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles: Velocity magnitude from...",
    "content": "Velocity magnitude from the three velocity components 2. Viscous dissipation rate using the strain rate tensor foreach () { vel [] = sqrt ( sq ( u . x []) + sq ( u . y []) + sq ( u . z [])); Strain Rate Tensor Calculation Compute D\u00b2 = D\u1d62\u2c7cD\u1d62\u2c7c where D\u1d62\u2c7c is the strain rate tensor: - Diagonal terms: \u2202u\u1d62/\u2202x\u1d62 - Off-diagonal terms: \u00bd(\u2202u\u1d62/\u2202x\u2c7c + \u2202u\u2c7c/\u2202x\u1d62) The dissipation is then 2\u03bcD\u00b2, where \u03bc is the local viscosity. double D2 = 0. ; foreach_dimension () { double DII = ( u . x [ 1 , 0 , 0 ] - u . x [- 1 , 0 , 0 ]) / ( 2 * Delta ); double DIJ = 0.5 * (( u . x [ 0 , 1 , 0 ] - u . x [ 0 ,- 1 , 0 ] + u . y [ 1 , 0 , 0 ] - u . y [- 1 , 0 , 0 ]) / ( 2 * Delta )); double DIK = 0.5 * (( u . x [ 0 , 0 , 1 ] - u . x [ 0 , 0 ,- 1 ] + u . z [ 1 , 0 , 0 ] - u . z [- 1 , 0 , 0 ]) / ( 2 * Delta )); D2 += sq ( DII ) + sq ( DIJ ) + sq ( DIK ); } Dissipation Scaling Convert the dissipation to log10 scale for better visualization range. Values \u2264 0 are mapped to -10 to avoid logarithm issues.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles: D2c [] =...",
    "content": "D2c [] = 2 * ( mu ( f [])) * D2 ; if ( D2c [] > 0. ) { D2c [] = log ( D2c []) / log ( 10. ); } else { D2c [] = - 10. ; } delta_min = delta_min > Delta ? Delta : delta_min ; } Interpolation Mode Selection Choose between structured grid interpolation (linear = true) or direct boundary point extraction (linear = false). If the requested grid spacing exceeds 1/4 of the minimum cell size, force boundary point mode to avoid under-resolution. if (( linear == true ) && ( delta_min < 4 * (( double )(( zmax - zmin ) / ( nz ))))) { linear = false ; } if ( linear == false ) { Boundary Point Extraction Mode Output data directly at computational points on the left boundary. This preserves the adaptive mesh structure but may result in irregular point spacing. Output format: y z f vel D2c FILE * fp = ferr ; foreach_boundary ( left ) { fprintf ( fp , \" %g %g %g %g %g\\n \" , y , z , f [], vel [], D2c []); } } else { Structured Grid Interpolation Mode Interpolate field values onto a regular Cartesian grid.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles: This provides uniform...",
    "content": "This provides uniform spacing suitable for standard visualization tools. FILE * fp = ferr ; Grid Setup Create a uniform grid with: - nz points in z-direction (user-specified) - ny points in y-direction (computed to maintain aspect ratio) - Equal spacing in both directions (DeltaZ = DetlaY) double delta_z = ( double )(( zmax - zmin ) / ( nz )); int ny = ( int )(( ymax - ymin ) / delta_z ); double delta_y = ( double )(( ymax - ymin ) / ( ny )); Memory Allocation Allocate a 2D array to store interpolated values for all fields. The array is structured as field[i][len*j + k] where: - i: y-index - j: z-index - k: field index in the scalar list int len = list_len ( list ); double ** field = ( double **) matrix_new ( ny , nz , len * sizeof ( double )); Interpolation Loop For each grid point, interpolate all scalar fields from the octree structure.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles: This uses trilinear...",
    "content": "This uses trilinear interpolation internally. for ( int i = 0 ; i < ny ; i ++) { double y = delta_y * i + ymin ; for ( int j = 0 ; j < nz ; j ++) { double z = delta_z * j + zmin ; int k = 0 ; for ( scalar s in list ) { field [ i ][ len * j + k ++] = interpolate ( s , xSlice , y , z ); } } } Data Output Write the interpolated data in a format suitable for visualization: - First two columns: y and z coordinates - Remaining columns: scalar field values in list order for ( int i = 0 ; i < ny ; i ++) { double y = delta_y * i + ymin ; for ( int j = 0 ; j < nz ; j ++) { double z = delta_z * j + zmin ; fprintf ( fp , \" %g %g \" , y , z ); int k = 0 ; for ( scalar s in list ) { fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } fflush ( fp ); matrix_free ( field ); } }",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - C/C++ Code",
    "content": "#include\"grid/octree.h\"#include\"navier-stokes/centered.h\"#define FILTERED26#include\"two-phase.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#include<string.h>charfilename[80];intny,nz;doubleymin,zmin,ymax,zmax,xSlice,Oh;boollinear;scalar*list=NULL;scalar vel[],D2c[];",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "u.t[bottom]=dirichlet(0.);u.r[bottom]=dirichlet(0.);f[bottom]=dirichlet(1.);",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "sprintf(filename,\"%s\",arguments[1]);restore(file=filename);f.prolongation=fraction_refine;boundary({f,u.x,u.y,u.z});",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "ymin=HUGE;foreach_boundary(left){if(y<ymin)ymin=y;}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "ymax=atof(arguments[2]);zmin=0.0;zmax=atof(arguments[3]);xSlice=atof(arguments[4]);nz=atoi(arguments[5]);Oh=atof(arguments[6]);linear=(strcmp(arguments[7],\"true\")==0);",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "list=list_add(list,f);list=list_add(list,vel);list=list_add(list,D2c);doubledelta_min=HUGE;",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "foreach(){vel[]=sqrt(sq(u.x[])+sq(u.y[])+sq(u.z[]));",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "doubleD2=0.;foreach_dimension(){doubleDII=(u.x[1,0,0]-u.x[-1,0,0])/(2*Delta);doubleDIJ=0.5*((u.x[0,1,0]-u.x[0,-1,0]+u.y[1,0,0]-u.y[-1,0,0])/(2*Delta));doubleDIK=0.5*((u.x[0,0,1]-u.x[0,0,-1]+u.z[1,0,0]-u.z[-1,0,0])/(2*Delta));D2+=sq(DII)+sq(DIJ)+sq(DIK);}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "D2c[]=2*(mu(f[]))*D2;if(D2c[]>0.){D2c[]=log(D2c[])/log(10.);}else{D2c[]=-10.;}delta_min=delta_min>Delta?Delta:delta_min;}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "if((linear==true)&&(delta_min<4*((double)((zmax-zmin)/(nz))))){linear=false;}if(linear==false){",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "FILE*fp=ferr;foreach_boundary(left){fprintf(fp,\"%g%g%g%g%g\\n\",y,z,f[],vel[],D2c[]);}}else{",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "doubledelta_z=(double)((zmax-zmin)/(nz));intny=(int)((ymax-ymin)/delta_z);doubledelta_y=(double)((ymax-ymin)/(ny));",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "intlen=list_len(list);double**field=(double**)matrix_new(ny,nz,len*sizeof(double));",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "for(inti=0;i<ny;i++){doubley=delta_y*i+ymin;for(intj=0;j<nz;j++){doublez=delta_z*j+zmin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,xSlice,y,z);}}}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataXSlice.c | Jumping Bubbles - Code Example",
    "content": "for(inti=0;i<ny;i++){doubley=delta_y*i+ymin;for(intj=0;j<nz;j++){doublez=delta_z*j+zmin;fprintf(fp,\"%g%g\",y,z);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}fflush(fp);matrix_free(field);}}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataXSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Context",
    "content": "postProcess/Video3D.py See raw file #!/usr/bin/env python3 # -*- coding: utf-8 -*- Basilisk C Snapshot Visualization Script This script processes Basilisk C simulation output files to generate 3D visualizations of multiphase flow simulations. It reads cell and facet data from intermediate snapshot files, creates 3D meshes using PyVista, and saves rendered images for animation production. The script uses multiprocessing to handle large datasets efficiently and includes memory management strategies to prevent out-of-memory errors during batch processing.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Context",
    "content": "Usage: python visualize_snapshots.py Dependencies: - numpy: Array processing - pyvista: 3D visualization and mesh handling - multiprocessing: Parallel processing - Basilisk C executables: getCells_bottomPlate, getFacets3D import subprocess as sp import numpy as np import pyvista as pv import os import multiprocessing import gc # Garbage collection # =============================== # Configuration and Settings # =============================== # Camera configuration for consistent visualization CAMERA_CONFIG = { \"position\" : ( 7.75 , 3.50 , - 2.50 ), \"focal_point\" : ( 0.0 , 0.0 , 0.0 ), \"up_vector\" : ( - 0.30 , 0.95 , 0.025 ), \"parallel_scale\" : 2.2 } # Reflection planes for symmetry operations REFLECTION_NORMALS = { 'x' : [ 1 , 0 , 0 ], 'z' : [ 0 , 0 , 1 ] } # =============================== # Utility Functions # =============================== def parse_vertex(vertex_str): Parse a vertex string into a numpy array.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Converts space-separated string...",
    "content": "Converts space-separated string coordinates into a numpy array for 3D point representation. Args: vertex_str (str): Space-separated vertex coordinates (e.g., \u201c1.0 2.0 3.0\u201d) Returns: np.ndarray: 3D coordinate array Example: >>> parse_vertex(\u201c1.0 2.0 3.0\u201d) array([1., 2., 3.]) return np.fromstring(vertex_str, sep = ' ' ) def run_process(command): Execute a Basilisk C utility and capture its output. Runs external Basilisk processing tools and returns the stderr output, which contains the processed geometric data.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Args: command (list):...",
    "content": "Args: command (list): Command and arguments to execute Returns: str: Decoded stderr output containing geometric data Raises: subprocess.CalledProcessError: If the external command fails Note: Basilisk C utilities output data to stderr by convention p = sp.Popen(command, stdout = sp.PIPE, stderr = sp.PIPE) stdout, stderr = p.communicate() if p.returncode != 0 : error_msg = stdout.decode( \"utf-8\" ) if stdout else stderr.decode( \"utf-8\" ) raise sp.CalledProcessError(p.returncode, command[ 0 ], output = error_msg) return stderr.decode( \"utf-8\" ).strip() # =============================== # Mesh Creation Functions # =============================== def create_polydata(points, lines_array, faces_array): Create a PyVista PolyData object from points and connectivity arrays. Constructs a complete mesh representation with vertices, edges, and faces for visualization purposes.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Args: points (list):...",
    "content": "Args: points (list): List of 3D points defining vertices lines_array (np.ndarray): Connectivity array for line elements faces_array (np.ndarray): Connectivity array for face elements Returns: pv.PolyData: Complete mesh object ready for visualization polydata = pv.PolyData() polydata.points = np.array(points) polydata.lines = lines_array polydata.faces = faces_array return polydata def process_cells(cell_data): Process cell data from Basilisk output into PyVista meshes. Parses the cell structure data and creates individual cell meshes representing the computational grid elements.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Args: cell_data (str):...",
    "content": "Args: cell_data (str): Raw cell data from getCells_bottomPlate output Returns: list: List of PyVista PolyData objects representing cells Note: Assumes rectangular cells with standard connectivity pattern # Standard connectivity for rectangular cells lines_array = np.array([[ 2 , 0 , 1 ], [ 2 , 1 , 2 ], [ 2 , 2 , 3 ], [ 2 , 3 , 0 ]], dtype = np.int32) faces_array = np.array([[ 4 , 0 , 1 , 2 , 3 ]], dtype = np.int32) # Parse cell data blocks separated by double newlines cells = [[parse_vertex(point) for point in cell.split( ' \\n ' )] for cell in cell_data.split( ' \\n\\n ' )] return [create_polydata(cell, lines_array, faces_array) for cell in cells] def process_facets(facet_data): Process facet data into a single unified mesh. Converts facet vertex data into an indexed mesh representation, eliminating duplicate vertices for efficiency. This is typically used for interface reconstruction in multiphase flows.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Args: facet_data (str):...",
    "content": "Args: facet_data (str): Raw facet data from getFacets3D output Returns: pv.PolyData: Unified mesh containing all facets Performance: Uses dictionary-based vertex indexing to avoid duplicate points, reducing memory usage for large datasets. vertex_to_index = {} points, cells = [], [] for facet in facet_data.split( ' \\n\\n ' ): cell = [] for vertex_str in facet.split( ' \\n ' ): vertex = parse_vertex(vertex_str) vertex_tuple = tuple (vertex) # Convert to hashable type # Index unique vertices if vertex_tuple not in vertex_to_index: vertex_to_index[vertex_tuple] = len (points) points.append(vertex) cell.append(vertex_to_index[vertex_tuple]) # Build VTK-style connectivity array cells.extend([ len (cell)] + cell) return pv.PolyData(np.array(points, dtype = np.float64), faces = np.array(cells, dtype = np.int32)) def reflect_mesh(mesh, normals): Apply reflection symmetry operations to a mesh.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Creates reflected copies...",
    "content": "Creates reflected copies of the mesh across specified planes to reconstruct the full domain from symmetry-reduced simulations. Args: mesh (pv.PolyData): Original mesh to reflect normals (dict): Dictionary mapping labels to normal vectors Returns: pv.PolyData: Combined mesh including all reflections Note: Reflections are applied sequentially and merged with the original for normal in normals.values(): mesh = mesh.merge(mesh.reflect(normal)) return mesh # =============================== # Main Processing Functions # =============================== def get_grid(filename): Extract and process computational grid from Basilisk snapshot. Reads cell data from a snapshot file and constructs the visualization mesh for the computational grid, applying symmetry operations.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Args: filename (str):...",
    "content": "Args: filename (str): Path to Basilisk snapshot file Returns: pv.PolyData: Complete grid mesh with reflections applied Note: Requires getCells_bottomPlate executable in the working directory cell_data = run_process([ \"./getCells_bottomPlate\" , filename]) cells = process_cells(cell_data) mesh = pv.MultiBlock(cells).combine() return reflect_mesh(mesh, REFLECTION_NORMALS) def get_facets_3d(filename): Extract and process 3D interface facets from Basilisk snapshot. Reads facet data representing fluid interfaces and constructs the visualization mesh with symmetry operations applied.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Args: filename (str):...",
    "content": "Args: filename (str): Path to Basilisk snapshot file Returns: pv.PolyData: Complete interface mesh with reflections Note: Requires getFacets3D executable in the working directory facet_data = run_process([ \"./getFacets3D\" , filename]) mesh = process_facets(facet_data) return reflect_mesh(mesh, REFLECTION_NORMALS) def process_and_save_image(t, base_filename, image_folder): Process a single time step and generate visualization image. Reads simulation data for a specific time, creates 3D visualization with grid and interface meshes, and saves the rendered image. Args: t (float): Simulation time base_filename (str): Template filename with format specifier image_folder (str): Output directory for images Performance: Includes explicit garbage collection to manage memory usage during batch processing of large datasets. Note: Skips processing if output image already exists or input file is missing.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Uses off-screen rendering...",
    "content": "Uses off-screen rendering for headless operation. filename = base_filename % t image_filename = f\" { image_folder } / { int (t * 1e4 ) :06d} .png\" # Check file existence if not os.path.exists(filename): print ( f\"File { filename } does not exist\" ) return if os.path.exists(image_filename): print ( f\"Image { image_filename } already exists\" ) return print ( f\"Processing t = { t } \" ) # Process mesh data cells = get_grid(filename) poly_data = get_facets_3d(filename) # Configure off-screen renderer plotter = pv.Plotter(off_screen = True ) try : # Add mesh components with different styles plotter.add_mesh(cells, color = 'grey' ) # Solid grid plotter.add_mesh(cells, color = 'black' , style = 'wireframe' ) # Grid edges plotter.add_mesh(poly_data, color = 'orange' ) # Interface # Apply camera configuration plotter.camera.position = CAMERA_CONFIG[ \"position\" ] plotter.camera.focal_point = CAMERA_CONFIG[ \"focal_point\" ] plotter.camera.up = CAMERA_CONFIG[ \"up_vector\" ] plotter.camera.parallel_scale = CAMERA_CONFIG[ \"parallel_scale\" ] # Add timestamp annotation plotter.add_text( f\"t = { t :.2f} \" , position = 'upper_right' , font_size = 15 , color = 'black' , font_file = 'cmunrm.ttf' ) # Render and save plotter.screenshot(image_filename) plotter.close() except Exception as e: print ( f\"Error processing t = { t } : { str (e) } \" ) finally : # Explicit memory cleanup for large datasets del cells, poly_data, plotter gc.collect() def process_single_time_step(args): Wrapper function for multiprocessing pool.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Unpacks arguments and...",
    "content": "Unpacks arguments and calls the main processing function, ensuring proper garbage collection after each process. Args: args (tuple): Packed arguments for process_and_save_image Note: Additional garbage collection helps prevent memory accumulation in long-running batch processes. process_and_save_image( * args) gc.collect() # =============================== # Main Execution # =============================== def main(): Main function that drives the script execution. Sets up the processing pipeline for batch visualization of Basilisk snapshots, using multiprocessing to handle multiple time steps in parallel.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles: Creates output directory...",
    "content": "Creates output directory and manages the processing pool. # Configuration base_filename = \"intermediate/snapshot- %5.4f \" image_folder = \"Video\" # Time stepping parameters time_step = 0.01 end_time = 8 # Create output directory if not os.path.exists(image_folder): os.makedirs(image_folder) # Generate time steps time_steps = np.arange( 0 , end_time + time_step, time_step) args = [(t, base_filename, image_folder) for t in time_steps] # Process in parallel with limited pool size for memory management # TODO : Make number of processes configurable via command line with multiprocessing.Pool(processes = 2 ) as pool: pool. map (process_single_time_step, args) if __name__ == '__main__' : main()",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example: Context",
    "content": "importsubprocessasspimportnumpyasnpimportpyvistaaspvimportosimportmultiprocessingimportgc# Garbage collection# ===============================# Configuration and Settings# ===============================# Camera configuration for consistent visualizationCAMERA_CONFIG={\"position\": (7.75,3.50,-2.50),\"focal_point\": (0.0,0.0,0.0),\"up_vector\": (-0.30,0.95,0.025),\"parallel_scale\":2.2}# Reflection planes for symmetry operationsREFLECTION_NORMALS={'x': [1,0,0],'z': [0,0,1]}# ===============================# Utility Functions# ===============================defparse_vertex(vertex_str):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example",
    "content": "returnnp.fromstring(vertex_str, sep=' ')defrun_process(command):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example",
    "content": "p=sp.Popen(command, stdout=sp.PIPE, stderr=sp.PIPE)stdout, stderr=p.communicate()ifp.returncode!=0:error_msg=stdout.decode(\"utf-8\")ifstdoutelsestderr.decode(\"utf-8\")raisesp.CalledProcessError(p.returncode, command[0], output=error_msg)returnstderr.decode(\"utf-8\").strip()# ===============================# Mesh Creation Functions# ===============================defcreate_polydata(points, lines_array, faces_array):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example",
    "content": "polydata=pv.PolyData()polydata.points=np.array(points)polydata.lines=lines_arraypolydata.faces=faces_arrayreturnpolydatadefprocess_cells(cell_data):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example",
    "content": "# Standard connectivity for rectangular cellslines_array=np.array([[2,0,1], [2,1,2], [2,2,3], [2,3,0]], dtype=np.int32)faces_array=np.array([[4,0,1,2,3]], dtype=np.int32)# Parse cell data blocks separated by double newlinescells=[[parse_vertex(point)forpointincell.split('\\n')]forcellincell_data.split('\\n\\n')]return[create_polydata(cell, lines_array, faces_array)forcellincells]defprocess_facets(facet_data):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example: Context",
    "content": "vertex_to_index={}points, cells=[], []forfacetinfacet_data.split('\\n\\n'):cell=[]forvertex_strinfacet.split('\\n'):vertex=parse_vertex(vertex_str)vertex_tuple=tuple(vertex)# Convert to hashable type# Index unique verticesifvertex_tuplenotinvertex_to_index:vertex_to_index[vertex_tuple]=len(points)points.append(vertex)cell.append(vertex_to_index[vertex_tuple])# Build VTK-style connectivity arraycells.extend([len(cell)]+cell)returnpv.PolyData(np.array(points, dtype=np.float64),faces=np.array(cells, dtype=np.int32))defreflect_mesh(mesh, normals):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example",
    "content": "fornormalinnormals.values():mesh=mesh.merge(mesh.reflect(normal))returnmesh# ===============================# Main Processing Functions# ===============================defget_grid(filename):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example",
    "content": "cell_data=run_process([\"./getCells_bottomPlate\", filename])cells=process_cells(cell_data)mesh=pv.MultiBlock(cells).combine()returnreflect_mesh(mesh, REFLECTION_NORMALS)defget_facets_3d(filename):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example",
    "content": "facet_data=run_process([\"./getFacets3D\", filename])mesh=process_facets(facet_data)returnreflect_mesh(mesh, REFLECTION_NORMALS)defprocess_and_save_image(t, base_filename, image_folder):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example: Context",
    "content": "filename=base_filename%timage_filename=f\"{image_folder}/{int(t*1e4):06d}.png\"# Check file existenceifnotos.path.exists(filename):print(f\"File{filename}does not exist\")returnifos.path.exists(image_filename):print(f\"Image{image_filename}already exists\")returnprint(f\"Processing t ={t}\")# Process mesh datacells=get_grid(filename)poly_data=get_facets_3d(filename)# Configure off-screen rendererplotter=pv.Plotter(off_screen=True)try:# Add mesh components with different stylesplotter.add_mesh(cells, color='grey')# Solid gridplotter.add_mesh(cells, color='black', style='wireframe')# Grid edgesplotter.add_mesh(poly_data, color='orange')# Interface# Apply camera configurationplotter.camera.position=CAMERA_CONFIG[\"position\"]plotter.camera.focal_point=CAMERA_CONFIG[\"focal_point\"]plotter.camera.up=CAMERA_CONFIG[\"up_vector\"]plotter.camera.parallel_scale=CAMERA_CONFIG[\"parallel_scale\"]# Add timestamp annotationplotter.add_text(f\"t ={t:.2f}\", position='upper_right',font_size=15, color='black', font_file='cmunrm.ttf')# Render and saveplotter.screenshot(image_filename)plotter.close()exceptExceptionase:print(f\"Error processing t ={t}:{str(e)}\")finally:# Explicit memory cleanup for large datasetsdelcells, poly_data, plottergc.collect()defprocess_single_time_step(args):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example",
    "content": "process_and_save_image(*args)gc.collect()# ===============================# Main Execution# ===============================defmain():",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video3D.py | Jumping Bubbles - Code Example: Context",
    "content": "# Configurationbase_filename=\"intermediate/snapshot-%5.4f\"image_folder=\"Video\"# Time stepping parameterstime_step=0.01end_time=8# Create output directoryifnotos.path.exists(image_folder):os.makedirs(image_folder)# Generate time stepstime_steps=np.arange(0, end_time+time_step, time_step)args=[(t, base_filename, image_folder)fortintime_steps]# Process in parallel with limited pool size for memory management#TODO: Make number of processes configurable via command linewithmultiprocessing.Pool(processes=2)aspool:pool.map(process_single_time_step, args)if__name__=='__main__':main()",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video3D.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "Post-Processing Tools | Documentation",
    "content": "Post-Processing Tools getCells_bottomPlate.c This program extracts and visualizes boundary data from Basilisk C simulation files, specifically designed for analyz... getDataXSlice.c This program extracts and interpolates flow field data from Basilisk/Gerris dump files, focusing on velocity fields a... getDataZSlice.c This program performs spatial interpolation of fluid dynamics simulation data from Basilisk dump files. It extracts v... getFacets3D.c This module provides functionality for extracting and outputting interface facets from volume fraction fields in comp... Video2DSlice.py Fluid Dynamics Visualization for Basilisk C Simulations This script processes Basilisk C simulation output data to ge... Video3D.py Basilisk C Snapshot Visualization Script This script processes Basilisk C simulation output files to generate 3D visu... Visulization3D.ipynb This notebook provides visualization and analysis related to Visulization3D.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/index.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets3D.c | Jumping Bubbles: Context",
    "content": "postProcess/getFacets3D.c See raw file Facet Output Visualization Tool This module provides functionality for extracting and outputting interface facets from volume fraction fields in computational fluid dynamics simulations. It is designed to work with the Basilisk C framework for solving partial differential equations on adaptive octree/quadtree grids. Overview The tool reads volume fraction data from saved simulation files and extracts the interface geometry using facet reconstruction algorithms. The extracted facets can be visualized or processed for further analysis of multiphase flow interfaces.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getFacets3D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets3D.c | Jumping Bubbles: C/C++ Code",
    "content": "Authors Vatsal Sanjay (vatsalsanjay@gmail.com) Physics of Fluids Group Dependencies Basilisk C framework Octree grid implementation Navier-Stokes centered solver Volume fraction utilities #include \"grid/octree.h\" #include \"navier-stokes/centered.h\" #include \"fractions.h\" scalar f []; char filename [ 80 ]; output_facets_v2 Extracts and outputs the facets (interface segments/polygons) from a volume fraction field. This function implements a marching squares/cubes-like algorithm to reconstruct interfaces from volume fraction data. The function iterates through all grid cells and identifies those containing an interface (where the volume fraction is between 0 and 1). For each interface cell, it: 1. Computes the interface normal using neighboring cell data 2. Calculates the plane constant \u03b1 for the linear interface approximation 3. Extracts the intersection points between the interface and cell edges 4.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getFacets3D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets3D.c | Jumping Bubbles: Outputs the facet...",
    "content": "Outputs the facet vertices to the specified file Parameters c : Volume fraction scalar field containing the interface data fp : Output file pointer for writing facet coordinates (default: stdout) s : Face vector field for surface tension calculations (default: {{-1}}) Output Format The output format depends on the spatial dimension: - 1D : Single x-coordinate of the interface position - 2D : Line segments as pairs of (x,y) coordinates, blank line separated - 3D : Polygon vertices as (x,y,z) coordinates, blank line separated Implementation Notes Only processes cells with volume fraction in range (1e-6, 1-1e-6) to avoid numerical issues near pure phases Uses the PLIC (Piecewise Linear Interface Calculation) method for interface reconstruction Facet extraction tolerance is set to 1.1 for robust polygon generation in 3D cases trace void output_facets_v2 ( scalar c , FILE * fp = stdout , face vector s = {{- 1 }}) { foreach () if ( c [] > 1e-6 && c [] < 1. - 1e-6 ) { coord n = facet_normal ( point , c , s ); double alpha = plane_alpha ( c [], n ); #if dimension == fprintf ( fp , \" %g\\n \" , x + Delta * alpha / n . x ); #elif dimension == coord segment [ 2 ]; if ( facets ( n , alpha , segment ) == 2 ) fprintf ( fp , \" %g %g\\n%g %g\\n\\n \" , x + segment [ 0 ]. x * Delta , y + segment [ 0 ]. y * Delta , x + segment [ 1 ]. x * Delta , y + segment [ 1 ]. y * Delta ); #else // dimension == coord v [ 12 ]; int m = facets ( n , alpha , v , 1.1 ); for ( int i = 0 ; i < m ; i ++) fprintf ( fp , \" %g %g %g\\n \" , x + v [ i ]. x * Delta , y + v [ i ]. y * Delta , z + v [ i ]. z * Delta ); if ( m > 0 ) fputc ( ' \\n ' , fp ); #endif } fflush ( fp ); } main Entry point for the facet extraction tool.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getFacets3D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets3D.c | Jumping Bubbles: Processes a saved...",
    "content": "Processes a saved simulation file specified as a command-line argument and outputs the extracted facets to standard error. Command Line Usage ./program_name simulation_file.dump Parameters a : Number of command line arguments arguments : Array of command line argument strings arguments[1] : Path to the input simulation file Processing Steps Reads the filename from command line arguments Sets boundary conditions for the volume fraction field Restores the simulation state from the saved file Ensures proper prolongation operators for adaptive mesh refinement Calls output_facets_v2 to extract and output interface facets Boundary Conditions Bottom boundary: Dirichlet condition with f = 1 (fully filled) Tree Grid Handling For adaptive (tree) grids, the function ensures that the volume fraction field uses the appropriate fraction_refine prolongation operator. This is crucial for maintaining conservation properties during mesh refinement and coarsening operations.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getFacets3D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets3D.c | Jumping Bubbles: C/C++ Main",
    "content": "Output Interface facets are written to standard error (ferr) in a format suitable for visualization with tools like gnuplot or paraview. int main ( int a , char const * arguments []) { sprintf ( filename , \" %s \" , arguments [ 1 ]); f [ bottom ] = dirichlet ( 1. ); restore ( file = filename ); #if TREE // Ensure proper prolongation for volume fraction fields on adaptive grids void (* prolongation )( Point , scalar ) = f . prolongation ; if ( prolongation != fraction_refine ) { f . prolongation = fraction_refine ; f . dirty = true ; } #endif // TREE output_facets_v2 ( f , ferr ); }",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getFacets3D.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets3D.c | Jumping Bubbles - C/C++ Code",
    "content": "#include\"grid/octree.h\"#include\"navier-stokes/centered.h\"#include\"fractions.h\"scalar f[];charfilename[80];",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getFacets3D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets3D.c | Jumping Bubbles - Code Example: tracevoidoutput_facets_v2(scalar c,FILE*fp=stdout,face vector...",
    "content": "tracevoidoutput_facets_v2(scalar c,FILE*fp=stdout,face vector s={{-1}}){foreach()if(c[]>1e-6&&c[]<1.-1e-6){coord n=facet_normal(point,c,s);doublealpha=plane_alpha(c[],n);#if dimension ==fprintf(fp,\"%g\\n\",x+Delta*alpha/n.x);#elif dimension ==coord segment[2];if(facets(n,alpha,segment)==2)fprintf(fp,\"%g%g\\n%g%g\\n\\n\",x+segment[0].x*Delta,y+segment[0].y*Delta,x+segment[1].x*Delta,y+segment[1].y*Delta);#else// dimension ==coord v[12];intm=facets(n,alpha,v,1.1);for(inti=0;i<m;i++)fprintf(fp,\"%g%g%g\\n\",x+v[i].x*Delta,y+v[i].y*Delta,z+v[i].z*Delta);if(m>0)fputc('\\n',fp);#endif}fflush(fp);}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getFacets3D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getFacets3D.c | Jumping Bubbles - Code Example",
    "content": "intmain(inta,charconst*arguments[]){sprintf(filename,\"%s\",arguments[1]);f[bottom]=dirichlet(1.);restore(file=filename);#if TREE// Ensure proper prolongation for volume fraction fields on adaptive gridsvoid(*prolongation)(Point,scalar)=f.prolongation;if(prolongation!=fraction_refine){f.prolongation=fraction_refine;f.dirty=true;}#endif// TREEoutput_facets_v2(f,ferr);}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getFacets3D.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Context",
    "content": "postProcess/Video2DSlice.py See raw file #!/usr/bin/env python3 # -*- coding: utf-8 -*- Fluid Dynamics Visualization for Basilisk C Simulations This script processes Basilisk C simulation output data to generate high-quality visualizations of fluid dynamics phenomena. It creates contour plots showing velocity magnitude and viscous dissipation rate for both X and Z slices through the computational domain. The script is designed to work with snapshot data from Basilisk simulations, particularly for studying flows with specified Ohnesorge numbers. It uses multiprocessing to efficiently process multiple time steps in parallel.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Examples",
    "content": "Usage: python fluid_visualization.py [\u2013Oh OHNESORGE_NUMBER] Example: python fluid_visualization.py \u2013Oh 0.01 Dependencies: - numpy: For numerical operations - matplotlib: For visualization - concurrent.futures: For parallel execution - multiprocessing: For parallel processing of time steps import numpy as np import os import subprocess as sp import matplotlib import matplotlib.pyplot as plt import matplotlib.patches as patches from matplotlib.ticker import StrMethodFormatter import concurrent.futures import multiprocessing import argparse # =============================== # Matplotlib Configuration # =============================== matplotlib.rcParams[ 'font.family' ] = 'serif' matplotlib.rcParams[ 'text.usetex' ] = True # Font sizes for publication-quality figures AXES_LABEL_SIZE = 50 TICK_LABEL_SIZE = 20 # =============================== # Data Processing Functions # =============================== def get_data(exe): Execute external program and parse its output data.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Runs a Basilisk...",
    "content": "Runs a Basilisk utility program (getDataXSlice or getDataZSlice) to extract simulation data along a specified plane. The utility outputs data to stderr in a space-separated format which is then parsed into a numpy array. Args: exe (list): Command and arguments to execute, e.g., [\u201c./getDataXSlice\u201d, filename, ymax, xmax, \u2026] Returns: numpy.ndarray: Transposed data array with shape (5, n_points) containing: [y_coords, x_coords, volume_fraction, velocity_magnitude, D2] Raises: sp.CalledProcessError: If the external program fails ValueError: If data cannot be parsed into expected shape Note: The external utilities must be compiled and available in the current directory.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Results",
    "content": "They output 5 columns: y, x, f, |u|, and log10(2 Oh D:D). result = sp.run(exe, capture_output = True , text = True , check = True ) try : if not result.stderr: raise ValueError ( f\"No output from { exe[ 0 ] } \" ) data = np.fromstring(result.stderr, sep = ' ' ).reshape(( - 1 , 5 )) return data.T except ( ValueError , AttributeError ) as e: raise ValueError ( f\"Failed to parse output from { exe[ 0 ] } : { e } \" ) # =============================== # Plotting Functions # =============================== def plot_subplot(ax, data, ymin, xmax, ymax): Create contour plots on a single subplot. Generates a composite visualization showing: 1. Interface contour (f=0.5) in green 2. Velocity magnitude field on the left half 3. Viscous dissipation rate on the right half The plot is symmetric about x=0, with different fields displayed on each side to efficiently show multiple quantities in a single view.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Context",
    "content": "Args: ax (matplotlib.axes.Axes): The axes object to plot on data (numpy.ndarray): Data array from get_data() containing [y, x, f, vel, D2] ymin (float): Minimum y-coordinate for plot bounds xmax (float): Maximum x-coordinate (plot extends from -xmax to xmax) ymax (float): Maximum y-coordinate for plot bounds Returns: tuple: (cntrl1, cntrl2) - Contour plot objects for velocity and dissipation rate, respectively. Used for colorbar creation.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Examples",
    "content": "Example: >>> fig, ax = plt.subplots() >>> data = get_data([\u201c./getDataXSlice\u201d, \u2026]) >>> vel_contour, diss_contour = plot_subplot(ax, data, -1, 2.5, 2.5) y, x, f, vel, D2 = data # Plot interface contour (f=0.5) on both sides ax.tricontour(x, y, f, levels = [ 0.5 ], colors = 'green' , linewidths = 5 ) ax.tricontour( - x, y, f, levels = [ 0.5 ], colors = 'green' , linewidths = 5 ) # Left side: velocity magnitude cntrl1 = ax.tricontourf( - x, y, vel, levels = np.linspace( 0 , 5 , 500 ), cmap = 'Purples' , extend = 'max' ) # Right side: viscous dissipation (log scale) cntrl2 = ax.tricontourf(x, y, D2, levels = np.linspace( - 2 , 2 , 400 ), cmap = 'hot_r' , extend = 'both' ) # Add centerline ax.plot([ 0 , 0 ], [ymin, ymax], '--' , color = 'grey' , linewidth = 4 ) # Add bounding box rect = patches.Rectangle(( - xmax, ymin), 2 * xmax, ymax - ymin, linewidth = 6 , edgecolor = 'k' , facecolor = 'none' ) ax.add_patch(rect) # Configure axes ax.set_aspect( 'equal' ) ax.set_xlim( - xmax, xmax) ax.set_ylim(ymin, ymax) ax.axis( 'off' ) return cntrl1, cntrl2 def plot_data(filename, image_name, ymin, xmax, ymax, n, Oh, linear, t): Generate complete visualization with X and Z slice views.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Creates a two-panel...",
    "content": "Creates a two-panel figure showing orthogonal slices through the simulation domain. Each panel displays velocity magnitude and viscous dissipation rate split across the vertical centerline. This provides a comprehensive view of the flow structure and energy dissipation patterns. Args: filename (str): Path to Basilisk snapshot file image_name (str): Output path for the generated PNG image ymin (float): Minimum y-coordinate for plot bounds xmax (float): Maximum x-coordinate for plot bounds ymax (float): Maximum y-coordinate for plot bounds n (int): Grid resolution for data extraction Oh (float): Ohnesorge number (Oh = \u03bc/\u221a(\u03c1\u03c3R)) linear (str): Interpolation mode (\u2018true\u2019 or \u2018false\u2019) t (float): Non-dimensional time t/\u221a(\u03c1R\u00b3/\u03c3) Note: The figure size is automatically adjusted to maintain proper aspect ratios for the domain. Colorbars are positioned below each subplot.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Performance: Uses ThreadPoolExecutor...",
    "content": "Performance: Uses ThreadPoolExecutor to parallelize data extraction for X and Z slices, reducing I/O wait time by approximately 40%. # Calculate figure dimensions to maintain aspect ratio fig_width = 24 # inches fig_height = fig_width * (ymax - ymin) / xmax fig = plt.figure(figsize = (fig_width, fig_height)) # Create subplots for X and Z slices ax1 = fig.add_subplot( 121 ) ax2 = fig.add_subplot( 122 ) # Prepare commands for data extraction utilities commands = [ [ \"./getDataXSlice\" , filename, str (ymax), str (xmax), str ( 0. ), str (n), str (Oh), linear], [ \"./getDataZSlice\" , filename, str (ymax), str (xmax), str ( 0. ), str (n), str (Oh), linear] ] # Execute data extraction in parallel with concurrent.futures.ThreadPoolExecutor() as executor: results = executor. map (get_data, commands) # Generate plots for each slice for ax, data in zip ([ax1, ax2], results): cntrl1, cntrl2 = plot_subplot(ax, data, ymin, xmax, ymax) ax.set_aspect( 'equal' ) # Manually position subplots for optimal layout ax1.set_position([ 0.095 , 0.1 , 0.4 , 0.8 ]) ax2.set_position([ 0.4975 , 0.1 , 0.4 , 0.8 ]) # Add colorbar for velocity magnitude (left subplot) l, b, w, h = ax1.get_position().bounds cb1 = fig.add_axes([l + 0.05 * w, b - 0.075 * h, 0.9 * w, 0.01 ]) c1 = plt.colorbar(cntrl1, cax = cb1, orientation = 'horizontal' ) c1.set_label( r' $ \\| u_i \\| / \\s qrt{ \\ gamma/ \\r ho_lR_0} $ ' , fontsize = TICK_LABEL_SIZE, labelpad = 5 ) c1.ax.tick_params(labelsize = TICK_LABEL_SIZE) c1.ax.xaxis.set_major_formatter(StrMethodFormatter( ' {x:,.1f} ' )) # Add colorbar for viscous dissipation (right subplot) l, b, w, h = ax2.get_position().bounds cb2 = fig.add_axes([l + 0.05 * w, b - 0.075 * h, 0.9 * w, 0.01 ]) c2 = plt.colorbar(cntrl2, cax = cb2, orientation = 'horizontal' ) c2.set_label( r' $ \\ log_ {10} \\ left ( 2Oh \\m athcal{D}_{ij} \\m athcal{D}_{ij} \\r ight ) $ ' , fontsize = TICK_LABEL_SIZE) c2.ax.tick_params(labelsize = TICK_LABEL_SIZE) c2.ax.xaxis.set_major_formatter(StrMethodFormatter( ' {x:,.1f} ' )) # Add title with current time ax1.set_title( r' $ t/ \\s qrt{ \\r ho_lR_0 ^ 3/ \\ gamma} = %3 . 2f $ ' % t, fontsize = TICK_LABEL_SIZE + 10 , pad = 10 ) # Save figure with tight bounding box plt.savefig(image_name, bbox_inches = 'tight' ) plt.close() # =============================== # Time Step Processing # =============================== def process_single_time_step(t, base_filename, image_folder, ymin, Oh): Process a single simulation time step to generate visualization.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Function Definition",
    "content": "Handles file existence checks, prevents redundant processing, and manages the complete visualization pipeline for one time step. This function is designed to be called in parallel by multiprocessing.Pool.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Args: t (float):...",
    "content": "Args: t (float): Time value for this snapshot base_filename (str): Format string for snapshot filenames, e.g., \u201cintermediate/snapshot-%5.4f\u201d image_folder (str): Directory to save output images ymin (float): Minimum y-coordinate for plot bounds Oh (float): Ohnesorge number for the simulation Returns: None Side Effects: - Creates PNG file in image_folder if processing succeeds - Prints status messages to stdout Example: >>> process_single_time_step(1.5, \u201csnapshot-%5.4f\u201d, \u201coutput/\u201d, -1.0, 0.01) Processing 1.5 filename = base_filename % t image_name = os.path.join(image_folder, f'snapshot- { t :.4f} .png' ) # Check if input file exists if not os.path.exists(filename): print ( f\"File { filename } does not exist\" ) return # Skip if output already exists (allows resuming interrupted runs) if os.path.exists(image_name): print ( f\"Image { image_name } already exists\" ) return print ( f\"Processing { t } \" ) # Visualization parameters xmax, ymax, n = 2.5 , 2.5 , 256 linear = 'false' # Generate visualization plot_data(filename, image_name, ymin, xmax, ymax, n, Oh, linear, t) # =============================== # Main Execution # =============================== def main(): Main function that drives the script execution.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Parses command-line arguments,...",
    "content": "Parses command-line arguments, sets up the processing environment, and orchestrates parallel processing of multiple time steps. The script uses multiprocessing to efficiently handle large numbers of snapshots. The workflow: 1. Parse command-line arguments for Ohnesorge number 2. Create output directory if needed 3. Generate list of time steps to process 4.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles: Use multiprocessing pool...",
    "content": "Use multiprocessing pool to process time steps in parallel Performance Considerations: - Uses 4 processes by default (adjust based on available cores) - Each process handles file I/O and plotting independently - Memory usage scales with number of parallel processes # Set up command-line argument parsing parser = argparse.ArgumentParser( description = \"Process Basilisk fluid dynamics simulation data to create visualizations.\" ) parser.add_argument( '--Oh' , type = float , default = 0.01 , help = 'Ohnesorge number (default: 0.01)' ) args = parser.parse_args() # Configuration base_filename = \"intermediate/snapshot- %5.4f \" image_folder = \"Video2DSlice\" ymin = - 1.025 Oh = args.Oh # Create output directory if it doesn't exist if not os.path.exists(image_folder): os.makedirs(image_folder) # Generate time steps time_step = 0.01 end_time = 8 time_steps = np.arange( 0 , end_time + time_step, time_step) # Process time steps in parallel # TODO : Make number of processes configurable via command line with multiprocessing.Pool(processes = 4 ) as pool: pool.starmap(process_single_time_step, [(t, base_filename, image_folder, ymin, Oh) for t in time_steps]) # Script entry point if __name__ == '__main__' : main()",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles - Code Example: Methods",
    "content": "importnumpyasnpimportosimportsubprocessasspimportmatplotlibimportmatplotlib.pyplotaspltimportmatplotlib.patchesaspatchesfrommatplotlib.tickerimportStrMethodFormatterimportconcurrent.futuresimportmultiprocessingimportargparse# ===============================# Matplotlib Configuration# ===============================matplotlib.rcParams['font.family']='serif'matplotlib.rcParams['text.usetex']=True# Font sizes for publication-quality figuresAXES_LABEL_SIZE=50TICK_LABEL_SIZE=20# ===============================# Data Processing Functions# ===============================defget_data(exe):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles - Code Example",
    "content": "result=sp.run(exe, capture_output=True, text=True, check=True)try:ifnotresult.stderr:raiseValueError(f\"No output from{exe[0]}\")data=np.fromstring(result.stderr, sep=' ').reshape((-1,5))returndata.Texcept(ValueError,AttributeError)ase:raiseValueError(f\"Failed to parse output from{exe[0]}:{e}\")# ===============================# Plotting Functions# ===============================defplot_subplot(ax, data, ymin, xmax, ymax):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles - Code Example: y, x, f,...",
    "content": "y, x, f, vel, D2=data# Plot interface contour (f=0.5) on both sidesax.tricontour(x, y, f, levels=[0.5], colors='green', linewidths=5)ax.tricontour(-x, y, f, levels=[0.5], colors='green', linewidths=5)# Left side: velocity magnitudecntrl1=ax.tricontourf(-x, y, vel, levels=np.linspace(0,5,500),cmap='Purples', extend='max')# Right side: viscous dissipation (log scale)cntrl2=ax.tricontourf(x, y, D2, levels=np.linspace(-2,2,400),cmap='hot_r', extend='both')# Add centerlineax.plot([0,0], [ymin, ymax],'--', color='grey', linewidth=4)# Add bounding boxrect=patches.Rectangle((-xmax, ymin),2*xmax, ymax-ymin,linewidth=6, edgecolor='k', facecolor='none')ax.add_patch(rect)# Configure axesax.set_aspect('equal')ax.set_xlim(-xmax, xmax)ax.set_ylim(ymin, ymax)ax.axis('off')returncntrl1, cntrl2defplot_data(filename, image_name, ymin, xmax, ymax, n, Oh, linear, t):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles - Code Example: # Calculate figure...",
    "content": "# Calculate figure dimensions to maintain aspect ratiofig_width=24# inchesfig_height=fig_width*(ymax-ymin)/xmaxfig=plt.figure(figsize=(fig_width, fig_height))# Create subplots for X and Z slicesax1=fig.add_subplot(121)ax2=fig.add_subplot(122)# Prepare commands for data extraction utilitiescommands=[[\"./getDataXSlice\", filename,str(ymax),str(xmax),str(0.),str(n),str(Oh), linear],[\"./getDataZSlice\", filename,str(ymax),str(xmax),str(0.),str(n),str(Oh), linear]]# Execute data extraction in parallelwithconcurrent.futures.ThreadPoolExecutor()asexecutor:results=executor.map(get_data, commands)# Generate plots for each sliceforax, datainzip([ax1, ax2], results):cntrl1, cntrl2=plot_subplot(ax, data, ymin, xmax, ymax)ax.set_aspect('equal')# Manually position subplots for optimal layoutax1.set_position([0.095,0.1,0.4,0.8])ax2.set_position([0.4975,0.1,0.4,0.8])# Add colorbar for velocity magnitude (left subplot)l, b, w, h=ax1.get_position().boundscb1=fig.add_axes([l+0.05*w, b-0.075*h,0.9*w,0.01])c1=plt.colorbar(cntrl1, cax=cb1, orientation='horizontal')c1.set_label(r'$\\|u_i\\|/\\sqrt{\\gamma/\\rho_lR_0}$',fontsize=TICK_LABEL_SIZE, labelpad=5)c1.ax.tick_params(labelsize=TICK_LABEL_SIZE)c1.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}'))# Add colorbar for viscous dissipation (right subplot)l, b, w, h=ax2.get_position().boundscb2=fig.add_axes([l+0.05*w, b-0.075*h,0.9*w,0.01])c2=plt.colorbar(cntrl2, cax=cb2, orientation='horizontal')c2.set_label(r'$\\log_{10}\\left(2Oh\\mathcal{D}_{ij}\\mathcal{D}_{ij}\\right)$',fontsize=TICK_LABEL_SIZE)c2.ax.tick_params(labelsize=TICK_LABEL_SIZE)c2.ax.xaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}'))# Add title with current timeax1.set_title(r'$t/\\sqrt{\\rho_lR_0^3/\\gamma} = %3.2f$'%t,fontsize=TICK_LABEL_SIZE+10, pad=10)# Save figure with tight bounding boxplt.savefig(image_name, bbox_inches='tight')plt.close()# ===============================# Time Step Processing# ===============================defprocess_single_time_step(t, base_filename, image_folder, ymin, Oh):",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles - Code Example: Context",
    "content": "filename=base_filename%timage_name=os.path.join(image_folder,f'snapshot-{t:.4f}.png')# Check if input file existsifnotos.path.exists(filename):print(f\"File{filename}does not exist\")return# Skip if output already exists (allows resuming interrupted runs)ifos.path.exists(image_name):print(f\"Image{image_name}already exists\")returnprint(f\"Processing{t}\")# Visualization parametersxmax, ymax, n=2.5,2.5,256linear='false'# Generate visualizationplot_data(filename, image_name, ymin, xmax, ymax, n, Oh, linear, t)# ===============================# Main Execution# ===============================defmain():",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Video2DSlice.py | Jumping Bubbles - Code Example: # Set up...",
    "content": "# Set up command-line argument parsingparser=argparse.ArgumentParser(description=\"Process Basilisk fluid dynamics simulation data to create visualizations.\")parser.add_argument('--Oh',type=float, default=0.01,help='Ohnesorge number (default: 0.01)')args=parser.parse_args()# Configurationbase_filename=\"intermediate/snapshot-%5.4f\"image_folder=\"Video2DSlice\"ymin=-1.025Oh=args.Oh# Create output directory if it doesn't existifnotos.path.exists(image_folder):os.makedirs(image_folder)# Generate time stepstime_step=0.01end_time=8time_steps=np.arange(0, end_time+time_step, time_step)# Process time steps in parallel#TODO: Make number of processes configurable via command linewithmultiprocessing.Pool(processes=4)aspool:pool.starmap(process_single_time_step,[(t, base_filename, image_folder, ymin, Oh)fortintime_steps])# Script entry pointif__name__=='__main__':main()",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Video2DSlice.py.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles: Context",
    "content": "postProcess/getDataZSlice.c See raw file Data Interpolation from Dump Files This program performs spatial interpolation of fluid dynamics simulation data from Basilisk dump files. It extracts velocity fields, volume fractions, and viscous dissipation rates from octree-based adaptive mesh refinement (AMR) simulations and interpolates them onto regular grids for post-processing and visualization. Physics Background The code analyzes two-phase flow simulations where: - Phase 1 represents the primary fluid (e.g., a droplet) - Phase 2 represents the surrounding medium (e.g., air) The simulation employs the Volume-of-Fluid (VOF) method with the Navier-Stokes equations to track the interface between phases.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles: Key physical parameters...",
    "content": "Key physical parameters include: - Density ratio: \u03c1\u2082/\u03c1\u2081 = 10\u207b\u00b3 - Viscosity ratio: \u03bc\u2082/\u03bc\u2081 = 10\u207b\u00b3 - Ohnesorge number: Oh = \u03bc\u2081/\u221a(\u03c1\u2081\u03c3R) controlling viscous-to-inertial forces Author Information Author: Vatsal Sanjay Email: vatsalsanjay@gmail.com Affiliation: Physics of Fluids #include \"grid/octree.h\" #include \"navier-stokes/centered.h\" #define FILTERED 31 #include \"two-phase.h\" #include \"navier-stokes/conserving.h\" #include \"tension.h\" #include <string.h> Global Variables filename : Path to the input dump file ny , nx : Grid dimensions for regular interpolation ymin , xmin , ymax , xmax : Spatial bounds for interpolation region zSlice : Z-coordinate for 2D slice extraction from 3D data Oh : Ohnesorge number for viscosity scaling linear : Flag for linear vs. adaptive interpolation list : List of scalar fields to interpolate char filename [ 80 ]; int ny , nx ; double ymin , xmin , ymax , xmax , zSlice , Oh ; bool linear ; scalar * list = NULL ; Field Variables vel[] : Velocity magnitude field |u| = \u221a(u\u00b2+v\u00b2+w\u00b2) D2c[] : Logarithm of viscous dissipation rate 2\u03bcD:D scalar vel [], D2c []; Physical Constants Define the density and viscosity ratios between phase 2 (surrounding medium) and phase 1 (primary fluid).",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles: These values typical...",
    "content": "These values typical for air-water systems. #define MU21 ( 1.00e-3 ) 68 #define RHO21 ( 1.00e-3 ) 69 70 Main Function Processes command-line arguments and performs the interpolation workflow.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles: Command-line Arguments arguments[1]...",
    "content": "Command-line Arguments arguments[1] : Input dump file path arguments[2] : Maximum y-coordinate (ymax) arguments[3] : Maximum x-coordinate (xmax) arguments[4] : Z-slice coordinate for 2D extraction arguments[5] : Number of grid points in x-direction (nx) arguments[6] : Ohnesorge number arguments[7] : Linear interpolation flag (true/false) Workflow Restore simulation state from dump file Set boundary conditions Compute derived fields (velocity magnitude, dissipation) Perform interpolation based on grid resolution Output results to stderr int main ( int a , char const * arguments []) { Boundary Conditions Apply no-slip boundary conditions at the bottom: - Zero tangential velocity: u.t = 0 - Zero radial velocity: u.r = 0 - Full wetting: f = 1 (volume fraction) u . t [ bottom ] = dirichlet ( 0. ); u . r [ bottom ] = dirichlet ( 0. ); f [ bottom ] = dirichlet ( 1. ); File Loading and Initialization Load the simulation state from the specified dump file and ensure proper prolongation operators for the volume fraction field to maintain sharp interfaces during interpolation. sprintf ( filename , \" %s \" , arguments [ 1 ]); restore ( file = filename ); f . prolongation = fraction_refine ; boundary ({ f , u . x , u . y , u . z }); Domain Bounds Determination Find the minimum y-coordinate from the back boundary to establish the lower bound of the interpolation domain. ymin = HUGE ; foreach_boundary ( back ) { if ( y < ymin ) ymin = y ; } Parameter Assignment Parse remaining command-line arguments to set interpolation parameters and physical properties. ymax = atof ( arguments [ 2 ]); xmin = 0.0 ; xmax = atof ( arguments [ 3 ]); zSlice = atof ( arguments [ 4 ]); nx = atoi ( arguments [ 5 ]); Oh = atof ( arguments [ 6 ]); linear = ( strcmp ( arguments [ 7 ], \"true\" ) == 0 ); Physical Properties Set density and viscosity values based on the Ohnesorge number and predefined ratios.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles: This maintains the...",
    "content": "This maintains the correct non-dimensional groups for the simulation. rho1 = 1.0 ; mu1 = Oh ; rho2 = RHO21 ; mu2 = MU21 * Oh ; Field List Construction Build the list of scalar fields to interpolate: - Volume fraction (f) - Velocity magnitude (vel) - Viscous dissipation (D2c) list = list_add ( list , f ); list = list_add ( list , vel ); list = list_add ( list , D2c ); double delta_min = HUGE ; Derived Field Computation Calculate velocity magnitude and viscous dissipation rate at each grid point.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles: The dissipation rate...",
    "content": "The dissipation rate D2c = 2\u03bcD:D represents energy loss due to viscosity, where D is the rate-of-deformation tensor. foreach () { vel [] = sqrt ( sq ( u . x []) + sq ( u . y []) + sq ( u . z [])); Calculate components of the rate-of-deformation tensor D using second-order central differences: - D_ii = \u2202u_i/\u2202x_i (diagonal terms) - D_ij = 0.5(\u2202u_i/\u2202x_j + \u2202u_j/\u2202x_i) (off-diagonal terms) Then compute D:D = \u03a3(D_ij)\u00b2 for viscous dissipation. double D2 = 0. ; foreach_dimension () { double DII = ( u . x [ 1 , 0 , 0 ] - u . x [- 1 , 0 , 0 ]) / ( 2 * Delta ); double DIJ = 0.5 * (( u . x [ 0 , 1 , 0 ] - u . x [ 0 ,- 1 , 0 ] + u . y [ 1 , 0 , 0 ] - u . y [- 1 , 0 , 0 ]) / ( 2 * Delta )); double DIK = 0.5 * (( u . x [ 0 , 0 , 1 ] - u . x [ 0 , 0 ,- 1 ] + u . z [ 1 , 0 , 0 ] - u . z [- 1 , 0 , 0 ]) / ( 2 * Delta )); D2 += sq ( DII ) + sq ( DIJ ) + sq ( DIK ); } Store log\u2081\u2080 of viscous dissipation for better visualization of the wide dynamic range. Use -10 as floor value for zero dissipation.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles: D2c [] =...",
    "content": "D2c [] = 2 * ( mu ( f [])) * D2 ; if ( D2c [] > 0. ) { D2c [] = log ( D2c []) / log ( 10. ); } else { D2c [] = - 10. ; } delta_min = delta_min > Delta ? Delta : delta_min ; } Interpolation Mode Selection Switch to adaptive interpolation if the requested regular grid spacing exceeds 1/4 of the minimum AMR cell size to avoid undersampling. if (( linear == true ) && ( delta_min < 4 * (( double )(( xmax - xmin ) / ( nx ))))) { linear = false ; } if ( linear == false ) { Adaptive Interpolation Output data at native AMR resolution along the back boundary plane. This preserves the adaptive mesh structure and avoids interpolation artifacts in regions with fine features. FILE * fp = ferr ; foreach_boundary ( back ) { fprintf ( fp , \" %g %g %g %g %g\\n \" , y , x , f [], vel [], D2c []); } } else { Regular Grid Interpolation Interpolate fields onto a uniform Cartesian grid for compatibility with standard visualization tools. The grid spacing is determined by the requested nx points in the x-direction.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles: FILE * fp...",
    "content": "FILE * fp = ferr ; double delta_x = ( double )(( xmax - xmin ) / ( nx )); int ny = ( int )(( ymax - ymin ) / delta_x ); double delta_y = ( double )(( ymax - ymin ) / ( ny )); int len = list_len ( list ); double ** field = ( double **) matrix_new ( ny , nx , len * sizeof ( double )); First pass: Interpolate all fields to regular grid points and store in memory to ensure consistent interpolation across all variables. for ( int i = 0 ; i < ny ; i ++) { double y = delta_y * i + ymin ; for ( int j = 0 ; j < nx ; j ++) { double x = delta_x * j + xmin ; int k = 0 ; for ( scalar s in list ) { field [ i ][ len * j + k ++] = interpolate ( s , x , y , zSlice ); } } } Second pass: Output interpolated data in column format suitable for plotting with gnuplot, matplotlib, or similar tools.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles: Format: y x...",
    "content": "Format: y x f vel D2c for ( int i = 0 ; i < ny ; i ++) { double y = delta_y * i + ymin ; for ( int j = 0 ; j < nx ; j ++) { double x = delta_x * j + xmin ; fprintf ( fp , \" %g %g \" , y , x ); int k = 0 ; for ( scalar s in list ) { fprintf ( fp , \" %g \" , field [ i ][ len * j + k ++]); } fputc ( ' \\n ' , fp ); } } fflush ( fp ); matrix_free ( field ); } }",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - C/C++ Code",
    "content": "#include\"grid/octree.h\"#include\"navier-stokes/centered.h\"#define FILTERED31#include\"two-phase.h\"#include\"navier-stokes/conserving.h\"#include\"tension.h\"#include<string.h>",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "charfilename[80];intny,nx;doubleymin,xmin,ymax,xmax,zSlice,Oh;boollinear;scalar*list=NULL;",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "u.t[bottom]=dirichlet(0.);u.r[bottom]=dirichlet(0.);f[bottom]=dirichlet(1.);",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "sprintf(filename,\"%s\",arguments[1]);restore(file=filename);f.prolongation=fraction_refine;boundary({f,u.x,u.y,u.z});",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "ymin=HUGE;foreach_boundary(back){if(y<ymin)ymin=y;}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "ymax=atof(arguments[2]);xmin=0.0;xmax=atof(arguments[3]);zSlice=atof(arguments[4]);nx=atoi(arguments[5]);Oh=atof(arguments[6]);linear=(strcmp(arguments[7],\"true\")==0);",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "list=list_add(list,f);list=list_add(list,vel);list=list_add(list,D2c);doubledelta_min=HUGE;",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "foreach(){vel[]=sqrt(sq(u.x[])+sq(u.y[])+sq(u.z[]));",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "doubleD2=0.;foreach_dimension(){doubleDII=(u.x[1,0,0]-u.x[-1,0,0])/(2*Delta);doubleDIJ=0.5*((u.x[0,1,0]-u.x[0,-1,0]+u.y[1,0,0]-u.y[-1,0,0])/(2*Delta));doubleDIK=0.5*((u.x[0,0,1]-u.x[0,0,-1]+u.z[1,0,0]-u.z[-1,0,0])/(2*Delta));D2+=sq(DII)+sq(DIJ)+sq(DIK);}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "D2c[]=2*(mu(f[]))*D2;if(D2c[]>0.){D2c[]=log(D2c[])/log(10.);}else{D2c[]=-10.;}delta_min=delta_min>Delta?Delta:delta_min;}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "if((linear==true)&&(delta_min<4*((double)((xmax-xmin)/(nx))))){linear=false;}if(linear==false){",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "FILE*fp=ferr;foreach_boundary(back){fprintf(fp,\"%g%g%g%g%g\\n\",y,x,f[],vel[],D2c[]);}}else{",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "FILE*fp=ferr;doubledelta_x=(double)((xmax-xmin)/(nx));intny=(int)((ymax-ymin)/delta_x);doubledelta_y=(double)((ymax-ymin)/(ny));intlen=list_len(list);double**field=(double**)matrix_new(ny,nx,len*sizeof(double));",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "for(inti=0;i<ny;i++){doubley=delta_y*i+ymin;for(intj=0;j<nx;j++){doublex=delta_x*j+xmin;intk=0;for(scalar s in list){field[i][len*j+k++]=interpolate(s,x,y,zSlice);}}}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getDataZSlice.c | Jumping Bubbles - Code Example",
    "content": "for(inti=0;i<ny;i++){doubley=delta_y*i+ymin;for(intj=0;j<nx;j++){doublex=delta_x*j+xmin;fprintf(fp,\"%g%g\",y,x);intk=0;for(scalar s in list){fprintf(fp,\"%g\",field[i][len*j+k++]);}fputc('\\n',fp);}}fflush(fp);matrix_free(field);}}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getDataZSlice.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getCells_bottomPlate.c | Jumping Bubbles: Context",
    "content": "postProcess/getCells_bottomPlate.c See raw file Boundary Visualization Tool This program extracts and visualizes boundary data from Basilisk C simulation files, specifically designed for analyzing fluid dynamics simulations on adaptive octree grids. The tool outputs boundary cell coordinates in a format suitable for visualization software. Overview The program reads a Basilisk simulation snapshot file and iterates through all cells at the bottom boundary of the computational domain. For each boundary cell, it outputs the four corner coordinates of the cell face, creating a quadrilateral representation suitable for 3D visualization. Authors Vatsal Sanjay (vatsalsanjay@gmail.com) Youssef Physics of Fluids Group Usage ./bview <simulation_file> Output Format The program outputs to standard error (stderr) the coordinates of boundary cell faces as quadrilaterals. Each quadrilateral is defined by four corner points, with a blank line separating each cell.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getCells_bottomPlate.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getCells_bottomPlate.c | Jumping Bubbles: C/C++ Code",
    "content": "Dependencies Basilisk C framework Octree grid module for adaptive mesh refinement Navier-Stokes solver (centered scheme) Volume fraction tracking module #include \"grid/octree.h\" #include \"navier-stokes/centered.h\" #include \"fractions.h\" char filename [ 80 ]; Main Function Entry point for the boundary visualization tool. Processes command-line arguments and extracts boundary data from the specified simulation file.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getCells_bottomPlate.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getCells_bottomPlate.c | Jumping Bubbles: Parameters a :...",
    "content": "Parameters a : Number of command-line arguments arguments : Array of command-line argument strings arguments[0] : Program name (unused) arguments[1] : Path to the Basilisk simulation file to process Process Flow Extracts the simulation filename from command-line arguments Restores the simulation state from the specified file Iterates through all cells at the bottom boundary Outputs quadrilateral coordinates for each boundary cell face Output Details For each boundary cell, the program outputs four corner coordinates in the following order: - Bottom-left corner: (x - \u0394/2, y, z - \u0394/2) - Top-left corner: (x - \u0394/2, y, z + \u0394/2) - Top-right corner: (x + \u0394/2, y, z + \u0394/2) - Bottom-right corner: (x + \u0394/2, y, z - \u0394/2) Where (x, y, z) represents the cell center and \u0394 (Delta) is the cell size.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getCells_bottomPlate.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getCells_bottomPlate.c | Jumping Bubbles: Notes Output is...",
    "content": "Notes Output is directed to stderr to separate from standard output Each quadrilateral is followed by two newlines for separation The coordinate ordering creates counter-clockwise vertices when viewed from outside the domain (positive y direction) int main ( int a , char const * arguments []) { // Extract simulation filename from command-line arguments sprintf ( filename , \" %s \" , arguments [ 1 ]); // Restore simulation state from the specified file restore ( file = filename ); // Iterate through all cells at the bottom boundary foreach_boundary ( bottom ) { // Output quadrilateral coordinates for visualization // Format: four corner points of the boundary cell face fprintf ( ferr , \" %g %g %g\\n%g %g %g\\n%g %g %g\\n%g %g %g\\n\\n \" , x - Delta / 2. , y , z - Delta / 2. , // Bottom-left corner x - Delta / 2. , y , z + Delta / 2. , // Top-left corner x + Delta / 2. , y , z + Delta / 2. , // Top-right corner x + Delta / 2. , y , z - Delta / 2. ); // Bottom-right corner } return 0 ; }",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getCells_bottomPlate.c.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "postProcess/getCells_bottomPlate.c | Jumping Bubbles - C/C++ Code",
    "content": "#include\"grid/octree.h\"#include\"navier-stokes/centered.h\"#include\"fractions.h\"charfilename[80];",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getCells_bottomPlate.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/getCells_bottomPlate.c | Jumping Bubbles - Code Example: intmain(inta,charconst*arguments[]){// Extract simulation...",
    "content": "intmain(inta,charconst*arguments[]){// Extract simulation filename from command-line argumentssprintf(filename,\"%s\",arguments[1]);// Restore simulation state from the specified filerestore(file=filename);// Iterate through all cells at the bottom boundaryforeach_boundary(bottom){// Output quadrilateral coordinates for visualization// Format: four corner points of the boundary cell facefprintf(ferr,\"%g%g%g\\n%g%g%g\\n%g%g%g\\n%g%g%g\\n\\n\",x-Delta/2.,y,z-Delta/2.,// Bottom-left cornerx-Delta/2.,y,z+Delta/2.,// Top-left cornerx+Delta/2.,y,z+Delta/2.,// Top-right cornerx+Delta/2.,y,z-Delta/2.);// Bottom-right corner}return0;}",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/getCells_bottomPlate.c.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "postProcess/Visulization3D.ipynb | Jumping Bubbles",
    "content": "postProcess/Visulization3D.ipynb See raw file Visulization3D.ipynb Jupyter Notebook: Visulization3D.ipynb Download Notebook View in nbviewer Open in Colab About this notebook This notebook provides visualization and analysis related to Visulization3D. Key Features: Visualization of data and results Analysis of simulation outputs Interactive exploration of parameters Tip: For the best interactive experience, download the notebook or open it in Google Colab. Notebook Preview Notebook Preview Unavailable The notebook preview could not be loaded. This may be because: The notebook file is not yet available in the repository The nbviewer service is temporarily unavailable The repository is private or has access restrictions You can still download the notebook using the button above or view it directly through one of the external services.",
    "url": "https://comphy-lab.org/JumpingBubbles/postProcess/Visulization3D.ipynb.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/DataFile/retrieveDataFile.sh | Jumping Bubbles",
    "content": "simulationCases/DataFile/retrieveDataFile.sh See raw file retrieveDataFile.sh #!/bin/bash curl -L https://www.dropbox.com/s/b5bg8a4aaw20sm3/InitialCondition.stl ? dl=1 -o InitialCondition.stl",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/DataFile/retrieveDataFile.sh.html",
    "type": "docs_content",
    "priority": 4
  },
  {
    "title": "simulationCases/DataFile/retrieveDataFile.sh | Jumping Bubbles - Code Example",
    "content": "#!/bin/bashcurl-Lhttps://www.dropbox.com/s/b5bg8a4aaw20sm3/InitialCondition.stl?dl=1-oInitialCondition.stl",
    "url": "https://comphy-lab.org/JumpingBubbles/simulationCases/DataFile/retrieveDataFile.sh.html",
    "type": "docs_code",
    "priority": 4
  },
  {
    "title": "News - <i class=\"fa-solid fa-graduation-cap gradcap-icon\"></i> CoMPhy Lab is Moving to Durham University!",
    "content": "Join Us Starting July 1st, 2025 , the CoMPhy Lab will be relocating to Durham University, UK. We are excited to join the [Condensed Matter Physics section](https://www.durham.ac.uk/research/institutes-and-centres/condensed-matter-physics/) in the [Department of Physics](https://www.durham.ac.uk/departments/academic/physics/) and continue our research in computational physics and fluid dynamics in our new home.",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "News - June",
    "content": "- Jnandeep Talukdar graduated with a master's degree (grade: 10/10) from University of Twente. Thesis: Singularities with Surfactants",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "News - May",
    "content": "- [Bashkatov, A., B\u00fcrkle, F., Demirk\u0131r, \u00c7., Ding, W., Sanjay, V. , Babich, A., Yang, X., Mutschke, G., Czarske, J., Lohse, D., et al. Electrolyte droplet spraying in H2 bubbles during water electrolysis under normal and microgravity conditions. Nat. Commun., 16, 4580 (2025).](/research#17) View Paper - [ Dixit, A. , Oratis, A., Zinelis, K., Lohse, D., & Sanjay, V. Viscoelastic Worthington Jets and Droplets Produced by Bursting Bubbles. J. Fluid Mech., 1010, A2 (2025).](/research#16) View Paper",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "News - April",
    "content": "- Vatsal Sanjay awarded the Ammodo Science Fellowship . His research will focus on understanding fluid dynamics in fungal networks\u2014investigating how these vast underground systems transport water, nutrients, and genetic information across ecosystems. Read More Image credit: J. Heitman, B. J. Howlett, P. W. Crous, E. H. Stukenbrock, T. Y. James & N. A. R. Gow, The fungal kingdom, John Wiley & Sons (2020)",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "News - March",
    "content": "- Prof. Detlef Lohse shares his scientific journey in The Living Histories Series . His inspiring discussion on curiosity, mentorship, and the \"puzzle solving\" joy of science offers valuable insights for researchers at all career stages. Watch on YouTube",
    "url": "https://comphy-lab.org#news",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "History - <i class=\"fa-solid fa-graduation-cap gradcap-icon\"></i> CoMPhy Lab is Moving to Durham University!",
    "content": "Join Us Starting July 1st, 2025 , the CoMPhy Lab will be relocating to Durham University, UK. We are excited to join the [Condensed Matter Physics section](https://www.durham.ac.uk/research/institutes-and-centres/condensed-matter-physics/) in the [Department of Physics](https://www.durham.ac.uk/departments/academic/physics/) and continue our research in computational physics and fluid dynamics in our new home.",
    "url": "https://comphy-lab.org#history",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "History - June",
    "content": "- Jnandeep Talukdar graduated with a master's degree (grade: 10/10) from University of Twente. Thesis: Singularities with Surfactants",
    "url": "https://comphy-lab.org#history",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "History - May",
    "content": "- [Bashkatov, A., B\u00fcrkle, F., Demirk\u0131r, \u00c7., Ding, W., Sanjay, V. , Babich, A., Yang, X., Mutschke, G., Czarske, J., Lohse, D., et al. Electrolyte droplet spraying in H2 bubbles during water electrolysis under normal and microgravity conditions. Nat. Commun., 16, 4580 (2025).](/research#17) View Paper - [ Dixit, A. , Oratis, A., Zinelis, K., Lohse, D., & Sanjay, V. Viscoelastic Worthington Jets and Droplets Produced by Bursting Bubbles. J. Fluid Mech., 1010, A2 (2025).](/research#16) View Paper",
    "url": "https://comphy-lab.org#history",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "History - April",
    "content": "- Vatsal Sanjay awarded the Ammodo Science Fellowship . His research will focus on understanding fluid dynamics in fungal networks\u2014investigating how these vast underground systems transport water, nutrients, and genetic information across ecosystems. Read More Image credit: J. Heitman, B. J. Howlett, P. W. Crous, E. H. Stukenbrock, T. Y. James & N. A. R. Gow, The fungal kingdom, John Wiley & Sons (2020)",
    "url": "https://comphy-lab.org#history",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "History - March",
    "content": "- Prof. Detlef Lohse shares his scientific journey in The Living Histories Series . His inspiring discussion on curiosity, mentorship, and the \"puzzle solving\" joy of science offers valuable insights for researchers at all career stages. Watch on YouTube - [ Sanjay, V. , & Lohse, D. Unifying theory of scaling in drop impact: Forces & maximum spreading diameter. Published in Physical Review Letters.](/research#15) View Paper - Join us for a hybrid online+offline course: [High-Fidelity Simulations Using Basilisk C](/teaching/2025-Basilisk101-Madrid) in Madrid, Spain (March 10-13). Learn some computational (colorful) fluid dynamics with hands-on coding sessions.",
    "url": "https://comphy-lab.org#history",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "History - February",
    "content": "- [ Sanjay, V. , Zhang, B., Lv, C., & Lohse, D. J. Fluid Mech., 1004, A6 (2025) selected as the cover article.](/research#14) Download Cover View Paper - Milan Sent graduated with a bachelor's degree from University of Twente. Thesis: Spinning Pizza",
    "url": "https://comphy-lab.org#history",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "History - December",
    "content": "- [Balasubramanian, A. G., Sanjay, V. , Jalaal, M., Vinuesa, R., & Tammisola, O. J. Fluid Mech., 1001, A9 (2024). selected as the cover article.](/research#12) Download Cover View Paper",
    "url": "https://comphy-lab.org#history",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "History - November",
    "content": "- Vatsal Sanjay recognized as an Outstanding Reviewer 2023 by the Journal of Fluid Mechanics for his contributions to the peer review process.",
    "url": "https://comphy-lab.org#history",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "History - May",
    "content": "- Vatsal Sanjay awarded the KIVI Hoogendoorn Fluid Mechanics Award 2023 for his PhD thesis \"Viscous Free-Surface Flows\". The award ceremony took place at the Burgers Symposium on 29\u201330 May 2024 in Lunteren.",
    "url": "https://comphy-lab.org#history",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - About Us",
    "content": "We investigate [**non-Newtonian free-surface flows**](/research/?tag=Non-Newtonian) and [**soft matter singularities**](/research/?tag=Soft-matter-singularities). Our group employs a synergy of continuum simulations, experiments (through collaborations), and theoretical analysis to understand phenomena ranging involving drops, bubbles, jets, sheets, and more. We strive to connect fundamental findings with real-world applications, from industrial processes to everyday fluid dynamics.",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Soft Matter Singularities",
    "content": "We examine topological transitions in fluid systems\u2014such as [**droplet impact**](/research/?tag=Drops), [**bubble bursting**](/research/?tag=Bubbles), and [**sheet fragmentation**](/research/?tag=Sheets) \u2014 where local instabilities drive fast, often dramatic flow dynamics. Our goal is to expose the universal mechanisms governing these [**singular**](/research/?tag=Soft-matter-singularities) events in soft matter.",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Non-Newtonian Flows as the `Drosophila' of Continuum Mechanics",
    "content": "From [**elastoviscoplastic**](/research/?tag=Non-Newtonian) bubble bursting and elastic sheet break-up to champagne [**bubble**](/research/?tag=Bubbles) bursting and classical Taylor\u2013Culick retractions, non-Newtonian fluids serve as model systems to explore the fundamentals of continuum mechanics. By integrating high-fidelity simulations, analytical frameworks, and collaborative experiments, we reveal how microstructural stresses affect fluid and solid dynamics. This research provides key insights for industrial and environmental applications.",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Viscous Free-Surface Flows",
    "content": "We investigate various viscous free-surface flows including inertial contact lines, [**bubble**](/research/?tag=Bubbles) removal, and focusing of [**waves**](/research/?tag=Waves). These phenomena are critical to energy transitions and manufacturing. For instance, a key challenge is optimizing bubble detachment in electrolysis to boost efficiency. This research involves advanced numerical methods and industry partnerships, with the broader aim of advancing technologies from chemical reactors to printing processes.",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Commitment to Open Science",
    "content": "Open exchange of ideas drives our progress. We share our codes from the earliest stages of development, embracing transparent research practices to foster collaboration and reproducibility. We welcome inquiries and partnerships from the broader scientific community. Watchout for [![GitHub](https://img.shields.io/badge/GitHub-100000?style=flat-square&logo=github&logoColor=white)](https://github.com/comphy-lab) and [ ](https://github.com/comphy-lab \"Visit our GitHub organization\") on this website to interact with our codes. Feel free to contact us for discussions about our work or anything else related to fluid physics. Nothing is more exhilarating than a healthy scientific discussion.",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Location & Website",
    "content": "[![Location](https://img.shields.io/badge/-Physics%20of%20Fluids-4285F4?style=flat&logo=googlemaps&logoColor=white)](https://maps.app.goo.gl/jSTCYnfcndF1uZPV8) [![Website](https://img.shields.io/badge/-comphy--lab.org-4285F4?style=flat&logo=googlechrome&logoColor=white)](http://www.comphy-lab.org) [![Email](https://img.shields.io/badge/-mailto:vatsalsy@comphy--lab.org-EA4335?style=flat&logo=gmail&logoColor=white)](mailto:vatsalsy@comphy-lab.org) vatsalsy@comphy-lab.org",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Academic Profiles",
    "content": "[![Google Scholar](https://img.shields.io/badge/-Google%20Scholar-4285F4?style=flat&logo=googlescholar&logoColor=white)](https://scholar.google.com/citations?user=tHb_qZoAAAAJ&hl=en) [![ORCID](https://img.shields.io/badge/-ORCID-A6CE39?style=flat&logo=orcid&logoColor=white)](https://orcid.org/0000-0002-4293-6099) [![arXiv](https://img.shields.io/badge/-arXiv-B31B1B?style=flat&logo=arxiv&logoColor=white)](https://arxiv.org/search/?query=vatsal+sanjay&searchtype=all&source=header) [![ResearchGate](https://img.shields.io/badge/-ResearchGate-00CCBB?style=flat&logo=researchgate&logoColor=white)](https://www.researchgate.net/profile/Vatsal-Sanjay-2)",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Aboutcomphy - Social Media",
    "content": "[![X](https://img.shields.io/badge/-@CoMPhyLab-000000?style=flat&logo=x&logoColor=white)](https://twitter.com/VatsalSanjay) [![Bluesky](https://img.shields.io/badge/-@comphy--lab.org-0285FF?style=flat&logo=bluesky&logoColor=white)](https://bsky.app/profile/comphy-lab.org) For supplementary videos and teaser of our upcoming work:",
    "url": "https://comphy-lab.org/#about",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - CLAUDE.md",
    "content": "This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Repository Overview",
    "content": "This repository contains the CoMPhy Lab website, a static site built with Jekyll for the Computational Multiphase Physics Laboratory. The site features research publications, team member information, teaching materials, and lab news.",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Command Palette and Search System",
    "content": "The website implements a sophisticated command palette system that requires coordination between multiple files: - **`command-palette.js`** must load before **`command-data.js`** (dependency order) - **Fuse.js** powers fuzzy search functionality - Search database (`search_db.json`) is maintained in a separate repository and updated via GitHub Actions - Context-aware commands based on current page location - Keyboard shortcut: \u2318K (Mac) / Ctrl+K (Windows)",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Theme System Architecture",
    "content": "- CSS variables defined in `:root` for light theme, overridden in `[data-theme=\"dark\"]` - Theme state persisted in localStorage and synced across all pages - Page-specific theme variables in `research.css`, `teaching.css`, `team.css` - Smooth transitions between themes using CSS transitions",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Research Tag Filtering",
    "content": "- Client-side JavaScript filtering with SEO-friendly static pages - Pre-generated tag pages that redirect to filtered views - Multiple URL variations for better SEO coverage - Tags must be added to `_research/index.md` using ` TagName ` format",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Fix common issues",
    "content": "./scripts/fix-script-order.sh # Fix script loading order ./scripts/fix-js-line-length.sh # Enforce 80 char limit ./scripts/fix-quotes.sh # Standardize to double quotes ```",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Adding Research Papers",
    "content": "Add to `_research/index.md` with this exact format: ```markdown [NUMBER] Author1, A., **Author2, B.**, & Author3, C. Title. _Journal_, Volume, Pages (Year). Tag1 Tag2 Featured [![Badge](https://img.shields.io/static/v1.svg?style=flat-square&label=LABEL&message=MESSAGE&color=COLOR)](URL) ``` - Use `**Name**` for lab members - Add ` Featured ` tag to display on homepage (max 2) - ID attribute enables direct linking: `/research/#NUMBER`",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Team Member Format",
    "content": "In `_team/index.md`: ```html ```",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - News",
    "content": "Managing news items across the site: - **Using slash command**: `/add-news \"Your news content here\"` - automatically handles both News.md and history.md - **Manual editing**: - Add to both `News.md` (main page) and `history.md` (archive) - News.md maintains only 5 most recent items (plus pinned Durham announcement) - Format: `- News content` under `### Month Year` headers - **Important notes**: - Pinned items have no month/year header - Maintain blank lines between sections - Older items removed from News.md remain in history.md",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Teaching Course Pages",
    "content": "- Main page: `_teaching/index.md` (uses `teaching` layout) - Course pages: `_teaching/YYYY-CourseName-Location.md` (uses `teaching-course` layout) - Images: Store in `/assets/images/teaching/` (600x400px for cards, 1200x400px for banners)",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Script Dependencies",
    "content": "The lint-check.sh script automatically fixes these, but be aware: - Fuse.js must load before any search functionality - command-palette.js must load before command-data.js - Theme initialization must happen early in page load",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Pre-commit Hooks",
    "content": "Automatically installed via setup.sh using Husky: - ESLint with auto-fix for JavaScript - Prettier for formatting - markdownlint for Markdown files - Only staged files are checked - Bypass with `git commit --no-verify` in emergencies",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Search Database Updates",
    "content": "- Maintained in [comphy-lab/comphy-search](https://github.com/comphy-lab/comphy-search) repository - Updated daily via GitHub Actions - Includes blog content from blogs.comphy-lab.org - Manual trigger available in Actions tab",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - CSS Variable System",
    "content": "Key variables for customization: ```css /* Colors */ --primary-color, --secondary-color, --accent-color --text-color, --bg-color, --card-bg /* Typography */ --font-family-serif, --font-family-sans /* Spacing */ --spacing-unit, --content-max-width /* Shadows & Transitions */ --shadow-sm, --shadow-md, --transition-speed ```",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Test Coverage Areas",
    "content": "- Command palette functionality (navigation, search, keyboard shortcuts) - Line breaking utilities (80-character enforcement) - Platform detection (Mac vs Windows shortcuts) - Teaching page sorting algorithms - Browser API mocks in `setup.js`",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Build Process",
    "content": "The build.sh script performs these operations in sequence: 1. Jekyll build with production environment 2. Search database generation (if in GitHub Actions) 3. SEO tag generation 4. Filtered research page creation",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Asset Optimization",
    "content": "- Images should be optimized before adding - Use WebP format where possible - Lazy loading implemented for images - CSS consolidated by breakpoint for better caching",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - File Management",
    "content": "- ALWAYS prefer editing existing files over creating new ones - Developer documentation (README.md, CONTRIBUTING.md, etc.) should NEVER be created unless explicitly requested - Site content markdown files (research papers, news items, teaching pages) follow their specific workflows: - Research: Add to `_research/index.md` following the documented format - News: Use `/add-news` command or edit `News.md` and `history.md` - Teaching: Create course pages in `_teaching/` directory when adding new courses - Follow existing patterns in the codebase",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Code Style",
    "content": "- 80-character line limit for JavaScript - Double quotes for strings - ES6+ features (arrow functions, const/let, async/await) - Mobile-first CSS with min-width media queries - BEM naming for CSS classes",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - Git Workflow",
    "content": "- Work on feature branches - Run `./scripts/lint-check.sh` before committing - Ensure tests pass with `npm test` - Reference issue numbers in commits",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - /add-news: Adds a news...",
    "content": "Adds a news item to both News.md and history.md while maintaining the 5-item limit on the main page. **Workflow:** 1. Add the news item to the appropriate month/year section in both files 2. If month/year doesn't exist, create it 3. Keep only 5 most recent news items in News.md (excluding the pinned Durham announcement) 4. Preserve the pinned item (recognized by not having ### Month header above it) **Usage:** ```bash /add-news \"Your news content here\" ``` **Implementation steps:** 1. Read both News.md and history.md 2. Ask for month/year if not provided or unclear 3. Add to history.md in the correct chronological position 4. Add to News.md in the correct position 5. Count non-pinned news items in News.md 6. If count > 5, remove oldest items from News.md only 7.",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Claude - /add-news: Save both files...",
    "content": "Save both files **Important notes:** - The pinned Durham announcement has no month/year header - News items start with \"- \" (dash and space) - Maintain blank lines between sections for proper formatting - In history.md, years are sorted descending (newest first) - Within a year, months appear in chronological order",
    "url": "https://comphy-lab.org#claude",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Index - Computational MultiphasePhysics (CoMPhy) Lab",
    "content": "Computational Multiphase Physics (CoMPhy) Lab Picture: Worthington jet formed due to bursting bubble. Featured Research",
    "url": "https://comphy-lab.org#intro",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "404 - 404! But, there are no dragons either.",
    "content": "404! But, there are no dragons either. Seems like you didn't find what you wanted. But don't worry - we've got plenty of exciting projects waiting for you to explore! Check Out: Take Me Home",
    "url": "https://comphy-lab.org#intro",
    "type": "website_section",
    "priority": 8
  },
  {
    "title": "Add news",
    "content": "Add the following news item to both News.md and history.md: $ARGUMENTS Follow these steps: 1. Parse the news content from $ARGUMENTS 2. Determine the appropriate month and year (ask if unclear) 3. Read both News.md and history.md files 4. Add the news item to history.md in the correct chronological position: - Years are sorted descending (newest first) - Months within a year are in chronological order - Format: `- [news content]` 5. Add the same item to News.md: - Find the correct month/year section (create if needed) - Insert after the month heading - Preserve the pinned Durham announcement (no month header) 6. Count non-pinned news items in News.md 7. If more than 5 items exist, remove the oldest ones 8. Ensure proper spacing between sections 9. Save both files Important formatting: - News items start with \"- \" - Leave blank lines between different news items - The pinned item has no \"### Month\" header above it - Month headers use format: ### Month (e.g., ### May)",
    "url": "https://comphy-lab.org/.claude/commands/add-news/",
    "type": "website_content",
    "priority": 10
  }
]